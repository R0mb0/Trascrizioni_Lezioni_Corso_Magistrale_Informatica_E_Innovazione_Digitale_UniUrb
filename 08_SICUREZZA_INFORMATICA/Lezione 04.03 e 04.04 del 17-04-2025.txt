Ok. Bene, allora, la volta scorsa abbiamo studiato la cifratura chiave pubblica, in particolare cifrari semanticamente sicuri e cpa sicuri. I due concetti coincidono quando si parla della criptografia chiave asimmetrica. In particolare abbiamo visto appunto come due possibili implementazioni, quelle basate su RSA e quella basata su Diffie Elman, che prende il nome di protocollo di Elgamano. E ripercorrendo un po' il confronto con la cifratura chiave simmetrica, resta da vedere com'è la definizione di Chosen Cybertext Attack anche nel contesto della criptografia chiave pubblica, che se vi ricordate era la condizione di sicurezza più elevata che avevamo nel contesto della criptografia a chiave simmetrica, quindi la nozione più forte da questo punto di vista. Lo stesso discorso, come vedremo tra poco, vale anche per l'ambito della cifratura chiave pubblica, tant'è che se andiamo a vedere qui l'Attack Game su cui si basa la CCA Security, vediamo che è praticamente identico a quello che avevamo già visto in passato. Come al solito cambia semplicemente il fatto che qui parliamo di cifratura chiave, però il comportamento dell'attaccante è lo stesso che avevamo già visto. Quindi in questo contesto al solito vediamo che abbiamo un challenger che calcola la coppia di chiavi pubblica e privata, rende nota all'avversario la chiave pubblica, dopodiché l'avversario può fare due cose, può sottoporre le cosiddette query di encryption oppure le query di decryption. Le query di encryption sono le stesse query che abbiamo visto per la CPA Security, quindi l'avversario sceglie una coppia di messaggi, di plain text, li sottopone al challenger, il challenger risponde con la cifratura di uno dei due, fatta usando la chiave pubblica, a seconda dell'esperimento in cui ci troviamo. Le query di decryption sono come nel CCA Tag Game che già conoscevamo, ovvero sono query in cui l'avversario sceglie un cifratext, diverso da quelli generati dal challenger, e se lo fa decifrare dal challenger che utilizza naturalmente a questo scopo la chiave segreta corrispondente alla chiave pubblica. Come al solito, l'obiettivo dell'avversario, eseguendo il proprio algoritmo efficiente, è quello di indovinare in quale esperimento ci troviamo. Il vantaggio dell'avversario si calcola nel modo che abbiamo sempre visto, così come la nozione di CCA security è quella che già conoscevamo, ovvero il nostro cifrario a chiave pubblica è CCA sicuro, se il vantaggio dell'avversario è negligible per tutti gli avversari efficienti. Quindi ci si può chiedere se, con qualche variante ovviamente, i due meccanismi che abbiamo visto nella scorsa lezione, e quindi la cifratura a chiave pubblica basata su RSA oppure Elgamal, che l'altra volta abbiamo visto sotto quali condizioni sono CCA sicuri, adesso vediamo sotto quali condizioni sono CCA sicuri, cioè sono robusti rispetto a avversari che eseguono questo tipo di attack game. Le cose sono un po' diverse a seconda del meccanismo che prendiamo in considerazione, ovvero nel caso di RSA il teorema che stabilisce sotto quali condizioni lo schema di cifratura a chiave pubblica basato su RSA è CCA sicuro, sono molto simili a quelle che abbiamo visto nel teorema della volta scorsa. Cambia una sola condizione. Se vi ricordate questo meccanismo, questo schema, oltre a RSA usa una funzione hash e usa un cifrario simmetrico, se prendiamo per buona la RSA assumption, quindi assumiamo che RSA sia robusto, e se la funzione hash è sicura e il cifrario a chiave simmetrica è CCA sicuro, allora il teorema dice che lo schema basato su RSA è a sua volta CCA sicuro. Quindi di fatto è lo stesso teorema che abbiamo visto l'altra volta, solo che l'altra volta l'ipotesi era che lo schema fosse CPA sicuro e la conclusione era che la RSA fosse CCA sicuro, quindi stesso schema del teorema. Stavolta vediamo invece che se il cifrario simmetrico è CCA sicuro, allora anche lo schema basato su RSA è CCA sicuro. Quindi l'analogia con quello che abbiamo visto l'altra volta è assolutamente evidente. Il discorso invece è un po' più complicato per El Gamal. Non basta prendere il teorema che abbiamo visto settimana scorsa e estendere El Gamal utilizzando un cifrario simmetrico CCA sicuro per far sì che El Gamal sia a sua volta CCA sicuro. Dobbiamo modificare l'assunzione relativa alla computational deferment assumption. non entro nei dettagli di questa cosa, vi faccio vedere giusto dall'intuizione che sta dietro questo tipo di restrizione che dobbiamo applicare. Ora, se vi ricordate, nel Gamal abbiamo che questa coppia rappresenta chiave segreta chiave pubblica. Questo è quello che succede nel Gamal. Poi, quando si fa la cifratura, bisogna scegliere un beta e un G alla beta per cui lo schema utilizzerà G alla alfa beta che deriva da questa informazione no, scusate, deriva da questa informazione e da questa per fare la cifratura, mentre lato di cifratura si utilizzano questa e questa. In entrambi i casi l'obiettivo è recuperare questa informazione che serve per recuperare la chiave del cifrario simmetrico che il Gamal utilizza. Ora, il punto qual è? Il punto è che di tutte queste informazioni l'unica segreta è questa. tutte le altre possono essere sono o visibili all'avversario è il caso di G alla alfa o addirittura scelte dall'avversario è il caso di queste due perché se torniamo un attimo all'attack game che abbiamo appena visto nell'attack game della CCA security che è questo l'avversario può fare una decryption query. scegliere un cyphertext e far solo decifrare ma scegliere un cyphertext significa che l'avversario può scegliere queste due informazioni perché queste informazioni qui le sceglie chi fa la cifratura. Ok? Quindi questo che cosa significa? cosa comporta che tra l'altro di query decryption l'avversario ne può sottoporre tante e quindi l'avversario può provare a sottoporre al challenger tanti cyphertext per ciascuno sceglie un beta calcola G alla beta fa la cifratura sfruttando G alla alfa e si fa la decifratura dal challenger e in base a tutto il feedback che riceve cerca di capire se è possibile derivare delle informazioni relativamente ad alfa perché è alfa che deve essere diciamo hackerato dall'avversario e se noi applichiamo la la Diffie-Hellman la computational assumption che abbiamo sempre visto non è proprio la stessa cosa rispetto alla strategia dell'avversario che abbiamo appena descritto perché la Diffie-Hellman computational assumption classica ci dice che da G alla alfa e da G alla beta non è possibile recuperare G alla alfa beta in questo in questo caso la situazione è un pochino più complicata perché l'avversario qualcosa in più lo sa conosce beta perché è lui che lo sceglie quando fa le decryption query e quindi siamo in una situazione in cui l'avversario conosce beta perché ogni volta che fa una decryption query sceglie un beta calcola G alla beta calcola G alla alfa beta e poi fa la cifratura e chiede e chiede al al challenger di decifrare ok quindi l'avversario ha delle informazioni in più con cui con cui poter lavorare quindi queste informazioni in più non ci danno cioè rispetto a queste informazioni in più che l'avversario ha noi non abbiamo nessuna garanzia da parte della computational defierment assumption classica questo è il motivo per cui va estesa va resa un pochino più complessa la computational defierment assumption e la tag game che dobbiamo usare è questo che vedete qui ve lo descrivo veramente non entro nei dettagli però è la tag game che rispetto al quale se naturalmente soddisfa la condizione di sicurezza che so nel nome di interactive computational defierment assumption ebbene lo soddisfacimento di questa sostegno ci garantisce che anche il gamal come rsa può essere cca sicuro però ripeto bisogna complicare un pochino le cose l'attag game è un attag game contro diciamo il problema che sta alla base della soluzione di Fiedelman e prevede che il challenger scelga alpha scelga beta calcoli g all'alpha calcoli g alla beta g all'alpha beta e dopodiché si dà la possibilità all'avversario di sottoporre delle query le query che sottopone l'avversario sono di questo tipo qua g alla beta g all'alpha beta v e w sono rappresentano g alla beta g all'alpha beta e il challenger risponde sì se il primo termine della coppia elevato alla chiave segreta coincide con il secondo elemento della coppia se coincidono l'avversario vince è un attack game un pochino più sofisticato rispetto alla computational di Fiedelman assumption però appunto è quello che ci permette di stabilire se l'avversario eseguendo l'attack game della cca security ha una qualche possibilità di violare il modo in cui Elgamal usa di Fiedelman se vale questa soluzione cioè il vantaggio dell'avversario in questo attack game è task curabile per tutti gli avversari efficienti allora vuol dire che la probabilità che l'avversario ha di violare di Fiedelman nel protocollo di Elgamal è negligible ecco questa è la conclusione non ci interessano i dettagli vi ho accennato questa cosa giusto per arrivare al risultato finale che invece è quello che ci interessa che è questo che appunto dice che Elgamal lo schema di Elgamal è cca sicuro se il cifrario simmetrico che utilizza è cca sicuro se la funzione hash è sicura e se vale la interactive computational difiermional assumption che abbiamo appena iscritto e che ripeto è un pochino più complicata rispetto alla computational difiermional assumption che già conoscevamo tutto qua insomma su questo non voglio soffermarvi perché la parte teorica che ci sta sotto non la dimostriamo il risultato finale che ci interessa è che anche se attraverso condizioni leggermente diverse sia lo schema basato su RSA che lo schema di Elgamal sotto certe condizioni sono cca sicuri questa è la conclusione che interessa noi e quindi garantiscono il massimo livello di sicurezza che avevamo già visto studiato nel caso dell'autenticata di encryption che è quella forma di cifratura chiave simmetrica che garantiva lo stesso tipo di risultato quindi tutto qua niente di particolare a parte i due schemi di cui abbiamo parlato la settimana scorsa ce ne sono altri che sono cci assicuri quindi cito giusto un paio che si basano su delle primitive diverse rispetto a quanto fanno Elgamal e RSA cito queste perché hanno delle ipotesi interessanti diciamo rispetto a quelle che abbiamo studiato però non ne entriamo nel dettaglio di questi rappresentano degli schemi che volendo uno potrebbe approfondire in un progetto per quello che ho citato in questo slide non peraltro fra le tante perché poi ce ne sono naturalmente anche altre literature come per la cifratura a chiave simmetrica anche gli schemi basati su chiave pubblica possono funzionare con i dati associati con i metadati che necessitano di prova di integrità ma non richiedono necessariamente la la confidenzialità ok esattamente come avevamo visto per l'altro etichetto di encryption quindi in questo caso c'è un parametro in più che viene passato alle funzioni di cifratura di cifratura quindi in questo caso oltre a chiave pubblica al plain text in fase di cifratura vengono passati anche i metadati dati associati che devono essere utilizzati anche in fase di decifratura tutto qua insomma niente di di diverso rispetto a quanto avevamo già già visto in passato oggi invece la cosa interessante che vi volevo raccontare brevemente consiste in una variante dello schema basato su RSA che viene molto utilizzato in letteratura ok e che il motivo è che risulta essere più efficiente rispetto a quanto non sia lo schema basato su RSA che abbiamo studiato e che ripeto lo schema che abbiamo visto la settimana scorsa che cosa fa usa RSA per cifrare quella che è una chiave simmetrica che viene usata da un cifrario simmetrico per cifrare il plaintext in realtà viene utilizzata una funzione hash per quindi la chiave simmetrica che si utilizza il digest di un valore randomico così sono dettagli la cosa importante è che in quella maniera quando produciamo quando usiamo lo schema basato su RSA quello che succede è che vengono prodotti due duplice output perché abbiamo la cifratura della chiave simmetrica e abbiamo il ciphertext ottenuto usando quella chiave simmetrica questo è il senso di questa coppia qui ok è un'operazione costosa perché dobbiamo usare diverse primitive diversi meccanismi in mezzo c'è anche l'utilizzo di una funzione hash e questa procedura non è particolarmente efficiente soprattutto quando dobbiamo cifrare messaggi brevi ok quindi la variante che vi racconto adesso è stata proposta è stata studiata soprattutto per fare cifratura la chiave pubblica nel caso in cui i messaggi che dobbiamo cifrare sono brevi sono corti perché è la situazione in cui si vede maggiormente il problema di inefficienza dello schema che abbiamo visto l'altra volta la soluzione che vi racconto avverso un paio di esempi oggi prende il nome di PKCS1 che è uno degli schemi di cifratura a chiave pubblica più utilizzati e che ha varianti che possono essere come vedremo sia CPA che CCA sicuri l'idea di base di questo schema è che si usa solamente RSA o più in generale si usa solamente la funzione lo schema di funzione contract door senza usare un cifrario simmetrico quindi non viene sputtato un cifrario simmetrico anche perché tanto se l'obiettivo è cifrare messaggi di piccole dimensioni possiamo fare a meno di usare un cifrario simmetrico chiaramente noi sappiamo che non possiamo usare direttamente RSA per la cifratura perché questa cosa qui non è sicura non funziona perché RSA è deterministico mentre invece per garantire che la cifratura chiave pubblica che utilizziamo sia CPA sicura è necessario che il meccanismo che usiamo sia probabilistico quindi è ovvio che non possiamo usare RSA così com'è ed è il motivo per cui l'altra volta avevamo introdotto quel fattore randomico che ci permetteva di scegliere una chiave simmetrica in maniera casuale cifrata con RSA e poi usare un cifrario simmetrico quindi anche in questo caso dobbiamo tenere conto del fatto che dobbiamo rimanere probabilistici e però l'obiettivo è quello di non utilizzare un cifrario simmetrico la soluzione consiste nel usare una una funzione di codifica diciamo chiamiamola una funzione di codifica che altera il plaintext prima di darlo in pasto a RSA lo altera in maniera probabilistica infatti come vedremo poi vi farò vedere un esempio di possibili funzioni di codifica la funzione di codifica che cosa fa è una funzione P che prende il plaintext prende un nonce combina plaintext e nonce in qualche modo generando quella che è una codifica randomica del plaintext ok poi come vedremo RSA o qualunque schema di funzione con trapdoor è applicato a questa codifica ok naturalmente così come c'è la funzione di codifica ci deve essere una corrispondente funzione di codifica che a partire dal risultato della codifica mi restituisce il plaintext da cui era stata ottenuta ok quindi la solita condizione di correttezza deve essere questa io prendo un qualunque plaintext un nonce R scelto randomicamente applico la codifica se al risultato di questa codifica applico la funzione di decodifica devo riottenere N questa perché questa operazione di codifica decodifica innanzitutto per alterare il plaintext in maniera randomica e poi dare il risultato in passo RSA ok in questa maniera il risultato è statistico perché dipende da R perché RSA non viene più applicato direttamente sul messaggio M ma viene applicato su un input che dipende da M e da un'informazione randomica quindi cambiando l'informazione randomica anche se M è sempre lo stesso RSA produrrà risultati diversi quindi è un modo per rendere probabilistico RSA e quindi renderlo sicuro almeno CPA sicuro ok senza dover usare un cifrario simmetrico basato su una chiave scelta randomicamente e quindi essere più efficienti in termini di performance questa è l'idea il il modo in cui funziona qui vi faccio vedere come funziona quest'idea in maniera generica quindi qui non facciamo riferimento a RSA in particolare ma facciamo riferimento a un qualunque schema di funzione contrappdor di cui RSA ad esempio quindi un qualunque schema di funzione contrappdor che ha la sua funzione di generazione delle chiavi la sua funzione di cifratura e la sua funzione di cifratura I vi ricordo che nel caso di RSA la funzione F consiste nell'elevare alla chiave pubblica al plaintext la funzione I consiste invece nell'elevare la cifratura alla chiave segreta poi vi farò vedere nel caso di RSA appunto però qui vediamo lo schema di questo schema che sfrutta appunto la codifica in particolare come funziona la cifratura allora siccome la cifratura deve essere probabilistica scegliamo un valore randomico R e facciamo la famosa codifica di cui parlavamo prima P è una funzione di codifica che prende il plaintext prende R e restituisce un certo X ok l'X che otteniamo in questa maniera è quello che io vado a cifrare con lo schema di funzione e contratto quindi chiave pubblica valore codificato ottengo il cifratext ok e quello è il risultato vedete non abbiamo usato funzioni hash non abbiamo usato cifrari simmetrici abbiamo usato solo ed esclusivamente come primitiva criptografica la funzione di cifratura con trapdoor che però è applicata non direttamente al plaintext ma una codifica randomica del plaintext ok lato di cifratura che cosa devo fare beh chiaramente userò la chiave segreta per invertire il ciphertext e riottenere X dopodiché X va decodificato decodificato per riottenere M ok e questa è l'idea di questo tipo di schema no di questo tipo di schema di questa pkcs1 è usato è dentro TLS ad esempio e viene molto usato però lo vedremo nella prossima lezione forse già oggi per le firme digitali per le firme digitali per le firme digitali che è qualcosa che dobbiamo ancora discutere però come vedremo le firme digitali si fanno usano sempre meccanismi chiave pubblica e quindi possono essere RSA un candidato e in quel caso si usa questa implementazione qui problema che disegnita problema eh quello lo vedremo quello lo vedremo sì sì in particolare la codifica in pkcs1 quindi la la funzione p è definita in questa maniera qui è molto semplice vedete prende il plaintext e per combinarlo col valore randomico R fa solo semplicemente una concatenazione no quei tre eh tre byte che anzi due byte uno usato due volte che vedete quindi questo questo e questo servono per eh dividere nella stringa in maniera non ambigua la parte che contiene R dalla parte che contiene M ok la lunghezza di R è prefissata quindi la codifica di qualunque plaintext comincia 2 byte 0002 poi c'è un valore random che ha una certa lunghezza prefissata poi c'è il byte 00 e poi c'è il plaintext ok quindi in PKCS1 quello che si fa è prendere il plaintext ricavare x in questa maniera e poi andare a cifrare x usando RSA quindi come dicevamo prima alla fine RSA non viene applicato sul plaintext ma viene applicato su un input che dipende dal plaintext ma anche da un'informazione randomica quindi se voi andate a cifrare due volte lo stesso plaintext usando PKCS1 otterrete probabilmente due ciphertext diversi perché? perché sceglierete due valori randomici diversi chiaramente il dominio dei non deve essere super poli in modo tale che la probabilità di usare lo stesso non due volte sia negligible ok vi faccio vedere l'algoritmo proprio nel caso di RSA ok che è questo qui sono tutto troppo avanti scusate ah no ah no non glielo ho messo vabbè comunque ho messo direttamente l'attacco nel caso di RSA questo non è altro che X alla E dove è la chiave pubblica è la chiave pubblica RSA mentre questo non è altro che C alla D no dove D è la chiave segreta RSA no dove in chiave pubblica è sempre la coppia e N chiave segreta la coppia di N no ok ok quindi la cifratura la si fa in questa maniera la decifratura la si fa in quest'altra maniera ok tutto il resto rimane invariato in particolare nel modo in cui M viene codificato ovvero in questa maniera qua ok questa implementazione dello schema che in gergo viene chiamato schema di padding pubblico encryption con schema di padding è fatto così quindi con RSA come funzione con trapdoor e codifica definita in questa in questa maniera qua questa non è esattamente la versione implementata in TLS perché questa è suscettibile di attacchi poi vi faccio vedere quella che invece viene usata oggi in maniera in maniera sicura e l'attacco è l'attacco cui è vulnerabile questo tipo di schema è abbastanza simile ad altri attacchi di tipo CCA che abbiamo visto in passato non so se vi ricordate il pudro attack o attacchi simili è un attacco definito qualche anno fa da Breichenbacher e che si è rivelato essere efficace contro implementazioni di PKCS1 con RSA implementate in SSL3 se vi ricordate è l'antenato di TLS no? e l'attacco segue un po' lo schema generale dell'Attack Game della CCA Security perché è un attacco dove l'attaccante sceglie un cypher text da farsi decifrare e in base al feedback che ottiene riesce a ricavare qualche informazione utile molto simile al pudro attack che avevamo descritto nel caso nell'attacco contro l'authenticated encryption implementata con il meccanismo di MAC dell'Encrypt molto simile infatti cosa succede in questo attacco l'avversario ascolta e sniffa il canale per intercettare dei cypher text che passano e i cypher text hanno questa forma qui dove x è quella famosa codifica che vi ho fatto vedere prima cioè x è sempre qualcosa del tipo 00 02 r 00 m no ok quindi l'avversario si mette in ascolti del canale e intercetta un cypher text calcolato in quel modo ok magari da sessioni precedenti dopodichè che cosa fa l'avversario sceglie un notice e calcola un nuovo cypher text c primo come prodotto tra c e r elevato alla e dove è la chiave pubblica ok quindi c primo non è altro che x alla e per r alla e che è uguale a x r alla e ok questa roba qui quindi l'avversario costruisce un cypher text in questa maniera no e lo manda come primo messaggio di una nuova sessione come nel cc attack game questa è una decryption query no il server che riceve c primo lo va a decifrare ok come lo va a decifrare c primo lo eleva alla d d e la chiave segreta associata a d e il risultato sarà questo x per r ok a questo punto torniamo un attimo indietro una volta che il server ha decifrato c primo quindi ottiene x per r che cosa deve fare deve fare la decodifica no perché torniamo un attimo indietro sono trovante non indietro deve fare la decodifica no ovvero il server ha appena calcolato x cioè l'esito della decifratura quindi ha ottenuto questa questa informazione qua poi deve fare la decodifica no fare la decodifica nel caso di pkcs1 è molto semplice consiste banalmente nell'estrarre i bit che stanno in fondo al messaggio tolta tolto questo prefisso quindi la codifica è estremamente banale tolgo il prefisso fatto da 0002 r00 quello che mi rimane è il plaintext ok ora il server ha ricevuto un ciphertext la cui decodifica la cui decifratura è x per r ok vi ricordo che x era un messaggio corretto x per r non si sa se è una codifica corretta no perché r è un valore randomico scelto dall'avversario e questo viene moltiplicato per x quindi x per r probabilmente non rispetta questo formato magari i primi due byte non sono 0002 no se voi prendete un messaggio che ha questo formato lo moltiplicate per un valore randomico lo alterate ok lo alterate molto probabilmente in particolare alterate questi questo byte questo byte e questo byte ok quindi il server che cosa farà quando cerca di decodificare x per r molto probabilmente restituisce errore ok perché ciò che sta leggendo non rispetta questo formato quindi l'avversario che cosa impara? se il server restituisce errore l'avversario impara che la decifratura dc' è un qualcosa che non comincia con 0002 e che non ha 00 dopo il loss ok quindi deduce una proprietà del plaintext associato a c' primo ok e questo è sufficiente per fargli dargli un vantaggio ricordate fin dall'inizio l'obiettivo della cifratura è fare in modo che dall'analisi del cypher text l'avversario non deve dedurre nessun tipo di proprietà del plaintext invece in questa maniera l'avversario deduce che dalla risposta del server che il plaintext non contiene questi tre byte non il plaintext la decifratura di dc' primo non contiene quei tre byte ok è sufficiente questo per arrivare a hackerare la la chiave la risposta è sì è sì tant'è che ci sono implementazioni di questo attacco che sono riuscite a hackerare chiavi rsa di 2048 bit quindi chiavi significative facendo qualche milione di query di decryption in questo modo ok questo è il motivo per cui rsa pkcs1 così come ve l'ho raccontato da ssl3.0 in avanti non è stato più usato è stato modificato ok la la prima estensione che è stata proposta si chiama OIP Optimal Asymmetric Encryption Padding che diciamo che in principio funziona esattamente come in questo schema generale cambia solo questa roba qua che è troppo semplice come funzione di codifica troppo semplice no OIP usa una funzione di codifica basata sull'applicazione di una funzione hash che di solito è SHA256 che viene applicata a M concatenato con R quindi il risultato della codifica è qualcosa di impredicibile ok poi a un certo punto anche OIP è stato attaccato da da da Munger che ha usato un timing attack quindi un attacco basato sulla misurazione dei tempi di esecuzione dell'algoritmo dopodiché si è arrivati a ulteriori estensioni le più note oramai stabilmente sicure sono OIP plus che ci assicuro che nella sua implementazione che usa RSA prende il nome di SAIP questa è la SAIP lo stato dell'arte attualmente per quanto riguarda l'implementazione di di questo schema qua ok ha una funzione di padding che si basa comunque su funzioni hash però l'idea è sempre quella che abbiamo appena raccontato quindi si sceglie un valore randomico usando funzioni hash si combina il valore randomico con il plain text M dopodiché si usa RSA per cifrare questa codifica ok dall'altra parte si usa RSA per decifrare il cyber text e poi decodificare questo risultato per riottenere error ok questo ripeto è il modo in cui si fa cifratura chiave pubblica soprattutto per messaggi di piccole dimensioni e questo si ritrova anche in TLS ad esempio ok quindi abbiamo un ripercorso anche se in maniera più breve rispetto a quanto avevamo fatto in passato un po' la classificazione della tassonomia di schemi di cifratura a chiave pubblica quando è che sono semanticamente o in maniera equivalente ci più assicuri quando è che invece diventano poi cca sicuri sotto quali condizioni di base i due schemi che abbiamo studiato quello basato su rsa e il gamal che invece si basa su difierman quello basato su rsa è abbastanza inefficiente per cui quello che abbiamo appena visto oggi è una variante più efficiente che non utilizza per niente cifrare a chiave simmetrica ma usa direttamente ed esclusivamente rsa per cifrare non direttamente il plaintext perché altrimenti sarebbe deterministico e quindi non va bene ma si usa rsa per cifrare una codifica randomica del plaintext randomica significa una codifica che dipende dal plaintext combinato con un valore random questa è un po' l'idea di base dietro questo tipo di meccanismo questo è tutto per quanto riguarda la cifratura a chiave a chiave pubblica quindi il problema della della confidenzialità come garantire la la confidenzialità ora i meccanismi che abbiamo visto in particolare vedremo nel caso di rsa in realtà si utilizzano anche per realizzare quelle che prendono i nomi di firme digitali che adesso andremo un po' a vedere prima dal punto di vista teorico che cos'è una firma digitale poi come si implementano e vedremo che per implementarli si utilizzano si utilizza in particolare rsa in maniera opposta rispetto a al modo in cui l'abbiamo vista usato fino ad ora ma questo lo lo capiremo a breve prima naturalmente dobbiamo andare a vedere che cos'è uno schema di firma digitale e poi in conseguenza capiremo come usare rsa per realizzarlo dobbiamo condividere slide eccoci qua allora che cosa serve una firma digitale una firma digitale è un po' se vogliamo l'analogo della prova di integrità che abbiamo studiato per i meccanismi chiave simmetrica e che era basata se vi ricordate sui MAC ok il MAC che cosa serviva serviva per garantire l'integrità di un messaggio inviato perché perché il tag restituito dal MAC era un valore che dipendeva da che cosa dal messaggio e da una chiave condivisa col mittente quindi solamente un certo mittente poteva essere in grado di calcolare il tag l'assegnatura il messaggio per cui chi riceveva quel messaggio e ne vedeva il tag verificava il tag e aveva la garanzia del fatto che quel messaggio proveniva da quel particolare mittente con cui condivideva la chiave l'idea qui è la stessa cioè io voglio avere una garanzia sull'origine di un messaggio ok però questa garanzia la voglio avere in un contesto in cui non c'è condivisione di chiavi simmetriche no lo voglio questa garanzia la voglio in un contesto in cui viene utilizzata la cifratura a chiave pubblica ok questo è un po' il nostro obiettivo finale però a tutti gli effetti la firma digitale in questo contesto equivale a che cosa equivale al tag no come come intuizione equivale al tag calcolato da un mac anche il tag calcolato da un mac a tutti gli effetti lo possiamo vedere come una firma no un qualcosa che certifica l'origine di un messaggio solo che il tag di mac è basato su una primitiva che usa chiavi simmetriche le firme digitali invece si basano su scrittografia asimmetrica quindi sistemi basati su chiave pubbliche e chiave privata ok uno schema di firma digitale formalmente si definisce nel modo che vediamo in questo slide ed è facile vedere l'analogia in questa definizione con quella degli schemi di funzione con Trapdoor che invece si usano per la citatura e lo vedremo tra poco ora quali sono gli ingredienti di uno schema di firma sono tre algoritmi il primo algoritmo G già lo conosciamo è l'algoritmo di generazione di una coppia di chiavi di cui una è pubblica e l'altra è segreta cambia la terminologia quando settimana scorsa parlavamo di cifratura P-K era la chiave pubblica S-K era la chiave segreta P-K era la chiave di cifratura S-K era la chiave di cifratura questa era l'interpretazione quindi l'interpretazione è leggermente diversa perché S-K che per noi era la chiave segreta qui la chiameremo chiave di firma ok P-K che era la chiave pubblica di cifratura qui la chiameremo chiave di verifica non cambia nulla per quanto riguarda i rapporti di di di secretezza nel senso che la chiave di firma S-K è l'ingrediente segreto della coppia P-K invece è l'ingrediente pubblico ok l'algoritmo di firma usa la chiave di firma S-K che è appunto segreta deve essere un algoritmo probabilistico ok e l'output di questo algoritmo è la firma o quello che per noi nel mondo dei MAC era il tag ok e qui è denotato con sigma quindi l'algoritmo di firma prende il messaggio che vogliamo firmare e usando la chiave segreta la chiave di firma genera sigma che è la firma il tag del messaggio del messaggio ok terzo ingrediente l'algoritmo di verifica deterministico che è un algoritmo che un po' come nei MAC che cosa fa prende in input il messaggio prende in input la firma del messaggio e usando la chiave pubblica verifica se sigma è una firma valida del messaggio anio ok se andate a prendere la definizione di MAC e la confrontate con questa vedrete che sono prossimo che uguali l'unica differenza sta nel materiale crittografico usato nel MAC si usa una sola chiave simmetrica per quelle che abbiamo chiamato segnatura e verifica calcolo del tag e verifica del tag qui invece si usano due chiavi diverse una per fare l'assegnatura una per fare la firma cambia solo la terminologia l'altra invece si usa per la verifica la chiave segreta la usate per firmare la chiave pubblica la usate per verificare la proprietà di correttezza è la solita cioè se voi prendete un messaggio M e lo firmate con la chiave segreta e poi lanciate l'algoritmo di verifica su M sulla firma calcolata in questo modo e usando la chiave di verifica corrispondente alla chiave di firma allora il risultato sarà accept cioè la firma viene accettata con probabilità 1 dobbiamo tirare in ballo le probabilità perché l'algoritmo di firma è probabilistico ok ripeto gli schemi di firma sono l'analogo dei MAC solo che i MAC erano definiti usando meccanismi a chiave simmetrica ok gli schemi di firma invece vengono definiti usando meccanismi basati su chiave asimmetrica questa è l'unica differenza l'obiettivo è sempre lo stesso di là parlavamo di tag qui parliamo di firma ma alla fine in entrambi i casi si tratta di prove di integrità ok la sicurezza degli schemi di firma si basa come al solito su un attack game che è molto simile all'attack game contro i MAC chiaramente e ha come obiettivo quello di verificare se l'avversario è in grado oppure no di falsificare una firma quindi di nuovo anche qui potete andare a fare il confronto con l'attack game per i MAC e vedrete che ci sono forti analogie in questo attack game che cosa vediamo vediamo che il challenger calcola una coppia di chiavi usando l'algoritmo G pubblica la chiave di verifica dopodiché l'avversario che cosa fa l'avversario sottopone una sequenza di messaggi al challenger che risponde firmandoli quindi esibendo la firma di questi di questi messaggi e chiaramente l'obiettivo dell'avversario a un certo punto è quello di provare a falsificare la firma ovvero pubblicare una coppia messaggio firma che naturalmente possa essere verificata con successo rispetto alla chiave di verifica che conosce quindi è chiaro che se l'avversario ci riesce vuol dire che ha falsificato la firma e quindi ha violato l'integrità quindi anche in questo caso se mettete l'uno accanto all'altro tagging per gli schemi di firma e quello per i MAC vedrete che sono pressoché identici ok quindi il nostro schema si dice che è sicuro se il vantaggio dell'avversario è negligible per tutti gli avversari efficienti in questo tagging la sicurezza definita in questa maniera è forte o debole a seconda di come definiamo la forge repair cioè la falsificazione che l'avversario deve produrre nella definizione originale di sicurezza debole diciamo M nella coppia M sigma restituita dall'avversario M deve essere un messaggio nuovo diverso da quelli che ha mai firmato in precedenza il challenger nella nozione di sicurezza forte M non è detto che sia nuovo potrebbe essere un messaggio già visto già firmato in precedenza purché naturalmente l'avversario sia in grado di esibire una firma nuova per quel messaggio una firma diversa perché un messaggio può avere tante firme visto che l'algoritmo di firma è probabilistico ok quindi come per tutti gli algoritmi probabilistici noi sappiamo appunto che voi prendete prendete un messaggio M lo andate a firmare potete ottenere una distribuzione di probabilità su tante diverse firme proprio perché l'algoritmo è probabilistico quindi nell'attac game ad esempio nell'attac game che ne so l'avversario l'ha mandato al challenger il challenger ha restituito questa firma qua se l'avversario è in grado di trovare un'altra firma per lo stesso messaggio vince vince l'attac game e viola la sicurezza forte ok spesso gli schemi di firma vengono combinati con le funzioni hash ma lo stesso l'avevamo visto con gli mac vi ricordate la costruzione hash del mac dovevamo calcolare il tag di un messaggio se il messaggio è molto grande prima di calcolare prima di applicare il mac al messaggio si applicava una funzione hash al messaggio e il mac si applicava al digest del messaggio qui succede la stessa cosa se il messaggio è troppo grande se il messaggio che dovete firmare è troppo grande in realtà la firma non si applica al messaggio ma si applica al digest del messaggio ok e chiaramente se la funzione hash che si utilizza è resistente alle collisioni e se lo schema di firma è sicuro questa variante è altrettanto sicura quindi usare nel mezzo una funzione hash resistente alle collisioni non compromette la sicurezza di uno schema di firma digitale sicuro ok quindi questa è una cosa che si può fare senza senza problemi l'importante è usare appunto una funzione hash resistente alle collisioni ok ora tornando un attimo alla definizione che abbiamo dato di schema di firma digitale se vedete questo è molto simile ad esempio alla definizione di schemi di funzione con trapdoor a ruoli invertiti perché negli schemi di funzione con trapdoor ad esempio adesso è un caso di schema di funzione con trapdoor che cosa si fa prima si codifica il messaggio usando la chiave pubblica poi sul risultato applicando la chiave segreta si utilizza l'altro algoritmo che mi fa restituire il nuovo messaggio qui succede qualcosa di analogo ma al contrario negli schemi di funzione con trapdoor la tripla era G F E E E la funzione F che cosa faceva? faceva questa operazione ok la funzione I faceva questo giusto questa era la definizione che abbiamo visto gli schemi di funzione con trapdoor RSA un esempio in cui in cui F fa questa operazione e fa questa operazione dove sono chiave pubblica chiave segreto ok ora riguardiamo la definizione che abbiamo dato di schema di firma digitale è molto simile no però lavora al contrario perché perché la firma la fate usando la chiave segreta la verifica successivamente la fate usando la chiave pubblica allora si potrebbe chiedere va bene ma come realizzo nella pratica uno schema di firma digitale beh possiamo usare uno schema di funzione con trapdoor dove questa operazione qui rappresenta la firma quest'altra rappresenta la verifica ok questa è un po' l'idea ovvero tornando a all'esempio di rsa questa è l'operazione che vi permette di firmare questa è l'operazione che vi permette di verificare lo usate al contrario visto che la firma la si fa con la chiave segreta e la verifica con la chiave pubblica usate il rsa al contrario ed ecco che avete un modo per fare una firma digitale andiamo a vedere la definizione astratta di come potete usare uno schema di permutazione con trapdoor per realizzare firme digitali in realtà è leggermente più complicato di come ve l'ho detta perché adesso come vedremo interviene anche una funzione hash ok vedremo come e il risultato prende il nome di full domain hash signature scheme ok quindi vediamo brevemente voi usate uno schema di permutazione con trapdoor dove io vi ricordo che la funzione f è quella che prende qui viene usato m quindi quella che prende m usa la chiave pubblica e viene restituito un chiamiamo y per cui vale questa condizione qua ok questo è il modo in cui funzionano gli schemi di permutazione con trapdoor l'idea è di usarlo al contrario per realizzare uno schema di firma digitale in che modo andiamo a vedere allora l'algoritmo di generazione delle chiavi è sempre lo stesso quindi generiamo la coppia pk sk ok dopodiché la firma l'algoritmo di firma è quello che usa la chiave segreta ok quindi dobbiamo usare questo algoritmo qua dello schema di permutazione con trapdoor vedete l'algoritmo di firma prende la chiave segreta il messaggio che vogliamo firmare e usa questo algoritmo dello schema di permutazione con trapdoor che è quello che usa la chiave segreta però non direttamente sul messaggio ma sul suo digest tra poco capiremo perché ok l'algoritmo di verifica si basa sulla chiave pubblica e quindi si dovrà basare su questo algoritmo dello schema di permutazione con trapdoor ok infatti che cosa succede succede che voi usando la chiave pubblica applicata sulla firma ok che è questa questa è la firma ok usando l'algoritmo f dello schema di permutazione con trapdoor recuperate un certo y che se è uguale al digest di m mi dà mi dà mi dà mi dà successo perché vuol dire che allora la firma era valida ok questo è il modo in cui funziona fondo me nasci ok ora perché qui non metto direttamente m immaginiamo di definire una variante fatta così il motivo è ancora più semplice perché comunque questo non è ancora probabilistico nel senso che come dice qua fissata una copia di chiavi ogni messaggio ha una sola firma però il motivo il motivo per cui comunque diciamo non è problematico deriva dal fatto che viene usata la funzione hash lo vediamo vedendo che cosa succede se non usassimo la funzione hash se la firma fosse semplicemente fatta così no quindi per firmare io uso l'algoritmo i direttamente su su m ok quindi per verificare la firma io non avrei bisogno di fare questo controllo perché dovrei restituire direttamente direttamente m ok ma se le cose stessero così l'avversario cosa può fare l'avversario sceglie qualunque input chiamiamolo sigma primo per f ok sceglie un sigma primo di qualunque genere applica l'algoritmo f usando la chiave di verifica che quella la conoscono tutti e recuperare che cosa recuperare un messaggio m primo la cui firma è sigma primo quindi m primo sigma primo ha tutti gli effetti che cos'è è una coppia falsificata dall'avversario perché riesco a costruirla usando solo informazioni pubbliche no è chiaro e questo è il motivo per cui viene usata la funzione hash perché avendo usato una funzione hash se la funzione hash è resistente alle collisioni questo giochino l'avversario non lo può fare perché perché anche se l'avversario sceglie un sigma primo come cavolo gli pare a lui usa la chiave pubblica e ottiene un un m primo questo m primo non è il messaggio la cui firma è sigma primo questo m primo è il digest di un messaggio la cui firma è sigma primo ok quindi per sapere per sapere qual è il messaggio di cui sigma prima la firma l'avversario dal digest dovrebbe passare al messaggio vero e proprio ma per farlo dovrebbe invertire h ma se h è resistente alle collisioni quindi è one way l'avversario non è in grado di invertirla e quindi ricostruire la coppia messaggio firma ok questo è il motivo per cui si firma il digest e non il messaggio ok e questo è il motivo per cui c'è un teorema che dice che se lo schema di permutazione con trapdoor che usiamo è sicuro quindi è one way e la funzione hash anche questa è one way è sicura quindi è un random oracle allora lo schema di firma digitale che abbiamo appena costruito cioè questo qui è uno schema di firma digitale sicuro ok naturalmente se come schema di permutazione con trapdoor usate RSA ecco che avete la versione RSA del full domain hash signature schema non mi ricordo se l'ho messa però se non l'ho messa è facile da ricavare ah sì ce l'ho questo almeno ce l'avevo ed ecco che avete uno schema di firma basato su RSA quindi l'algoritmo è quello che genera la coppia di chiavi RSA quindi i cui risultato sono questa chiave di verifica e questa chiave di firma la chiave di verifica viene pubblicata è nota tutti la chiave di firma se la tiene solo chi deve fare la firma dopodiché l'algoritmo di firma che cosa fa immaginiamo di voler firmare un messaggio M calcolo il digest di M ad esempio usando SHA 256 e applico la chiave segreta per calcolare la firma tramite RSA e nel RSA sappiamo come avviene basta prendere Y e elevarlo alla D e questa è la firma ok l'algoritmo di verifica usa la chiave pubblica quindi che cosa fa prende la firma la eleviamo alla E che è la chiave di verifica la chiave pubblica e se ciò che otteniamo è il digest di M allora accettiamo la firma ok quindi alla fine uno schema come RSA lo potete usare a seconda di come lo usate naturalmente o per fare cifratura la chiave pubblica o per fare firme digitali no cioè esempio immaginiamo che io abbia questa coppia di chiavi ok questa è la mia coppia di chiavi questa la conoscete tutti questa me la tengo io per me ok ora se voi usate questa chiave chiave pubblica per cifrare un messaggio da mandarmi quindi M è un messaggio che voi volete mandare a me in maniera confidenziale e fate questa operazione voi state cifrando il messaggio ok e solo io che conosco di lo posso recuperare quindi state usando RSA per fare cifratura a chiave pubblica ovvero proteggere un messaggio rispetto alla confidenzialità perché mi volete mandare un messaggio privato che nessuno è in grado di leggere ho semplificato in realtà l'abbiamo visto prima l'abbiamo visto la settimana scorsa RSA non è che lo usate così com'è per fare cifratura ma usate o Pkcs1 usate RSA con un cifrario simmetrico non è importanza però in una maniera più o meno complessa voi state usando la chiave pubblica di RSA per cifrare un messaggio da mandare a me quindi confidenzialità ragioniamo al contrario ok io voglio mandare un messaggio a voi quindi stiamo ragionando la direzione opposta e voglio darvi la garanzia che quel messaggio proviene da me non da qualcun altro quindi cosa faccio io prendo quel messaggio e lo firmo e come lo firmo lo firmo usando la mia chiave segreta quindi ho io stavolta un messaggio da mandare a voi integro lo firmo e in questo caso la firma sigma che cos'è? è M alla D in realtà non è proprio M è il digest di M ok è il digest di M alla D D è la mia chiave segreta voi ricevete questa coppia fate la verifica usando la chiave pubblica e per verificare che M e sigma sia una coppia valida no? quindi a seconda della direzione in cui comunichiamo siete voi che volete mandare un messaggio confidenziale a me o sono io che voglio mandare un messaggio integro a voi in ogni caso viene usato anche se in maniera un po' diversa sempre RSA ok usando prima la chiave pubblica per fare decifertura e quindi la decifertura che è la chiave segreta oppure al contrario usando prima la chiave segreta per fare la firma e usando la chiave pubblica per fare la verifica allora l'esempio che vi ho fatto riguarda la mia coppia di chiave pubblica segreta e quindi l'esempio che vi ho fatto naturalmente riguarda la situazione in cui voi volete mandare a me un messaggio confidenziale oppure io voglio mandare a voi un messaggio integro e integro e poi giro io la domanda a voi se io voglio mandare a voi o a uno di voi semplifichiamo se io voglio mandare a uno di voi un messaggio che sia sia confidenziale che integro come si fa? bisogna no bisogna sì esatto bisogna usare allora perché io vi mando un messaggio integro devo usare la mia chiave segreta per firmare il messaggio e quindi fare questa cosa qua ok se voglio garantire la confidenzialità cosa mi serve? mi serve la chiave pubblica del destinatario ok quindi bisogna lavorare sia con la mia coppia di chiavi ma anche rispetto a quella del destinatario quindi a quel punto che cosa farò? userò la chiave pubblica del destinatario per cifrare M e magari anche la firma dopo dipende vi ricordate quando mi ha fatto l'autenticata di encryption lì si faceva encrypt del Mac oppure Mac del encrypt e qui è la stessa cosa solo che l'encrypt lo facciamo usando RSA nella forma che abbiamo in una delle forme che abbiamo visto ok il Mac lo facciamo con la firma digitale ok quindi anche se in maniera diversa di fatto che sia che noi facciamo encrypt del Mac sia che noi facciamo Mac dell'encrypt stiamo comunque usando RSA in due modi diversi no? perché la cifratura si fa o con KCS1 o con RSA combinato con un cifrado simmetrico mentre invece la firma si fa con RSA e full domain hash che è questa roba qua poi ce ne sono altre ad esempio lo stesso PKCS1 si può usare per le firme ok però si combinano esattamente nello stesso modo in cui abbiamo visto nel caso dell'encrypt del Mac o Mac dell'encrypt lo vedremo nel dettaglio come funziona questa cosa qui si prenderà il nome di Si Encryption è l'equivalente dell'autenticata dell'encryption però fa questo giochino in questo caso devi usare RSA due volte basarsi su due schemi diversi che però sono entrambi basati su RSA per fare il maincrypt e per fare il Mac cioè per fare la firma è chiaro che mi servono due coppie sono in ballo si usano due coppie di chiave diverse la mia perché la mia serie è per fare la firma quella del destinatario per garantire la confidenzialità quindi serve se sono io il mittente mi serve la mia chiave segreta per la firma e la chiave pubblica del destinatario per la cifra o viceversa scambiandoci scambiandoci il ruolo è chiaro? questo è l'ultima cosa vi dico ci salutiamo qui c'è il teorema appunto che dice che full domain hash fatto con RSA è sicuro che è quello che avevamo appena appena detto per motivi che sapevamo e va bene direi che ci possiamo fermare qui e continuare la prossima volta che sarà il 30 di aprile quindi dopo dopo la pausa pasquale ok quindi sì mercoledì mercoledì 30 aprile va bene grazie alla prossima domenda Grazie a tutti.