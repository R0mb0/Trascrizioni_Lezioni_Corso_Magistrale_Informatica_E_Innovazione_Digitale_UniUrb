Ok, quindi riprendiamo la lezione sulla sicurezza di tipo CPA, quindi cifrari che sono CPA sicuri, per CPA intendiamo il chosen plan test attack che abbiamo descritto ieri. Quindi abbiamo visto che per avere un cifrario CPA sicuro è necessario passare da cifrari deterministici a cifrari probabilistici. E abbiamo visto in mia teorica come questo si può fare con due applicazioni pratiche, il randomized counter mode e il CBC mode, che sono appunto due modi alternativi di rendere probabilistico un cifrario che di base è deterministico. Vi faccio vedere oggi brevemente un'applicazione dei cifrari CPA sicuri, dopodiché chiuderemo la parte relativa alla confidenzialità, quindi ci sposteremo su un'altra proprietà di sicurezza. Il caso d'uso che vi avevo già anticipato riguarda il sistema di cifratura utilizzato nell'ambito dei DVD e dei Blu-ray. Nell'ambito dei DVD il sistema prende il nome di Content Scrambling System, CSS, ed è il sistema che si utilizzava per cifrare tipicamente un film all'interno di un DVD in maniera tale da proteggerlo da tentativi di copia. E quindi prevenire atti di pirateria. Il CSR originale, che risale agli anni 90, è un protocollo che fa uso di cifrari CPA sicuri, quindi di cifrari probabilistici. In che maniera? Qui vediamo chiaramente ad un certo livello di astrazione come funziona la cifratura. Allora... Allora... Allora... Ecco qua. Allora, come avviene la cifratura di un film all'interno di un DVD? Il film è il plaintext, che dobbiamo memorizzare in maniera protetta all'interno del DVD. La cifratura del plaintext, quindi del film, avviene con una chiave. Ogni film ha la sua chiave, fondamentalmente. Questa è l'idea. Ad esempio, nel nostro caso, nel nostro esempio, questa è la chiave randomica, casuale, che viene scelta per cifrare il film. Il problema qual è? Il problema è far condividere questa chiave con tutti quanti i dispositivi su cui poi vogliamo mandare in play il DVD e guardare il film. Ok? È chiaro che non possiamo pensare che un dispositivo a priori possa condividere tutte le chiavi con cui tutti i film erano cifrati. Questo non ha consenso in un contesto reale. E quindi che cosa si fa? Beh, si associava ogni produttore di lettori DVD con una chiave. Ok? Quindi la Panasonic aveva la sua chiave, la Itachi aveva la sua chiave, la Sony aveva la sua chiave e così via. Quindi ogni distributore, ogni produttore di lettori di DVD aveva una chiave da associare al dispositivo. Ok? Quella che qui viene indicata con KD, di Staper Device. Quando veniva prodotto un film e distribuito il DVD, per cui in prima battuta ci scendiva la chiave per cifrare il film, cosa si faceva? Beh, all'interno del DVD si andava a memorizzare un ciphertext della chiave ottenuto con ciascuna delle KD note. Quelle sono note, ok? Note, diciamo, ai produttori di film. Perché? Perché gli vengono comunicate segretamente dai vari produttori. Quindi la Sony dà la propria chiave del dispositivo alla Warner. La Warner fa uscire un film e quindi la Warner conosce la chiave di un dispositivo della Sony e la usa per cifrare la chiave di cifratura del film. Perché la chiave di cifratura del film, questa qui, è diversa per ciascun film. Quindi cosa fa la Warner? Fa quest'operazione qua. Per alcune le due. Quindi usa la chiave del dispositivo che conosce per cifrare la chiave di cifratura del film. Ok? Se le chiavi dei dispositivi sono 100, io devo creare 100 diversi ciphertext. Ok? Quindi per ogni device key io faccio questa operazione. Creo un ciphertext della chiave di cifratura del film. E questi ciphertext li memorizzo dentro il DVD. Ok? Poi dentro il DVD vado a memorizzare il film criptato. Con la chiave K. Ok? Dopodiché all'interno del DVD vado a scrivere questa sequenza di ciphertext. Questo è il modo in cui venivano memorizzate le informazioni all'interno del DVD. Quindi dentro il DVD c'è il film criptato. Con la chiave K. Ogni film ha la sua. E accanto al film criptato c'è un elenco di tanti ciphertext. Che tutti questi ciphertext cifrano la stessa cosa. Cioè la chiave K. Però ciascuno ottenuto con una diversa device key. Sì. Sì. Ogni device key è associato a un manufacturer. A volte è associata a un singolo manufacturer. Ne aveva diverse. Una per ogni famiglia di dispositivi. Ok? Però il concetto è che ogni device key è associata non a un singolo dispositivo specifico. Ma l'intera produzione. L'intera produzione di dispositivi di quel tipo. Ok? Quindi quando su un certo dispositivo veniva inserito un DVD. Il dispositivo che cosa faceva? Il lettore cosa faceva? Andava a cercare tra i tanti ciphertext. Quello associato alla chiave memorizzata dentro il dispositivo. Quindi andava a decifrare K. E poi con la chiave K andava a decifrare il film. Questa era l'idea. Ok? Ora. No, no, no. Every film has a key. Yeah. The same key for all the copies. And that's one of the reasons why Piersy has been possible. Vabbè, by the way. Quindi, quali sono le caratteristiche dei cifrali che venivano utilizzati? Beh, questo Piersy Piedeva essere semplicemente un cifrario semanticamente sicuro. Quindi deterministico. Perché? Perché la chiave K veniva usata per memorizzare un solo plaintext. Quindi si poteva usare un block cipher, uno string cipher, quelli che conosciamo. Non c'era bisogno che fosse probabilistico, proprio perché la chiave K veniva usata una volta sola per memorizzare il film, il plaintext. Questo invece doveva essere un cifrario probabilistico. Ok? Cioè un cifrario CPA sicuro. Proprio perché la stessa device K veniva usata tante volte, quanti sono in diversi film. Ok? Quindi se vogliamo usare la stessa chiave più volte, dobbiamo usare un cifrario probabilistico se vogliamo essere CPA sicuro. Ok? Quindi ad esempio questo poteva essere AES 128 in CBC Mod. Per fare un esempio. Ok? Ora il problema qual era? Il problema era che se una di queste veniva violata, ed è quello che è successo, ok? Chiaramente essendo la stessa per tutti i dispositivi di una stessa famiglia, ecco che si poteva piratare, fare atti di pirateria per copiare legalmente i film, perché violata una chiave, violati tutti quanti i dispositivi di quello stesso tipo. Ok? Ed è così che di fatto le cose, è in questo modo che le cose sono andate. Per comprometterla hanno fatto delle... Beh, hanno... Diciamo che hanno usato soprattutto delle side channel attacks, perché la chiave è immunizzata nel dispositivo, quindi avendo disposizione nel dispositivo e quindi con le strumentazioni opportune per fare dei side channel attacks sul dispositivo, alla fine una chiave è stata recuperata in questa maniera qua, fondamentalmente. ci sono degli articoli in letteratura che raccontano come... come avveniva la critanalisi di queste chiavi. Ok? Ok? Quindi quando il CSS è stato compromesso in questa maniera qua, si è cercato un modo per isolare questo tipo di problema e quindi far sì che la compromissione di una di queste non comportasse la violazione di tutti quanti i film passati e futuri, chiaramente, no? perché è chiaro che una volta che una di queste chiavi viene violata, in teoria il produttore dovrebbe buttare via tutti quanti i dispositivi già venduti di un certo tipo, cioè quelli associati a quella chiave, che è chiaramente impensabile. Come si è cercato di risolvere questo problema? Beh, di fatto associando chiavi diverse a dispositivi diversi. in una maniera chiaramente efficiente, perché altrimenti non è che questa cosa qui, questa operazione qui, la potete scalare fino a un milione, due milioni, dieci milioni di dispositivi, non c'è spazio, non devo dire, per memorizzare tanti, sai, far text quante sono i diversi dispositivi con chiavi diverse. Chiaramente la cosa è impensabile. E quindi se pensate a una soluzione abbastanza interessante, che consisteva, scusate, ecco, che consisteva nel creare un albero di chiavi. Ok? Perché un albero di chiavi? Adesso ne vado a dire. Questa è l'idea che sta alla base dell'estensione del CSS che ha dato origine all'Advanced Access Content System, che è il sistema che invece è utilizzato nei Blu-ray. Ok? Allora l'idea qual è? L'idea è di avere una chiave diversa per ogni dispositivo. Ok? Ogni device, ogni lettore di Blu-ray ha la sua chiave. Ok? Quali sono queste chiavi? Le vediamo a livello delle foglie di questo albero binario. Queste sono le chiavi dei dispositivi. Qui l'esempietto con otto dispositivi. Ok? Bene. Sopra queste chiavi viene costruito un albero binario dove ogni nodo interno è associato con una nuova chiave random. Quindi K9, K10, 11, 12 e così via. Allora ci sono delle chiavi. Chiavi random. Ok? Ora l'idea qual era? L'idea era che nel dispositivo, in questo caso il numero 3, veniva incapsulata, veniva memorizzata la sua device key ma anche tutte le chiavi associate ai nodi del percorso che da quella foglia va alla radice. Quindi in questo caso quattro chiavi. Ok? Ora è chiaro che qui ad esempio con otto magari le chiavi sono milioni. No? Quindi l'n può essere molto grande però in questa maniera dentro ogni dispositivo venivano memorizzate quante chiavi. Logaritmo in base 2 di n. Ok? In questo caso le abbiamo otto chiavi otto dispositivi le chiavi memorizzate in ogni dispositivo sono quattro. Ok? Perché a ogni questo è un albero binario quindi in funzione del logaritmo in base 2 di n arriviamo alla radice. ok? Quindi nel primo dispositivo le chiavi numerizzate sono K1, K9, K13, K15 nel secondo dispositivo sono K2, K9, K13, K15 e così via. Dentro ogni dispositivo ci sono quattro quattro chiavi. Ok? Perché questo? Ora andiamo a vedere quello che succede quando si cifra un film no? Ora la cifratura del film viene in questa maniera qua. Ovvero come per i DVD si sceglie una chiave per cifrare il film. ok? E viene fatta la cifratura del film usando un cifrario semanticamente sicuro. Ok? Poi e qui viene la novità la chiave di cifratura del film viene cifrata usando che cosa? Usando questa chiave qua. La chiave associativa è associata alla radice dell'albero. Perché? Perché con questa? Perché questa chiave qui è presente in tutti i dispositivi. No? Tutti i dispositivi conoscono K15. Quindi tutti i dispositivi possono decifrare C1 per ottenere K e quindi decifrare C cioè il film per ottenere appunto il film in chiave. Ok? ora quindi fin qui sono poche le novità rispetto al contesto del DVD. Dov'è che emerge l'utilità di questa struttura ad albero? Emerge nel momento in cui una delle chiavi viene compromessa. ok? Ok? Immaginiamo che gli hacker riescano a piratare uno dei device e quindi a pubblicare nel dark web tutte le chiavi di quel device. Immaginiamo che il device sia il numero 3. Quindi nel dark web vengono pubblicate K3 K10 K13 e K15 diventano di pubblico dominio. Ok? Non appena succede questo quelle quattro chiavi devono essere revocate. No? Allora mentre nel caso di DVD la revoca non si poteva fare perché revocare una chiave significava buttare via tutti i device. No? In questo caso diciamo non dobbiamo buttare via tutti i device cioè il primo il secondo il quarto il quinto e così via devono poter continuare a lavorare. Beh questo si può fare spostando la nado perché è vero che buttiamo via queste però se continuiamo a usare le altre chiavi per cifrare il film ecco che salviamo i device tranne il terzo. Ok? Ad esempio in questo caso specifico supponendo che questo device sia stato compromesso allora la cifratura di un film come avviene? Più o meno come prima nel senso che scelgo una chiave con la quale cifro il film dopodiché la chiave in cifratura del film la vado a cifrare usando che cosa? Usando chiavi dell'albero che consentono a tutti i dispositivi tranne il terzo di recuperare K ok? Come faccio a sapere quali sono queste chiavi? Beh mi basta visitare il cammino delle chiavi compromesse e andare a vedere chi è la chiave vicina il sibling no? Ok? Partendo da K3 chi è la vicina di K3? K4 quindi devo usare K4 per cifrare K poi vado su l'altra compromessa era K10 chi è il sibling di K10? E K9 e quindi uso anche K9 per cifrare K poi vado su 13 compromessa chi è il sibling è 14 e quindi uso anche K14 per cifrare K poi arriva l'altra dice che è compromessa quella ormai non serve più a niente quindi di fatto quello che succede è che nel nel Blu-ray io mi ritrovo la chiave di cifratura del film cifrata con questa ma anche con questa ma anche con questa bastano tre chiavi ora tutti i dispositivi tranne quello compromesso sono in grado di recuperare il film l'unico dispositivo che non è in grado di recuperare il film è il terzo perché lui conosce solo queste quattro chiavi tutti gli altri riescono a recuperare K o usando K4 o usando K9 o usando K14 perché vi ricordo che ogni dispositivo conosce tutte le chiavi che vanno dalla foglia che rappresenta il dispositivo fino ad arrivare alla radice ok quindi la differenza rispetto al CSS è che con questa soluzione diventa possibile revocare una chiave senza per questo compromettere l'uso dei dispositivi ok ok mentre prima quindi non si poteva fare se una chiave era compromessa allora erano compromessi tutti i dispositivi che usavano quella chiave poi in realtà anche per i blu-ray ci sono stati dei problemi di pirateria ma non per colpa di questa struttura d'albero ma per il modo in cui K era memorizzata fisicamente nell'hardware del dispositivo si è riusciti in certi casi a fare criptanalisi di K e quindi anche nel caso del blu-ray si è riusciti in un modo diverso rispetto al caso di DVD a piratare a piratare film fondamentalmente questa è un po' l'idea però l'idea di questo protocollo per la regola delle chiavi è buona che funziona viene utilizzata anche in altri contesti perché capita in certe situazioni in cui per qualche motivo una chiave deve essere evocata e questo è un modo per poterlo fare andando a compromettere solamente uno specifico in questo caso device può essere un utente piuttosto che altro ok chiaramente anche in questo caso E è un algoritmo di cifratura di un cifrario CPA sicuro quindi probabilistico mentre invece il primo può essere l'algoritmo di cifratura di un cifrario deterministico va bene questo è l'esempio che vi volevo mostrare questo diciamo completa la parte relativa ai cifrari il cui obiettivo è quello di proteggere la confidenzialità delle informazioni volevo farvi vedere un schema che riassume quello che abbiamo quello che abbiamo visto è questo questo schema riassume la panoramica un po' dei diversi tipi di cifrari che abbiamo introdotto i legami che esistono tra di loro sia in ambito deterministico che probabilistico in particolare siamo partiti dai PRG scusate dagli string cipher basati sui PRG che sono basati sui PRG e che sono cifrari semanticamente sicuri se il PRG è sicuro ok poi siamo passati ai block cipher che sono semanticamente sicuri se appunto risultano essere sicuri rispetto alla game che abbiamo visto qualche lezione fa e abbiamo visto che i block cipher usati in questa maniera qua non vanno bene cioè non è che posso prendere un block cipher e cifrare tutti i blocchi di un plaintext sempre usando la stessa chiave perché ricadono il problema di cifrare per sostituzione quindi questi sono deprecati ok abbiamo visto come i block cipher nella pratica vengono realizzati l'esempio che abbiamo studiato è quello del del gas ok poi abbiamo visto alcune di queste frecce nel senso che abbiamo abbiamo fatto vedere in particolare che un block cipher può essere visto come un caso particolare di un prf prf è un function che ha un certo dominio un certo codominio quando dominio e codominio coincidono allora si parla di block cipher che si comporta come una funzione di permutazione la cifratura si comporta come una permutazione cioè donando un function come qualunque funzione e allora abbiamo fatto vedere che se il block cipher è sicuro e il suo dominio è super poli allora quel block cipher è anche un prf sicuro perché questo è utile è utile perché perché abbiamo fatto vedere che preso un prf sicuro possiamo costruire un prg sicuro e quindi uno string cipher semanticamente sicuro quindi abbiamo fatto vedere questo passaggio ok che prende il nome di deterministic counter mode abbiamo accennato al fatto che esistono anche altri passaggi non li abbiamo approfonditi perché questi sono meno interessanti quindi in particolare questo ma anche questo qua sappiamo solo che esistono ci interessa e fin qui siamo nell'ambito dei cifrari semanticamente sicuri sotto l'ipotesi che la chiave venga usata una volta sola se vogliamo usare una chiave più di una volta per cifrare più il plaintext i cifrari deterministici non vanno più bene abbiamo visto ieri bisogna passare a quelli probabilistici ok e il modo generale per farlo è di considerare un PRF e un cifrario deterministico combinarli per ottenerne uno probabilistico le implementazioni pratiche che abbiamo visto di questa idea sono il randomized counter mode e il cbc mode uno usa un PRF sicuro l'altro usa un block cipher sicuro in entrambi i casi il risultato è un cifrario cpa sicuro cioè sicuro rispetto al chosen point text attack probabilistico ok quindi la morale di tutto questo discorso è che per garantire la confidenzialità dei vostri messaggi occorre utilizzare questo tipo di cifrario cioè cifrario probabilistici cpa sicuri ok e abbiamo visto sotto quali condizioni se usiamo queste costruzioni abbiamo la garanzia che siano davvero cpa sicuri questo riassume un po' le le basi di quello che abbiamo visto fino adesso adesso ci spostiamo e dalla confidenzialità dalla secrecy ci muoviamo verso l'integrità ok quindi il tema adesso è non ci interessa tanto proteggere la segretezza di un messaggio ci interessa proteggerne l'integrità dal fatto che alice che vuole mandare un messaggio a bob e vuole che a bob arrivi esattamente il messaggio che alice gli ha mandato e che questo non possa essere alterato da qualcuno che si comporta da man in the middle come? no esatto ok questa è l'idea quindi adesso non ci preoccupiamo più della secrecy ma ci preoccupiamo dell'integrity poi dopo chiaramente metteremo insieme sia secrecy che integrity nello stesso nella stessa soluzione ok però prima li esaminiamo separatamente ok quindi ok quindi il problema diventa questo ok quindi passiamo da una situazione in cui alice mandava un messaggio a bob e un avversario che ascolta voleva capire quale fosse il contenuto del messaggio e quindi il messaggio veniva cifrato in maniera tale da impedire all'avversario di capire quale fosse il play adesso invece il problema è alice vuole mandare un messaggio a bob non ci interessa che l'avversario lo legga ci interessa che l'avversario non sia in grado di manipolarlo modificarlo ok quindi l'integrità ok ora il problema dell'integrità esiste già prima ancora che si sviluppasse il tema della cyber security quando è nata internet il problema dell'integrità esisteva e aveva a che fare con la correttezza non tanto con la sicurezza perché perché la rete non è perfetta ci possono essere dei degli errori in trasmissione e allora a lato destinatario come si fa a capire se una sequenza di bit che è stata trasmessa dal mittente è quella corretta o qualche bit è stato cambiato per colpa di errori di trasmissione legati al canale quindi il basso di corrente o quel che è qual'era la soluzione che si adottava e che si sono implementate già dagli anni 60 70 quando 70 quando sono cominciati a fare i primi esperimenti di di trasmissione dei dati sulla rete uno degli esempi consisteva nell'usare degli algoritmi per la verifica dell'integrità dei messaggi un esempio tipico era il CRC32 non so se l'avete mai sentito ricordare ad esempio di un corso di reti che è un algoritmo che di fatto che cosa faceva prendeva il messaggio calcolava un valore sulla base di quel messaggio l'esempio più banale può essere calcolare la parità del messaggio quindi contare quanti sono i bit 1 quindi in qualche modo l'output del CRC32 è un valore che dipende dal messaggio che si trasmette questo output chiamiamolo tag quindi il mittente trasmetteva al destinatario il messaggio e il tag del messaggio il destinatario che sapeva anche lui quale algoritmo era stato usato per calcolare il tag a partire dal messaggio faceva il test di verifica appunto per verificare che applicando l'algoritmo il messaggio ricevuto si ottenesse lo stesso tag quindi Alice quindi l'idea era che Alice manda a Bob il messaggio e il tag del messaggio no no sto parlando di come funzionava in originale il CRC32 nelle prime versioni del protocollo Ethernet ok a Bob Bob per verificare l'integrità di M semplicemente doveva applicare lo stesso algoritmo usato da Alice e fare il confronto con il tag se erano uguali vuol dire che il messaggio era integro ok questa stessa idea di base la possiamo usare anche per l'integrità nell'ambito della cyber security però così com'è non funziona perché così com'è non funziona perché mettiamoci nei panni di un man in the middle che vede passare un messaggio e tag semplicemente può modificare entrambi quindi sostituire M con M primo sostituire T con T primo a Bob arrivano M primo e T primo Bob fa il check tag di M primo e T primo e quindi Bob conclude che il messaggio è integro quando in realtà non è così ok quindi in qualche modo se vogliamo garantire l'integrità rispetto a man in the middle malevoli no dobbiamo proteggere la creazione del tag questa è l'idea ok e l'unico modo per proteggere la creazione del tag cioè far sì che il man in the middle non possa sostituire M T con M primo T primo consiste nell'usare una primitiva chettografica analoga ai cifrari che consenta di calcolare il tag di un messaggio usando una chiave ok come si fa con la cifratura quindi assumere che Alice conosca una chiave K che condivide con Bob quindi esattamente come nella cifratura chiave simmetrica che abbiamo visto per la confidenzialità dopodiché l'idea qual è l'idea è di usare una primitiva chettografica un'operazione chettografica che prende il messaggio e usando la chiave crea il tag dall'altra parte a questo punto posso trasmettere la coppia MT dall'altra parte chi riceve la coppia MT userà una funzione di verifica che usando la chiave K il messaggio M e il tag T stabilisce se il messaggio è integro oppure no però la cosa importante è che per fare la verifica mi serve la chiave così come per fare per creare il tag mi serviva la chiave ok il fatto che serva la chiave per fare per creare il tag e per fare la verifica del tag fa sì che un man in the middle interviene qui nel mezzo non possa modificare la coppia MT senza che il receiver se ne accorga perché l'avversario cosa dovrebbe fare sostituire questa coppia con un'altra ok valida rispetto ad una chiave che l'avversario però non conosce ok quindi per garantire l'integrità in un contesto in cui ci sono avversari malevoli non possiamo semplicemente usare un protocollo senza chiave come quelli che esistono dall'ethernet in avanti ma dobbiamo usare un protocollo con chiave ok qui i due algoritmi sono prima i due algoritmi erano E encryption D decryption ok adesso gli algoritmi sono S che sta per signature perché T il tag T è una segnatura del messaggio ok T è come una firma che mettiamo sul messaggio usando la chiave K ok vista per verifier ok quindi questo algoritmo firma segna il messaggio M creando il tag questo algoritmo verifica che questo tag sia corretto per il messaggio M rispetto alla stessa chiave che è stata usata da chi ha fatto la segnatura ok chiaramente prima di andare a vedere come si può implementare come si può implementare S come si può implementare V dobbiamo capire innanzitutto come definire la sicurezza di meccanismi di questo genere quindi abbiamo bisogno anche qui di un attack game no questi meccanismi vengono chiamati MAC ok message autoenticato autoenticato in codice codice di autenticazione dei messaggi ok quindi c'è un attack game per stabilire come si definisce la sicurezza di un MAC dove un MAC che cos'è qui viene tra definizione formale di quello che ho appena raccontato a parole un MAC è questa coppia un MAC è questa coppia di algoritmi uno che serve per creare il tag associato al messaggio usando una certa chiave e un altro per fare la verifica del tag rispetto chiaramente alla stessa chiave il risultato della verifica è booleano vero o falso accetto il rifiuto il tag e questa è la proprietà di correttezza ok cioè se io faccio la segnatura di M con K e questa segnatura questo tag lo verifico rispetto allo stesso messaggio M e alla stessa chiave K allora con probabilità uno il risultato sarà set ok ok ok questo invece è l'attack game che useremo per stabilire la sicurezza di un Mac cioè quando è che un Mac è sicuro ok quindi esattamente come abbiamo fatto per la confidenzialità vedete che la definizione di sicurezza la possiamo già vedere è questa qua che cosa dice dice che il nostro Mac è sicuro se il vantaggio dell'avversario nel gioco che andremo a descrivere deve essere come sempre trascurabile negligible per tutti gli avversari efficienti vedete la definizione è sempre la stessa un sistema sicuro se il vantaggio dell'avversario in un certo game in un certo gioco è trascurabile per tutti gli avversari efficienti quindi dobbiamo andare a vedere come è fatto il gioco ok e vedrete che intuitivamente questo gioco ci dice cosa deve fare l'avversario per violare l'integrità no? allora vediamo un po' come si svolge il gioco abbiamo il challenger che sceglie casualmente la chiave K per fare una segnatura e abbiamo l'avversario che decide quali messaggi il challenger deve segnare ok quindi l'avversario sceglie una sequenza di messaggi che il challenger deve firmare ok perché? perché nella realtà può succedere questo che è l'avversario a scegliere quali messaggi io devo firmare ok e per ognuno di questi il challenger deve calcolare il tag e farlo vedere l'avversario vedete che è molto simile alla tag game della CPA security loro che invece che cifrare il challenger firma ok questo gioco va avanti finché lo decide l'avversario comunque il tempo è limitato polinomialmente prima o poi l'avversario che cosa fa? però poi l'avversario cerca di creare di falsificare forgerire la falsificazione una coppia nuova messaggio tang una coppia valida naturalmente il suo obiettivo è quello cioè una coppia che soddisfa questa condizione pur non conoscendo la chiave chiaramente ok quindi l'obiettivo dell'avversario in base a questo scambio che ha avuto con il challenger è quello di provare a falsificare una coppia messaggio tang accettabile dalla chiave k per la chiave k ok e il vantaggio dell'avversario è la probabilità di riuscire a fare questa cosa tutto qua quindi l'obiettivo dell'avversario è falsificare una firma fondamentalmente l'idea di base è questa e quali sono le informazioni che ha a disposizione l'avversario per riuscirci sono tante coppie messaggio tag messaggio tag messaggio tag che è riuscito a farsi firmare dal challenger l'unica cosa che non sa è la chiave k bene se il vantaggio dell'avversario in questo gioco è trascurabile per tutti gli avversari efficienti ma vuol dire che il macchio è sicuro vuol dire che l'avversario non è in grado realisticamente di falsificare una firma ok perché l'obiettivo dell'avversario è falsificare la firma perché se ci riesce può violare l'integrità no perché abbiamo al solito dice che invia una coppia a bob creata rispetto ad una certa chiave k se l'avversario è in grado di vincere questo gioco vuol dire che è in grado di trovare una coppia nuova valida valida vuol dire che bob l'accetta usando la chiave k esatto certo che non sia già stata generata prima quindi nuovo non capirò ok infatti la condizione è questa chiaro che se l'avversario è in grado di vincere questo gioco con una certa probabilità non trascurabile allora quando vede passare un messaggio da Alice a bob lo può prendere e sostituire con questo e bob non ha modo di accorgersene e quindi riesce a violare l'integrità questo è il motivo per cui questo gioco rappresenta correttamente in tentativo da parte dell'avversario di violare l'integrità ok in gergo in gergo se l'avversario riesce a falsificare una coppia quella coppia quindi prende il nome di existential forgery una falsificazione esistenziale cioè esiste una falsificazione di una firma che l'avversario è in grado di trovare ok i MAC come vedremo possono essere deterministici o probabilistici ok se un MAC è deterministico vale un po' come il discorso che abbiamo fatto già per i cifrali se un MAC è deterministico vuol dire che il risultato di questo algoritmo può essere uno ed un solo tag se invece il MAC è probabilistico il risultato di questa operazione non è un unico tag ma è una distribuzione di probabilità su un certo numero di tag ok è chiaro che in questo caso nel caso dei MAC probabilistici ora supponiamo che a un certo punto il challenger generi questa ok con una certa probabilità se l'avversario è capace di falsificare questa vince perché questa coppia è diversa da questa e quindi è una falsificazione ok bene allora andiamo a vedere come si possono creare i i i i MAC ok il modo più semplice per creare un MAC consiste nell'usare un PRF un absolute random function quindi definire l'algoritmo di segnatura semplicemente usando il PRF ok e di conseguenza la verifica funziona in questa maniera qua ok consiste nel fare il check che il tag che io ricevo coincida con il valore del PRF rispetto alla TVK del messaggio che ho ricevuto ok quindi questa storia è molto semplice c'è anche un bel teorema che dice che se il PRF è sicuro un PRF con questo dominio e questo codominio e se il codominio è super poli allora il MAC è sicuro dei TAR l'insieme di possibilità deve essere super poli ok perché deve essere super poli perché se non fosse super poli la probabilità di indovinare il tag giusto per un messaggio in maniera casuale sarebbe non trascurabile sì con le chiavi esatto con i nonce con i nonce con le chiavi no ok perché dobbiamo sempre considerare l'attacco casuale cioè l'attaccante che prova a indovinare a caso qual è il tag giusto di un messaggio e la probabilità che lui ha di indovinarlo a caso è questa no dove il denominatore è l'insieme di tutti i tag ora questa quantità deve essere trascurabile ma lo è solamente se il denominatore è super poli quindi il solito discorso che avevamo sempre fatto dobbiamo evitare che scelte casuali dell'avversario abbiano una probabilità non trascurabile di di di di quindi ad esempio se potreste usare che ne so AS128 che è un PRF sicuro per fare la generazione dei tag quindi immaginatevi Alice e Bob che condividono una chiave K per garantire l'integrità di un messaggio Alice cosa fa? manda il messaggio e poi manda anche la cifratura del messaggio fatta con AS128 dall'altra parte Bob non deve fare altro che provare a cifrare il messaggio che ha ricevuto usando la chiave che condivide con Alice e vedere se il valore che ottiene coincide con il ciphertext che è stato trasmesso ok quindi in questo caso il tag è un ciphertext fondamentalmente ok bene sembra che vada tutto bene però c'è un problema e qual è questo problema? beh il problema emerge già dall'esempio che vi ho fatto no? se usate come PRF AS128 quanto possono essere grandi i messaggi che potete taggare? perché AS128 lavora su blocchi di 128 bit e restituisce blocchi di 128 bit quindi se voi usate come funzione di segnatura AS128 significa che voi potete firmare solo messaggi di 128 bit che non ha molto senso in contesto reale magari voglio creare il tag di un messaggio che è lungo un mega ok quindi il problema è scalare cioè riuscire a taggare anche messaggi lunghi a piacere quindi abbiamo bisogno di un modo volendo continuare a usare un PRF sicuro come AS128 ad esempio abbiamo bisogno di un modo per applicare più volte quel PRF a tutti i blocchi di 128 bit che compongono il plaintext no? perché l'idea è quella no? il mio PRF lavora su blocchi di 128 bit il mio messaggio è più grande che cosa faccio? spezzo il messaggio in tanti blocchi di 128 bit applico in qualche modo il PRF a questi blocchi e poi in qualche modo dovrò combinare i risultati il risultato finale dovrà essere un blocchettino di 128 bit che rappresenta il tag quindi a partire da un messaggio di un giga devo poter produrre un tag di 128 bit ma lo devo fare in maniera sicura ok? ora questo teorema mi dice che l'utilizzo di un PRF sicuro mi dà luogo a un max sicuro se devo taggare un solo blocco ma se devo taggare un messaggio fatto di tanti blocchi come devo fare? e ci sono diverse modi di fare questo tipo di operazione in maniera in maniera sicura ve ne faccio vedere due o tre che sono quelli che si utilizzano negli standard ufficiali che trovate in letteratura il primo modo di farlo è una costruzione che si chiama CBC e che usa il PRF sul plaintext che viene diviso in tanti blocchi in maniera combinata come vediamo in questo pseudocodice quindi esattamente come prima immaginate di avere il vostro PRF ok che potrebbe essere un bloccypher qui stiamo assumendo che dominio e dominio coincidono e avete il vostro messaggio che è molto più lungo rispetto alla dimensione di un blocco infatti vedete il messaggio viene diviso in tanti blocchettini a 1 2 a v ok e la costruzione è questa qua andiamo a vedere come funziona allora t è il tag che vogliamo ottenere il valore iniziale del tag è il blocco fatto di tutti i zeri ok n n è la dimensione del di ciascun di ciascun blocco ok quindi il primo tag è questo ok poi entra in un ciclo all'interno del quale prendo i blocchi del plaintext e faccio l'operazione che vedete quindi andiamo a vedere devo prendere il blocco corrente del plaintext ok legarlo in xor col tag ok e il risultato darlo in pasto al prf usando la chiave k ok il risultato sarà il nuovo tag e questa cosa si reitera adesso che cosa faccio prendo il blocco successivo del plaintext lo leggo di nuovo in xor col tag corrente e il risultato lo ridò di nuovo in pasto al prf sempre usando la chiave k e ottengo il tag aggiornato e questa cosa va avanti finché non ho esaurito tutti i blocchi del plaintext quindi in pratica per ogni blocco del plaintext faccio lo xor col tag ottenuto al passo precedente e il risultato lo cifro usando il prf e la chiave k il prf potrebbe essere as quindi n magari 128 quindi cosa succede parto da questo tag iniziale faccio lo xor con il primo blocco del plaintext cifro il risultato usando la chiave k e questo è il nuovo tag prendo un altro blocco del plaintext faccio lo xor col tag cifro il risultato usando as di nuovo con la chiave k e vado avanti così finché non ho esaurito tutti i blocchi di plaintext alla fine di questo ciclo non ha importanza quanto fosse grande il plaintext il risultato finale è un tag di 128 bit di end bit poiché e sarà il tag del nostro messaggio notate perché vi farò vedere la differenza rispetto alla prossima costruzione che uso sempre la stessa chiave k per cifrare un qualcosa che dipende dal plaintext dal blocco corrente del plaintext e dal tag corrente calcolato fino a quel momento questa è la costruzione cbc per i prs una costruzione alternativa è la f stella che cambia un po' ruolo dei vari ingredienti ok viene sempre fatto un ciclo però stavolta però stavolta il prf per ogni blocco del plaintext viene usato con una chiave diversa prima la chiave che si usava era sempre la stessa però l'input era una elaborazione di plaintext e tag qui invece l'input è semplicemente il plaintext però cambia la chiave chi ha la chiave la chiave è il tag corrente si parte da la k ok e la si usa come chiave anzi facciamo così facciamo la stessa notazione che ho dato prima uso la chiave k per cifrare il primo blocco di plaintext ok e il risultato è un tag che io userò come chiave per cifrare il blocco successivo e vado avanti così quindi cambio uso il tag ottenuto ad ogni step come chiave per lo step successivo ok questa è f star diciamo chiaro chiaro ora voi direte finita qui abbiamo le nostre due costruzioni quindi abbiamo un modo per comporre un PRF sicuro e formare un MAC sicuro no ancora non ci siamo perché né FCBC né FStella sono MAC sicuri per rendere i sicuri bisogna fare un altro passaggio ovvero bisogna prendere l'output cioè il tag ottenuto usando una di queste due costruzioni e cifrarlo un'altra volta con una chiave nuova ok quindi immaginate di usare di usare OFCBC OF STELLA per taggare un messaggio M a partire da una certa chiave K1 ok il risultato il risultato abbiamo visto è un certo tag ok se ci fermiamo lì non siamo sicuri cosa bisogna fare prendere il tag risultante dall'algoritmo che abbiamo scelto e cifrarlo un'altra volta con il nostro PRF usando una chiave nuova diversa quindi alla fine il tag sarà la cifratura del tag che una delle due costruzioni mi ha prodotto però è importante che K1 e K2 siano diverse ok quindi K1 è la chiave che io uso per costruire il tag usando FCBC o FSTELL prendo il risultato finale e lo cifro un'altra volta usando il PRF e una chiave nuova ok dove questo è lo stesso PRF su cui si basano questi due quello che abbiamo visto visto prima se facciamo questa operazione qui abbiamo un teorema che ci dice che questa costruzione che si chiama encrypted PRF è sicura è una costruzione sicura però è necessario che l'insieme dei tag sia superpolio per il motivo che dicevamo prima la probabilità che l'avversario ha di indovinare deve essere trascurabile quindi l'insieme dei tag deve essere per forza superpolio encrypted PRF è uno standard in particolare encrypted PRF con FCBC è lo standard che usa l'ansi ok ed è lo standard che è stato adottato nell'ambito bancario per pagare i messaggi che vengono scambiati e quindi garantire l'integrità delle informazioni memorizzate nei database bancari mentre invece encrypted PRF basato su F stella è lo standard che usa l'ETF adesso dirò qualcosa sugli standard ed è lo standard usato nei protocolli la maggior parte dei protocolli di rete ok il primo prende il nome di encrypted CBC perché si basa su FCBC il secondo prende il nome di nested MAC che è quello che si basa su F stella e entrambi sono MAC sicuri ok ci sono ANSI chi sono gli ATF visto che ogni volta che vi tiro fuori in un'organizzazione vi dico anche due parole su qual è il loro scopo l'ANSI l'American National Standard Institute che mi dice il nome è quell'istituto con l'organizzazione non profit americana che ha come obiettivo quello di definire degli standard accettati da tutti fondamentalmente l'ANSI crea standard in tantissimi contesti diversi ed è l'organizzazione di riferimento in tanti diversi contesti in particolare quello bancario per quanto riguarda gli standard per la cyber security invece l'ETF è l'Internet Ingenier Task Force che è appunto quell'organizzazione non profit il cui obiettivo è quello di sviluppare standard per i protocolli di rete quindi un dominio applicativo più specifico rispetto all'ANSI l'ANSI spazia intanto diversi dominio applicativi in particolare l'ETF è molto attiva nel definire protocolli per la cyber security e tra questi abbiamo appunto l'Internet per quanto riguarda l'integrità cioè l'Encrypt del PRF con F stella ok tra l'altro come dice lì l'ETF è stato uno dei promotori per recenti per la definizione di standard di cifratura per l'era post quantum quindi stabilire degli standard da usare quando avremo i computer quantistici quindi chiaramente bisogna anticipare i tempi bisogna essere pronti per quando avverrà quel tipo di rivoluzione che di fatto cambierà molte cose nel mondo della criptografia lo vedremo in particolare quando parleremo di criptografia a chiave pubblica quindi cifratura asimmetrica ci sono tutta una serie di teoremi relativi alla sicurezza delle primitive criptografiche che usiamo che adesso valgono ma che non varranno più se l'avversario avrà a disposizione i computer quantistici è il solito discorso che abbiamo fatto fin dall'inizio c'è sempre quel famoso parametro lambda che ci dice chi sono gli avversari efficienti quindi la evoluzione di sicurezza è sempre parametrica rispetto a una certa classe di avversari efficienti se all'avversario è andato in mano un computer quantistico la sua efficienza esplode e quindi certi risultati che valgono adesso sulla sicurezza delle primitive criptografiche non varranno più quando avremo avversari di quel tipo di espressività lì e quindi molte cose dovranno cambiare esistono già definiti sulla carta algoritmi di cifratura che risultano essere sistemi di cifratura che risultano essere semanticamente sicuri anche rispetto ad avversari chiamiamoli quantistici e lo scopo degli ETF è proporre degli standard da mettere in atto nel momento in cui dovremmo passare da da criptografia standard la criptografia cosiddetta quantistica ok quindi è bene essere pronti da questo punto di vista esiste un terzo modo per avere un maxicuro quindi un modo ortogonale rispetto a a quello che abbiamo visto qui l'idea è prendo una delle costruzioni FCBCOF stella e ne cifro il risultato ok questa è l'idea l'altra idea è invece fare il contrario cifro l'input e poi applico una delle due costruzioni quindi ribalto l'ordine di applicazione delle operazioni ok quindi l'idea è quindi l'idea è usando una certa chiave k1 cifro faccio l'encryption usando un certo cifrario del messaggio M ok il risultato lo do in pasto a una delle due costruzioni che abbiamo visto usando una chiave diversa anche qui vedete le due chiavi le due chiavi sono diverse esattamente come nel nell'esempio nel caso precedente ok come qua le due chiavi devono essere le due chiavi devono essere diverse ok quindi però l'idea è sempre quella o applico prima la costruzione e poi cifratura oppure il contrario prima la cifratura e poi la costruzione ok se seguo quest'idea qui c'è un teorema che mi dice che questa costruzione qua cioè il FCBC UF stella applicati alla cifratura del plaintext mi dà un maxicuro questo tipo di costruzione prende il nome di Cypher Mac quindi le tre le tre grandi famiglie di Mac che si trovano nella letteratura sono queste Cypher Mac è uno standard mist che è un'altra organizzazione ancora che you encrypt your data through an HTTPS protocol within HTTPS integrity is implemented by using nested mac ok if you are in the context of a bank information system the integrity of the data within the information system is implemented by using encrypted CDC so it's the context to decide what kind of integrity we have ok e cipher mac ovvero cmac è è l'implementazione di questa idea qui questo lo cancelliamo ok ok quindi cmac fa questa roba fcbc applicato sulla encryption del plaintext e ripeto è uno standard del nest chi è il nest? il nest è un'altra organizzazione americana che come l'ansi promuove la definizione la diffusione di standard in ambito tecnologico quindi un ambito un po' più ristretto rispetto a quello dell'ansi ma anche questi molto attivi soprattutto nel contesto della cyber security forse l'avevamo menzionata anche quando abbiamo parlato della kid jane nessuno mi ricordo comunque è uno di questi ok ci siamo tutto chiaro benissimo io direi che per oggi si può fermare anche qua finiamo un po' prima perché così non evito di partire con un argomento nuovo facciamo un blindato Europé Nihilwurf Grazie.