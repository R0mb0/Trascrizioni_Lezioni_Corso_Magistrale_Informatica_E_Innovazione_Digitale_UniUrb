Ok, se vi ricordate quando facciamo la parte relativa alla confidenzialità, al termine della presentazione del lavario primitivo, avevo mostrato questo schema riassuntivo che mette in evidenza quali sono le primitive criptografiche dedicate al problema della confidenzialità e in ultima istanza eravamo arrivati a presentare le implementazioni pratiche di cifrari sicuri rispetto al chosen point test attack, che è quello più significativo nel contesto della secrecy, e le implementazioni dei cifrari in particolare probabilistici, cioè gli unici in grado di garantire questo tipo di sicurezza, essenzialmente le due modalità che avevamo visto erano stati il randomized counter mode e il cipher blockchaining mode e questi erano i risultati che avevamo ottenuto. Nelle scorse lezioni invece abbiamo affrontato il problema dell'integrità e come questo viene risolto utilizzando invece come strumenti criptografici i messaggi ad enticcati codi, i MAC. Abbiamo visto diversi modi di definire un MAC, in prima battuta attraverso l'uso di primitive già viste in precedenza, cioè il PRF, abbiamo visto in particolare che sono quelle riportate qui in blu, che ci raccontano come si può utilizzare in maniera reiterata un PRF per costruire il tag, abbiamo visto come integrare questo meccanismo con l'utilizzo di funzioni hash, che possono essere con chiave o senza chiave, in particolare abbiamo visto il paradigma dell'assistico. In particolare abbiamo visto il paradigma dell'hash-then-prf, cui fanno riferimento costruzioni come ad esempio quella composta e quella di Carter-Wegman. e infine abbiamo visto le funzioni hash senza chiave, con le loro applicazioni sempre nel contesto dei MAC e dell'integrità. Volevo sapere se si sente bene da remoto, ho un dubbio sul microfono. Ok, grazie. Quindi abbiamo fatto una panoramica di quelli che sono gli strumenti che si utilizzano appunto per garantire separatamente dalla parte la confidenzialità, la segretezza e l'integrità dall'altra. Adesso è arrivato il momento di mettere assieme queste due proprietà, quindi mettere assieme gli strumenti che si utilizzano per garantirle e vedere come nella pratica, si definiscono meccanismi che contemporaneamente offrono integrità e confidenzialità insieme. Ok? Questo è quello che vedremo in queste lezioni. Ora, quando si parla di combinare secrecy e integrity, si parla di quella che viene chiamata authenticated encryption. Chiaramente siamo sempre nel mondo della cifratura a chiave simmetrica, quindi sia la confidenzialità che l'integrità vengono garantite utilizzando meccanismi basati su chiave condivisa. Ok? Ovvero quelli che abbiamo studiato. Ora, siccome noi abbiamo studiato separatamente, da una parte, cifrari probabilistici, dall'altra abbiamo studiato i MAC, il modo più intuitivo e più naturale di definire un meccanismo che garantisca contemporaneamente le due proprietà consiste nel comporre questi strumenti. Ok? Comporli possibilmente in cascata, prima uno e poi l'altro. E se seguiamo quest'idea possiamo optare per due diversi paradigmi. Il primo, che prende il nome di encrypt the MAC, e l'idea è prima si cifra il plaintext e poi, usando il MAC, si genera un tag che naturalmente a questo punto riguarderà l'intero ciphertext. Ok? E... Questo paradigma è presente in applicazioni pratiche, ad esempio in una delle versioni di TLS, che è il protocollo per la cifratura delle informazioni end-to-end a livello di trappotto, di cui parleremo nel dettaglio, ma anche in IPsec, che invece è un analogo protocollo rispetto a TLS, però lavora a livello di rete invece che a livello di trasporto. L'altro paradigma che possiamo scegliere invece è il MAC-deb-encrypt, ovvero prima calcoliamo il tag del plaintext, usando il MAC, poi facciamo la cifratura della coppia plaintext e tag, quindi cifriamo il tutto. Ok? Questa è l'altra possibilità. Anche questo è presente in versioni di TLS, così come del protocollo 802.11, che anche questo lo vedremo, tutti questi che sto menzionando li vedremo più o meno in dettaglio, questo in particolare è il protocollo che si usa per la cifratura delle comunicazioni in reti Wi-Fi. Naturalmente questi non sono gli unici paradigmi, sicuramente sono quelli per noi più semplici, perché conosciamo già gli ingredienti, e vedremo appunto come combinare gli ingredienti per realizzare questi due paradigmi. Naturalmente ci sono altre possibilità per realizzare l'authenticated encryption. Ad esempio è possibile, vi farò vedere un esempio particolare, si possono realizzare schemi integrati. Cosa vuol dire schemi integrati? Cioè schemi che non si basano né su cifrari probabilistici, né su MAC, così come li abbiamo visti in passato, ma sono schemi che utilizzano primitive che già conosciamo, quindi direttamente PRF o funzioni hash, tipicamente sono queste le due primitive coinvolte, PRF per la cifratura e funzioni hash per il discorso relativo all'integrità. E quindi i schemi integrati cosa fanno? Utilizzano in maniera nativa direttamente queste operazioni criptografiche primitive, combinandole in una maniera che non si riconduce né all'encrypt del MAC, né al MAC dell'encrypt, perché in genere vengono usate in maniera diciamo appunto integrata e non in cascata. Uno dei protocolli più famosi di questa natura è il protocollo offset codebook mode, sempre per la trasmissione end to end di informazioni protette. Non vi farò vedere questo protocollo come esempio, invece vi farò vedere come funziona il protocollo di Telegram, di Telegram, che è un'app per la trasmissione. Oltre, che è un'appartista di Telegram, che è un'appartista di Telegram. Ah, di developer. Di developer. Di developer. Di developer di Telegram opto per un'integrale original schemi. On l'altro, per esempio, di developer di WhatsApp opto per un'encrypt del MAC paradigma. e ok? Come, isnti ? Ouve,usevigni ? Di software s tudo et However, dovaneci Weimarci in somm contactingили St ट qual forseggi Bugün es Paret e di a wittor briefly about most whatsapp telegram by emphasizing advantages and disadvantages of these two completely different approaches ok quindi ci sono diversi modi composizionali di offrire l'authenticated encryption usando paradigmi già noti primo caso il primo secondo caso oppure meccanismi completamente originali che utilizzano direttamente le primitive a livello ad esempio di prf di poste nish in ogni caso indipendentemente dallo schema che si adotta l'obiettivo appunto è quello di garantire quella che abbiamo chiamato authenticated encryption cioè la combina combo secrecy e integrity dove la secrecy in genere richiediamo che sia garantita rispetto alla cpa security quindi attenzione di encryption richiede quantomeno la sicurezza rispetto al chosen play test attack che abbiamo discusso in passato e in più l'altra condizione che deriva dal fatto che combiniamo secrecy integrity ed è una condizione leggermente diversa rispetto a quella che abbiamo studiato col con i mac è data dalla cosiddetta cypher text integrity perché cypher text integrity perché se noi garantiamo l'integrità del cypher text automaticamente garantiamo l'integrità del plain text che ci sta sotto ok quando abbiamo studiato i mac siccome non era coinvolta cifratura l'integrità riguardava il plain text ok ma adesso che invece aggiungiamo la cifratura perché ci interessa anche la confidenzialità allora va da sé che non ci basta più garantire garantire la segretezza del plain text all'interno del cypher text ma ci interessa anche garantire l'integrità del cypher text e di di conseguenza quella del del plain text ora l'integrità del cypher text la possiamo definire formalmente come tutte le proprietà di sicurezza che abbiamo visto fino adesso attraverso come al solito un attack game ok intuitivamente piuttosto piuttosto semplice perché è molto simile a alla integrità del plain text che abbiamo definito quando abbiamo studiato la sicurezza dei mac ok vedete la tag game piuttosto semplice l'unica differenza appunto è che c'è l'integrità riguarda appunto il cypher text piuttosto che un plain text infatti vedete che nella tag game che cosa abbiamo abbiamo il challenger che come al solito sceglie in maniera casuale in maniera randomica la chiave dopo di che dopo di che sia molto williammato che non radicale che usa delle mini powert Anthony dopodiché esattamente come in tutti gli attacchi che avevamo visto in passato è l'avversario che sceglie il messaggio la sequenza di messaggi da farsi cifrare dal dal challenger qui non c'è un esperimento in cui l'avversario deve indovinare quale messaggio è stato cifrato perché l'obiettivo non è la segretezza in questo caso l'obiettivo è l'integrità infatti vedete che l'avversario sceglie un messaggio e il challenger cifra quel messaggio quindi il l'avversario sa esattamente quando l'avversario riceve il cypher text sa esattamente a quale plaintext fa riferimento chiaramente non conosce la chiave però ok perché in questo caso ripeto l'obiettivo da parte dell'avversario è quello di provare a violare l'integrità del del nostro sistema di cifratura ovvero l'avversario a un certo punto dopo aver sottomesso una sequenza di messaggi da farsi cifrare prova a elaborare prova forgiare prova a falsificare un un cypher text valido per quella chiave è chiaramente diverso da tutti quelli che ha visto in precedenza chiaramente avversario vince gioco se riesce a appunto falsificare un cypher text valido rispetto alla chiave che il challenger ha usato per cifrare la sequenza di plaintext quindi l'idea qual è l'idea è che l'avversario ha la possibilità di osservare la cifratura di plaintext di sua scelta e osservando la sequenza di cifrature di plaintext di sua scelta eseguendo il proprio algoritmo efficiente tenta di come risultato finale di falsificare un nuovo cypher text mai visto prima generato attraverso naturalmente la chiave k perché che è segreta è chiaro che se l'avversario vince questo gioco significa che l'avversario in grado da solo senza conoscere k di falsificare un cypher text ed eventualmente di inviarlo immaginate una trasmissione tra alice e bob che condividono la chiave k ok alice e bob comunicano utilizzando la chiave k se l'avversario in grado di vincere questo questo gioco è in grado di per sé da solo senza conoscere k di falsificare un cypher text e decidere di mandarlo a bob ok bob riterrà di aver ricevuto quel cypher text da alice perché un cypher text generato usando la chiave k condivisa con alice quando in realtà quel messaggio non è stato generato da alice ma è stato generato dall'avversario quindi avremmo una violazione della proprietà di integrità ovvero bob riceverebbe un messaggio che in realtà non è stato creato da alice ma è stato creato dall'avversario ok quindi l'intuizione di questo di questo atta game è proprio quella di verificare la capacità del dell'avversario di forgiare di falsificare messaggi pur non conoscendo la chiave opportuna ok la definizione di integrità del cypher text di sicurezza da questo punto di vista è la solita e ci dice che il nostro cifrario garantisce l'integrità del cypher text se il vantaggio dell'avversario in questo gioco è trascurabile per ogni avversario efficiente è come al solito niente di niente di strano di diverso ok quindi mettendo assieme confidenzialità e integrità così come ne abbiamo definite confidenzialità non sappiamo già basata sul concetto di sicurezza di tipo cpa cioè un test attack integrità invece definita in termini della tag game che abbiamo appena visto quindi combinando queste due nozioni di sicurezza otteniamo la definizione di autenticata di encryption ok quindi un cifra un qualunque meccanismo no si dice garantire l'autenticata di encryption ovvero è a e sicuro appunto questo consenso qua quindi è sicuro rispetto alla tecnica di encryption se contemporaneamente è cpa sicuro quindi garantisce la confidenzialità rispetto al chiuso per il test attack e garantisce l'integrità del 6 del cypher text così come l'abbiamo appena definita ok quindi un meccanismo che sia contemporaneamente cpa sicuro e che garantisce l'integrità del cypher text è un meccanismo che è sicuro rispetto all'autenticata di encryption quindi garantisce sia la proprietà di confidenzialità che la proprietà di integrità ok va bene dubbi chiaro tutto chiaro quindi diciamo studieremo paradigmi che siano sicuri rispetto all'autenticata di encryption ok questa è un po è l'idea ora per far questo quello che faremo sarà estendere la nozione di cpa security ok per avere diciamo un'unica nozione di sicurezza che possa abbracciare contemporaneamente confidenzialità e integrità per far questo prendiamo e lo faremo vedere adesso la nozione classica di cpa security e la estendiamo col concetto di di integrità del cypher text in maniera analoga quella che abbiamo abbiamo appena visto prima il risultato è un nuovo atta game che prende il nome di cio sai per text attack e quindi non più cioè un plan text attack ma ciò sai fa text attack che sarà l'atta game che come vedremo da una parte estende la cpa security in che maniera in maniera tale da garantire anche la proprietà di integrità del cypher test nel senso che abbiamo visto poc'anzi quindi in un unico attac game noi ci ritroviamo entrambe le condizioni che ci interessano confidenzialità integrità l'atta game che vedete qui fino a un certo punto identico all'attac game della cpa security ok in particolare è vedremo che il comportamento di del challenger dell'avversario grossomodo è lo stesso ovvero gli amici per l'evidenza quali sono gli elementi tipici del cpa attacca da una parte abbiamo come al solito il nostro challenger che sceglie casualmente la chiave di cifratura k ok dall'altra abbiamo l'avversario che da una parte si comporta esattamente come l'avversario tipico della cpa security ovvero in questa maniera qui questo è esattamente il comportamento dell'avversario che abbiamo già visto per la cpa security ovvero l'avversario sceglie coppie di messaggi di pari lunghezza e li manda al challenger il challenger risponde cifrandone uno dei due rispetto alla scelta dipende dall'esperimento in cui ci troviamo chiaramente solo il challenger sa qual è l'esperimento dell'avversario non lo sa ok e questo è il comportamento tipico della cpa security fin qui nulla di nuovo per raggiungere il discorso dell'integrità all'avversario diamo una ulteriore capability ovvero gli permettiamo di sottoporre non solo query di decifratura al challenger come nel caso della cpa security ma gli permettiamo di sottoporre anche query di decifratura che cosa vuol dire questo vuol dire che l'avversario può scegliere un qualunque ciphertext chiaramente diverso da quelli che ha generato il challenger e può chiedere al challenger di farselo decifrare quindi vedete l'operazione inversa rispetto a quella che definisce la cpa security nella cpa security l'avversario manda dei plaintext e il challenger risponde con la cifratura in questa estensione avviene anche il contrario ovvero l'avversario scelge lo sottoporre text e il challenger glielo decifra ok quindi stiamo dando all'avversario la libertà di fare query di qualunque genere ovvero chiedere al challenger di farsi cifrare i messaggi oppure chiedere al challenger di farsi decifrare dei dei ciphertext quindi gli stiamo dando il massimo potere possibile il massimo grado di libertà possibile a questo avversario la struttura del gioco dopo di che rimane quella che già conosciamo ovvero a un certo punto l'avversario che esegue il suo algoritmo efficiente sparerà come risultato un bit e il suo vantaggio come al solito sarà sempre comunque la differenza tra la probabilità di due eventi ovvero sparare il bit 1 quando siamo nell'esperimento 0 oppure sparare sempre lo stesso bit 1 quando siamo nell'esperimento 1 e la definizione di sicurezza rispetto a questo atta game è sempre la solita e ci dice che appunto il nostro cifrario è questa volta cca sicuro cioè sicuro rispetto al chosen ciphertext attack se il vantaggio dell'avversario è trascurabile per tutti gli avversari efficienti ok questo è l'attacco più potente con cui avremo a che fare perché un attacco rispetto al quale l'avversario da una parte cerca di attraverso queste query cerca di capire qual è il legame tra i ciphertext che osserva e i messaggi che potrebbero averli generati quindi di fatto cerca di violare la la confidenzialità ok dall'altra attraverso queste query quelle di decryption cerca di cerca di eh violare l'integrità dei ciphertext perché se attraverso questo tipo di query l'avversario è in grado di generare autonomamente un ciphertext che il challenger riesce a decifrare usando k correttamente in un messaggio in un plaintext plausibile questo significa se l'avversario riesce a fare questo questo significa che l'avversario è in grado di violare l'integrità del ciphertext esattamente come nella tag game che avevamo visto prima perché significa che è in grado di generare un testo cifrato legittimo senza conoscere la chiave ok quindi la la combinazione di query di encryption e query di decryption eh consente all'avversario se può di tentare di violare da una parte la confidenzialità dall'altra l'integrità e questo è il motivo per cui la CCA security è il massimo livello possibile di sicurezza che noi possiamo verificare per meccanismi crittografici che vogliono garantire sia la confidenzialità che l'integrità quindi per i meccanismi che studieremo ci chiederemo se sono CCA sicuri oppure oppure no ok tra l'altro c'è un teorema che a livello formale ci stabilisce questo ovvero eh se un meccanismo è eh garantisce l'autentichetta di encryption allora quel meccanismo è automaticamente CCA sicuro ok bene detto questo fissati i contorni che dal punto di vista teorico ci stabiliscono qual è la la la la la la nozione di sicurezza che ci interessa per eh i meccanismi eh usati per l'autentichetta di encryption andiamo a vedere come implementarli e cominciamo dal paradigma dell'encrypt del Mac. Quindi cominciamo dalla composizione, da soluzioni che si basano sulla composizione di meccanismi che già conosciamo. Quindi immaginate di avere un cifrario per l'encryption e la decryption e immaginate di avere un Mac per la creazione del tag. Siccome facciamo prima la cifratura della segnatura, è necessario che il Mac in input prenda dei cifrari. Il cifrario usa la sua chiave, prende un plaintext e genera un cifrari. Il Mac, usando la sua chiave diversa da quella del cifrario, prenderà un cifrari e creerà il tag, la segnatura. Questa è l'idea. L'implementazione è quella che vedete. Abbiamo bisogno di due chiavi diverse tra loro, una per la cifratura e l'altra per il Mac. Non ci deve essere nessuna relazione tra queste due chiavi. E in input abbiamo il nostro plaintext M. La prima operazione consiste nel usare la chiave di cifratura per cifrare il plaintext e generare quindi il corrispondente ciphertext. Nella seconda fase, il Mac usa la chiave di segnatura per taggare il ciphertext e quindi creare la firma T di integrità. L'output è la coppia ciphertext tag. Questa viene inviata, immaginate che Alice abbia eseguito questi due step, trasmette a Bob ciphertext tag. Dall'altra parte, cosa deve fare Bob? Deve innanzitutto verificare che T sia un tag corretto di C. Ok? Quindi esegue l'algoritmo di verifica del Mac usando la chiave del Mac per verificare che T sia corretto rispetto a C. Ok? Se la verifica ha successo, allora posso procedere con la decifratura del ciphertext che mi dà come risultato il plaintext. Ok? Quindi, da parte sua, Bob verifica che il ciphertext sia integro. Se è integro, lo decifra. Ok? Quindi, vedete, la procedura è abbastanza semplice. Questo teorema ci dice che se il cifrario che usiamo per la cifratura è cpa sicuro e il Mac che usiamo per la segnatura è sicuro, allora la combinazione di questi due strumenti, di questi due meccanismi, quindi l'encrypt del Mac realizzato usando questi due meccanismi, è sicuro rispetto all'autenticata di encryption. Ok? E di conseguenza vuol dire anche che ci sia sicuro. Quindi, massimo livello di sicurezza. Quindi, l'encrypt del Mac funziona bene. Ok? Tra l'altro, come corollario del teorema abbiamo che il vantaggio dell'avversario nei confronti di questo meccanismo dipende solo ed esclusivamente dal vantaggio che l'avversario ha nei confronti separatamente del cifrario e del Mac. Ok? Non cambia, è lo stesso. Cioè, il vantaggio dell'avversario rispetto alla CPA security del nostro paradigma encrypt del Mac è uguale al vantaggio che l'avversario ha nei confronti del cifrario preso in isolamento senza comporlo col Mac. E lo stesso discorso vale nei confronti del Mac. Ovvero, il vantaggio che l'avversario ha nei confronti di questa costruzione nell'attac game relativo all'integrità è lo stesso che lui ha nei confronti del Mac preso in isolamento. Quindi, cosa vuol dire questo? Vuol dire che in questo paradigma la composizione dei due meccanismi funziona bene. Funziona bene perché la composizione del del cifrario e del Mac fatta in questo modo non introduce delle vulnerabilità. non introduce delle vulnerabilità perché il vantaggio che l'avversario ha nei confronti di questa costruzione è esattamente lo stesso che l'avversario ha nei confronti delle sue componenti. Non aumenta. Quindi, vuol dire che è una costruzione ideale da questo punto di vista. Meglio di così non potremmo pretendere. questo è il motivo per cui è un tipo di costruzione molto usato nelle soluzioni pratiche. Viceversa, l'altra alternativa io vi ho presentato la costruzione standard ok? Senza andare a specificare chi è il cifrario e chi è il Mac. Tanto c'è il teorema che ci dice che voi potete prendere un qualunque cifrario CPA sicuro e un qualunque Mac sicuro. Quindi, ad esempio, che ne so, potete usare AES in CBC mod per la cifratura perché è un cifrario probabilistico CPA sicuro e potete combinarlo usando come Mac HMAC che si basa su Shad 156 o a Carter Wegman ok? Non ha importanza. L'importante è che usate un Mac sicuro. Quindi, potete combinare cifrari CPA sicuri e Mac sicuri in tutti i modi che volete chiaramente rispettando questa costruzione qua. Ok? L'altro paradigma invece applica le due operazioni in senso opposto. Quindi, prima si segna il plaintext quindi vedete infatti che il Mac prende in input usa la chiave prende in input il plaintext e genera il tag del plaintext dopodiché che cosa succede? Succede che dobbiamo cifrare e che cos'è che andiamo a cifrare? Andiamo a cifrare la coppia plaintext e tag visto che la cifratura la facciamo dopo infatti vedete che il cifrario in input prende una coppia plaintext tag e genera un ciphertext quindi andando a vedere la costruzione vedete che nella prima fase usando la chiave del Mac si segna il plaintext generando il tag corrispondente ok nella seconda fase si prende la coppia plaintext e tag e usando la chiave di cifratura si genera il ciphertext ok quindi naturalmente l'output sarà semplicemente il ciphertext dall'altra parte chi riceve questo ciphertext cosa deve fare come prima cosa decifrare il ciphertext la decifratura darà come risultato una coppia messaggio tag dopodiché devo semplicemente usare il Mac per verificare che quella coppia sia corretta rispetto alla chiave del Mac ok bene questo paradigma è sicuro per l'autentichetta di encryption in generale la risposta è no a differenza dell'encrypt del Mac ok cioè non abbiamo a differenza del caso precedente non abbiamo un teorema che dice che se il cifrario è al CPA sicuro e se il Mac è sicuro allora la costruzione del Mac dell'encrypt garantisce l'autentichetta di encryption security ci sono dei controesempi ve ne mostrerò uno di situazioni in cui anche se usate due meccanismi sicuri uno per la cifratura e uno per il Mac se li componete in questa maniera qua non ottenete l'autentichetta dell'encryption questo che cosa significa significa che in generale la in cyber security la composizionalità non valo cioè non è vero in generale in caso particolare come nel caso di prima sì però in generale non è vero che se voi prendete delle componenti sicure e le combinate insieme ciò che ottenete a sua volta è sicuro ci sono situazioni in cui questo non accade e questo è uno dei problemi più grossi della cyber security perché se le proprietà di sicurezza fossero composizionali allora basterebbe prendere tanti ingredienti tanti mattoncini che garantiscono le proprietà di sicurezza che ci interessano li compongono insieme ed ecco che gioco è fatto se fosse così semplice ci sarebbero molti meno problemi nell'ambito della cyber security invece purtroppo le proprietà di sicurezza in generale non sono composizionali e questo è un esempio ok il paradigma MacDenCrypt è un esempio del fatto che la composizionalità non vale un esempio pratico di protocollo che utilizzava il MacDenCrypt è SSL SSL protocollo security socket layer è diciamo l'antenato di TLS perché il TLS il Transports Lawyer Security la prima versione di TLS di fatto corrisponde a SSL 3.1 quindi a un certo punto SSL è diventato è diventato TLS TLS tanto per fare un esempio è il protocollo per la cifratura end to end che si utilizza all'interno del protocollo HTTPS la versione sicura di HTTP si basa su TLS ma tanti altri protocolli di comunicazione sicura end to end si basano su canali protetti costruiti usando TLS quindi oramai TLS è lo standard fatto da questo punto di vista prima che prima di TLS appunto c'era SSL SSL usava il paradigma MAC dell'encrypt dove per la cifratura usava AES in CBC mode che è uno dei cifrari probabilistici che abbiamo studiato che è CPA sicuro ok come MAC sicuro aveva diverse opzioni tra quelli che abbiamo tra quelli che abbiamo studiato ora SSL 3.0 che usava questo paradigma aveva una vulnerabilità dovuta appunto al fatto che la composizione MAC dell'encrypt non è composizionale rispetto alle proprietà di sicurezza per quale motivo beh perché allora ripensiamo un attimo come funziona la cifratura probabilistica in CBC mode ora senza andare a rivedere l'algoritmo però in generale il CBC mode che cosa faceva prendeva il messaggio lo spezzava in tanti blocchi ok dopodiché anche il sciper text era diviso in tanti blocchi il primo dei quali era un nonce randomico ok dopodiché la cifratura di ogni blocco del plain text veniva fatta combinando il plain text il blocco del plain text col blocco precedente del cipher text ok quindi il primo blocco del plain text di fatto il primo scusate il primo blocco del cipher text di fatto era ottenuto combinando in XOR il primo blocco del plain text col famoso nonce cioè il primo blocco del cipher text e così viene incascato a tutti gli altri ok quindi alla fine il cipher text aveva tanti blocchi quanto il plain text più un inizio che è il valore randomico da qui appunto il fatto che la cifratura era probabilistica ora il fatto per lavorare in questo modo è necessario spezzare il plain text in tanti blocchi ad esempio nel caso di SSL la lunghezza di ogni blocco era 16 16 byte ok quindi il cipher text deve essere un multiplo della lunghezza del blocco ok non è detto che il plain text fosse però un multiplo di 16 byte quindi vuol dire che c'è sempre un pezzettino in fondo in più del cipher text ok che deriva appunto da questa necessità il fatto di dover essere di una certa lunghezza multiplo di una certa lunghezza questa parte in più il famoso blocco di padding viene chiamato proprio perché il fatto viene generato in maniera artificiosa proprio per consentire all'algoritmo di funzionare è la causa della vulnerabilità perché perché pensate come funziona il MAC dell'encrypt il MAC dell'encrypt prima segna il plain text ok usando l'algoritmo di segnatura del MAC ma il plain text potrebbe essere più corto del cipher text che poi otterremo proprio per il fatto che ci potrebbe essere quel blocco di padding ok quindi questo cosa significa significa che il tag che il MAC genera copre l'integrità del plain text no non copre l'integrità di quel pezzo di cipher text in più che abbiamo rispetto al plain text per effetto dell'operazione di padding ok è chiaro il discorso lo visualizzo immaginate che questo sia questo è il vostro plain text ok e il MAC calcola il tag riferito a queste informazioni ok ora quando andiamo a fare la cifratura di M in cbc mode che cosa succede? succede che il messaggio viene spezzato in tanti blocchi ok ora supponiamo che per completare l'ultimo blocco manchi un pezzettino ok quindi si fa padding dell'ultimo blocco del messaggio per estenderlo alla lunghezza che serve nel nostro caso 16 byte quindi il plain text che andremo di fatto a cifrare non è esattamente quello di cui abbiamo calcolato il tag ma è ha un pezzettino in più quindi quando andiamo a cifrare il messaggio con il pad otterremo un ciphertext che ha un pezzettino che fa riferimento a questo che non è coperto da integrità perché il tag non lo considera quindi vuol dire che c'è ripeto c'è un pezzo del ciphertext che non è coperto dal MAC che non è coperto da integrità ok questo è più che sufficiente il fatto che ci sia un pezzettino del ciphertext senza prova di integrità è sufficiente per montare un attacco che adesso vi farò vedere che si chiama il primo attacco di questo tipo si chiama Poodle trovato in letteratura adesso ve lo descrivo brevemente ed è un attacco di tipo chosen ciphertext attack quindi tornando all'attack game che abbiamo visto prima è un attacco che fondamentalmente rispetto all'attack game che abbiamo visto è un attacco rispetto all'attack game che abbiamo visto qui il Poodle attack è un attacco che sfrutta questo tipo di query che l'attaccante può fare ok e sfruttando questo tipo di query riesce a violare il meccanismo ok quindi è chiaro il discorso che nel mac then encrypt usando la cifratura in cbc mode c'è un pezzo del ciphertext che non è coperto dalla prova di integrità per via del padding che si fa sull'ultimo blocco ok come funziona l'attacco ora torniamo un attimo qui quando si fa la cifratura il pad viene aggiunto al play test sempre dello stesso modo ok ad esempio che ne so non è così nella pratica ma poniamoci una sequenza di zeri ok dopodiché faccio la cifratura quando faccio la decifratura io devo rimuovere poi il pad perché il pad non c'entra niente col play test quindi quando faccio la decifratura di fatto quello che accade è che verifico che il pezzettino in fondo decifrato abbia il formato corretto del pad perché lo devo riconoscere perché solo riconoscendolo poi lo rimuovo e ciò che mi rimane è il mio messaggio ok è per quello che il pad deve essere sempre fatto nello stesso modo perché solo se è fatto sempre nello stesso modo io lo riconosco una volta che ho decifrato lo tolgo e ciò che mi rimane è il messaggio che devo leggere il plain text che devo leggere ok quindi quando faccio la decifratura dovrei ottenere in fondo al messaggio che ottengo per effetto della decifratura un qualcosa che corrisponde col pad che è un aspetto che ci sia lo riconosco lo tolgo e ciò che mi rimane è il plain text da consegnare ok quindi in pratica al lato della decifratura devo riconoscere il pad ok se non riconosco il pad la decifratura dà errore perché a quel punto non sa più no se qual è il plain text cioè quanto perso nell'ultimo blocco devo togliere e quindi per ambiguità la decifratura d'errore ok bene ricordiamoci questo comportamento della decifratura chi fa l'attacco chi fa il put dell'attacco che cosa fa allora pensiamo all'attacco di prima l'avversario intercetta il cypher text che Alice manda Bob ok poi che cosa fa prende la parte finale del cypher text quella che contiene il pad ok e la sostituisce con una sequenza a piacere no quindi di fatto sostituisce nel cypher text il pad ok di solito per fare una cosa furba poi capiremo perché non è che lo sostituisce con una sequenza a piacere ma lo sostituisce ad esempio con un certo blocco del cypher text stesso quindi ad esempio che ne so abbiamo un cypher text di 100 blocchi l'ultimo è quello del pad l'avversario che cosa fa intercetta il cypher text prende il primo blocco o l'iesimo blocco del cypher text non ha importanza e lo sovrascrive sull'ultimo ok dopodiché inoltre il messaggio bob no ora bob non ha modo di accorgersi della mancanza di integrità chiaramente il cypher text non è più integro perché è stato modificato dall'avversario però bob non se ne può accorgere della mancanza di integrità perché perché il pezzettino che l'avversario ha sostituito non è coperto dal tag perché la segnatura è stata fatta prima della cifratura ok quindi bob che cosa fa prova a decifrare il messaggio il cypher text la decifratura fallisce perché fallisce perché il pad è stato è stato modificato quando bob fa la decifratura si aspetta di ottenere un messaggio che in fondo ha il pad in fondo ci sarà qualcosa di sporco diverso dal pad e quindi la decifratura fallisce ok e dà il feedback guarda non sono riuscito a decifrare l'avversario se ne accorge che bob non è riuscito a decifrare ok e cosa impara dal fatto che bob non è riuscito a decifrare impara che il blocco con cui ha sostituito il pad quindi il pezzo di cypher text che ha preso per sovrascrivere blocco di pad ha una struttura diversa rispetto al pad l'avversario sa come è fatto il pad lo sanno tutti come è fatto il pad quindi se la decifratura fallisce vuol dire che il pezzettino di cypher text che l'avversario ha sovrascritto sul blocco di pad ha una struttura diversa rispetto a quella del pad quindi vuol dire che il pezzo di plain text relativo a quel blocco è diverso rispetto al pad quindi l'avversario deduce una proprietà del plain text il fatto che sia diversa rispetto a una certa sequenza di bit e questo è in violazione della sicurezza semantica vi ricordate all'inizio la sicurezza semantica cosa ci dice che dall'analisi del cypher text io non devo indovinare nessun tipo di proprietà del plain text ok con probabilità di invisible invece in questo caso l'avversario impara una proprietà di un pezzo del cypher text impara che ha una struttura diversa rispetto a quella del pad ok questa cosa se viene ripetuta tante volte rappresenta di fatto nella pratica una vulnerabilità che consente di recuperare il plain text chiaramente questa cosa l'ha fatta più e più volte in attacchi pratici questa cosa può essere fatta anche centinaia di migliaia di volte e combinando i risultati di ciascuno di questi esperimenti l'avversario riesce a violare la confidenzialità del plain text lo fa con altri lo può fare con altri cypher text cioè centinaia di migliaia di volte vuol dire cambiando il messaggio no non gli danno informazioni sullo stesso messaggio ma se tu collezioni un numero sufficientemente grande di cypher text tutti accumulati dal fatto che sono relative a plain text diversi diversi dal pad al certo punto riesci facendo crit'analisi analisi statistica riesci a capire come invece fatto come invece dovrebbe essere fatta la sequenza di cypher text relativa al pad e quindi riesci riesci a associare un plain text il pad al al cypher corrispondente e quindi a fare crit'analisi di fatto sulla chiave però hai bisogno di una quantità di informazioni di questo genere estremamente elevata però nella pratica questa cosa ha funzionato ha dato il luogo degli attacchi veri sul è ok e gaysdefi not at least ok quindi il puder è un esempio pratico di attacco di tipo cca perché è un esempio di c'è un site per text attack come aveva visto prima ed è un esempio pratico di come realizzare una strategia per un avversario efficiente che gli fa vincere la tag game e quindi compromettere questo caso la confidenzialità del paradigma mac dell'encrypt e questo ripeto nonostante gli ingredienti del mac dell'encrypt soddisfano le condizioni del terreno che avevamo visto prima per l'altro paradigma perché qui stiamo parlando di un cibici moda è semplici modo che è un cifrario probabilistico cpa sicuro il mac può essere sicuro quanto volete ma tanto il problema qui non sta nel mac sta nel modo in cui di componente in cascata e quindi il risultato finale in generale mac dell'encrypt non è ai secchiore da notare che se sostituissimo il as cbc mod con un random ice counter mode se vi ricordate randona scander counter mod usa un prf per generare come come se fosse un prg quindi per generare una sequenza pseudo random da legare in sor con il plain text lì non c'è bisogno di spezzare di aggiungere un pad di aggiungere padre in quel tipo di di costruzione quindi se usassimo ad esempio a s in random ice counter mode invece che in cbc mod ecco che usando lo stesso mac di prima non importanza qual esso sia ecco che improvvisamente otterremmo una costruzione un'implementazione mac dell'encrypt che è sicura quindi dipende dalle implementazioni quindi in generale non possiamo dire che qualunque implementazione sia sicura alcune lo sono altre no chiaramente è molto meglio avere a che fare con una costruzione come l'encrypt del mac perché per quella c'è un teorema che vi garantisce che qualunque meccanismo voi andate ad utilizzare la costruzione sicura mentre invece con il mac dell'encrypt siete costretti a valutare caso per caso per vedere cosa succede ok ora nella pratica le costruzioni che garantiscono l'autenticata di encryption da una parte si devono basare sempre comunque su cifrari probabilistici perché la cpa security ce ne abbiamo solo se il cifrari probabilistico quindi tutti i meccanismi che vogliono garantire l'autenticata di encryption sono meccanismi basati su non basati su qualche informazione randomica perché è quella che serve al cifrario per essere probabilistico e quindi garantire la cpa security quindi da lì da lì non si scappa quindi tutti i sistemi che garantiscono l'autenticata di encryption sono sistemi che si basano sull'utilizzo di un'informazione randomica di un nonso quindi sono tutti non smith ok il più in genere delle implementazioni pratiche spesso e volentieri questi meccanismi hanno anche si portano dietro anche quelli che vengono chiamati dati associati i cosiddetti associated data ok a cosa servono gli associati data nella nella pratica sono dati che integra il plaintext devono essere inviati insieme al plaintext ma rispetto al plaintext questi associati data non hanno la necessità di essere confidenziali mentre invece devono essere integri quindi il plaintext deve essere sia confidenziali che integro i dati associati devono essere solo integri non è necessario che siano confidenziali esempio perché c'è perché ci può essere la necessità di trasmettere anche dei dati associati beh pensate ai metadati ad esempio pensate ai metadati che ad un certo livello il pacchetto deve contenere che sia a livello di sessione o che sia a livello di rete metadati che contengono che le so informazioni sulla sessione di comunicazione informazioni relative agli p se siamo arrivato di rete ci sono tanti metadati che magari devono essere associati al messaggio da inviare e questi metadati non devono viaggiare cifrati ad esempio perché lungo il tragitto devono poter essere letti da router da gateway o da altri dispositivi per il corretto indirizzamento però questi dati di integri chiaramente l'avversario li può vedere perché non hanno niente a che fare col plaintext ma non deve poterli manipolare senza essere diciamo beccato ok quindi i cifrari pratica si utilizzano per autenticchette di encryption sono cifrari che da una parte chiedono un nonso perché cifrario deve essere probabilistico e a volte chiedono anche dati associati quindi i nostri base associate detta cypher sono dei cifrari che come vedete combinano diverse informazioni lavorano sulla chiave il plaintext sui dati associati e sul nostro ok il non serve per la cifratura probabilistica i dati associati non vengono cifrati ma vengono taggati ok notate che se il plaintext è vuoto una stringa vuota e quindi avete solo i dati associati il nostro cifrario di fatto si comporta come un mac perché l'unica cosa che garantisce l'integrità dei dati associati quindi mac ok ad esempio prendiamo il paradigma in credo mac vediamo come si comporta quando ci sono dati associati e pure il nostro ok allora la cifratura è probabilistica perché il cifrario deve esserci più assicuro quindi questo significa che per cifrare il messaggio m deve usare il nonso come viene usato dipende dal tipo di cifratura probabilistica cbc moda non domani counter moda quindi questo è un'importanza in entrambi i casi ad esempio abbiamo bisogno di un nonso randomico per far lavorare l'algoritmo ok badate bene che stiamo cifrando solo m solo il plaintext non stiamo cifrando i dati associati ok una volta creato il cybertext cosa vado a segnare con il mac usando la chiave di disegnatura vado a segnare sia il cybertext che i dati associati perché devo proteggere rispetto all'integrità sia l'uno che l'altro o comunque il no perché perché anche il max potrebbe essere probabilistico immaginate di usare carter wegman dice bisogno di un valore randomico si può usare lo stesso valore randomico utilizzato per la cifratura ok e quindi genere il tag vedete il tag copre sia il cypher text che i dati associati e questo sarà l'output finale dall'altra parte la verifica e la decifratura vengono fatte sempre tenendo conto del fatto che sono coinvolti anche i dati associati e chiaramente devo usare lo stesso nonso ok sì qui mi sono dimenticato direi che chiaramente devo inviare anche il nonso perché altrimenti chi fa la decifratura non sa la decifratura deve conoscerlo e oltre che naturalmente adesso qui o come auto perché qui come auto come sono solo il risultato della della dell'increpte mac ok ho dato per scontato che insieme a risultato del del del mac ci siano anche tutti vengono spediti anche tutte le altre informazioni quindi in particolare il nostro e chiaramente anche i dati associati perché quelli che non trasmesso in chiaro qui l'ho dato per per scontato infatti a lato decifratura o l'output delle in clip del mac o i dati associati e all'anno lo vedete da qui che cos'è che riceve bomb ok e basta il resto è identico ok tant'è che spesso e volentieri appunto trovati in letteratura cifrari con l'acronimo indicati con l'acronimo a e a b a e sta per autenticata di encryption quindi cifrare che garantiscono confidenzialità integrità ad significa che sono in grado di gestire anche i dati associati cioè quei metadati che non hanno bisogno di essere protetti rispetto alla confidenzialità ma solo rispetto all'integrità ok ci siamo bene iniziamo col vedere un po' di esempi pratici di cifratura a e ad nella pratica meccanismi che sono stati sviluppati per garantire questo tipo di sicurezza ve ne faccio vedere alcuni ancora utilizzati che soddisfano queste proprietà ve ne faccio vedere almeno almeno uno o due invece che venivano utilizzati ma che non sono più utilizzati perché perché sono vulnerabili e vedremo anche per quale per quale motivo e come ho detto inizio della lezione vi farò vedere sia il caso di whatsapp che il caso di telegram visto che ultimamente se ne parla tanto per lo scandalo che c'è stato alla casa bianca potrebbe essere interessante vedere come è fatto signal che è la chat che a quanto pare utilizzavano i responsabili della sicurezza nazionale per scambiarsi le informazioni sui piani d'attacco in medio oriente e che la settimana scorsa ha fatto notizia perché in quella chat era stato incluso anche per sbaglio un giornalista ok Signal è un'app alternativa whatsapp telegram nata negli ultimi anni con un focus specifico sui requisiti di sicurezza ok un approfondimento che potrebbe rappresentare un progetto è prendere uno qualunque dei protocolli che non sono qua in questa slide e aprirlo sviscerarlo e vedere come è fatto come funziona adesso vi ho fatto un esempio di Signal perché mi è venuto in mente perché è capitato di leggerlo sui giornali però i protocolli in giro ce ne sono tanti per applicazioni di vario genere questo è l'esempio di un app ma non è detto che sia un app può essere un protocollo di comunicazione per reti wired per reti wireless qualunque genere di protocollo a e a d si prende si apre si va a vedere come è fatto e lo si descrive questo è un esempio classico di possibile progetto bene allora andiamo a vedere un po come sono fatti alcuni di questi partiamo dal galois counter mode che che si usa parecchio ve lo cito come struttura non entro nei dettagli di come è fatto al suo interno perché perché di fatto lo sappiamo già come funziona in gran parte sappiamo già come funziona ci sono alcuni dettagli che sono invece specifici dativi suoi allora galois counter mode intanto è un cifrario basato su nonse a e a d quindi garantisce l'autenticata di encryption e lavora anche con dati associati esiste dal 2007 nel corso degli anni è diventato uno standard del mist una delle varie agenzie e organizzazioni di cui abbiamo parlato in passato si basa sul paradigma encrypt the mac ok quindi sappiamo già dal teorema che abbiamo visto prima che se il cifrario è cipià sicuro e il mac è sicuro allora la costruzione garantisce l'autenticata di encryption e infatti il cifrario che galois counter mode utilizza è cipià sicuro perché di fatto implementa il randomize counter mode quindi non il cvc che di cui abbiamo parlato prima della vulnerabilità dell'attacco pudel quindi usa il randomize counter mode che abbiamo visto in passato quindi lì non c'è nulla da raccontare perché l'abbiamo già lo sappiamo già come funziona il prf usato all'interno del randomize counter mode è as128 ok quindi per quanto riguarda la cifratura sappiamo già come funziona galois counter mode niente di nuovo come mac anche qui viene usato un mac sicuro e il mac sicuro che si utilizza anche questo è probabilistico si basa sullo stesso nonso che utilizza il cifrario cpià sicuro e come mac probabilistico usa l'unico mac probabilistico che abbiamo studiato che è quello di carter e wegman ok se vi ricordate carter wegman utilizza al suo interno una cifratura basata sull'oxor quindi sul one time pad e una funzione hash quindi ciò che differenzia un'implementazione di carter e wegman dall'altra è la particolare funzione hash che viene utilizzata e se vi ricordate abbiamo fatto vedere che dentro carter wegman carter wegman affinché sia sicuro bisogna usare come funzione hash un duf non un u hf ok cioè quindi una funzione un pochino più robusta rispetto alle funzioni hash universali i duf sono quelle funzioni hash universali che sono robuste rispetto agli attacchi condotti per valutare la differenza tra gli hash di diversi messaggi se vi ricordate nel caso del galois counter mod come funzione hash si utilizza una variante proprietaria della funzione hp se vi ricordate la funzione hp quella basata sul polinomiale che di base nella sua versione base non è un duf è un u hf ma non è un duf leggermente modificata lì la modifica che avevo suggerito io fatto vedere io era prendere il polinomiale e modificarlo per la chiave si otteneva un duf ok dentro galois counter mod la modifica che si fa all'hp originale è leggermente diversa un pochino più complessa rispetto a quella che vi ho suggerito io e questa funzione hash prende il nome di g hash g stop per galois ok quindi g hash è una variante della funzione hash con chiave hp variante sappiamo motivo perché necessaria proprio perché hp di base non è un duf e la variante lo rende tale e quindi di conseguenza rende il mac di caratter Wegman sicuro quindi galois counter mod è un sistema basato su due meccanismi entrambi probabilistici sia al lato cifrario che al lato mac ed è estremamente efficiente lato mac lo è perché il motivo l'abbiamo già visto in passato caratter Wegman è stato proposto proprio per questioni di efficienza cioè avere garantire certi livelli di robustezza anche con valori di epsilon molto piccoli dove l'epsilon è il parametro che garantisce quanto è sicuro alla forza 10 quindi sicuramente caratter Wegman è estremamente efficiente il randomize counter mod in AS altrettanto lo è quindi questo è il motivo per cui questo standard comincia ad essere piuttosto piuttosto diffuso se voi lo usate come puro mac quindi quando il plaintext non c'è anche proprio per la sua efficienza viene usato spesso anche solo come mac e basta e in questo caso si chiama gmac di nuovo la gista per galois ok e anche questo è uno standard piuttosto piuttosto diffuso quindi questo è un primo esempio che vi do dove l'unica l'unica l'unico dettaglio che non che non vi mostro è come implementata come implementata Giasch che è quella variante di HP che rende HP un doof ok invece veniamo iniziamo a guardare TLS che è il protocollo che vedremo maggiormente nel dettaglio proprio perché è il più diffuso è il protocollo per la protezione del traffico che si utilizza a livello di trasporto nella formosa tassonomia dei livelli di rete siamo quindi a livello 4 a livello di trasporto quindi è a quel livello che TLS lavora quindi a tutti gli effetti lavorando a quel livello siamo in grado di proteggere sessioni di comunicazione o end to end quindi un'intera sessione di comunicazione end to end può essere protetta in questa maniera ok TLS l'obiettivo di TLS è appunto quello di garantire l'autenticata ed encryption ok è uno standard del IETF quindi della massima organizzazione che si occupa di standard per internet l'esempio che vi ho già fatto è quello di HTTPS cioè la versione sicura del protocollo HTTP che usa che usa TLS per rendere sicura la comunicazione oramai considerate che al giorno d'oggi all'incirca il 90-95% delle comunicazioni su web quindi tutte le comunicazioni client server attraverso qualunque tipo di browser sono tutte comunicazioni quasi tutte comunicazioni cifrate il rapporto ormai siamo sul 90-95% perché? perché oramai tutti i siti sono tutti navigabili in HTTPS ok quando provate ad accedere a un sito attraverso il protocollo HTTP spesso e volentieri vi appare un warning da parte del browser che vi dice guarda che questa è una sessione non protetta sono sicuro di voler andare avanti e sotto c'è TLS ok è TLS il protocollo che garantisce la protezione di questo tipo di informazioni come vi dicevo prima facendo un po' di storia di TLS TLS nasce nella sua primissima versione come estensione di SSL che è il suo antenato il Secure Circuit Lawyer Protocol ok di fatto la prima versione di TLS coincide con la 3.1 di SSL ok poi ha subito delle integrazioni si è passati dalla 1.0 alla 1.2 i motivi per cui si passava da una versione all'altra era sempre legato alle vulnerabilità ok vi dirò ad esempio ad esempio il passaggio dalla 1.0 alla 1.2 si è reso necessario perché la prima versione di TLS soffriva del pudel attack che vi ho raccontato prima ok quindi di fatto si è abbandonato il paradigma macta l'encrypto dentro TLS la versione di 1.2 anche questa si è dimostrata essere vulnerabile a dei degli attacchi simili al pudel ma basati su side channel quindi dei timing attack quindi un po' più sofisticati quindi non attacchi di critanalisi ma quelli di tipo side channel quindi misurazione dei tempi di esecuzione e cose di questo genere si è arrivati alla fine al 2017 nell'ultimissima versione che è tuttora quella in uso che era 1.3 che è robusta è stata anche validata da un punto di vista formale utilizzando metodi di cui parleremo più avanti e quindi di fatto è è lo standard attuale no? TLS prevede fondamentalmente due fasi ok? perché richiede due fasi? allora TLS implementa un cifrario che garantisce l'autenticato di encryption con dati associati non space e quant'altro che sono tutti i meccanismi che richiedono la condivisione di una chiave perché sono tutti i meccanismi basati su chiavi simmetriche ok? questo è ovvio quindi per poter usare questi meccanismi bisogna che i due host no? su cui vogliamo montare la comunicazione end to end condividano almeno due chiavi almeno in realtà di più però rispetto alla definizione che abbiamo visto noi almeno due chiavi una chiave per la cifratura e una chiave per il MAC poi in realtà vedremo sono di più ma questi sono dettagli implementativi come si fa a condividere queste chiavi? ci vuole quando in realtà magari a dice Bob non si sono mai parlati prima ci vuole una fase preliminare che TLS conduce il cui che si chiama handshake protocol l'obiettivo di questa fase di setup preliminare è permettere ad Alice e Bob di condividere le chiavi che serviranno poi per la trasmissione sicura ok? ok? il goal del handshake protocol è in particolare far condividere ad Alice e Bob quello che viene chiamato master secret che è una singola chiave una quindi un segreto che Alice e Bob che magari prima non si sono mai parlati alla fine del handshake protocol condivideranno ok? quindi durante il handshake protocol Alice e Bob si mettono d'accordo sul master sul master secret ok? ora io di questo protocollo adesso non vi posso parlare perché si basa su meccanismi di cifratura chiave pubblica che studieremo a partire dalla prossima settimana quindi quando avremo studiato la cifratura asimmetrica quindi basata su chiave pubblica riprenderemo a un certo punto il handshake protocol di TLS e vi lo farò vedere quindi per adesso lo mettiamo da parte e assumiamo che esista questa fase di setup e in qualche modo alla fine di questa fase di setup Alice e Bob condividono un master secret a cosa serve questo master secret? nella fase successiva che è il record protocol che è il protocollo che implementa la comunicazione basata su un cifrario non-based AEAD quindi che fa autenticative encryption e gestisce i dati associati ok? quindi dobbiamo immaginare che sulla base del master secret Alice e Bob si mettano d'accordo su tutte le chiavi che servono quella del MAC quella del cifrario e implementino poi come come faccio di immaginare un paradigma che è di tipo encrypt the MAC TLS al suo interno supporta tanti algoritmi diversi quindi supporta diversi meccanismi di cifratura e supporta diversi MAC quali usare? ebbene questo di solito viene negoziato tra i due host nella fase di setup quindi nella fase di setup non solo Alice e Bob si mettono d'accordo sul master secret ma si mettono d'accordo anche su quale cifrario e quale MAC usare all'interno del paradigma encrypt the MAC ok? questa è l'idea e vabbè si però posso dire tanto se non è presto quali sono le particolarità del record protocol di TLS 1.3 non vi sto a raccontare i dettagli della cifratura e del tag perché ripeto il paradigma encrypt the MAC poi quale cifrario usare quale MAC usare non ha importanza TLS ormai ne supporta tanti e quale usare è il risultato del negoziato fra i due host ok? quindi fin lì niente di nuovo le cose interessanti sono un po' all'inizio del record protocol quando Alice e Bob a partire dal master secret devono condividere devono decidere quante e quali chiavi usare allora nell'idea astratta che abbiamo fatto vedere di chiavi ne servono due una per la cifratura e una per il tag in realtà ne servono di più perché ne servono di più perché ad esempio si utilizzano coppie di chiavi diverse per ogni direzione di trasmissione cioè le chiavi che usa Alice per trasmettere verso Bob sono diverse dalle chiavi che usa Bob per trasmettere verso Alice ok quindi le chiavi nella direzione da client a server sono diverse dalle chiavi che si usano nella direzione da server a client quindi servono più chiavi ok come fanno Alice e Bob a condividere queste chiavi a partire dal master secret usano HKDF questo è uno dei motivi per cui la settimana scorsa vi ho raccontato come funziona HKDF a partire da HMAC e l'obiettivo di HKDF appunto è quello di costruire a partire da un unico segreto una sequenza pseudo random a sua volta segreta e quindi è il protocollo ideale per generare delle sub keys a partire da un'unica key ed è esattamente il protocollo che usa TLS 1.3 quindi anche quello lo conosciamo già quindi nulla di nuovo come avviene poi la cifratura i dati vengono organizzati in pacchetti abbiamo un messaggio molto grande per trasmettere questo viene diviso in tanti pacchetti ogni pacchetto avrà un certo numero di blocchi i blocchi la dimensione di ciascun blocco è 2 alla 14 byte ok i blocchi sono numerati in sequenza 1 2 3 4 a partire da 0 e così via la cifratura deve essere probabilistica perché altrimenti non sarebbe più assicura ok quindi ha bisogno di un nonce qui la cosa interessante è vedere come si calcola il nonce perché è un procedimento originale di tls poi la cifratura come si fa ripeto di solito utilizza as o in cbc mod o in randomize counter mod quindi i due modi che abbiamo visto quindi lì niente di nuovo la novità sta nel modo in cui viene calcolato il nonce per far partire la cifratura e come si calcola questo nonce il nonce è di 8 byte ok e da dove deriva il nonce il nonce è l'oxor di due diverse informazioni quali sono queste informazioni la prima è il numero di sequenza del blocco ok perché ogni ogni blocco ha il suo nonce ok proprio per il motivo che abbiamo sempre detto lo scopo della cifratura probabilistica è quella di poter usare sempre la stessa chiave per messaggi diversi tanto ciò che cambia il nonce e quindi la chiave protetta ok quindi ogni blocco di 2 alla 14 byte ha il suo nonce per la cifratura che è una sequenza di 8 byte e questo nonce da dove deriva ripeto è l'oxor di due informazioni la prima informazione è il numero di sequenza del blocco ok espresso in una stringa di 8 byte la seconda informazione è una stringa casuale che deriva dalla master secret sempre usando hkdh come questo per ogni blocco ok quindi per ogni blocco che cosa succede si prende il sequence number del blocco si prende una stringa casuale che deriva da che cosa deriva da hkdf applicata sul master secret a partire dal master secret hkdf genera tutte le sottochiavi ma genera anche questi questi nonce ok l'oxor del sequence number e del nonce generato da hkdf è il valore casuale che usiamo per la cifratura probabilistica quindi è la famosa random string che il il cifrario probabilistico usa per fare la cifratura ok questo questa costruzione è un po' complicata no perché uno potrebbe dire perché dobbiamo fare sta roba qua possiamo fare anche solo questa no e usare direttamente questo senza combinar l'inxor con il serial sequence number serve per rendere ancora più randomico il processo di selezione del nonce per il blocco nell'ipotesi remota che questo processo generi due volte lo stesso nonce combinando l'inxor con il numero di sequenza che cambia sempre perché ogni blocco c'è il suo questo diminuisce ulteriormente la probabilità che due blocchi vengano cifrati a partire dello stesso nonce e questo va evitato perché se due blocchi vengono cifrati a partire dello stesso nonce allora diventiamo vulnerabili al two time pad attacca non possiamo usare la stessa chiave due volte per cifrare lo stesso messaggio che è quello che succederebbe di fatto se lo stesso nonce venisse usato due volte infatti in passato abbiamo sempre detto che per garantire la CPA security di cifrare i probabilistici lo spazio dei nonce deve essere super poli ok questo è il meccanismo implementato nella pratica per rendere il più randomico possibile il procedimento di generazione dei nonce perché dovete sapere che molte delle vulnerabilità che si sono osservate nelle implementazioni pratiche dei cifrari sono spesso legate al modo in cui si calcolano i nonce perché generare un numero casuale impredicibile è molto difficile infatti abbiamo detto a suo tempo che i generatori di numeri casuali che si usano nei simulatori non si possono usare anche per generare i nonce per la criptografia perché sono predecibili quindi spesso volentieri le vulnerabilità dipendono da questo fattore qua e quindi l'effettiva casualità dei nonce è un fattore importantissimo nella sicurezza dei cifrari e TLS usa questo particolare meccanismo che si è rivelato essere piuttosto piuttosto robusto ok questo è il modo in cui funziona il record protocol di TLS 1.3 qui vi ho raccontato quali sono gli elementi di novità specifici del record protocol perché come viene fatta la cifratura e la segnatura già lo sappiamo è un encrypt del MAC basato su meccanismi che quelli che mettono a disposizione TLS sono più o meno quelli che abbiamo studiato ok poi più avanti vi farò vedere invece come funziona l'end shake protocol necessario per far condividere ad Alice e Bob il master secret va bene per questa mattina ci fermiamo qui e continuiamo poi il pomeriggio col penetration testing l'assero ing belangrijk seguler Isa