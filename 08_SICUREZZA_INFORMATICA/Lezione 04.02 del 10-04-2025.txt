Ecco qua. Sono hard, sono difficili da risolvere e che quindi contribuiscono alla sicurezza degli schemi che abbiamo visto. Sia RSA che di Fielman, e lo vedremo oggi, possono essere usati per implementare schemi di cifratura a chiave pubblica, che sono l'analogo, la controparte degli schemi di cifratura a chiave simmetrica che abbiamo visto all'inizio del corso. Ok? Quindi oggi vediamo, iniziamo a vedere come definire un cifrario asimmetrico, asimmetrico perché si usano due chiavi diverse per cifrare e decifrare, che possono, come vedremo, possono adottare come primitive di base RSA oppure di Fielman. Ok? Le definizioni teoriche che vi farò vedere adesso sono molto simili a quelle che abbiamo già visto per la cifratura asimmetrica. Infatti poi anche le nostre di sicurezza, quindi sicurezza semantica e CPA security, sono molto simili. Ok? Partiamo dalla definizione di che cos'è uno schema di cifratura a chiave pubblica o asimmetrica. È una tripla di algoritmi efficienti, dove G è l'algoritmo che serve per generare le due chiavi, la chiave pubblica e la chiave segreta. È un algoritmo probabilistico perché chiaramente la scelta della coppia deve essere randomica, non prevedibile. Come viene scelta la coppia dipende dal tipo di primitive criptografiche che vengono utilizzate. L'abbiamo visto ieri, l'algoritmo di generazione delle chiavi di RSA deve scegliere i due numeri primi, eccetera, eccetera. Anche Diffie Hellman fa una cosa del genere, si parte da due numeri primi, però l'approccio è completamente diverso. In ogni caso, come vedremo, soprattutto nel caso di Diffie Hellman, dobbiamo chiarire cosa vuol dire scegliere la chiave pubblica e la chiave privata. Perché Diffie Hellman, come l'abbiamo presentato ieri, non fa uso di chiavi pubblico-private. È uno schema che abbiamo visto per permettere di implementare l'anonymous key exchange, però non parla mai esplicitamente di chiavi pubblico-private. Quindi questo sarà da definire. Invece nel caso di RSA è più semplice pensare a cosa sono in questo caso le chiavi pubbliche e private. Comunque lo vedremo nell'implementazione. Gli altri due algoritmi sono quello di cifratura e decifratura. La prima cosa interessante da notare, adesso capiremo perché, è che l'algoritmo di cifratura deve essere probabilistico. Perché se fosse deterministico, lo schema sarebbe banalmente insicuro. Tra poco vedremo perché. L'algoritmo di decifratura che cosa fa? Prende in input la chiave pubblica, prende il plaintext M e restituisce il ciphertext applicando appunto l'algoritmo a questi due input. Quindi in pratica la chiave pubblica ci serve per cifrare il plaintext. L'algoritmo di decifratura è deterministico, come sempre. E invece di usare la chiave pubblica ha avuto la chiave segreta, la chiave privata, per decifrare il ciphertext. Come al solito abbiamo la proprietà di correttezza che dice che se cifriamo un plaintext M usando la chiave pubblica e poi il ciphertext che otteniamo lo decifriamo usando la chiave segreta corrispondente alla chiave pubblica, allora dobbiamo riottenere il plaintext M. Tutto questo con probabilità 1. Nella proprietà di correttezza si parla di probabilità per il semplice fatto che l'algoritmo di decifratura è probabilistico, quindi dobbiamo esprimere tutto in termini di probabilità. Ok? Quindi in pratica questa descrizione fondamentalmente ci dice che nella cifratura chiave pubblica si usa la chiave pubblica per cifrare, la chiave privata per decifrare. Questa è l'idea. Ok? Bene. Bene. Applicazioni di questo metodo di decifratura, di questo schema ce ne sono tante, innumerevoli, qui ci sono due esempi classici che fanno riferimento a situazioni reali. Ad esempio nel primo caso si parla dell'invio di mail cifrate. Non so se lo conoscete, uno dei primi programmi di gestione della posta elettronica arricchito, integrato con strumenti per la protezione delle mail, è stato PGP già parecchi anni fa. E' un altro protomail un pochino più recente. Entrambi offrono meccanismi per appunto cifrare i messaggi che vengono inviati via mail. E lo schema in entrambi i casi ad un certo livello di gestione è sempre lo stesso. Ovvero se Alice deve mandare una mail a Bob, semplicemente che cosa fa? L'idea di base sarebbe quella di cifrare il messaggio usando la chiave pubblica di Bob. Maniera tale che solo Bob lo possa decifrare, perché solo lui conosce la chiave segreta corrispondente. Nella realtà per questioni di performance le cose non vanno esattamente in questo modo, il motivo l'abbiamo in parte visto ieri, la cifratura, le operazioni criptografiche asimmetriche sono costose in termini di performance. Se ne siamo fatti un'idea ieri ragionando sulla lunghezza delle chiavi, rispetto ad esempio ai meccanismi basati su cifratura asimmetrica che usano chiavi molto più corte per garantire il livello di sicurezza. Poi torneremo su questo discorso. Quindi per questo motivo le applicazioni pratiche, in particolare sia PGP che ProtonMail, usano lo schema di cifratura chiave pubblica solo per cifrare una chiave, non l'intera mail. Per cifrare una chiave simmetrica che viene usata per cifrare la mail con un cifrario simmetrico. Quindi l'idea qual è? L'idea è che Alice sceglie una chiave simmetrica per cifrare la mail, ad esempio usando un AES in CBC mode oppure uno schema di authenticated encryption come quelli che abbiamo visto solo dalla encrypted Mac che abbiamo visto la scorsa settimana. Quindi usa una chiave simmetrica per proteggere la mail e manda la mail. Poi cosa fa? Usa la chiave pubblica di Bob per cifrare la chiave simmetrica e manda anche questo ciphertext a Bob. Quindi Bob dall'altra parte che cosa deve fare? Usare la chiave segreta per recuperare la chiave simmetrica e poi usare la chiave simmetrica per decifrare la mail. Quindi in questo modo la cifratura asimmetrica viene usata per cifrare solo pochi byte, quelli della chiave. Ok? Un meccanismo di questo tipo si usa anche per la condivisione dei file cifrati. Immaginate di avere nel cloud un repository a pubblico accesso che però volete utilizzare per condividere dati in maniera privata con altri utenti, in maniera tale che i file siano accessibili solamente a loro e non ad altri, non autorizzati. Un modo semplice per farlo è usare appunto uno schema di cifratura analogo al precedente, per cui immaginiamo il solito scenario in cui Alice vuole condividere un file con Bob. Cosa fa? Cifra il file usando l'authenticated encryption, ad esempio, e quindi un cifrario simmetrico e poi che cosa fa? Memorizza nello stesso repository anche la cifratura della chiave usata per cifrare il file tramite la chiave pubblica di Bob, in questo caso, che è quello che deve poter avere accesso al file. Quindi Bob cosa fa? Accede ai repository, decrypta usando la propria chiave segreta la chiave simmetrica che Alice ha usato per cifrare il file e poi usando quella recupera anche il file. Quindi la stessa identica idea dell'esempio precedente. Questo è il modo tipico in cui si utilizzano gli schemi a chiave asimmetriche. non si usano mai per cifrare grandi quantità di dati, si preferiscono usare cifrari simmetrici, mentre quello asimmetrico si usa solo per proteggere il materiale crittografico, in questo caso le chiave. e ti pensi da che la posizione di useremo? ti hai visto? beh ieri abbiamo visto come RSA e di Fjellman potrebbero essere usati per consentire a due utenti che non si conoscono un valore condiviso. Quindi due utenti che non sanno nulla l'uno dell'altro. Ok? In quel caso tra l'altro ci sarebbe anche il problema dell'identità, dell'identità che non l'ha gestito. Ok? In questo caso noi implicitamente stiamo assumendo che il problema dell'identità è risolto dal fatto che Alice sa qual è la chiave pubblica di Bob. Ok? No? Perché qui stiamo dicendo che per permettere ad Alice di condividere una qualche informazione con Bob, Alice cifra con l'informazione e poi cifra la chiave crittografica utilizzata con la chiave pubblica di Bob. Quindi noi per adesso lo stiamo sottovalutando questo problema, però stiamo assumendo in maniera semplicistica che Alice conosca chi ha il problema di Bob. Se così è abbiamo risolto il problema dell'identità. Ok? E quindi in questa maniera ci dobbiamo preoccupare solo del problema della confidenzialità e dell'integrità. Ieri non abbiamo proprio parlato di identità, ieri parlavamo di due entità che non si conoscono, abbiamo astratto dal discorso di identità e ci siamo chiesti come fanno queste due entità a condividere un segreto da zero. E allora abbiamo visto che possono usare RSA o Diffie Hellman, in realtà in maniera non sicura nel caso di Diffie Hellman perché abbiamo visto che c'è il problema del mal in the middle. Ma come risolvere tutti questi problemi legati all'identità lo vedremo quando studieremo protocolli più avanzati. Ok? E useremo comunque questi ingredienti qua alla fine, niente di più complesso. Quindi avendo definito la cifratura a chiave asimmetrica ci possiamo chiedere come cambiano, se cambiano, tutte le definizioni che abbiamo visto all'inizio del corso relative alla cifratura asimmetrica. A partire dalla definizione di sicurezza semantica, la semantic security che è stata la prima che abbiamo visto. La definizione è quasi la stessa, tiene conto del fatto che qui cambia il tipo di cifratura, la chiave pubblica non è la chiave simmetrica. Infatti se vediamo la tag game sarebbe istruttivo fare il confronto tra questo tag game e quello della semantic security che abbiamo visto per la cifratura asimmetrica. Li mettete uno di fianco all'altro, confronto e vedrete che corrispondono. Ok? In questo tag game, come al solito, abbiamo il challenger che inizialmente, questa è una peculiarità della cifratura asimmetrica, deve scegliere la coppia di chiavi, Pk e Sk, e pubblicare la chiave pubblica, perché quella deve essere nota a tutti. Ok? E si tiene invece privatamente la chiave segreta. L'avversario risponde, come già faceva nella tag game che conoscevamo dalla cifratura asimmetrica, ovvero sceglie due messaggi di pari lunghezza, M0 ed M1, e li manda al challenger. Il challenger, a seconda dell'esperimento in cui ci troviamo, cifra uno dei due messaggi. Ok? E manda la cifratura all'avversario. L'avversario deve fare guessing usando il proprio algoritmo efficiente per cercare di chiaramente indovinare di quale messaggio si tratta, quale dei due messaggi è stato cifrato. E il suo vantaggio è la solita differenza di probabilità tra due eventi, come abbiamo sempre discusso anche in passato. Così come la definizione di sicurezza semantica. E dice che un cifrario è semanticamente sicuro se il vantaggio dell'avversario è negligible per tutti gli avversari efficienti. Quindi lo schema è esattamente quello che già conosciamo. Ok? Ora, vedendo questo attack game, capiamo subito il motivo per cui il cifrario deve essere probabilistico. Perché se non è probabilistico, l'avversario ha un modo molto banale di vincere questo attack game. Considerato che la chiave pubblica la conoscono tutti e quindi anche l'avversario. Come fa a vincere questo gioco? Immaginate che il cifrario sia deterministico. Ok? Quindi la funzione di cifratura è deterministica. Quindi questo significa che data una chiave pubblica e dato un messaggio esiste uno ed un solo ciphertext corrispondente. Ok? Quindi sotto questa ipotesi come fa l'avversario a vincere questo attack game? Cosa deve fare? Per capire se è stato cifrato, è un 0 o un 1. Esatto. Prova a fare la cifratura anche lui. No? Perché qui il challenger che cosa fa? Cifra uno dei due messaggi con la chiave pubblica. Ma la chiave appunto è pubblica. Anche l'avversario può fare la stessa operazione. Ok? Quindi cosa deve... Quando l'avversario riceve C, il ciphertext, cosa deve fare? Deve anche lui cifrare M0 e cifrare M1 e poi fa il confronto. E guarda quale dei due ciphertext coincide con C. Ed ecco che ha già vinto la tag game. Quindi se il cifrario è deterministico, non può essere semanticamente sicuro. E questo è il motivo per cui, ve l'avevo anticipato ieri, noi non possiamo usare RSA così com'è per fare asymmetric encryption. Perché RSA è deterministico. E quindi, se usassimo RSA come cifrario, l'avversario vincerebbe banalmente. Ok? Se invece il cifrario è probabilistico, allora l'avversario non può vincere la tag game usando questa strategia che abbiamo appena detto. Per quale motivo? Perché se il cifrario è probabilistico, la cifratura che fa il challenger potrebbe dare un risultato diverso rispetto alla cifratura che la fa l'avversario. anche se entrambi usano la stessa chiave e la fanno sugli stessi messaggi. Perché? Perché in quel caso il risultato della cifratura dipenderebbe da un nonce, quindi quello dipende dal nonce che sceglie il challenger, dal nonce che sceglie l'avversario. Quindi in quel caso questa strategia dell'avversario non funziona più. Ok? Quindi, come abbiamo appena detto, è indispensabile che il cifrario sia probabilistico. Ok? Quindi vedremo tra poco come rendere probabilistico RSA fare altrettanto con BFH. Passiamo invece alla sicurezza di tipo chosen plaintext attack. Anche qui andiamo a riprendere quella vecchia che avevamo studiato per la cifratura chiavesimmetrica e la adattiamo a questo nuovo contesto. Quindi anche in questo caso abbiamo il challenger che calcola la coppia di chiavi in maniera randomica. L'avversario, rispetto alla sicurezza semantica, l'avversario non sottopone una sola coppia ma ha una sequenza di coppie di plaintext. E per ogni coppia al solito il challenger risponde cifrando uno dei due messaggi. E anche qui lo scopo dell'avversario è capire in quale esperimento ci troviamo. Quindi la definizione è sempre la solita. Ok? E se vi ricordate il motivo per cui avevamo introdotto la sicurezza di tipo chosen plaintext attack rispetto alla sicurezza semantica era perché volevamo garantire volevamo lavorare con cifrare i sicuri anche quando veniva utilizzata la stessa chiave per cifrare più messaggi. Ok? E se vi ricordate nel caso della cifratura asimmetrica per ottenere la CPA security i cifrari dovranno diventare probabilistici. No? Nel caso della cifratura asimmetrica i cifrari devono essere già probabilistici qui per la semantic security. Sono già probabilistici. Devono essere già probabilistici. L'abbiamo appena detto. Ok? Quindi quando passiamo dalla semantic security alla CPA security abbiamo già tutti gli ingredienti no? Che ci servivano perché la cosa fondamentale era passare da un cifrare deterministico o non probabilistico. Questo che cosa significa? Significa che nel mondo della cifratura asimmetrica sicurezza semantica e CPA security sono equivalenti. non cambia nulla. In particolare c'è un teorema che dice che se un cifrario a chiave pubblica è semanticamente sicuro allora è già anche CPA sicuro. Il motivo è già probabilistico quindi l'idea è questa. Quindi se vogliamo nel contesto un po' più semplice rispetto al trasformare di proprietà che avevamo introdotto per la cifratura a chiave asimmetrica. Ok? Bene. Quindi ora vediamo come implementare cifrari a chiave asimmetrica usando i due approcci che abbiamo introdotto ieri. partiamo dall'idea generale di come fare cifratura a chiave asimmetrica usando uno schema di funzione con Trapdoor che è la generalizzazione dell'idea dell'RSA che vedremo comunque tra poco anche quella del dettaglio. Quindi immaginiamo di avere uno schema di funzione con Trapdoor come ad esempio RSA e come possiamo utilizzarlo sfruttarlo per creare un cifrario a chiave a chiave pubblica? Sappiamo che dobbiamo renderlo probabilistico l'idea è questa. L'altra idea è sfruttiamo il principio che abbiamo discusso negli esempi di prima. Ok? Quindi non facciamo la cifratura dell'intero messaggio ma facciamo solo la cifratura di una chiave che poi usiamo con un cifrario simmetrico per cifrare il plaintext. Ok? L'idea è quella. E' infatti quella che è implementata qua. Quindi immaginate di avere uno schema di produzione del contrario come ad esempio RSA un cifrario simmetrico che ne so ASNCBCMOD o quello che volete uno stream cipher quello che volete non ha importanza e una questione hash che vedremo tra poco come viene utilizzato. La cifratura come funziona? Allora in prima battuta dobbiamo scegliere un nonce perché? Perché il cifrario deve essere probabilistico. Quindi scegliamo in maniera randomica un nonce. Dopodiché che cosa facciamo? usiamo lo schema di funzione con trapdoor per mappare il nonce nell'output corrispondente usando la funzione F e quindi la chiave pubblica. Ok? Quindi quindi scegliamo randomicamente il nostro nonce e poi usiamo lo schema di funzione con trapdoor per nascondere il nonce di fatto. Ok? tramite la chiave pubblica. Ok? Poi che cosa facciamo? Calcoliamo il digest del nonce usando la funzione hash. Questo digest lo useremo come chiave per cifrare il plaintext. adesso faccio un esempio. Allora partiamo scegliendo un valore casuale. X x is random value. Ok? First step we have to hide x and to design we use the traveler function scheme in this way. we we employ the probic key and we hide the random value and the result is y. Ok? First step. Second step. We compute the digest of the random value. And we use the digest of the random value as key. Ok? So the symmetric key is the digest of the random value. Yeah, yeah, the random value. And then we encrypt the plain text by using the digest of the random value. So in the end we publish the cipher text and the value of y. Ok? So what happens at the other side? I need to recover from epsilon I recover x by using the secret key and this algorithm. Then I compute the digest and then I decrypt. Ok? Quindi, ripetendo, come avviene la cifratura? Scelgo un valore random randomico. Applico la funzione f dello schema di funzione contra updoor per nascondere questo valore randomico usando la chiave pubblica e il risultato sarà l'output y. poi del valore randomico calcolo il digest usando una funzione hash e questo digest lo uso come chiave simmetrica per la cifratura del playtest. Ok? E quindi sparo in output y e c. Vedete che è la stessa idea di pgp o di proton mail? Cioè io non uso la la primitiva asimmetrica in questo caso lo schema di funzione contra per cifrare l'intero plaintext ma lo uso solo per nascondere per cifrare che cosa in questo caso l'informazione da cui deriva la chiave chiave che userò con un cifrario simmetrico per cifrare appunto il plaintext quindi dall'altra parte al lato decifratura che cosa succederà ricevo y ricevo c chiaramente al lato decifratura devo usare la chiave segreta a cosa mi serve la chiave segreta mi serve per invertire y e recuperare x no ok una volta che ho recuperato x calcolo il suo digest che è la chiave che mi serve per decifrare il plaintext ok ok cosa dice il teorema il teorema fa delle ipotesi su i tre sui tre ingredienti che abbiamo utilizzato per per costruire questo schema quindi il teorema ci dice che se usiamo un certo tipo di funzione di schema di funzione contratto un certo tipo di si parla cifrario simmetrico un certo tipo di expansion la costruzione che otteniamo è un cifrario asimmetrico semanticamente sicuro e quindi anche cpa sicuro ok quali sono queste ipotesi molto semplice questo questo schema deve essere sicuro cioè non invertibile l'unico modo per invertire è conoscere la chiave segreta ok questo deve essere semanticamente sicuro ok e e la funzione deve essere sicura nel senso che non deve essere invertibile un donno esatto dal punto di vista di un avversario l'output di una funzione è imprevedibile quindi anche la funzione deve essere non invertibile quindi sicura rispetto al discorso alla proprietà di one wayness che avevamo studiato ok quindi se valgono queste tre condizioni il vostro cifrario scritto in questa maniera qua è semanticamente e quindi cpa sicuro ok come funziona se come schema di funzione con trap usiamo RSA qui vedete il funzionamento quindi come al solito dobbiamo generare la coppia di chiavi RSA e l'abbiamo visto ieri come si fa quindi si parte da questi due parametri in particolare in particolare dobbiamo scegliere in maniera randomica i due numeri primi P e Q tale per cui N è P per Q dobbiamo scegliere D che è l'inverso di E modulo P meno 1 per Q meno 1 e quindi il risultato sarà che questa è la chiave pubblica e questa è la chiave segreta questo è l'algoritmo di generazione delle chiavi di LRSA ok quindi la cifratura si fa così ok il il non random è un valore in ZN perché tutti i calcoli RSA sono in ZN ok il mapping di X in Y si fa così in RSA cioè dobbiamo prendere X e levarlo alla E che è la chiave pubblica ok le altre operazioni le abbiamo già viste K è il digest di X e C è il software text di corrispondente M rispetto a K usando il cifrario simmetrico che vogliamo e quindi l'output sarà questa coppia ok quindi vedete qui le idee sono due stiamo usando RSA facendolo diventare probabilistico perché l'input di RSA è randomico X è l'input che diamo a RSA è randomico e quindi stiamo rendendo il nostro schema probabilistico ok e l'informazione che noi nascondiamo usando RSA oltre che essere randomica rappresenta anche di fatto la chiave utilizzata per cifrare il plaintext ok poi la decifratura naturalmente funziona in maniera analoga vedete chi decifra riceve Y riceve C usa la chiave segreta per invertire Y e riottenere scusate sono dentro invece che avanti usa usa la la chiave segreta per invertire Y e recuperare X e l'operazione da fare lo sappiamo è questa e ok e poi si procede come al solito si calcola il digest di X si fa la decifratura del ciphertext ok vale il teorema generale che abbiamo detto prima assumendo che RSA sia sicuro rispetto al discorso che abbiamo fatto ieri ok ok questo è un modo non è l'unico dopo ve ne faccio vedere anche un altro è un modo per usare RSA per costruire un cifrario asimmetrico semanticamente sicuro il caso di Diffie Elman è un pochino più complicato perché dobbiamo decidere usando Diffie Elman che cos'è la chiave pubblica e che cos'è la chiave segreta usando gli ingredienti di Diffie Elman ok vi ricordate quali sono gli ingredienti di Diffie Elman Liffie Elman lavora su un gruppo ciclico no quelli insieme generato da un generatore G gli elementi del gruppo ciclico sono le potenze di G da 0 a Q-1 dove Q è il numero primo ok quindi gli ingredienti di Diffie Elman che andiamo a usare sono un gruppo ciclico G generato da un generatore G quindi nel gruppo ciclico ci sono G alla 0 G alla 1 G alla Q-1 ok e sono tutti elementi che fanno parte di Veta P dove P è un altro numero primo ok questo è quello che abbiamo visto ieri no quindi usiamo gli ingredienti di che conosciamo di Diffie Elman vedremo tra poco come gli altri ingredienti sono gli stessi di prima un cifrario simmetrico e una funzione hash ok ora andiamo a vedere come funziona la generazione della coppia di chiavi questa è la parte più interessante allora per generare le chiavi che cosa succede viene scelto in maniera casuale un alfa in ZQ quindi alfa è uno dei possibili esponenti che caratterizzano il gruppo ciclico quindi scegliamo alfa in maniera randomica e alfa lo useremo come chiave segreta quindi alfa è la chiave segreta la chiave pubblica invece è G alla alfa ok se vi ricordate ieri abbiamo visto che conoscendo G alla alfa anche se sapete qual è il generatore G non riuscite a recuperare alfa non esiste un ancoritmo efficiente che vi permette di recuperare alfa è una delle soluzioni che sta alla base dello schema di Diffie e che sfrutteremo quindi G alla alfa è la chiave pubblica alfa è la chiave segreta il tutto naturalmente randomico alfa è stata uscita in maniera randomica quindi l'algoritmo di generazione della chiave è a tutti gli effetti probabilistico ok come usiamo chiave pubblica chiave segreta vediamo un po' immaginiamo di avere Alice da una parte scriviamo così Alice da una parte Bob dall'altra ok Alice vuole mandare un messaggio a Bob ok e Bob ha questa coppia di chiavi dove questa abbiamo appena detto è la chiave pubblica e questa è la chiave segreta ok ora Alice per mandare un messaggio cifrato a Bob userà la chiave pubblica di Bob immaginiamo che la conosca ok e come la usa segue questo algoritmo andiamo a vedere che cosa succede sceglie randomicamente un beta no sempre il beta q come alfa quindi beta e zq quindi anche beta è un possibile esponente del gruppo ciclico ok poi calcola questa roba qui no calcola g alla beta e calcola g alla alfa beta come fa a calcolare g alla alfa beta prende g alla alfa che è la chiave pubblica di Bob e lo eleva alla beta che è il valore randomico che ha scelto lei ok quindi Alice ha un modo efficiente per calcolare sia questo che questa no concatena questi due valori e li dà in input alla funzione hash il digest lo usiamo come chiave qui per cifrare il plaintext a questo punto cosa fa Alice trasmette a Bob questa coppia g alla beta e il cyphertext ok ora Bob per decifrare il cyphertext ha bisogno di k per fare questa operazione ha bisogno di k per recuperare k ha bisogno di fare l'ash di questa concatenazione qui giusto ok ora ragioniamo come fa Bob a recuperare queste informazioni g alla beta lo ha ricevuto e quindi ce l'ha g alla alfa beta come fa calcolarlo prende g alla beta che lo ha appena ricevuto e lo eleva all'alfa che è la sua chiave segreta fa questa operazione g alla beta tutta l'alfa vi ricordi Alice invece aveva fatto il contrario Alice aveva fatto g alla alfa che è la chiave pubblica di Bob elevato alla beta che l'aveva scelto lui ok ma l'abbiamo visto ieri sia questo che questo mi danno come risultato questo qui e per come lo abbiamo calcolato esattamente l'idea di di firma che abbiamo visto ieri solo Alice e Bob sono capaci di farlo Alice riesce a farlo perché conosce beta l'ha scelto lui l'ha scelto lei Bob riesce a farlo perché ha alfa che ha la sua chiave segreta nessun altro è in grado di calcolare g alla alfa beta quindi nessun altro è in grado di fare questa operazione quindi solo Bob può recuperare k e quindi una volta recuperato k decifrare il plain text quindi vedete abbiamo usato le proprietà di firma che avevamo discorso ieri per realizzare uno schema che consente ad Alice di cifrare un messaggio da mandare a Bob questo tipo di schema si chiama Ergamal poi le implementazioni di Ergamal dipendono sempre dal solito da che tipo di funzionale si sceglie che tipo di cifrario simmetrico si sceglie però in generale vale un teorema simile a quello di prima che è questo che al solito dice che se H la funzione esce sicura qui ho usato questa notazione random vuol dire che H è sicura il comportamento di H è impredicibile una funzione pseudo casuale quindi se H la funzione esce sicura se l'ipotesi che ieri avevamo chiamato di firma computazionale quella CDH assumption vale per il gruppo ciclico cosa vuol dire vuol dire che anche se l'avversario vede passare anche se l'avversario vede G al alfa la conosce perché la chiave pubblica di Bob G al al beta la vede passare ma anche se ha queste due informazioni non è in grado comunque di calcolare G al alfa beta questa è la soluzione che avevo visto ieri quindi se vale questa soluzione qua H è una funzione esce sicura e usiamo un cifrario simmetrico sicuro allora il gamal è uno schema di ciclatura chiave asimmetrica semanticamente sicuro e quindi anche cpi a sicuro il gamal è uno schema molto interessante perché è molto flessibile le proprietà dei gruppi ciclici sono molto belle perché permettono di fare cose estremamente flessibili e interessanti si usa in contesti più ampi rispetto alla cifratura basata su RSA che è più rigida le proprietà matematiche che sono alla base di RSA sono più rigide da questo punto di vista vi faccio due esempi di applicazioni pratiche che si possono risolvere usando il gamal ma non si possono risolvere usando RSA proprio per la natura dei problemi matematici che ci stanno sotto ok sono due casi abbastanza tipici uno è quello della stress of decryption che è diventato anche abbastanza diffuso da quando si fanno operazioni crittografiche in cloud e in sistemi distribuiti ok perché garantisce la privacy in particolare la stress of decryption funziona così la chiave segreta necessaria per decifrare un certo messaggio viene spezzata in tante in tante in tante porzioni in tanti share si chiamano ok dopodiché i vari share vengono assegnati a diversi nodi ok tipicamente diversi server quando bisogna decifrare un ciphertext ogni server deve utilizzare il proprio share ok e il risultato dell'applicazione di un share al ciphertext decifra parte del ciphertext ma non fornisce informazioni sul plaintext ok quindi nessun server da solo è in grado di recuperare il plaintext ma è necessario che tutti tutti in realtà non tutti come vediamo tra poco ma è necessario che più o meno tutti partecipino se tutti partecipano fornendo il proprio share allora si riesce a decifrare il ciphertext in genere c'è una threshold esiste una threshold per cui per poter ottenere il plaintext almeno un numero di server pari alla threshold deve partecipare gli altri magari non sono connessi in quel momento per tanti vari motivi quindi se il numero di server che partecipa supera una certa threshold allora usando i vari share combinando il loro utilizzo si riesce a decifrare il ciphertext e recuperare il plaintext un altro esempio quello dell'oblivious transfer anche questo ha molte applicazioni pratiche immaginate una situazione in cui Alice ha un certo numero di plaintext ok Bob ha necessità di accedere a uno di questi ma non vuol far sapere ad Alice quale ok c'è un modo di risolvere questo problema usando il gamal per cui Bob impara uno dei plaintext l'idea è che Alice deve cifrare in qualche modo i vari i vari implante e i vari i plaintext e offrire la possibilità Bob di decifrare uno solo di quelli senza sapere quale ok sembra strano ma ripeto usando il gamal questo tipo di di di problema che si riesce si riesce a risolvere in entrambi i casi le motivazioni dietro il funzionamento di questi meccanismi sono legate a discorsi relativi alla privacy fondamentalmente ma ce ne sono tanti altri di esempi di questo di questo genere dove si usano gruppi ciclici per risolvere la questione un altro esempio che negli ultimi tempi è diventato parecchio utilizzato nell'ambito dell'addestramento di modelli di machine learning applicativi sono tanti dove c'è necessità di combinare per la creazione di un modello diversi dataset ok quindi situazioni in cui che ne so ci sono tanti nodi che possiedono un po' di dati e tutti questi dati dovrebbero confluire a un enorme unico dataset usato per addestrare un certo modello ok quindi una situazione in cui i dati che devono alimentare il dataset vengono da diverse fonti allora qui ci sono un grosso problema di privacy perché dove viene addestrato il modello magari non si ha interesse che vengono collezionati in un unico posto una grande quantità di dati che provengono da fonti diverse in totale violazione della privacy di queste informazioni magari ogni fonte vuole contribuire all'addestramento del dataset ma non vuole svelare le proprie informazioni che sembra una contraddizione in termini perché se vuoi partecipare al training devi formire i tuoi dati ma se sono dati sensibili allora sei reticente rispetto al discorso di prenderli e spedirli magari nel cloud dove c'è il modello che viene addestrato e allora la soluzione a questo tipo di problema segue un po' questa idea qua per cui quello che succede è che viene addestrato un modello parziale localmente direttamente sulla fonte ok quindi c'è un modellino parziale che viene addestrato sulla localmente dopodiché questo modellino viene cifrato al server centrale arrivano le cifrature di tutti i modelli parziali poi il server centrale ha un modo di combinare tutti i modelli parziali in un unico modello ok senza però svelare le informazioni sensibili relative ai dati che hanno alimentato i modelli parziali e la soluzione fa sempre uso di meccanismi basati sempre sul discorso dei gruppi ciclici per cui nel server centrale vi ritrovate un unico modello cifrato che è la combinazione di tanti modelli locali senza dover per questo accedere ai dati sensibili che hanno alimentato quei modelli questo è l'idea che sta alla base di quello che in generale viene chiamato federated learning un apprendimento federato bene veniamo un po' ad aspetti legati all'efficienza visto che nell'ambito della cifratura simmetrica l'efficienza è un problema no ad esempio nel caso di di di di di di di di abbiamo detto che per avere un cifrario di Elgamal semanticamente sicuro è necessario che la soluzione su di Fielman per il gruppo ciprico che viene utilizzato valga e perché valga bisogna usare numeri primi molto grandi nell'ordine ad esempio dei 2048 bit per quanto riguarda il valore del numero primo p qualcosa del genere l'avevamo già anticipata ieri e questo ha un costo perché quando si applicano le operazioni di di Fielman diversi levamenti a potenza che devono essere fatti g al alfa la beta e via dicendo queste sono operazioni che costano quando i numeri coinvolti sono numeri a 2048 bit ad esempio e questo appunto può essere un problema problema che in parte è stato risolto cercando di sostituire i gruppi ciclici con qualcosa di più efficiente da un punto di vista delle operazioni matematiche e la soluzione di maggior successo da questo punto di vista ha dato origine al finone della criptografia basata su curve elliptiche il cui obiettivo è quello di ispirarsi sempre all'idea di Diff Elman e quindi ai cifrari di Elgamal ok però rinunciando a lavorare sui gruppi ciclici proprio per i problemi di efficienza che abbiamo detto ma lavorando su altri gruppi di valori che però abbiano proprietà di sicurezza analoghe a quelle dei gruppi ciclici no perché usiamo i gruppi ciclici perché all'interno di un gruppo ciclico abbiamo visto che dato g all'alfa è difficile recuperare alfa quella è la chiave di tutto l'idea anche qua è quella di usare un gruppo di valori per cui c'è all'interno di un gruppo di valori un problema difficile da risolvere tipo quello di Diff Elman ok con la criptografia ellitica questo è possibile tant'è che i livelli di sicurezza analoghi a quelli di Diff Elman si riescono a raggiungere con numeri primi molto più piccoli li trovate anche se in maniera approssimata una corrispondenza cioè lo stesso livello di sicurezza che in Diff Elman avete con numeri primi di 2048 bit nel caso della criptografia ellittica ce l'avete con numeri primi di 256 bit vedete siamo molto molto vicini ad esempio ai valori degli schemi a chiave simmetrica anche là si parlava di 128 256 bit anche per le funzioni hash si parla con il minimo di 256 bit quindi si avvicina molto come come ordine di grandezza quindi come performance a quelli che conosciamo per gli schemi chiave simmetrica ok per questo motivo vi volevo far vedere anche se in maniera molto molto astratta come funziona la criptografia ellittica ok ripeto non è altro che una implementazione di Diff fielman dove invece che lavorare sui punti di un gruppo ciclico si lavora sui punti di una curva ellittica da qui il nome è criptografia ellittica quindi tutto si basa sulla scelta di una curva ellittica che sono curve la cui equazione generale è questa poi vi faccio vedere come come sono fatte ok quindi da un punto di vista intuitivo l'idea è proprio questa vedremo che scegliendo in un certo modo un gruppo di punti discreti di una certa curva ellittica quel gruppo di punti ha le stesse caratteristiche che hanno i gruppi ciclici ovvero certi problemi sono difficili da risolvere però sono problemi che hanno una realizzazione pratica più efficiente tra poco lo vedremo perché di fatto vedremo che tutte le operazioni di rilevamento a potenza nel caso della criptografia ellittica diventano dei prodotti e tutti i prodotti nel caso di Fiehlmann diventano addirittura delle somme nel caso della criptografia ellittica quindi si riduce molto la difficoltà delle operazioni oltre che alle dimensioni dei numeri primi in ballo allora vediamo un attimo come funziona anche se ad alto livello di rilevamento la criptografia ellittica che oramai è implementata in tutti i sistemi che usano si frattura a chiave asimmetrica gli standard sono pochissimi quelli che usano ancora meccanismi come RSA o come il gamal classico oramai ad esempio l'ultima versione di TLS per quanto riguarda la cifratura asimmetrica usa la criptografia ellittica in particolare usa una curva ellittica che si chiama P256 che vi farò vedere dopo quindi allo stato attuale delle cose la criptografia ellittica ormai ha soppiantato sicuramente RSA in molti casi anche il gamal ok bene questo è un esempio di curve ellittica ok avete mai visto una volta che vedete una curve ellittica ok vabbè non ci interessa studiare le proprietà della definizione delle curve ellittiche quello che ci interessa è che è possibile dare un'interpretazione geometrica tramite le curve ellittiche delle operazioni tipiche che riguardano i gruppi come i gruppi ciclici non parleremo di gruppi nel caso della criptografia ellittica parleremo di campi di field ma il concetto è sempre quello perché un campo rappresenta un insieme di valori chiuso rispetto alle operazioni di somma e di prodotto ok un po' come nel caso dei gruppi ciclici lì eravamo chiusi rispetto all'allevamento a potenza no perché il gruppo è ciclico perché voi applicate allo stesso generatore applicate un esponente qualunque ottenete sempre un valore che sta dentro il gruppo quella era la proprietà che avevamo visto ieri qui ragioneremo in una maniera analoga prendiamo un insieme di punti della curva ellittica e questi vedremo che sono chiusi rispetto all'operazione di somma e di prodotto no il motivo lo vediamo chiaramente a livello di interpretazione del geometro non è chiaro non è chiara l'idea che se io prendo due punti e li sommo per morstando che cosa vuol dire sommare due punti si ottiene come risultato un valore che rappresenta ancora un punto della stessa curva o idem per il prodotto cosa significa non è intuitiva come idea però l'interpretazione geometrica rompe un po' questa questa complessità dell'intuizione lo vediamo subito prendete ad esempio due punti P e Q di questa curva ellittica qual è l'interpretazione geometrica della somma di questi due punti si traccia l'unica retta che collega P e Q questa retta interseca per forza la curva ellittica in un terzo punto che è quel meno R quel punto lo si ribalta rispetto all'asse di riferimento e si ottiene R R è un punto della curva ellittica che per noi rappresenta la somma di P e Q ok quindi l'interpretazione di P più Q è R calcolato in questo modo qua ok sembra un modo strano però ripeto è un modo per interpretare la somma che ci permette di soddisfare quella proprietà che dicevamo prima ovvero presi due punti qualunque di una curva ellittica li sommiamo in questo modo otteniamo di nuovo un punto della curva ellittica ok ora che succede se qui si vede un po' peggio che succede se sommiamo un punto con se stesso è meno chiara la situazione no perché se sommiamo due punti diversi allora abbiamo detto tracciamo la retta che vi interseca entrambi e va bene ma se invece dobbiamo sommare P con se stesso ci sono infinite rette che passano per P ok e l'idea qual è l'idea è di prendere la tangente alla curva ellittica nel punto P ok questo è il punto P vogliamo fare P più P quindi il giochino di qua sopra non lo possiamo fare perché non abbiamo due punti diversi su cui far passare una retta e quindi ci dobbiamo inventare un trucco il trucco consiste nel prendere la tangente alla curva che passa per P questa tangente intersecherà la curva da qualche parte come nel caso precedente ribaltate rispetto all'asse di riferimento ed ecco che ottenete un altro punto della curva R che sarà il risultato di P più P ok ora una volta che abbiamo definito la somma di un numero con se stesso abbiamo anche il prodotto di conseguenza perché P più P è 2 per P quindi abbiamo definito come sommare e come moltiplicare punti ok basta il gioco è fatto non ci serve altro poi ci sono dei teoremi dei risultati che vengono dalla geometria e che ci interessano fino a un certo punto quello che ci interessa è che se noi scegliamo opportunamente una certa curva ellittica e all'interno di questa curva ellittica prendiamo un gruppo di punti che sia chiuso per somma e prodotto dove somma e prodotto sono definite nel modo che abbiamo visto prima ok il numero di punti che prendiamo deve essere sufficientemente grande il gruppo deve essere molto grande deve essere in particolare come facciamo a scegliere un gruppo sufficientemente grande partiamo sempre da un numero primo come nel caso di Fielman quindi scegliamo un numero primo ok quindi tutti i punti della curva che prendiamo saranno in Zp scelti come scelti in questa maniera qua ok quindi fissata la curva ellittica ok che chiaramente noi su cui lavoreremo in aritmetica modulo p noi andiamo a prendere un insieme di punti ok in che maniera queste sono le coordinate di ciascun punto e sia x che y devono stare in Zp ok quindi scegliamo in qualche modo un insieme di punti della curva ellittica l'unica cosa a cui fare attenzione è che l'insieme di questi punti ripeto deve essere chiuso per somma e prodotto quindi se due punti fanno parte di quelli insieme del nostro gruppo anche la loro somma ne fa parte anche il loro prodotto ne fa parte e così via quindi un insieme chiuso per somma e prodotto in aritematica modulare siamo sempre in Zp tralasciamo il modo in cui vengono scelti questi punti non ci interessa quello che ci interessa è che scelta opportunamente la curva ellittica scelta un gruppo di punti che sia un campo quindi che siano chiusi per somma e prodotto c'è un problema simile a quello di Diffie Hellman che è difficile da risolvere e qual è questo problema? il problema è che se io scelgo un qualunque fattore moltiplicativo alfa ok che ha un valore compreso fra 0 e la cardinalità del gruppo ok e scelgo un qualunque punto che chiameremo base point punto base P calcolo il prodotto del punto base per il fattore moltiplicativo alfa e vi faccio vedere questo valore anche se voi conoscete il punto base non siete capaci di recuperare alfa è un problema hard ok è un problema hard questo se vedete è molto simile a Diffie Hellman no? anche in Diffie Hellman io dovevo scegliere un numero primo P perché devo lavorare in ZP e un numero primo Q che rappresenta la cardinalità del gruppo ciclico poi in Diffie Hellman usavo la teoria dei gruppi ciclici quindi sceglievo un generatore e calcolavo il gruppo come tutte le potenze di quel generatore da 0 con meno 1 qui che cosa faccio? lavoro in maniera leggermente diversa ovvero scelgo una curva ellittica scelgo un insieme di punti in maniera discreta ovvero le coordinate dei punti che scelgo corrispondono a valori che stanno in ZP sono interi e questo insieme di punti sarà chiuso per somma e prodotto in base a come lo scelgo in questo insieme di punti mi scelgo un punto base che lo chiamo P il ruolo di P è analogo al ruolo del generatore G in Diffie Hellman dopodiché in Diffie Hellman il problema qual era? il problema era che se io sceglievo un alfa tra 0 e la cardinalità del gruppo ciclico e calcolavo G alla alfa e poi vi facevo vedere G alla alfa voi non eravate in grado di recuperare altro qua la stessa cosa invece che G scelgo un punto base e quello lo conoscono tutti un punto base degli insiemi di punti della curva ellittica ok? poi scelgo un fattore alfa compreso fra 0 la cardinalità del gruppo e calcolo alfa per P bene io vi faccio vedere questo anche se voi conoscete questo non siete nel grado di recuperare altro è lo stesso problema di Diffie Hellman in un contesto diverso qual è la differenza dal punto di vista dell'efficienza? che qua come operazione cosa uso? l'elevamento a potenza qua cosa uso? il prodotto prima considerazione seconda considerazione lo stesso livello di sicurezza che in Diffie Hellman cioè qua dentro ho con numeri primi a 2048 bit qua ce l'ho con numeri primi a 256 bit quindi ulteriore guardagno di efficienza ok? poi quando qua faccio il giochino di scegliere alfa scegliere beta e calcolare g all'alfa beta in uno di questi due modi qui ricordate? questo è quello che succede in Diffie Hellman qua avverrà in maniera analga scelgo alfa scelgo beta al punto base P e quello che mi basta fare è alfa per beta per P che lo calcolerò o come alfa P per beta oppure come beta P per alfa in maniera analoga di Fjellman con le stesse problematiche in termini di difficoltà ok? e il risultato finale è che è quello che vedete qua lo stesso livello di sicurezza che avete qui ce l'avete in criptografia ellittica con numeri prime 256 bit o in Diffie Hellman classico con numeri prime a 2048 bit o con numeri primi a 3072 bit in RSA poi se ci mettiamo dentro anche nelle funzioni hash vi ricordate l'overbound 256 bit anche per le funzioni hash ok? ok vi faccio vedere un esempio finale per confrontare una versione semplificata di El Gamal fatta con Diffie Hellman che è quella che è simile a quella che abbiamo visto prima un po' più semplice e El Gamal fatto invece con la criptografia ellittica ok? quindi partiamo da El Gamal ok? ora per realizzare El Gamal con Diffie Hellman partiamo come abbiamo sempre detto ho perso partiamo come abbiamo sempre detto da un gruppo ciclico sotto insieme di Zp ok? di ordine Q cosa vuol dire? vuol dire che la cardinalità di G è Q ok? poi nel gruppo ciclico abbiamo quello che è un generatore G no? perché il gruppo ciclico è definito in questa maniera qua G alla 0 G alla 1 eccetera eccetera fino a G alla numero 1 questo è il gruppo ciclico ok? che deriva dalla scelta di due numeri primi che sono questi ok? queste sono le le ipotesi di base per Diffie Hellman classico andiamo a vedere come funziona il Gamal in maniera leggermente rivisitata ah scusate dimenticavo questo è il problema difficile in Diffie Hellman io vi do G alla alfa voi non siete in grado di recuperare alfa ok? bene in il Gamal abbiamo detto che la chiave segreta è alfa la chiave pubblica è G alla alfa ok? poi da qui in avanti facciamo qualcosa di un po' più semplice rispetto al Gamal che vi ho presentato prima e cosa facciamo? è analogo è il Gamal ma la sua versione semplificata si sceglie beta ok? chi fa la cifrattura sceglie beta calcola G alla beta e G alla alfa beta ok? G alla alfa beta lo riesco a calcolare perché prendo G alla alfa e lo elevo alla beta ok? e qui è la novità rispetto al Gamal di prima nella versione semplificata la cifrattura la faccio così prendo banalmente il plaintext e lo moltiplico per G alla alfa beta dopodiché sparo in output G alla beta e il cifrattura chi fa la decifratura usa la chiave segreta alfa per costruire G alla alfa beta come fa? prende G alla beta che lo ha appena ricevuto lo eleva all'alfa che è la chiave segreta e ottene G alla alfa beta nel momento in cui G alla alfa beta recupero il plaintext calcolando C diviso G alla alfa beta visto che C l'avevo ottenuto moltiplicando e quindi qui faccio la divisione ok? quindi questa è una versione semplificata di il Gamal basata su di Fielman dall'altra parte vedete le operazioni corrispondenti no? per realizzare questa stessa versione di il Gamal però usando la criptografia ellittica ok? quindi invece di un gruppo ciclico io scelgo un gruppo di punti di una certa curva ellittica un gruppo di punti di cardinalità Q ok? al solito P e Q sono numeri primi però molto più piccoli rispetto al caso di Fielman quindi ho la mia curva ellittica in base a come ho scelto P scelgo un certo numero di punti di quella curva ellittica quanti ne scelgo Q dove Q è un altro numero primo benissimo tra tutti questi punti ne scelgo uno come base point il ruolo di P è analogo al ruolo del generatore G ok? non vi ho raccontato come vengono scelti i punti vi ho solo detto che caratteristiche devono avere però ci fidiamo del fatto che c'è un modo di sceglierli in maniera tale da garantire questo problema difficile cioè se io vi do alfa P dove P è il base point noto tutti voi non siete in grado di recuperare alfa ok? quindi esattamente come in Diffie Chiave segreta sarà alfa chiave pubblica sarà alfa P la cifratura vedete avviene nello stesso identico modo come procedimento scelgo un beta calcolo beta P e calcolo alfa beta P come faccio a calcolare alfa beta P? beh alfa P ce l'ho perché è chiave pubblica beta l'ho scelto io moltiplico i due ed ecco che ottengo alfa beta P o beta alfa P è la stessa cosa il prodotto è commutativo dopodiché guardate la cifratura guardate la differenza rispetto al caso di Diffie Heldman la cifratura la calcolo come somma in aritmetica modulare tra il plaintext e alfa beta P dopodiché l'output è analogo al caso precedente chi riceve l'output che cosa fa? prende beta P lo moltiplica per alfa che è la chiave segreta e quindi ottengo alfa beta P che dovrò sottrarre la cifratext per recuperare il plaintext ok? quindi morale della favola ho usato numeri primi molto più piccoli rispetto al caso di Diffie Heldman all'ordine di grandezza che l'abbiamo visto prima e per le operazioni di cifratura e di cifratura ho sostituito elevamenti a potenza con prodotti e prodotti con somme quindi semplificando ulteriormente quindi queste due cose combinate il fatto che ho chiavi numeri primi più piccoli e il fatto quindi ho valori più piccoli con cui lavorare e uso operazioni più semplici sommate insieme danno la maggiore efficienza di questo tipo di cifratura rispetto a il gamal basato su Diffie Heldman e soprattutto rispetto a RSA ok? questa è la curva elettrica che si usa dentro TLS l'ultima versione di TLS quindi la definizione generale è quella che abbiamo visto prima y al quadrato uguale a x al cubo più a x più b i due coefficienti a e b sono a e meno 3 b è un numero molto grande non ci stavo nella slide l'ho dovuto rappresentare in esadecimale ok? questa è la e e P il numero primo no? che mi dice sostanzialmente quanto sono grandi gli interi che rappresentano le coordinate dei punti no? perché le coordinate le coordinate di tutti i punti le coordinate x y dei punti della curva ellittica che fanno parte del gruppo no? sono in V P ok? quindi sono numeri piuttosto grandi ok? Q invece è parametrico quanti più punti prendere è un valore che dipende da P un po' più piccolo ma dipende da P con questa funzione e questi parametri è stato definito appunto uno standard che si chiama P256 che è uno standard proposto già da anni dal list ed è implementato ad esempio dentro TLS ok? va bene oggi possiamo anche finirla qui visto che dovremmo cominciare una roba nuova e siamo già arrivati a un buon punto poi poi continueremo con il discorso della CCA security che quello ancora non abbiamo fatto e con quello chiuderemo il discorso relativo alla cifratura chiave pubblica così potremo passare ad argomenti un pochino più complessi come le firme digitali e i protocolli di autenticazione mentre invece per quanto riguarda la parte pratica non teorica il prossimo argomento di cui volevo parlare è il funzionamento dei meccanismi criptografici che è stata la base delle blockchain e vi farò l'esempio della blockchain di bitcoin ok? quindi come funziona la criptografia dentro dentro dentro le blockchain ok? va bene ci vediamo quindi ci vediamo giovedì prossimo