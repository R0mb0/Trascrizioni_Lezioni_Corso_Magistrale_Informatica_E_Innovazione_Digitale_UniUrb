Eccoci qua. Allora, come vi ho anticipato oggi, voglio farvi fare un piccolo esperimento per cercare di realizzare un buffer overflow attack. Quindi vediamo se riusciamo ad hackerare il mio laptop. Però prima di mostrarvi l'esempio dobbiamo un po' contestualizzare ciò che faremo. In particolare dobbiamo rivedere un attimo come funziona la gestione della memoria per capire poi come agire sulla memoria e indurre un overflow. Qualche resta di fa vi avevo dato un paio di indicazioni di massima su come funziona il buffer overflow attack. Oggi entriamo nel dettaglio e per far questo perdiamo dieci minuti per cercare di capire un po' come funziona in C, visto che poi il buffer overflow attack lo implementeremo su una vulnerabilità di un programma in C che gira su questo laptop. E quindi andiamo a vedere come funziona la gestione della memoria per il C, ma tutto sommato le cose cambiano poco rispetto ad altri linguaggi imperativi. Allora, voi sapete, se non lo sapete lo vediamo adesso, che quando viene caricato dal sistema operativo in memoria un programma per l'esecuzione, viene riservata un'area di memoria per il programma e per le variabili di programma. Queste sono suddivise in diverse aree di questa memoria organizzata come una pila, uno stack e qui vedete quali sono le principali aree di memoria allocate per l'esecuzione del programma. Vedete che gli indirizzi di memoria in genere crescono dal basso verso l'alto, in questa figura, poi lo vedremo più nel dettaglio. Nella parte bassa della memoria vedete tre sezioni che sono quei tre segmenti, il text, data e il bss, che contengono le informazioni che vedete qua. Quindi in particolare il text segment contiene il programma da eseguire, ok? Codice eseguibile. Il data segment contiene le variabili statiche e globali che sono state inizializzate dal programma. Il segmento bss contiene le variabili globali e statiche che non sono state inizializzate dal programma, che magari assumono valori in corso d'opera. Ok? E poi, e queste ci interessano poco per il nostro esercizio, e poi abbiamo l'IP e lo stack, che sono due zone di memoria che crescono in base a quelle che sono le esigenze del programma. In particolare l'IP contiene la memoria che viene allocata ed è allocata dinamicamente all'interno del programma. L'IP, per fare un esempio, se usate la malloc o la calloc o qualunque altra funzione utile per l'allocazione di spazio di memoria, questo spazio di memoria viene riservato nel LIP. Ok? Invece tutte le variabili locali del programma, gli argomenti delle funzioni, l'indirizzo di ritorno, che poi vedremo che cos'è, tutti gli altri valori finiscono invece nello stack. Ed è lì che noi agiremo. Gli attacchi basati sul buffer overflow si possono fare generalmente sia sull'IP che sullo stack. Si può scegliere, sono tecniche un po' diverse, perché chiaramente diverse sono le tipologie di informazioni che trovate lì dentro. Noi faremo un esempio di buffer overflow sullo stack, quindi ci concentreremo sullo stack. Vedete, lo stack cresce dagli indirizzi alti verso gli indirizzi bassi. Cresce in questa direzione andando verso il basso. Facciamo un paio di esempietti, così capiamo bene come funzionano le cose. In questo piccolo programma scritto in C vedete tutte le varie informazioni dove si trovano nella memoria, così come strutturata nella slide che abbiamo visto prima. Ad esempio, X è una variabile globale inizializzata, quindi la trovate nel data segment. A e B sono variabili locali alla funzione main e quindi le trovate nello stack. Y è una variabile statica non inizializzata, la trovate nel segmento BSS e così via. PTR è una variabile locale, in particolare ha un puntatore, quindi è nello stack. Però l'area di memoria puntata da PTR, che è quella riservata con la malloc, che è un vettore di due interi, è lo spazio per un vettore di due interi, il fatto, non lo trovate nello stack ma lo trovate nel LIP, perché è memoria riservata tramite la malloc. Quindi i due valori 5 e 6 non li trovate nello stack, li trovate nel LIP. Mentre invece lo spazio per il puntatore PTR sta nello stack, insieme alle variabili A e B. Quindi quando invocate poi la free per liberare lo spazio riservato con la malloc, state lavorando sul LIP, non state lavorando sullo stack. Questo per fare un po' di distinzione. Noi non faremo esempi con variabili statiche o globali, perché ci vogliamo concentrare sullo stack, quindi lavoreremo su variabili locali, argomenti, quindi valori di ritorno e cose di questo genere. Ora, come vedremo... Vediamo se... Ah, se mi mostro un altro esempio, così lo vediamo un po' per volta. Questo è un altro esempio di una funzione che può essere dentro un programma, che si chiama func, che ha due argomenti, A e B, che diventano di fatto due variabili locali, quindi A e B le troviamo nello stack, e viene riservato spazio nello stack nel momento in cui viene invocata la funzione, perché sono argomenti alla funzione. Poi ci sono due variabili locali, anche questi nello stack, X e Y. Ok? Ora, quando viene invocata una funzione, cosa succede? Che nell'area di memoria organizzata come una pila, nello stack, viene riservato quello che prende il nome di frame. È una zona dello stack riservata alla funzione. I frame si possono sovrapporre nello stack seguendo la politica di accesso LIFO, perché se voi siete in una funzione per cui il suo frame è attivo nello stack e quella funzione ne chiama un'altra, nel momento in cui la chiamate, nello stack viene allocato, sopra quello presente attualmente, un altro frame per la funzione che è stata appena invocata. Quando la funzione che è stata invocata cessa la sua esecuzione, il suo frame sparisce, è nello stack che riemerge. Il frame della funzione chiamante. E questo è il motivo per cui lo stack è organizzato come una pila. Proprio perché i frame delle varie funzioni si sovrappongono in questa pila, man mano che le funzioni vengono chiamate e sono ancora attive, quando una funzione non è più attiva, e se ti uscire il controllo al chiamante, il suo frame sparisce. Sono andato troppo rapido? Chiaro? Un po' il discorso. Qui vedete la fotografia dello stack. Quindi adesso astraiamo da questa intera struttura, ci concentriamo sullo stack e sui frame che sono presenti sullo stack. Come vi ho detto prima, gli indirizzi crescono dal basso verso l'alto, ma lo stack cresce dall'alto verso il basso. L'abbiamo visto qua in questa freccia. E qui vedete il contenuto dello stack quando viene chiamata la funzione func. Vedete, ha due argomenti e quindi lo spazio per i due argomenti viene riservato subito, A e B. Poi c'è uno spazio per il return address, l'indirizzo di ritorno. A cosa serve l'indirizzo di ritorno? Per seguire il flusso di esecuzione. Ora, siccome func... Qui perdiamo il flusso di esecuzione sequenziale del programma, perché abbiamo chiamato una funzione. Quando la funzione cessa la sua esecuzione, bisogna restituire il controllo all'istruzione immediatamente successiva alla chiamata alla funzione func. Ok? Quindi, e dove sta questa istruzione? Ci serve l'indirizzo di questa funzione. Quindi nel return address c'è l'indirizzo di memoria dove si trova l'istruzione che andrà eseguita subito dopo aver finito di eseguire func. Ok? Cioè ci permette di restituire il controllo al chiamante. Ok? È chiaro? Perché finché il programma è sequenziale, voi seguite l'istruzione una volta e non avete bisogno di riferimenti. Ma se nel programma ci sono dei salti perché c'è una chiamata funzione, voi invocate una funzione, per la funzione termine la sua esecuzione deve restituire il controllo, a quale istruzione viene restituito il controllo? Che salto si fa? Dove si salta nel programma? Quindi nel return address c'è l'indirizzo della prima istruzione da eseguire dopo la terminazione della funzione. Ok? Poi vedete, saltiamo per un attimo il frame pointer che lo commentiamo tra poco, poi vedete che ci sono le variabili locali, nel nostro caso x e y. Ora, la cosa non finisce qui, vedete che c'è anche qualcos'altro, ci sono altre informazioni importanti, in particolare c'è il previous frame pointer e il current frame pointer. A cosa sono dei puntatori? A cosa servono? Allora, il C, come tanti altri linguaggi, è un linguaggio di programmazione compilato. Ok? Quindi l'eseguibile viene compilato staticamente. E quando compilate il codice staticamente, voi ancora non lo sapete a runtime quale sarà l'indirizzo all'interno dello stack delle varie variabili. Quello dipende dal flusso di esecuzione. Ad esempio, in particolare dipende quando viene invocata la funzione. No? Quindi ci sono delle informazioni che dipendono dal flusso di esecuzione e che non sono conoscibili a priori a compilation time. Ok? Per questo motivo, noi non potendo sapere a priori quale sarà l'indirizzo di ogni variabile locale, come si risolve questo problemino? Beh, molto semplicemente, l'indirizzo delle variabili locali vengono, diciamo, accedute partendo da quello che è un indirizzo base di riferimento e a partire da quello si calcola un offset. Ok? Ad esempio, la variabile y non si trova nell'indirizzo fisico preciso che avrà runtime. Perché? Perché non lo so quando compilo il programma quale sarà questo indirizzo. Però posso dire che la variabile y si trova ad un certo offset, ad una certa distanza, che ne so, a 12 byte di distanza, rispetto a un indirizzo base. Questo indirizzo base è il frame pointer. No? Quindi l'indirizzo base è l'indirizzo a partire dal quale io provo tutte le variabili locali della mia funzione. Quindi l'indirizzo di ogni funzione, di ogni variabile, lo posso calcolare come frame pointer più offset. L'offset è fisso. Lo conosco già a compilation time. Basta sapere quanto sono lunghe tutte le variabili locali. Quindi l'offset di x è 0, l'offset di y sarà 4 byte più avanti se x è un intero, di un certo tipo, e così via. Quindi l'offset lo posso calcolare a compilation time. Il frame pointer rimane non istanziato, lo si decide a runtime. A runtime, se devo accedere alla variabile y, mi basta dire prendi il frame pointer e aggiungi l'offset. Ok? Questo è il ruolo del frame pointer. No? È chiaro? Quindi ogni frame associato alle funzioni attive ha il suo frame pointer. Vedete che oltre al frame pointer c'è anche un previous frame pointer, che è il frame pointer del frame del chiamante, della funzione chiamante. Ok? Il motivo è lo stesso che abbiamo detto prima. Quando, immaginiamo che la funzione funk sia stata invocata dal main, quindi nello stack qua sopra, sopra il frame di funk c'è il frame di main. No? Quando la funzione funk termina la sua esecuzione, il suo frame sparisce, dobbiamo recuperare il frame della funzione main. Ok? Ma nel recuperare il frame della funzione main dobbiamo sapere chi è il suo frame pointer, perché l'accesso a tutte le variabili del main passano per il frame pointer. Solo che nel momento in cui io ho attivato il frame di funk io non c'ho più il frame pointer del main. Ed è il motivo per cui me lo salvo nel frame del del del del del del del frame del frame di funk. Così che quando funk termina la sua esecuzione, io leggo il previous frame pointer perché così butto via il frame di funk e leggendo il previous frame pointer so qual è la base del del frame che emerge, che sarà il frame del main. Ok? Mentre invece il return address mi dice quale istruzione andare a pescare dal text segment dove c'è il codice eseguibile. Ok? No, quindi termina l'esecuzione della funzione, il return address mi dice qual è la prossima istruzione da eseguire. Il previous frame pointer mi dice qual è il frame pointer del frame che torna ad essere attivo al top dello stack. stack perché al top dello stack c'è il frame della funzione attualmente in esecuzione. Sotto ci sono i frame di tutte le funzioni sospese. Ok? E questo è il modo in cui viene gestita un po' l'organizzazione della memoria in programmi come il C. Quindi noi lavoreremo nel nostro esempio su tre registri importanti. uno è il registro dove è presente il return address l'altro è il registro dove è presente il previous frame pointer e l'altro ancora sarà o no scusate sì quello o il current frame pointer a seconda dei casi quando ci serve e basta direi questo questi sono i registri le informazioni che ci servono per impostare il nostro attacco basato sul buffer overflow quindi ricordiamoci questa struttura qui poi adesso questa slide la lascio qui così quando cominciamo anzi no devo fare la collivisione qua vabbè comunque ricordiamoci la peschiamo se ci serve ok? Quindi ricordiamoci questa questa struttura qua ok? Ora ripassiamo un po' in cosa consiste l'overflow prima di andarlo a vedere in esercizio l'overflow si verifica quando voi copiate in memoria più dati rispetto alla quantità di memoria che è riservata per quei dati no? e abbiamo visto che linguaggi come il C++ hanno un sacco di funzioni che non sono diciamo programmate per verificare i casi di overflow e questo anche negli ambienti di esercizio è più o meno vero vedremo con delle eccezioni quindi si possono verificare dei segmentation for dovuti a questi accessi di memoria sbagliati e vi farò vedere un esempio tra poco vi faccio vedere un altro esempio perché questa è una cosa che ci dovremmo ricordare più avanti di come avviene la copia dei dati da memoria in memoria questo per esempio estremamente banale dove avete un vettore di 40 caratteri ok inizializzato in questa maniera qua abbiamo un altro vettore di 40 caratteri se io chiamo la funzione ad esempio string copy ma tutte le funzioni di manipolazione delle string le funzioni conoscete la semantica della string copy prende il secondo argomento e lo copia nel primo quindi prende la sorgente e lo copia nella destinazione ora se voi compilate eseguite questo programma il risultato sarà che nel vettore best non ci sarà l'intera stringa hello world extra string barra 0 extra string perché perché questo barra 0 ha il carattere speciale rappresenta la sequenza speciale di fine stringa ok quindi ciò che viene copiato nella destinazione è solo la stringa hello world no? quindi se nella sequenza che voi andate a copiare trovate lo 0 quello viene interpretato come fine stringa e lì si ferma la copia ok quindi ricordiamocelo questo perché dovremmo tenerne conto a un certo punto quando faremo il nostro il nostro attacco ora questo è un esempio non è ancora quello che userò userò io che vi mostra quando è che può verificarsi un overflow no? qui abbiamo due funzioni la main e la foo quindi quando viene lanciata l'esecuzione del programma prima cosa nello stack viene creato il frame della funzione main no? qui non c'è c'è solo scritto main stack frame e lì ci saranno ci sarà lo spazio per str che è il puntatore a carattere e basta non ci sarà nient'altro ok ci sarà il suo frame pointer e basta ok cosa fa il main invoca la funzione foo nel momento a runtime quando viene chiamata la funzione foo nello stack sopra il stack frame del main viene creato lo stack frame di foo lo stack cresce verso il basso quindi ve lo trovate qua in basso nello stack frame di foo che cosa trovate? l'abbiamo visto prima trovate eventuali argomenti ok che è str no? quindi trovate l'argomento puntatore str trovate il return address che è l'indirizzo di memoria dell'istruzione successiva alla foo che sarà questo return 1 del main ok? poi trovate il previous frame pointer che è il frame pointer nello stack relativo alla funzione main qua sopra a qualche parte e poi trovate che cosa? le variabili locali della funzione della funzione foo ce n'è una sola che è un vettore a 12 caratteri e quindi vedete qua ho messo le 12 celle del nostro del nostro vettore questo è il contenuto del frame della funzione foo ok? ci siamo? ritorna come situazione? perfetto ora che cosa succede se io vado a eseguire quando io vado a eseguire la funzione string copy dentro la foo no? la funzione string copy mi prende l'argomento che ha ricevuto che è la stringa puntata da str e la copia dentro un buffer il buffer ha 12 posizioni la stringa non si sa è stata fornita dal main in questo caso è più lunga di 12 ok? quindi che cosa succede? succede che a partire dalla cella dove c'è il buffer di 0 la string copy comincia a copiare ok? riempie riempie sicuramente le prime 12 celle e poi va avanti non è che si ferma ok? quindi va a sovrascrivere in particolare a seconda di quanto è lunga la stringa puntata da str va a sovrascrivere un'area di memoria che va dal previous frame pointer in su ok? ad esempio se la stringa che voi avete dato in pasto alla fu contiene tre caratteri in più finisce che voi andate a sovrascrivere il previous frame pointer il return address e il pointer il valore stesso del puntatore ok? quindi andate a sovrascrivere un'area di memoria che non dovreste sovrascrivere no? dopodiché dentro la funzione fu possono succedere altre cose ok? ancora ancora non c'è un segmentation fault no? ad esempio non so se vi ricordate ad esempio che avevo fatto vedere si era il buffer error flow e c'era una printf la printf veniva eseguita quindi prima del segmentation fault voi a video lo vedevate il risultato della printf qui la stessa cosa se dopo la string copy mettete una printf di buffer la stringa this is definitely longer than 12 viene visualizzata perché la printf va a leggere da buffer di 0 in su e finché trova la roba da leggere la la la la la spalla ok? quindi il problema è quando viene restituito il controllo al main quando viene restituito il controllo al main il frame lo stack frame di fu dovrebbe sparire ok? poi accedendo al previous frame pointer dovrei recuperare il frame pointer del main e soprattutto accedendo al return address io dovrei andare a recuperare la prossima istruzione da eseguire solo che adesso dentro il return address c'è della sporcizia cioè no? è garbage il contenuto del return address ed è lì che si verifica il segmentation può verificarsi il segmentation form perché il sistema va a leggere un valore dentro il registro del return address che magari non è un indirizzo valido e se non è un indirizzo valido va in errore tipicamente qui possono succedere diverse cose che sono elencate qui a seconda del valore presente nel return address no? nel momento in cui devo restituire il controllo al main possono capitare queste cose il nuovo valore che leggo nel return address non è un indirizzo fisico di memoria ok? è qualcosa di spurio di sporco quindi il salto di istruzione fallisce e quindi è un segmentation form ok? problemi non ne ho l'altra cosa che può capitare è che il nuovo valore è mappato ad un indirizzo fisico di memoria ma quell'indirizzo fisico di memoria è protetto non è accessibile ci sono dei vincoli ad esempio uno spazio riservato del sistema operativo non ha il permesso di andare a saltare in quel punto quindi di nuovo fallimento del return del del del del segmentation form ok? terzo caso il nuovo valore che trova nel return address è un indirizzo di memoria accessibile ok? quindi riesco a fare il salto però lì dentro non c'è un'istruzione c'è qualcosa quindi di nuovo altro segmentation form quindi i primi tre casi si riduce tutto al segmentation form il quarto caso che è quello che ci interessa a noi è quello in cui il nuovo valore presente nel return address è un indirizzo di memoria salto a quella indirizzo di memoria cosa trovo lì dentro un'istruzione e quindi che cosa fa il sistema esegue quell'istruzione ok? quindi se io sono capace di provocare un overflow ma non solo capire nel fare l'overflow dov'è il punto dove io devo andare a sovrascrivere il return address perché io non lo so ok? e lì metterci l'indirizzo vaido di un'area di memoria dove io ho messo un codice iniettato vaido ma magari malevolo ecco che io riesco a comportare l'attacco questa è l'idea ok? questo è l'esempio che useremo che è di fatto molto simile a questo ho il main che invoca la funzione vulnerable ok? la funzione vulnerable ha un buffer di 400 caratteri e adesso lasciate perdere le prime due righe qua che due o tre righe le ho messe semplicemente per fare la printf di uno dei registri dello stack uno dei tre registri che ci interessano così come come come come come come come come come come come come la cosa interessante è la read la read è una funzione di libreria standard del del c e cosa fa la read lo sapete cosa fa la read legge da qualche parte e copia in in un buffer in questo caso il secondo argomento è dove andiamo a copiare ok la read come primo argomento vorrebbe l'identificatore di un file da cui leggere ciò che va copiato 0 significa standard input quindi legge da tastiera quello che noi andiamo a scrivere fino a un massimo di 800 caratteri e ricopia dentro il buffer un po' come analogamente la string copy la read è vulnerabile al buffer dopo di che stampiamo il contenuto del buffer e restituiamo il controllo al main ok quindi questo è un programma vulnerabile no perché soffre di può soffrire di buffer se noi da tastiera scriviamo qualcosa che è più lungo di 400 caratteri ok l'obiettivo adesso è provare a vedere come sfruttare questa vulnerabilità per iniettare un codice malevolo da fare eseguire al sistema quando si accende l'overflow questa un po' è l'idea è tutto chiaro ok benissimo e poi questo materiale ancora non l'ho caricato su blended glielo metto oggi se ci riesco in giornata a puntare domani quindi troverete tutto sia queste slide che tutti i file che io ho usato per fare i test ok prima di fare i test apriamo una parentesi allora io ho usato un'architettura a 64 bit ok questo è importante perché ha un impatto sul come si presenta lo stack su quali sono i registri e quindi chiaramente tutto questo ha lo stesso attacco sulla macchina a 32 bit non funzionerebbe bisognerebbe cambiare un po' di un po' di parametri ok quindi su questo questo è un primo punto importante secondo punto importante per fare questo tipo di esperimento io ho usato questo laptop che ha una Ubuntu sopra potete usare se volete replicare queste cose io sconcino sempre una macchina virtuale ma una macchina Linux qualunque anche la Kali potete usare la cosa importante è che bisogna disabilitare alcuni alcuni parametri della configurazione dell'ambiente di esecuzione perché ad esempio ci sono dei meccanismi che sono implementati apposta per evitare questo tipo di attacchi ok allora per fare un attacco semplice ho disabilitato alcuni di questi meccanismi ci sono attacchi più sofisticati che riescono a bypassare anche alcuni alcuni meccanismi uno di questi meccanismi siccome il mio uno dei nostri obiettivi è quello di capire dov'è il return address all'interno dello stack per sapere in quale registro andare a mettere in quale indirizzo di memoria andare a mettere un particolare valore che mi fa saltare al malware se l'ambiente di esecuzione fosse deterministico a ogni esecuzione la situazione della memoria sarebbe sempre la stessa e quindi sarebbe più facile prevedere dove si trovano certe cose ok se a ogni esecuzione le cose cambiano in maniera randomica quindi ci sono degli elementi random nel processo di allocazione della memoria dello stack ad esempio si introducono delle celle vuote o comunque che servono a fare rumore ecco che diventa più difficile riuscire a prevedere dove andare a iniettare il codice uno di questi meccanismi si basa appunto sulla randomicità ed è l'address space layout randomization già il nome suggerisce quello che succede cioè è una componente che vada a introdurre degli elementi randomici nelle operazioni di allocazione della memoria e quindi rendere tutto più imprevedibile questo va disabilitato ok adesso vi faccio vedere qual è la differenza tra averlo attivo e averlo disabilitato e ve la faccio vedere semplicemente sul valore di questo indirizzo che qui stampo del motivo per cui glielo ho messo proprio per farvi vedere cosa succede agli indirizzi di memoria quando c'è questa funzione abilitato oppure no poi per rendere più interessante l'attacco quando ho compilato il sorgente questo vun.c che è questo programma ok l'ho ceduto come proprietà all'utente root quindi potrebbe essere un qualunque programma di sistema operativo per fare un esempio che contiene quella vulnerabilità no ed è non solo un programma di root ma è un programma set u.id cosa vuol dire vuol dire che anche se lo esegue un utente che non ha i diritti di root né né eredita i diritti nell'eseguire le funzioni del programma come capita spesso con le funzioni di sistema sono invocate una funzione di sistema magari invocata da un programma client di un utente normale però non vuol dire che quella funzione di sistema abbia i diritti di chi di chi l'ha invocata di chi l'ha fatta attivare ha i diritti di root perché deve fare certa operazione a livello di sistema operativo quindi anche se viene invocata da qualcuno che non ha quei diritti fa le cose previste dall'utente dall'utente root quindi a tutti gli effetti ho impostato i permessi del nostro programma come se fosse a tutti gli effetti un programma di sistema ok vulnerabile che un attaccante cerca di compromettere di sfruttare attraverso un buffer overflow per fargli fare qualcosa che noi non potremmo fare questa è l'idea ok nel compilare il sorgente ho dovuto mettere dei parametri che disabilitano ulteriori meccanismi di protezione dello stack quindi per far sì che l'attacco sia il più semplice possibile e già così è abbastanza complesso se no ci staremo qui tre giorni per vedere la procedura completa degli attacchi quindi rendiamo il setting il più semplice possibile disabilitando tutti i meccanismi che i sistemi di solito usano per evitare il buffer overflow e che comunque non sono sufficienti di per sé in molti casi va bene domande è tutto chiaro questo è il contesto il programma è questo qua quando serve lo andiamo a ripescare adesso condivido da qua sperando che tutto funzioni bene allora dobbiamo condividere eccolo qua qui dentro c'è il programma che abbiamo appena commentato che è questo vedete lui l'ho già compilato con i parametri che vi ho fatto vedere nella slide e adesso l'idea è cominciare a provocare qualche overflow e vedere come provare a sfruttarlo ok e il primo test che facciamo lo facciamo su questo input ok sono 450 io ho generato come si chiama l'ho generato così con quelle due righe ho usato python per generare quel print a per 450 mi ha generato quel file che è 450 450 supera il buffer da 400 ok quindi adesso quello che possiamo fare banalmente è invocare il nostro programmino passandogli il nostro il nostro input si vede laggiù quindi welcome poi ho stampato un registro la rsp è lo stack pointer ok cioè il top dello stack del frame ok enter some text gli ho dato input 1 usad lui mi fa vedere che cosa ho inserito vedete la printf ha successo poi però quando la funzione vulnerable restituisce il controllo al main c'è il segmentation fault ok se lo eseguo un'altra volta qual è la differenza è cambiato il top dello stack il programma è sempre lo stesso però la locazione in memoria è cambiata e il motivo è quello che vi dicevo prima è attivo quel meccanismo di protezione della memoria che introduce una randomizzazione tale da rendere più difficile per vedere dove saranno gli elementi dei vari frame all'interno del mondo dobbiamo disabilitarlo quel quel meccanismo quindi in reality io io io io io io il modso che stichetere da tax ok ok ho disabilitato ho disabilitato infatti adesso proviamo lanciarlo due o tre volte vedete cosa succede è sempre lo stesso il comportamento del gestore della memoria adesso è deterministico così le cose sono un po' più semplici ok abbiamo fatto il primo test andiamo a vedere lo stack avete mai usato un debugger per fare testing di programmi in C cosa avete usato? vabbè io userò GDB GDB è un debugger quindi lanciamo GDB ok proviamo a lanciare a vedere che cosa succede no esattamente quello che abbiamo visto prima quindi abbiamo il nostro segmentation fault vi faccio vedere i registri che ci interessano ecco qui ci sono tutti i registri della memoria a noi ne interessano tre ci interessano il frame pointer che è la base dello stack ok che sta in alto perché lo stack cresce verso il basso e il frame pointer è il registro RBP BP base pointer ok RSP stack pointer register of stack pointer è il top dello stack ok quindi dove inizia e dove finisce lo stack del frame e l'altro che ci interessa è il RIP l'instruction pointer è il valore del return address questi sono i tre registri che ci interessano ok andiamo a mettere a rieseguire il codice mettiamo un break point per fermarci subito prima dell'overflow vedere qual è lo stato del registro questo è il programma con indirizzo di memoria delle istruzioni assembly questo è il programma già già prodotto in assembly ok a sinistra vedete gli indirizzi a noi ci interessa sapere vogliamo andare a vedere qual è il contenuto dello stack prima di fare quella read che provoca l'overflow la read è qua vedete dove c'è questa call q quella è la read e siamo quindi a 60 come valore di indirizzi in più rispetto al punto iniziale del programma ok mettiamo un break point lì subito prima di fare la read quindi break asterisco ok abbiamo messo un break point subito prima della read a questo punto eseguiamo di nuovo il nostro programma dall'inizio ok e lui si ferma prima della read no si ferma prima della read a questo punto noi gli possiamo chiedere che valore c'è dentro i vari registri quello dell'RSP è lui ed è esattamente quello che avevo messo nella printf dentro del programma no quello che finisce con dc0 ok posso chiedere quanto vale l'RBP è quello che finisce con df60 rsp il top dello stack rbp invece è la base dello stack è tutta la rovescia perché lo stack cresce verso il basso vogliamo vedere il contenuto dello stack compreso tra i due registri bene andiamo a calcolarcelo sono più o meno da dc0 a df60 sono 120 diversi indirizzi quindi se sapete fare i conti in esadecimale e quindi andiamo a vedere a partire dal dal top dello stack andiamo a vedere tutti gli indirizzi no quindi questo è il top dello stack ok questi sono tutti sono 120 indirizzi fino ad arrivare all'rbp che è il nostro base pointer si procede alla rovescia ok vi ricordate quanto valeva l'rbp aspetta un po' l'rbp era il df60 che è questo ok è questo qui ora vi ricordate la struttura il cosa c'è il base pointer in corrispondenza del base quindi dove c'è il ve lo faccio vedere nelle sbagli vediamo un po' ah no devo far condividere a lui diciamo così cambiamo la condivisione vediamo qua qua qua qua ok l'rbp punta al current frame pointer no sopra di lui c'è il previous frame pointer e poi il famoso return address che è quello che dovremmo manipolare ok previous frame pointer su 64 bit perché è un'architettura a 64 bit return address dopo altri 64 bit dall'rbp ok torniamo alla alla alla nostra memoria l'rbp è quello che ho messo in evidenza ok ognuna di quelle stringhe è un valore a 32 bit perché sono 8 valori decimali quindi sono valori a 32 bit quindi questi sono 64 bit e sono quelli del previous frame pointer i successivi 64 sono il return address quindi il return address è questo abbiamo individuato il return address questo ci servirà per capire dove intervenire per manipolarlo ok quello è il nostro return address vediamo come si casina tutto quanto nel momento in cui facciamo la lettura quindi abbiamo messo il backpoint prima della lettura facciamo fare la lettura quindi eseguiamo l'istruzione next esegui la prossima istruzione che è la lettura ok adesso è stata fatta la scrittura che ha provocato l'overflow perché le as sono tante riguardiamo lo stato della memoria e vedete com'è cambiato dal dall'rsp da su in alto quel dc0 come indirizzo fino al df60 che che è l'rbp fino ad arrivare al return address che non è più quello di prima è stato sporcato ok prima era sta roba qua adesso è sta roba qua sapete che cos'è quella roba lì li vedete quegli indirizzi che sono tutti uguali cos'è 41 le a 41 è la codifica ASC della quindi in pratica abbiamo riempito lo stack di a compreso il return address e da qui il motivo del segmentation fault perché a a a 4a non è un indirizzo di memoria legale e quindi questo è quello che succede infatti facciamo continua e abbiamo il nostro segmentation fault quindi abbiamo capito come è organizzato lo stack dove si trova il return address ok bene facciamo un esperimento un pochino più sofisticato perché perché perché dobbiamo abbiamo capito in memoria dove è il return address no ma nella string in input le 2a del return address qua in mezzo dove sono dobbiamo individuarle no per capire dove andare a intervenire è chiaro in mezzo a queste 450a dove andiamo a pescare non lo sappiamo quindi come facciamo per per per scovare il punto esatto dell'input dove si trovano le a giuste beh cambiamo l'input diversifichiamolo l'input ok e lo diversifichiamo in questa maniera non lo diversifico tutto perché mi basta farlo in prossimità dell'overflow quindi dopo adesso ci guardiamo perché non mi ricordo questo questo è la è il python che ho usato per generare la stringa che è questa qui vedete i i primi 350 caratteri cioè prima dell'overflow sono ancora delle a e sono infatti sono delle a dal 350 al 450 vedete che sono tutti numeri diversi ok come li ho generati ho usato questa formuletta molto banale la funzione str è una funzioncina che prende un intero e lo converte in una stringa quindi l'intero 5 lo fa diventare la stringa 5 perché dobbiamo lavorare con le stringhe ok e questo doppio ciclo for non fa altro che prendere interi da 0 a 5 da 0 a 10 combinarli e trasformarli in stringhe il risultato vedete dal 351 in avanti è una stringa che sembra più o meno pseudo casuale questo ci permetterà di individuare lì dentro il punto preciso dove si trova il carattere che finisce o la sequenza di caratteri perché saranno 4 caratteri 4 più 4 che finiscono nei 64 bit del return address ok chiaro lo scopo quindi di nuovo eseguiamo il nostro debugger intanto andiamo a vedere che cosa succede con questo nuovo input ok benissimo vedete l'overflow provoca segmentation fault e andiamo a vedere nella zona che ci interessa mi sono segnato quale era il valore era lui spero di aver azzeccato il numero delle F vedete no quindi al solito RSP top dello stack in giù fino all'RDP vedete che per un po' ci sono le A ok adesso vi ricordate qual era il valore dell'RDP era questo quindi gli otto caratteri del return address sono questi due valori esadecimali ok adesso noi questi valori esadecimali li dobbiamo convertire in in ASI per riconoscere la stringa che gli abbiamo dato in input ok quindi voi dovete andare a prendervi la tabella di conversione da da da ASI in questo caso no alla nostra e allora c'è da fare una considerazione intanto non dovete leggerli allora ogni coppia di caratteri sono un chart cioè ogni coppia quindi abbiamo 38 33 37 33 e sono i 4 i 4 caratteri i del qua 30 34 39 33 però questa questa sequenza di 4 valori non dovete leggere da sinistra verso destra ma da destra verso sinistra perché c'è una codifica di conversione ASI decimale che ne cambia ne inverte la posizione quindi i caratteri sono in realtà 33 37 33 38 il primo e il terzo il primo e il terzo sono uguali no andate a vedere se se cercate la tabella di conversione il 33 è il 3 il 37 è il 7 quindi 3 7 3 il 38 è l'8 ok quindi il valore è 3 7 3 8 poi capite il trick perché il primo numero è sempre lo stesso il secondo corrisponde al valore perché 33 è il 3 37 è il 7 33 il 3 38 è l'8 e quindi anche per gli altri qui sarà uguale quindi sappiamo già che il numero quale sarà la stringa 3 esatto 3 9 4 0 quindi ricordatevi 37 38 39 4 0 questa è la sequenza dell'input corrispondente a quei due indirizzi di memoria ok e a questo punto andiamo a vedere me lo segno 37 38 39 4 0 ok adesso qui usciamo non ci interessa più andiamo a vedere la sequenza e lì dentro dobbiamo trovare la sequenza 37 38 39 40 che è qua lì è dove dobbiamo iniettare l'indirizzo che vogliamo noi ok quindi dobbiamo confezionare un input dove lì c'è quello che vogliamo noi adesso contiamo sono sono me ne sono segnati sono 74 caratteri prima di arrivare a quella sequenza quindi 350 più 74 prima di arrivare a quella sequenza che ci interessa e questo ci porta a costruire un'altra sequenza che è quella che vi faccio vedere adesso che l'ho chiamata forse questa sì questa qui esatto dove che cosa ho fatto allora intanto vediamo com'è composta è composta di quattro parti vedete è la concatenazione di quattro stringhe i nostri 450 caratteri ok i primi 100 sono questo carattere qui barra x 90 cos'è barra x 90 barra x 90 è la codifica dell'istruzione skip ok quindi se per caso durante l'esecuzione finiamo lì dentro non succede un segmentation fault ma si fa lo skip si passa a quella successiva ok quindi per 100 caratteri ho messo skip in gergo si chiama no ok no operation per 200 caratteri ho messo la codifica barra x c c che è una codifica di debugging che fa interrompere il programma senza errore quindi una sorta di placeholder che sta in mezzo che non fa nulla poi cosa ho messo ho messo per adesso ho messo delle x come padding per arrivare a 424 perché perché nell'input di prima visto che c'erano 350a più 74 per arrivare alla sequenza che ci interessa quindi erano 424 caratteri ok quindi io devo riempire 424 caratteri prima di mettere l'indirizzo che mi interessa no e quei 424 li ho riempiti così con 100 skip 200 cc e la differenza che è questa con delle x per adesso poi vedremo di metterci qualcos'altro no in questa maniera io arrivo no dove inizia dove iniziano i caratteri che finiscono nel return address no e adesso per esercizio ci ho messo semplicemente la sequenza abcdfg h ok quindi se tutto va bene io la sequenza abcdfgh me la ritroverò in esa decimale dove nel return address prima ci saranno in op i cc e poi le x ok infatti vedete che l'ho composto in questa maniera l'ho concatenato questo dovrebbe essere il risultato ci sono gli skip ci sono i cc non sono visualizzabili a standard output per quello che ci vedete con la roba sporca poi però vedete le x e alla fine c'è abcdfgh allora l'obiettivo se tutto va bene è trovare la codifica di abcdfgh nel return address ok questa è l'idea andiamo a vedere quindi lanciamo di nuovo il nostro gdb mettiamo il break dove l'avevamo messo prima su un aspetto dove lo mettiamo no lo mettiamo più avanti perché voglio farvi vedere già l'effetto dell'overflow ma prima del segmentation fault lo mettiamo vedete la penultima è il return dalla funzione vulnerable quindi il ritorno al main quindi è il passo prima del segmentation fault ok quindi andiamo a vedere cosa c'è nello stack lì quando la copia è stata già fatta per quello che non lo metto a più 60 vuol dire cosa c'è dopo la copia ok quindi mettiamo lì il break più cos'è 98 ok e eseguiamo il nostro programma con questo nuovo input eccolo qua siamo arrivati al punto che ci interessa e di nuovo andiamo a vedere cosa c'è a partire dalla posizione dell'RSP che al solito è questa la sono segnata DD cos'era DD C0 vedete com'è bello lo stack come riflette quello che abbiamo inserito all'inizio ci sono 100 A no in O scusate in skip poi in 90 quelli sono gli skip poi c'è il blocco dei CC quelli che non fanno nulla poi ci sono le X 58 58 58 e vedete dov'è che terminano i 58 qui e lì vedete 41 è la A 42 B 43 C D è qua E F G e H quindi siamo riusciti a controllare il contenuto del return address mettendoci quello che ci pareva noi pilotando l'input in base a quello che il debugger ci forniva come come informazioni ok ora fin qui tutto bene adesso dobbiamo fare l'attacco no allora qui ci dobbiamo mettere un indirizzo no dove trovare poi il malware allora dove lo mettiamo il malware abbiamo tanta memoria a disposizione il malware lo mettiamo qua in mezzo ok quindi al posto delle CC che non fanno niente lì mettiamoci il malware però devo fare in modo che quando arrivo qua il return address devo tornare quassù ok allora siccome è difficile prevedere esattamente il punto preciso magari è complicato per i motivi che dicevamo prima identificare il punto esatto dove inizia il malware però possiamo sfruttare di skip se noi abbiamo un'area di stack abbastanza grande che noi abbiamo riempito con degli skip e facciamo reindirizzare lì in mezzo da qualche parte no il flusso di esecuzione quindi dal return address arrivati qua al DF 60 ci sarà un salto all'indietro che punterà lì in mezzo da qualche parte dove ci sono degli skip a quel punto che cosa succede eseguo gli skip finché non arrivo all'inizio del malware e quindi poi eseguo il malware ok questa è l'idea facciamo uno step alla volta prima proviamo a far fare un salto no perché qui ancora abbiamo segmentation fault perché ABCDFGH non è un indirizzo legale proviamo a fargli fare un salto all'indietro no puntando in uno qualunque degli indirizzi dove c'è il no ad esempio che ne so potrebbe essere questo ok quindi al posto di ABCDFGH mettiamoci quell'indirizzo lì ok questa è l'idea bene andiamo a vedere tanto qui possiamo anche fare continuo e c'è segmentation fault perché ABCDFGH non è non è un indirizzo valido usciamo e andiamo a modificare il nostro python ok al posto riprendiamo quello di prima che era questo e cambiamo il rip ok anche qui bisogna fare attenzione perché non potete leggerla da sinistra verso destra ma per il solito discorso di prima la conversione legge da destra verso sinistra e lì che cosa trovate nel rip al posto di ABCDFGH ho messo questo indirizzo qua quello lì evidenziato che quindi comincia con F0 DD FF FF così via no ed è questa roba questa roba qua vedete ok slash x è per denotare il valore speciale e quindi questo valore qui questa stringa qui corrisponde a come abbiamo detto questo indirizzo qua ok quindi l'idea è che rieseguendo il tutto noi qui non ci troveremo ci troveremo che cosa il valore di quell'indirizzo che stava sopra ok ritorna bene allora rilanciamo il nostro gdb e mettiamo il solito break che abbiamo messo anche prima perché ci vogliamo interrompere subito prima del ritorno al main ok andiamo di nuovo a vedere subito prima del ritorno al main qual è la situazione dello stack ho sbagliato qualcosa quindi un bozzницы riprodiamo riprodiamo riprosse maria ma questo io non dottor forse l'ho fatto garant NBA si chiama per qual è davvero 3000 o ok ma vedere cosa c'è adesso dello stack quindi come prima ci sono le ci sono gli skip c'è il blocco di cc che non fa nulla ci sono le x che non ci interessano e vedete che siamo riusciti guardate siamo riusciti a modificare indirizzo il return address che è diventato questo quassù no visto quindi adesso secondo voi se vado avanti con l'esecuzione che cosa succede no non è un loop perché siamo arrivati qui no quando quando restituisco il controllo al main c'è il salto che indica il return address che mi fa tornare sopra cosa c'è qui e adesso lui guarda se li trova un'istruzione l'indirizzo valido 0 x ff eccetera eccetera di f0 è un indirizzo valido c'è dentro l'istruzione si la eseguo cosa l'istruzione skip vado avanti skip skip skip skip skip skip arriva cc di quella istruzione di debacchi che fa fermare il programma e quindi il programma dovrebbe fermarsi senza segmentation fault questo è quello che dovrebbe succedere e infatti non c'è segmentation fault l'overflow c'è stato ma non c'è segmentation fault perché noi siamo riusciti a modificare il return address mettendoci dentro un indirizzo valido di un qualcosa che conteneva un'istruzione non un carattere ok e questo perché perché abbiamo modificato l'input in punti precisi mettendoci dentro dove necessario indirizzi piuttosto che istruzioni quindi siamo quasi pronti per confezionare il nostro nostro anno perché a questo punto per avere un malware cosa manca mancano le istruzioni del malware da e dove le metteremo le metteremo nel blocco dove adesso che abbiamo messo cc che non fa niente a rompere il programma e basta e quindi abbiamo la possibilità di iniettare qui dentro nel nostro input chiaramente non abbiamo tanto spazio a disposizione abbiamo qualche decino centinaia di byte non ne abbiamo tanti però qui dentro ci possiamo mettere il nostro malware e rieseguendo la cosa nello stesso modo cosa succede succede che quando arriva il ritorno al settore indietro faccio gli skip ed eseguo il malware che questa è l'idea come si fa a iniettare malware qua dentro e qui bisogna fare due due considerazioni bisogna fare la prima è che la prima cosa che si viene in mente va bene scriviamo noi un malware lo compiliamo e poi l'eseguibile lo iniettiamo dentro dentro l'input e diamo in posto la nostra la nostra funzione quindi invece di quella stringa di tornando al nostro al nostro python tornando al nostro python era da tornando al nostro python dentro buff invece di metterci quegli xcc dovremmo metterci il codice eseguibile del nostro magro ok questa è la cosa più semplice da fare che tipo di malware niente resta ne ho provati tre adesso siciliesco che li faccio vedere tutti ma una delle cose più immediate che si può pensare a fare mettere un malware in cui effetto è quello di aprire una shell un terminale con i permessi di root dopodiché una volta che un terminale aperto di sopra ci faccio tutto quello che voglio ok e quindi cosa faccio scrivo due righe di codice in c che aprono un terminale i permessi non li devo neanche impostare perché perché i permessi sono ereditati dal programma vulnerabile che è un programma di root e io mi basta scrivere in c due righe per aprire una finestra di shell del gioco e fatto non lo possiamo fare non lo possiamo fare perché per due motivi il primo è che stiamo ignorando il fatto che quando noi scriviamo un programma lo compiliamo poi la sua esecuzione dipende anche dal da ciò che il sistema fa per gestirlo in memoria ci sono tutta una serie di operazioni abbiamo visto il sistema per l'esecuzione di un programma alloca lo stack fa tutte queste cose qua quando noi compiliamo un programma visto prima l'inizio della lezione in realtà nell'eseguibile non si conosce quale si fa riferimento al frame pointer gli offset però tutte cose che poi non funzionano più se non c'è un loader un sistema operativo che lo carichi in memoria e qui qui tutta questa roba non c'è perché noi il programma anche se lo compiliamo non è che lo stiamo dando in pasto al sistema operativo a quello calcolo carica in memoria in un frame stack per farlo eseguire correttamente noi lo stiamo caricando noi direttamente in memoria al posto del sistema operativo quindi non lo stiamo creando un frame per il codice eseguito noi lo stiamo prendendo così com'è e lo buttiamo dentro lo stack di un altro frame ok quindi non funzionerebbe un programma compilato in questa maniera qui a meno che invece di dargli il programma compilato noi diamo direttamente il codice assembly se noi diamo codice assembly che lavora direttamente sui registri e lo copiamo brutalmente dentro l'input allora le cose funzionano ok perché vengono bypassate tutte quelle operazioni di inizializzazione che dovrebbe fare il loader del sistema operativo quindi prima cosa non ci possiamo non possiamo scrivere un programma in c poi compilarlo e buttarlo dentro l'input dobbiamo farlo direttamente in assolutamente ok questa è la prima considerazione l'altro motivo per farlo è che facendo rinasse individuiamo un altro problema legato a un esempio che vi ho fatto vedere prima ovvero cosa succede se voi copiate una stringa dentro un'area di memoria in mezzo alla strega c'è il slash zero la coppia si ferma lì non va avanti perché lo slasero viene interpretato come fine stringa ok nei programmi di slasero ce ne possono essere ok scrivete un malware che poi a un certo punto a uno slasero in mezzo e quando fate giochino di copiarlo dentro lo stack magari non riuscite a copiarlo tutto perché c'è uno slasero in mezzo ok e quindi una cosa non funziona di nuovo questa cosa quel codice a sempre non si riesce mai passare risolvere quindi questo motivo sono i motivi per cui quelli che vengono chiamati shell code che sono pezzi di codice assembli il comitivo quello di far aprire una scelta eseguire maniche la pro scelta quindi si chiamano così shell code vanno confezionati in e assembli e poi una volta confezionati li possiamo buttare qui dentro nella variabile basso al posto degli xc ok ora per fortuna questo l'abbiamo visto anche in tanti altri esempi in passato non abbiamo bisogno noi di programmare la sembri di un malware basta andare su dove nato dove su metasploit e lì ne trovate quante le volete ok che è quello che ho fatto io quindi ho chiesto a metasploit ne ho trovati ne ho trovati tre carini di di shell code che metasploit vi prepara vi li istituisce come come lo scegliete e lui ve lo spara come output voi fate copia incolla e lo buttate lì dentro al posto di quella slash xc per 200 ci buttate dentro l'assembly copiato incollato da metasploit ok chiaramente non sarà lungo 200 quindi sarà lungo un po di più un po di meno dovete fare in modo in ogni caso che il rip sia dopo 424 caratteri quello perché altrimenti uscita dalla nobel non pescate più un return address e quindi dovete fare attenzione a questo a questo conto ok e il primo risultato è questo allora guardate la differenza tra quello sopra e quello sotto allora ci sono ancora i 100 skip poi un pezzo alla volta ho copiato il malware quello è la codifica esadecimale dell'assembly che mi ha dato metasploit già così è copiato incollato senza fare niente di particolare e poi vedete il pad delle x no quante x devo mettere ne devo mettere tante quante me ne servono per riempire arrivare a riempire 424 caratteri prima del rip il rip è quello di prima e quindi per il padding ho fatto il calcolo dell'espressione 424 meno i 100 skip meno la lunghezza del buffer che continuano scioccoli così sono sicuro che a partire dal 425 esimo carattere in avanti c'è il famoso return address che ho manipolato quindi in questa maniera cosa dovrebbe succedere dovrebbe succedere che di nuovo mi ritrovo come indirizzo il salto a questo qua sopra eseguo tutti gli skip poi però da qui in avanti c'è il malware che viene eseguito ok proviamo e poi vediamo se siamo riusciti a vackerare la macchina allora dunque l'input non mi ricordo qual è sarà il 5 diciamo di sì facciamo il gdb mettiamo il solito break per andare a vedere cosa succede subito prima il ritorno al main vedete che vedete in realtà non si vede niente però lì in mezzo c'è c'è il malware e almeno credo mi ricordo se la devo dire di sì speriamo andiamo a vedere al solito eccoci qua vedete allora lo riconoscete dove è il malware il malware è questo prima ci sono gli skip dopo ci sono le x e qua giù vedete che c'è il famoso salto che ci fa tornare qui ci fa tornare qui ed eseguire gli skip prima il malware poi vediamo cosa succede facciamo le dita non è terminato viene messo in background dal malware e il malware è attivo adesso andiamo a vedere così vi faccio vedere cosa ha fatto il malware vedete che non è terminato il programma è in background anche perché se viene terminato termina l'effetto del malware quindi rimane in background il programma di sistema l'effetto vediamo se ha avuto se c'è stato devo andare a condividere un'altra finestra che devo prendere un'altra quindi cambiamo la condivisione quindi vediamo un'altra finestra vediamo il malware che cosa ha fatto eccolo qua su questi sono tutti i servizi attivi c'è il chrome che sta facendo un sacco di robe qua su in alto ci sono un po' di porte aperte la 22 è quella di SSH ok? che ce l'ho installato qua sopra la 631 è quella per la stampante la 53 non me la ricordo questa è la porta che ha attivato il malware cioè l'effetto del malware è di aprire la porta 4444 e mettere e mettere in ascolto su quella porta telnet ok? senza bisogno di autenticazione niente quindi voi col vostro computer se beccate in rete voi che voi attaccate avete IP del mio non dovete far altro che dal vostro computer io lo posso fare localmente lo posso fare quindi non so telnet e poi faccio open vabbè io localmente l'indirizzo locale è questo no? voi metterete l'IP della mia macchina così come si vede in rete ci mettete la porta ed ecco che viene aperta la sessione la sessione senza bisogno di autenticazione l'unico importante è che il mio laptop è open è on the web il mio IP è on the web that's it ok ne ho un altro chiudiamo qua poi togliamo tutto dalla rete perché altrimenti mi mi bucano tutti per quello che è meglio usare una macchina virtuale per fare questo genere di cose però ne ho un altro carino che vediamo ah no l'altra cosa che volevo dire da non sottovalutare è che prendiamo la condivisione ok questa cosa funziona vedete che l'ho ucciso ed è sparito tutto questa cosa funziona perché il programma vulnerabile l'ho lanciato dal debugger ok che non è quello che succede di solito il debugger lo usiamo solo per studiare la memoria poi però quello che ci aspettiamo è che il programma quando viene lanciato normalmente non dal debugger dia lo stesso tipo di problema con l'input che abbiamo creato ok non è quasi mai così infatti vedete lanciando il programma non dal debugger ma dalla shell non funziona il malware da errori da segmentation fault qual è il motivo il motivo è che l'occupazione in memoria del programma vulnerabile è diversa se c'è il debugger attivo oppure no nello stack camion sono shiftati un po' gli indirizzi ma questa cosa la possiamo risolvere perché basta fare il confronto tra l'RSP lo stack pointer che si ha quando viene eseguito il programma da solo e quello che invece valeva quando era eseguito dentro il debugger il valore dell'RSP quando era eseguito dentro il debugger era quello che finiva con dc0 se vi ricordate guardate il valore dell'RSP quando io eseguo il programma vulnerabile fuori dal debugger è d60 ok che è andiamo a vedere qua dal dd dal dd c0 al d60 vedete d60 è qua è tutto shiftato in avanti ok quindi noi che abbiamo messo come return address questo che era tre posizioni più avanti ddc0 dobbiamo metterlo tre posizioni avanti rispetto a questo cioè dobbiamo metterlo qui ok quindi dobbiamo spostare in avanti il return address ok quindi qua dentro invece del proviamo a farlo allora sarebbe questo lo cambiamo allora questo lo commentiamo e questo ci mettiamo cosa ci dobbiamo mettere non mi ricordo più tre posizioni avanti abbiamo detto ok no di più tre posizioni più avanti del sì questo del ddc santa era quello era ds santa sbagliava sicuramente perché non ho fatto i miei conti del dc santa proviamo vediamo un po' allora santa santo santo dobbiamo dobbiamo aggiungere la differenza santa santa santa adesso vediamo se mi viene vediamo se mi viene vediamo se mi viene su voi non lo vedete perché non l'ho condiviso sto cambiando dopo ve lo faccio vediamo ok dunque no devo ok solo si se il l ora ora non lo becco aspetta aspetta ma cazzo vediamo allora devo fare ma tac nemmeno l'input 6 eh sì ci sono riuscito cosa ho fatto allora era l'RSP nell'ambiente di esecuzione senza GDB è questo no? di E60 quindi andiamo a rivedere qua invece di essere di Dc0 è di E60 quindi invece di mettere che è tre posizioni più avanti rispetto a Dc0 l'ho messo al Dc90 che è tre posizioni più avanti quindi ho spostato dell'offset ok infatti l'attacco vedete ho messo Dc90 vedete ho messo Dc90 ok e quindi in questa maniera lanciando il programma se fuori dal GDB si attiva il malware ora voi mi direte va bene però te hai imbrogliato perché eh nel programma vulnerabile hai messo questa printf qua ok i programmi di sistema possono essere vulnerabili ma non hanno delle printf che vi dicono qual è il registro da cui partire quindi come fai a sapere qual è la differenza tra il registro che vale quando sei in GDB e il registro che invece hai nell'ambiente di esecuzione normale eh non lo possiamo sapere però possiamo andare per tentativi e soprattutto possiamo giocare su che cosa sull'ampiezza di area di memoria che noi riempiamo con i noop ok io non lo so se non avessi avuto quella printf io non avrei saputo che il punto dell'RSP invece che vi dice C0 era di E60 no? però se io voglio avere una buona probabilità di indovinare senza sapere quale sia a me basta allargare a piacere la parte di buffer con i noop per cui a me basta riuscire a a beccare un indirizzo che mi fa andare nello skip e poi dall'indirizzo avanti lo trovo il malware a forza di skip quindi è questo il motivo per cui è utile giocare con con un intervallo di di parte del buffer riempito con con il noop ok è chiaro quindi anche in un contesto reale ci si riesce anche senza sapere dove viene posizionato effettivamente in memoria senza GDB vi volevo mostrare un altro attacco adesso questo input 6 lo togliamo e questo lo rimettiamo a posto perché non volevo fare la conclusione no no no no no but the fact that it worked is that the the program was putting background yeah non ciò che sia posto ok devo farvi vedere l'altro lo rimettiamo posto perfetto abbiamo ripristinato come era ne ho altri due vare una per esempio una shell non apre la porta talent ma per direttamente una shell e un altro invece che questo qua non mi ricordo se se vale per il gdb no ho sbagliato un attimo va direttamente in 1060 2 mol a v원이 sento proviamo allora ok sì vabbè non me lo fa vedere tutto perché devo lavorare sul buffer però ve lo faccio vedere lo stesso perché ho provato un altro carino dove vedete qual è l'estratto qua giù in fondo non mi aspetto ecco ve lo asso un po sì il malware più piccolo dell'altro vedete è molto più stretto e l'effetto di questo malware è che spara in output il contenuto del file delle password che a un utente normale non sarebbe accessibile in lettura ok non c'è tutto perché devo allargare il buffer perché fa il passato molto più lungo e quindi devo lavorare con degli input più grandi però questo è un altro esempio di shellcode che si possono iniettare in input cui i programmi vulnerabili sono sensibili quindi di fatto se avete un programma di sistema che è vulnerabile al problema del buffer overflow con un po' di lavoro potete potete bucarlo in tutti i modi possibili l'ultima cosa che vi volevo dire tornando qua alle nostre slide è questa ovvero vabbè ci hai fatto vedere un attacco a un sistema che è sotto il buffer overflow ma io come devo fare a difendermi guardando il buffer overflow ci sono un po' di modi naturalmente non ci danno la garanzia completa perché i malware basati sul buffer overflow esistono dal primo ricordate quando vi ho raccontato il moris worm una delle vulnerabilità una delle diverse vulnerabilità che sfruttava derivava da un problema di buffer overflow che c'era in un programma di sistema che era il finger lì c'era una vulnerabilità di quel tipo ed era sfruttata più o meno in questa maniera qua quindi stiamo parlando della fine degli anni 80 tutt'oggi alcuni zero day attack si basano comunque in base su delle vulnerabilità che nascono dalle situazioni legate al buffer overflow perché si trovano pezzi di codice nei sistemi che sono vulnerabili al buffer overflow quindi è tuttora una delle categorie di vulnerabilità più usate in assoluto però per minimizzare la probabilità di scrivere codice vulnerabile al buffer overflow ci sono delle soluzioni sicuramente usare funzioni di libreria non deprecate come ho già fatto un elenco l'altra volta idem per quanto riguarda le librerie usare le librerie sicure due è possibile fare analisi statica del codice per fare dei test per verificare appunto i punti dove vengono effettuati dei trasferimenti da memoria a memoria usare possibilmente linguaggi di programmazione che prevedono dei check automatici della memoria i linguaggi dove si dà la possibilità allo sviluppatore di avere un accesso a un controllo diretti della memoria sono i linguaggi più vulnerabili quindi C, C++ la Java in su dove la gestione della memoria può essere demandata completamente al sistema prendete Python dove non dovete neanche dichiarare variabili lì ancora più, ancora meglio, tutto quello che si può demandare al sistema è bene che venga demandato al sistema la gestione della memoria poi ci sono delle soluzioni non a livello di linguaggio di programmazione ma a livello di sistema operativo anzi prima a livello dei compilatori e poi a livello del sistema operativo a livello dei compilatori ci sono una delle funzioni che ho dovuto disabilitare quando ho compilato il programma vulnerabile è il stack guard che è una funzionalità del compilatore e le ultime versioni del BCC ce l'hanno che permette di marcare certe aree di memoria come non eseguibili ok? ora il nostro attacco ha funzionato perché io ho iniettato del codice eseguibile del malware dentro lo stack ma nello stack non dovrebbero esserci brand di codice eseguibile il codice eseguibile dovrebbe essere in altra area di memoria nello stack dovrebbero esserci solo dati ok? quindi stack guard è uno strumento che permette di dire no guarda in quest'area di memoria che è dedicata agli stack frame non ci può essere codice eseguibile per cui nel momento in cui tu provi a eseguire codice in quell'area di memoria io ti blocco e quindi il nostro attacco non funzionerebbe ok? poi ripeto c'è modo di bypassarlo perché invece di iniettare il malware nello stack lo inietto nel data segment lo inietto qua giù nel test segment di nuovo devo sapere come ho organizzato la memoria fare dei test usare il debugger però invece che iniettare nello stack lo inietto qua ed ecco che riesco a bypassare uno strumento come stack guard poi invece a livello di sistema operativo ci sono altre soluzioni una è quella che abbiamo dovuto disabilitare che è la SLR che appunto introduce degli elementi randomici nell'allocazione degli spazi dello stack e quindi diventa più complicato anche se non del tutto impossibile indovinare i punti nello stack dove c'è il return address e iniettarli gli dati che ci interessano per puntare ad un'area in memoria dove ci sia il malware che voglio eseguire quindi sono soluzioni che rendono più complicata la possibilità di montare un attacco ma che non escludono completamente questo tipo di attacchi ok? domande? tutto chiaro? poi vi do tutti i sorgenti che ho usato così se volete replicare questo tipo di attacco provarne degli altri in maniera simile potrebbe essere un approfondimento per un progetto avete la possibilità di farlo ok? ci vediamo domani ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ciao ok ci vediamo ok no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no