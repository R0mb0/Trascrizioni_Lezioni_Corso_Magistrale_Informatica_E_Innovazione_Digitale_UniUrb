Grazie. Riprendiamo la registrazione. Allora, come dicevo, abbiamo visto come funzionano gli schemi di digital signature, quindi firma digitale e in particolare abbiamo visto l'esempio relativo alla costruzione che abbiamo chiamato full domain hash e a come questa si implementa usando RSA. Quindi riassumendo, l'idea è quella di utilizzare la chiave segreta RSA per codificare, per firmare non il plaintext ma il digest del messaggio. Il risultato è la firma che potrà poi essere verificata utilizzando la chiave pubblica corrispondente. Ok, questa è un po' l'idea. Eravamo arrivati a dire che attraverso questo teorema, se l'assunzione classica della sicurezza per RSA vale e utilizziamo una funzione hash impredicibile, allora questo schema di firma digitale è sicuro rispetto allo solito tag game che abbiamo visto in cui il compito dell'avversario è quello di provare a falsificare una firma. Il metodo più utilizzato in pratica per fare firme digitali basati sull'utilizzo di RSA è lo schema che abbiamo già visto, che è PKCS1. L'avevamo visto quando abbiamo parlato di RSA come strumento per fare cifratura a chiave pubblica. Lo stesso strumento naturalmente si può utilizzare anche per fare firme digitali, con gli stessi limiti e problematiche di sicurezza che avevamo già discusso a suo tempo. PKCS1 tra l'altro è forse il metodo più diffuso per fare firme digitali nell'ambito dei certificati di cui parleremo poi tra poco. Prima di questo però volevo chiudere il discorso relativo all'integrazione di strumenti di firma con strumenti di cifratura e quindi continuare l'analogia con quello che avevamo visto nell'ambito della cifratura a chiave simmetrica. Se vi ricordate quando abbiamo studiato i metodi basati su cifratura a chiave simmetrica, per combinare confidenzialità e integrità abbiamo introdotto l'authenticated encryption, che era uno strumento, un tool per mettere assieme cifrari da una parte e MAC dall'altra per garantire al tempo stesso segretezza e integrità. E gli schemi che avevamo visto erano l'encrypto del MAC oppure il MAC dell'encrypto. Un discorso analogo si può fare nell'ambito della cifratura a chiave pubblica, quindi usando come strumenti schemi basati su chiave pubblica. Sempre con il solito obiettivo, ovvero mettere in piedi uno schema che consenta di garantire contemporaneamente confidenzialità e integrità nel senso di origine del messaggio, da dove proviene il messaggio. Quindi l'idea è quella di avere la controparte dell'authenticated encryption. Che nell'ambito della cifratura a chiave pubblica prende il nome di sign encryption. Quindi sign encryption, vedremo, di fatto è l'implementazione dell'authenticated encryption usando però strumenti basati su chiave pubblica, piuttosto che su chiave condivisa. Lo schema generale, poi lo andremo a dettagliare in casi specifici, è quello che vedete qui. Immaginiamo di avere un sender, un receiver, quindi il solito scenario con Alice e Bob che vogliono dialogare tra di loro in maniera confidenziale e garantendo l'integrità. Rispetto all'authenticated encryption non possiamo assumere che Alice e Bob condividono una chiave segreta, quella necessaria per utilizzare, cifrare, chiave simmetriche, MAC e via dicendo. Quindi Alice e Bob non condividono nulla di segreto a priori, però conoscono le identità l'uno dell'altro. Poi vedremo questo in che modo importante e a cosa serve. In più assumeremo che ogni partecipante al nostro schema ha una coppia di chiavi pubblica e segreta. Quindi sia il sender che il receiver usano l'algoritmo di generazione delle chiavi per creare la coppia chiave pubblica e chiave segreta personale di ciascun partecipante. Perché ciascuno partecipante deve avere la propria coppia? Perché a seconda dell'operazione che vogliamo implementare verrà utilizzata una delle chiavi di uno dei due partecipanti. Un discorso che avevamo anticipato l'altra volta. Per fare la cifratura Alice che vuole mandare un messaggio segreto a Bob, quindi per proteggere rispetto alla confidenzialità questo messaggio Alice cosa dovrà fare? Dovrà usare la chiave pubblica di Bob, come negli schemi di cifratura basati su chiave pubblica. Ma se ne vuole garantire anche l'integrità e quindi l'origine dovrà firmarlo questo messaggio. E per firmarlo dovrà usare la propria chiave segreta, usando uno schema di firma digitale come PKCS1 o quant'altro. E lo stesso discorso vale al contrario, ha parlato Bob se vuole dialogare con Alice. Quindi mettiamoci nei panni di Alice che vuole mandare un messaggio a Bob. Per poter confezionare il messaggio da inviare a Bob, di che cosa ha bisogno Alice? Beh, ha bisogno, e qui vediamo tutti gli ingredienti, poi come vengono utilizzati lo vedremo in implementazioni pratiche. M è il plaintext che Alice vuole mandare a Bob. Poi due ingredienti importanti naturalmente sono l'identità, quella di Alice e quella di Bob, quindi l'identità del sender e l'identità del receiver. E qual è il materiale crittografico che serve per confezionare il messaggio? La chiave pubblica del receiver, perché mi serve per fare la cifratura, e la chiave segreta del sender che mi serve per fare la firma. Ok? Perché, ripeto, il messaggio va cifrato, ma anche firmato. Ok? Quindi questo è il motivo per cui servono... No, andiamo di qua. Annotiamo. Questo è il motivo per cui servono questi due ingredienti. La chiave segreta del mittente per la firma, la chiave pubblica del ricevente per la cifratura. Ok? Dall'altra parte, quindi Bob che riceve il messaggio cifrato, quindi sarebbe il cifrtext, quello che dice Bob, per recuperare M, per recuperare il plaintext, non lo cifrtext, Bob avrà bisogno della propria chiave segreta per la decifratura e della chiave pubblica del mittente per la verifica della firma. Ok? Quindi è simmetrico il comportamento, non lo so delle chiave. ID e identità. Ok? ID e identità. Perché, come vedremo, nel confezionare il cifrtext, useremo anche l'identità. per far capire a chi è destinato un messaggio e da chi proviene. Ok? Nella pratica, allora, perché il problema nella pratica è quello di associare, no? La coppia di chiave all'entità, all'utente. Ok? E qui entreranno in gioco, lo vedremo poi, i certificati. No? Un certificato è un documento di cui ci fidiamo per qualche motivo, vedremo perché. È un documento che crea un legame tra un'identità, cioè tra un'entità identificata in un certo modo, e la sua coppia di chiavi. Poi, chiaramente, della coppia di chiavi, noi conosciamo solo la parte pubblica, no? Quindi Piché, chiaramente a Schela conosce solo il proprietario, no? Però, conoscere l'identità dell'utente è importante perché ci permette, attraverso il certificato di quella, di quell'entità, di recuperare quella che è la sua chiave pubblica o di verifica, a seconda dell'uso che ne facciamo. Ok? Per fare cippertura, per fare verifica della firma, no? Quindi qui per ID del sender e del receiver intendiamo l'identità di un'entità, di una persona, di un agente, quello che è, così come appare in un certificato che associa poi quell'identità lì alla chiave pubblica. certifica... Ok? Chiaro? Cosa? Non ho capito. No, allora, è chiaro che se lì c'è Bobo, vogliono parlare fra di loro, devono fare riferimento alla propria identità. Ok? Le identità sono pubbliche, no? Alice potrebbe avere un certificato che dice, io sono Alice, questa è la mia chiave pubblica. Ok? Immaginiamo di avere agenti, non è sempre così, però immaginiamo di avere agenti che sono dotati di un certificato che dice, questa è l'identità, questa è la chiave pubblica associata con l'identità. poi la chiave segreta che chiaramente nel certificato non c'è. Quindi assumiamo che il sender che voglia parlare con un receiver che ha una certa identità abbia accesso al certificato che dice che l'identità di quel receiver è associata a una certa chiave pubblica. questa è un po' l'idea. Poi come vengono usati e in che ordine tutti questi ingredienti lo vediamo poi tra poco, perché i problemi da affrontare sono gli stessi che abbiamo visto con l'autenticata di encryption. Ad esempio, prima faccio la cifratura e poi la firma, o prima la firma e poi la cifratura? Nell'autenticata di encryption avevamo i due modelli, no? Encrypt then Mac oppure Mac then Encrypt. E qui il discorso è lo stesso. E infatti vedremo che si possono usare entrambe le strategie. No? Ci siamo. Ok. Chiaramente lo schema che andiamo a raccontare si è un po' fruttato lo schermo. Si vede bene? Dalle moto, sì. non capisco cos'è questa cosa che è apparsa qua, però va bene, andiamo avanti. Deve valere la solita proprietà di correttezza, ovvero se io prendo un messaggio no? e questa è l'identità del sender, questa è l'identità del receiver, il sender usa la chiave pubblica del receiver per fare la cifratura e usa la propria chiave segreta per fare la firma e il risultato sarà un certo ciphertext. Ok? Bene, dall'altra parte il receiver prende questo ciphertext e rispetto alla propria identità quella del sender usando la propria chiave segreta per fare la cifratura e usando la chiave di verifica del sender per fare la verifica della firma, bene, quindi se tutti usano questi ingredienti in maniera coerente, allora il receiver dovrebbe riottenere il plaintext M con probabilità 1, visto che comunque siamo sempre nel contesto di schemi probabilistici. Ok? Questa è un po' è la solita proprietà di correttezza. Ora, appunto, come dicevo prima, mentre nell'autenticata di encryption partiamo sempre dal presupposto che sender e receiver condividono già la chiave segreta rispetto alla quale fa recifratura e segnatura, nel caso di this encryption non esiste una chiave segreta condivisa, ma possiamo assumere che ogni partecipante, come dicevamo prima, abbia la propria coppia di chiavi pubblica e segreta e che il legame tra identità dell'agente e chiave pubblica sia un legame indissolubile, cioè un legame certo stabilito attraverso un certificato. Poi come fate il certificato lo vedremo poi. Ok? Quindi, ogni agente ha una propria identità e ha un certificato che associa a quell'identità la corrispondente chiave pubblica. Ora, come dicevamo prima, l'idea è quella di mettere in piedi uno schema che realizzi o l'encrypt del sign o il sign dell'encrypt esattamente come avveniva nel caso dell'authenticated encryption. Non vi faccio vedere come sono formalizzati gli attack game che garantiscono confidenzialità e integrità insieme perché sono piuttosto complessi però esistono e l'idea è che si possono combinare due nozioni di sicurezza che garantiscono da una parte la ciphertext integrity e dall'altra la semantic security rispetto al chosen ciphertext attack quindi esattamente come nell'authenticated encryption e la combinazione di queste condizioni di sicurezza fa sì che lo schema se valgono fa sì che lo schema che andiamo a costruire sia considerabile sicuro se valgono sia la proprietà relativa alla confidenzialità che quella relativa all'integrità i due modi per costruire sign encryption quindi adesso andiamo a vedere differiscono per l'ordine in cui le operazioni vengono applicate ad esempio in questo caso l'idea è fare prima la cifratura e poi la firma ok quindi siamo sempre nel contesto generale di prima ovvero ogni agente ha la propria coppia di chiavi in realtà ogni agente di coppie di chiavi ne ha due perché ogni agente può essere sia mittente che destinatario e quindi ogni ogni agente avrà una coppia di chiavi che usa per cifrare e decifrare e una coppia di chiavi che usa per firmare e verificare ok e sono quelle che vedete vedete qui ok questa è la coppia di chiavi che l'agente usa per la cifratura questa è la coppia di chiavi che l'agente usa per la firma ok quindi poi in realtà in certi casi possono anche coincidere però in generale assumiamo che sono possono coincidere specialmente se si basano sullo stesso algoritmo perché ad esempio noi potremmo nulla ci impedisce di usare PKCS1 sia per la cifratura che per la che per la firma ok o in altri casi noi potremmo usare che ne so e il gamal per la cifratura e PKCS1 per la firma quindi algoritmi diversi quindi è chiaro che a seconda del contesto in cui siamo queste due coppie devono essere distinte o possono anche essere la stessa la stessa coppia in generale assumiamo che sono distinte ok ora cosa succede a lato omittente quindi abbiamo il nostro plaintext ok questa è l'identità di Alice del Sander questa è l'identità del receiver per fare la cifratura abbiamo detto che serve la chiave pubblica del destinatario e serve la chiave di firma del del mittente ok come avviene come avviene con l'operazione nel caso di Encrypt del Sign allora prima si fa la cifratura ok questo è il messaggio da cifrare in plaintext no questo è un dato associato di identità del mittente ricordate quando si fa cifratura ci possono essere dei metà dati associati ok questa è la chiave di cifratura cioè che chiave uso per cifrare il messaggio uso la chiave di cifratura del destinatario cioè quella che in questa coppia qui ok quindi in pratica Alice prende la chiave pubblica di cifratura di Bob e la usa per cifrare il plaintext M e usando come dati associati la propria identità ok perché uso i dati come dato associato perché uso l'identità del mittente per far sapere a Bob che quel messaggio proviene da Alice e non da qualcun altro ok poi però devo dimostrare di essere Alice non basta che io metta come metadata la mia identità no perché chiunque potrebbe farlo ok chiunque potrebbe mettere qui come dato associato qualunque identità quindi devo devo dimostrare no e per dimostrare di essere veramente chi dichiaro di essere firmo il cifratest ok quindi quindi l'idea è prendo il plaintext cifro il plaintext con la chiave pubblica del destinatario aggiungo come dato associato la mia identità ok dopodiché che cosa faccio? per dimostrare per dimostrare di essere effettivamente io firmo il cifrtext ok faccio la firma del cifrtext in realtà cos'è che vado a firmare? vado a firmare la coppia cifrtext identità del destinatario ok per dichiarare che il messaggio che sto firmando è effettivamente destinato a quel particolare recipient e non a un altro ok quindi nella firma Alice di fatto dichiara non solo di essere Alice nel nel nel per quanto riguarda la cifratest quindi non solo con questa firma Alice dichiara di aver preparato c il cifrtext ma dichiara anche di voler mandare quel cifrtext a quel particolare recipient a Bob ok quindi ripeto Alice che cosa fa? prende il plaintext lo cifra con la chiave pubblica di Bob aggiungendo come metadati la propria identità per far sapere a Bob di essere Alice ok dopodiché firma cifrtext e identità di Bob ok del recipient ok dopodiché invia la coppia cifrtext e firma no dall'altra parte il recipient Bob riceve questa coppia la prima cosa che deve fare è verificare la firma verificare cioè che effettivamente sia stata Alice cioè a firmare il cifrtext e l'identità del recipient ok se la chiaramente per fare la verifica della firma di che cosa ha bisogno il recipient ha bisogno della chiave pubblica no di di firma di del sender no e la recupererà del certificato ok tra l'altro l'identità del sender viaggia con C no perché è un dato associato e i dati associati non sono cifrati quindi in pratica al recipient di che cosa arriva arriva un pacchetto che contiene il cifrtext i metadati che dicono che quel cifrtext viene da Alice e una firma fatta da Alice per certificare il fatto che è Alice che ha preparato quel cifrtext e che quel cifrtext è effettivamente destinato a Bob e non a qualcun altro ok quindi Bob che cosa fa dice bene mi è arrivato un pacchetto da qualcuno che dichiara di essere Alice insieme a quel pacchetto c'è firma allora andiamo a recuperare la chiave di verifica di Alice la prenderò dal certificato che è disponibile in qualche repository e la uso per verificare la firma quindi per verificare queste due informazioni ovvero il fatto che il messaggio è effettivamente destinato a me e che è stato confezionato da Alice ok se la verifica ha successo allora Bob è sicuro no del fatto che il cifrtext che ha ricevuto proviene da Alice è a lui destinato è destinato a Bob ok e quindi a quel punto può procedere a decifrarla e la decifratura naturalmente avverrà in che modo usando la propria chiave segreta di decifratura applicata al cifrtext e usando l'identità del sender come dato associato ok quindi prima Bob verifica che il messaggio che ha ricevuto proviene è stato confezionato veramente da Alice e che è destinato a lui e lo fa verificando la firma dopodiché procede se la verifica della firma è successo dopodiché procede a decifrare il cifrtext usando la propria chiave segreta ok e quindi alla fine di questa operazione avrà recuperato il plaintext no vedete adesso è chiaro il motivo per cui hanno un ruolo importante anche l'identità all'interno e non solo le chiavi all'interno dello schema perché sono un modo per legare gli agenti alle corrispondenti chiavi alle corrispondenti chiavi pubbliche ripeto come algoritmo di cifratura che ha queste due funzioni e come algoritmo e come schema di firma che invece ha queste due funzioni possiamo usare qualunque schema di quelli che abbiamo visto in queste settimane ok quindi schemi basati su RSA schemi basati su DFI Hellman quello che vogliamo ok lo schema generale rimane comunque questo come funziona invece il sign dell'encrypt ovvero prima si fa la firma e poi la cifratura allora in questo caso vedete il mettente usando la propria chiave di firma crea una firma di messaggio del plaintext e dell'identità del destinatario ok quindi prima cosa certifico con la mia firma digitale che il plaintext è il mio e che questo plaintext lo voglio mandare a quel particolare destinatario ok dopodiché che cosa faccio dopodiché faccio la cifratura la cifratura la faccio di messaggio cifrima cifro tutto ok uso come metadati come dati associati la mia identità e la cifratura la faccio con la chiave pubblica del recipient ok vedete è molto è alla fine è identico all'autodidica dell'encryption cambiano gli ingredienti che vengono usati dall'altra parte il recipient cosa fa beh il recipient riceve un cifrtext quindi la prima cosa che deve fare è decifrarlo no e lo fa usando la propria chiave di decifratura e usando come metadati come dati associati l'identità del del del del del del del del sender ok il risultato della decifratura se tutto va bene è questa coppia plaintext e firma quindi a questo punto il recipient non deve fare altro che verificare la firma usando la chiave pubblica la chiave di verifica di firma del del del del sender no se la verifica ha successo allora accetto il plaintext ok quindi se encryption non lo posso implementare in due modi encrypt and sign sign or sign and encrypt ci sono delle differenze dal punto di vista della sicurezza ce ne sono molte di meno rispetto a quelle che avevamo visto nel caso dell'autenticata di encryption se vi ricordate nel caso dell'autenticata di encryption di base solo encrypt del mac era sicuro mac dell'encrypt in generale non lo era c'erano delle vulnerabilità ok qui come vanno le cose allora abbiamo questi due teoremi che fondamentalmente dicono che entrambe le costruzioni sono sicure se chiaramente i due schemi che usiamo quello per la cifratura e quello per la firma sono a loro volta sicuri ok quindi in particolare i teoremi dicono che se lo schema di cifratura che io uso è CCA sicuro e questo vale per entrambi i teoremi allora la costruzione può essere sicura ok l'altra condizione riguarda la sicurezza dello schema di firma no in questo caso ovvero per l'encrypt del sign lo schema di firma deve essere fortemente sicuro nel caso del sign dell'encrypt è sufficiente che sia sicuro quindi c'è solo questa differenza qui la differenza ve la ricordo lo schema di firma è sicuro se l'attaccante non può falsificare la firma di un nuovo messaggio è fortemente sicuro se non può falsificare una firma alternativa di un messaggio che è già stato firmato in maniera diversa questo è quello che succede con il metodo se lo schema di firma è probabilistico e può restituire diverse firme per lo stesso messaggio ok quindi tutto sommato possiamo dire che entrambe le costruzioni sono sicure no Giorgio mi dice che vede sempre slide 12 no non è corretto vuol dire che non sto condividendo bene rifacciamo la condivisione probabilmente si era si era bloccata la condivisione adesso dovresti vedere la slide 16 vediamo se è così vedi sempre la 12 allora diamo un po' rompiamo la condivisione allora mettiamo un po' qua come sta adesso ok slide vedi la 16 adesso se ok stamattina andrà un po' i numeri si vede che c'è qualche disallineamento o problema di rete quindi entrambi le costruzioni di sign encryption tutto sommato possiamo dire che sono che sono sicure esistono delle costruzioni alternative per realizzare sign encryption in particolare usando Diffie Hellman ma di questo noi non parleremo non ve le mostrerò sappiamo che esistono delle delle proposte alternative mentre invece volevo mettere in evidenza una differenza un paio di differenze importanti tra encrypt and sign e sign e encrypt ok è vero che dal punto di vista della confidenzialità di identità che determinano la sicurezza sono pressoché equivalenti ma differenze significative emergono nel momento in cui prendiamo in considerazione ulteriori proprietà vi faccio due esempi una proprietà importante di cui non abbiamo mai parlato ma che nei risvolti pratici lo è abbastanza era cosiddetta forward security ok quindi sicurezza in avanti cosa rappresenta la forward security vediamo la definizione uno schema di sign encryption è forward secure quindi garantisce la forward secrecy se la cca security quindi la confidenzialità la robustezza rispetto alla chosen cyber text attack è preservata anche se l'avversario a un certo punto riesce ad ottenere la chiave segreta di firma del mittente ok quindi anche se l'attaccante per qualche motivo riesce a conoscere conoscere la chiave segreta di firma del mittente se lo schema è forward secure allora la segretezza dei messaggi inviati dal mittente non viene compromessa anche se la sua chiave di firma è stata compromessa adesso lo vediamo adesso lo vediamo se questa cosa vale per l'encrypt del sign o sign dell'encrypt questa è solo la definizione quindi la definizione di forward security dice che anche se l'avversario conosce la chiave di firma non riesce comunque a compromettere la confidenzialità del messaggio ok poi c'è un teorema che dice che solamente sign and encrypt soddisfa la formula security ok mentre invece encrypt and sign no ok l'idea è abbastanza non vi faccio una dimostrazione formale però l'idea è abbastanza semplice dietro questa dietro questo teorema è il fatto che solo sign and encrypt la soddisfa allora intanto per quanto riguarda sign and encrypt noi sappiamo che prima si fa la firma ok e poi si fa la cifratura quindi la firma in qualche modo è incapsulata e protetta dentro la cifratura ok quindi anche se l'avversario impara la chiave segreta del mettente ok la chiave di firma del mettente questa può essere usata solo per fare delle firme non non può essere non è di aiuto per andare a compromettere la cca security dei messaggi che sono già stati inviati ok perché perché non è d'aiuto per decifrare nulla se andiamo a vedere i messaggi vecchi che il sender ha mandato questi sono protetti dalla cifratura e dentro la cifratura c'è plain text e firma ok quindi non c'è modo per l'attaccante di andare a compromettere la la confidenzialità del messaggio no perché per compromettere la confidenzialità del messaggio non se ne fa nulla della chiave di firma del del mettente ok se andiamo a rivedere nel sign dell'encrypt vedete l'avversario quello che vede l'avversario quello che vede sono il ciphertext no l'avversario vede il ciphertext ok per decifrare e la firma è dentro il ciphertext quindi anche se l'avversario impara la chiave segreta di firma non se ne fa nulla per recuperare le informazioni che riguardano M ok gli serve la chiave di cifratura del recipient per accedere alla firma e al messaggio questa un po' è l'idea di base invece non si può dire lo stesso del oh no sono troppo anzi non si può dire lo stesso dell'encrypt del sign perché nell'encrypt del sign la firma è esterna cioè prima creare ciphertext e poi lo firmo ok quindi l'avversario la vede la firma e quindi questo cosa significa beh immaginate un avversario che vede passare questa coppia che è stata creata dal mittente no il mittente ha fatto in creep del sign quindi l'output è la cifratura e la firma della cifratura ok ora a questo punto l'avversario che cosa può fare siccome conosce la chiave segreta di firma del mittente può calcolare una firma alternativa di c ok quindi può costruirsi una nuova coppia ciphertext nuova firma fatta da lui ok ma questo è in violazione dell'attack game della chosen ciphertext attack perché se andate a rivedere l'attack game del chosen ciphertext attack l'obiettivo dell'avversario è proprio quello di riuscire ad esempio a creare un nuovo ciphertext che venga accettato dal dal dal recipient e in questo modo ci riesce quindi la cca security viene viene compromessa ok e ripeto il motivo fondamentale è che nell'encrypt del sign la firma è esterna e quindi l'avversario la può vedere e modificare nel sign e nell'encrypt la firma è interna e quindi l'avversario non ha modo di fare nulla interna rispetto alla cipartura no no non riesce a questo no questo non non riesce a farlo riesce a violare diciamo la sicurezza di tipo cca perché riesce a creare una nuova una nuova coppia beh no non è dell'integrità perché comunque l'attack game del chosen side side side side side side side side side side side side side side side side side side side quindi questo è un piccolo vantaggio a favore del sign dell'encrypt rispetto all'encrypt del sign c'è però un'altra proprietà rispetto al quale il gioco si inverte ovvero il sign dell'encrypt diventa peggio dell'encrypt del sign e quest'altra proprietà è la non repudiation partiamo dalla definizione cosa dice la proprietà di non repudiation dice che lo schema di sign encryption garantisce la non repudiation se l'integrità del cybertext è preservata anche se l'avversario ottiene la chiave segreta di decifratura del receiver garantire non repudiation significa garantire che il mittente non possa ripudiare i messaggi che ha inviato ok non è che Alice segue lo schema design encryption manda un messaggio e poi dice ah no non sono io che l'ho mandato non lo può fare ok la non repudiation vale solo per l'encrypting sign ok il motivo analogo con quello che abbiamo visto prima nell'encrypting sign la firma è esterna ok quindi la la firma non è in nessun modo compromessa dal fatto che l'avversario possa conoscere la chiave di decifratura del recipient e quindi non conoscere la chiave di decifratura del recipient non aiuta in nessun modo l'avversario a che ne so falsificare la firma dell'attente ok questa è un po' ideale idea generale quindi l'encrypting sign garantisce la non repudiation se l'attente usa sign encryption nella modalità encrypting sign non può ripudiare i messaggi che invia questo non vale nel caso della sign and encrypt ok il motivo è estremamente banale immaginate di usare sign and encrypt ok quindi l'output è un ciphertext che contiene fatto sul messaggio sulla firma immaginate un avversario che riesce a recuperare la chiave segreta di decifratura del recipient quello che deve fare semplicemente è decifrare il ciphertext quindi ottenendo questa coppia ok e poi rifare la cifratura usando la chiave pubblica come vari dati eh beh certo perché in sign and encrypt tornando indietro allora siamo siamo qua ehm se l'avversario conosce la chiave segreta di decifratura del recipient l'avversario può fare questa cosa qui giusto? no perché se l'avversario rompe questa chiave l'avversario recupera recupera plaintext e firma ok recupera la plaintext e firma poi che cosa fa? può rifare la cifratura cioè può può fare questa operazione qui ok no perché una volta che ha ottenuto questa può fare questa è pubblica quindi può rifare questa quindi ottenere un altro c chiamiamolo un c' primo diverso da c che però è la cifratura di m sigma cioè in pratica l'avversario può ottenere una cifratura diversa no ma valida della coppia m sigma e questa cosa viola la proprietà di integrità quindi se andiamo a rivedere l'attack game contro l'integrità degli schemi di firma di fatto questo ne compromette la condizione di sicurezza ok e quindi in questo caso l'ammittente potrebbe dire ma io non ho creato io quel salvertex che contiene messaggio fermo quindi lo ripudio non l'ho creato io mi hanno rubato mi hanno rubato no è stata rubata al recipient la chiave segreta di riciclatura non è colpa mia e quindi io ripudio questo questo particolare messaggio ok invece l'encrypt and sign non lo può fare non lo può fare perché perché la firma è esterna è l'ultima cosa che viene fatta ok e quindi anche se il la la la chiave di dicipatura del recipient viene rubata in in ogni caso io la firma essendo esterna l'avversario non ha modo usando la chiave di dicipatura ad andare ad alterare l'output generato dall'ammittente perché non conosce la firma la chiave di firma dell'ammittente quindi ci sono pro e contro nell'uso delle due costrutture di sign encryption una garantisce la forward security l'altra garantisce la non repudiation a seconda dei contesti può essere più utile avere una e non avere l'altra ma entrambi non le possiamo avere questa è un po' la morale torniamo un attimo al discorso dei certificati vediamo come sono fatti ok quindi come dicevamo prima un certificato è una informazione digitale no che crea un legame tra l'identità di un agente e la sua chiave pubblica i certificati sono importanti perché pensate a sign encryption a un certo punto qualunque sia lo schema che andiamo a usare quando io devo verificare una firma quindi qui ma analogamente anche nel caso dell'increpto del sign mi serve la chiave pubblica di verifica di chi ha fatto la firma e dove la provo non mi posso fidare che sia il mettente a dirmi questa è la mia chiave pubblica perché potrebbe essere un avversario che mi sta ingannando quindi queste informazioni le devo recuperare da un repository di cui mi fido ok e questo è esattamente lo scopo dei certificati i certificati sono creati da delle authorities delle certification authorities che sono trusted da chiunque e seguono un template un formato standard che è l'X509 il cui schema generale è quello che vedete qui ogni certificato contiene tre diverse tipologie di informazioni informazioni relative all'identità dell'agente coinvolto quindi se Alice vuole che venga emesso un certificato che attesti qual è la sua chiave pubblica nella sezione dedicata al subject data troverete tutte le informazioni relative ad Alice ok nella seconda sezione in short data trovate tutte le informazioni relative alla certification authority che sta rilasciando il certificato ok ad esempio vabbè di dov'è come si chiama la certification authority il numero di serie del certificato l'algoritmo di firma che utilizza il certificatore perché chiaramente io per fidarmi di un certificato è necessario che questo certificato sia firmato dalla certification authority ok quindi nel certificato ci sono informazioni relative all'algoritmo di firma la validità del certificato i certificati non valgono per sempre hanno una scadono hanno una una durata limitata nel tempo poi nella terza sezione ci sono le informazioni relative alla chiave pubblica del soggetto cui fa riferimento il certificato quindi ad esempio tutte le informazioni relative alla chiave pubblica di Alice ok quindi il certificato in pratica dice che dice chi è Alice chi è l'authority che sta creando il certificato e qual è la chiave pubblica di Alice quindi il certificato crea questo legame tra Alice e la sua chiave pubblica chiaramente nella terza sezione ci sono tutta una serie di informazioni relative a come usare la chiave pubblica di Alice e quindi quale schema a chiave pubblica fa riferimento quella chiave stiamo parlando di PKCS1 stiamo parlando di El Gamal stiamo parlando di un altro schema di cifratura o di firma a chiave pubblica quali sono i parametri ad esempio se siamo nel caso di El Gamal ci sono dei parametri che consentono di utilizzare poi la chiave pubblica in una maniera corretta che ne so c'è un gruppo ciclico bene qual è il generatore del gruppo ciclico ci sono dei numeri primi in ballo Q e P bene quali sono questi numeri primi tutte le informazioni che mi servono per utilizzare El Gamal quindi qual è l'algoritmo a cui fa riferimento la chiave pubblica quali sono i suoi parametri il valore della chiave pubblica le sue dimensioni per cosa è utilizzabile è una chiave pubblica da usare per la cifratura o è una chiave pubblica da usare per la verifica di una firma ok e ultimo elemento fondamentale la firma della certification authority sul certificato ok quindi voi direte va bene abbiamo un pezzo di carta firmato dalla certification authority che dice che la chiave pubblica di Alice è questa ok come faccio a fidarmi di questo certificato però il certificato è firmato quindi per verificare la bontà del certificato io posso verificare la sua firma ma per verificare la firma della certification authority sul certificato io devo conoscere la chiave di verifica pubblica della certification authority ok è vero che abbiamo spostato il problema dal conoscere la chiave di Alice al conoscere la chiave della certification authority però è un problema molto meno diciamo grave questo perché perché le chiavi di verifichi dei certification authority sono poche sono note a livello mondiale e l'informazione su quella che è la chiave pubblica delle certification authority è pubblica spesso e volentieri addirittura embed dall'interno dei sistemi no la maggior parte dei sistemi operativi escono di fabbrica o non vengono installati sulle macchine che incapsulano già all'interno i valori relativi alle chiave pubbliche di molte certification authority per cui sono già predisposti per verificare firme rilasciate dalle certification authority ok se voi comprate una mano un portatile e montate sopra l'ultima versione di Windows e aprite browser edge o chrome a seconda di quello che si installate sopra andate a vedere nelle impostazioni relative alla sicurezza le mancole delle certification authority riconosciute lì trovate già una lista di alcune authorities che le cui chiave pubbliche sono embedded già all'interno del sistema ok per cui la lettura di un qualunque certificato rilasciato da una di quelle authorities può essere verificata dal sistema senza dover andare a reperire informazioni altrove perché la chiave di verifica di quell'authority è già nota e ce ne sono diverse digi cert verisign robarsign sono solo alcune di queste e sono quelle che tipicamente di cui tipicamente trovate già la chiave pubblica di verifica nell'impostazione del vostro browser e in cascata ci possono essere altre certification authority che non sono le cui chiave di verifica non sono embedded nel sistema no? però per risolvere questo tipo di problema si utilizzano quelle che vengono chiamate catene di certificazioni per cui ad esempio c'è la digi cert che certifica l'affidabilità di un'altra certification authority ok la l'Aldina Alessandro Certifier è una nuova authority se questa authority viene certificata da digi cert cioè c'è un certificato firmato da digi cert che dice che l'Aldina Alessandro Certifier è un authority affidabile bene voi attraverso il vostro browser potete scaricare questo certificato verificare la firma della digi cert e quindi accettare il certificato e quindi da quel momento in avanti di fatto accettare qualunque certificato firmato dall'Aldina Alessandro Certifier perché perché l'Aldina Alessandro Certifier è una authority che a sua volta è stata certificata da digi cert per cui se Alice vi presenta un certificato firmato dall'Aldina Alessandro Certifier anche se non è firmato da digi cert voi vi fidate lo stesso perché in cascata siccome vi fidate di digi cert vi fidate anche nell'Aldina Alessandro Certifier e di conseguenza di infiderete di Alice che ha certificato e firmato da quest'ultima e quindi si formano delle catene di certificazione ok potete provare ad andare a vedere nelle impostazioni di sicurezza del browser quante e quale authorities sono embedded all'interno del nostro sistema e se ci sono delle catene ok e sempre più adesso ho fatto l'esempio del browser però una situazione analoga vale per tanti software che al loro interno hanno le funzionalità per la verifica delle firme pensate ad esempio ai reader di documenti in formato PDF prendete l'acrobat reader dell'adobe spesso volentieri i PDF sono firmati ok e quindi il software il reader deve essere equipaggiato con un modulo per andare a fare la verifica della firma sul PDF chiaramente deve riconoscere le authorities che hanno firmato il PDF no in quel caso il PDF in quel caso la criticità non è la confidenzialità del PDF ma è solo la sua integrità per cui il PDF che contiene tra i suoi vari metadati anche la firma ok con tutti i metadati che fanno riferimento sì sì sì sì in quella sezione esatto e quindi in quel caso nei metadati del PDF il reader trova tutte le informazioni per fare la verifica della firma presente sul sul PDF firma fatta tipicamente usando PKCS1 piuttosto che uno di quelli che dobbiamo ancora vedere che vedremo tra poco ok quindi di fatto la firma digitale fatta sul PDF in che cosa consiste consiste nella cifratura non di tutto il PDF ma di parte del PDF ad esempio del digest del PDF fatto usando la chiave segreta di chi fa la firma è chiaro che non si fa la cifratura dell'intero dell'intero documento ma ad esempio come abbiamo visto nel caso di Food Domain Ash si lavora si lavora sul sul digest del documento che vogliamo firmare esistono diversi modi di realizzare firme digitali senza utilizzare schemi a chiave pubblica come RSA alcuni tra i più comuni fanno uso di funzioni di RASH noi di questi non parleremo vi cito solo vi dico solo che esistono sono anche abbastanza semplici da utilizzare soprattutto in modalità one time one time significa che una firma la potete usare una volta sola ok invece se usate Full Domain Ash basate su RSA la vostra coppia di firma la potete usare tutte le volte che volete potete firmare tutti i documenti che volete le soluzioni basate su funzioni di ASH invece vi permettono di fare una sola firma il motivo è molto semplice perché in molti di questi approcci di base la firma consiste nel combinare in qualche modo chiave segreta e messaggio da firmare ok cioè voi prendete il messaggio che volete firmare e lo combinate con la vostra chiave segreta vi ricordate l'algoritmo di padding che è alla base di KCS1 dove il plain text veniva combinato con un valore randomico con dei byte specifici per intercalare i due qualcosa del genere si prende il messaggio si prende invece che un valore randomico la chiave segreta si combinano dopodiché il risultato non si dà in pasto a una funzione ASH il risultato il digest è la firma ok quindi l'idea è questa prende il messaggio prende la chiave segreta li combina insieme gli dà in pasto da la chiave 256 il risultato è la mia signature è la firma ok ora come fa come fa qualcuno a verificare che la firma sia stata fatta da dall'agente legittimo e non da qualcun altro per verificare la firma io devo chiedere la chiave segreta ok Alice fa una firma fatta così manda un messaggio a Bob Bob dice bene dimostrami che la firma l'hai fatta tu allora a quel punto Alice svela la chiave segreta Bob rifà il calcolo e verifica che la chiave segreta venuta da Alice è esattamente quella usata per creare la firma però ovvio che lo schermo di questo genere lo potete usare una volta solo no perché per fare la verifica della firma dovete svelare la chiave segreta poi esistono delle varianti in cui si usano i Merkel tree per combinare una struttura gerarchica diversi valori hash e quindi in quel caso appunto spuntando il Merkel tree si riescono a fare tante firme usando la stessa la stessa chiave però diciamo che è sempre sempre questa più avanti vi faccio vedere invece un modo di fare firme digitali usando Diffie Hellman che è l'unica primitiva che finora non abbiamo coinvolto nella descrizione degli schemi di firma digitale perché di fatto abbiamo parlato solo di soluzioni basate su RSA esistono anche schemi anzi tra i più diffusi ci sono schemi che invece fanno uso di Diffie Hellman e che tra poco andremo a vedere che richiedono un po' di dettagli in più rispetto a quello che abbiamo visto finora questo chiude il discorso relativo alle firme digitali e quindi ci permette al tempo stesso di chiudere anche un po' il discorso relativo a confidenzialità e integrità per gli schemi basati su chiave pubblica vi faccio vedere il riassunto questo schema è il riassunto generale dei metodi basati di quasi tutti i metodi adesso qualcosa ancora manca ma lo vedremo già da oggi questo è lo schema generale che riassume tutto quello che abbiamo visto riguardo la cifatura chiave pubblica quindi in particolare in particolare siamo partiti da queste due primitive di base che abbiamo introdotto per risolvere il problema dell'anonymous key exchange e naturalmente la scrittografia ellittica è una variante di Fielman e abbiamo visto come questi due diversi schemi possono essere usati per ad esempio fare cifratura a chiave pubblica se usiamo di Fielman lo schema che abbiamo studiato è quello di Algamale ce ne sono altri ma quello che abbiamo visto è Algamale se invece usiamo gli schemi di funzione con Trapdoor l'implementazione tipica quella di RSA con poi le varianti che fanno uso degli schemi di padding che abbiamo visto RSA è anche l'unico modo che finora abbiamo visto attraverso Fulldumayash di creare firme digitali esistono delle alternative per creare i firme digitali che però finora non abbiamo visto non vedremo gli schemi one time basati su funzione sono un esempio sono tutti temi che volendo possono essere approfonditi in un progetto l'unica cosa che manca e che sarà l'oggetto della prossima lezione è come sfruttare di Fielman per realizzare firme digitali e la soluzione sta in un protocollo dovuto a Shnor molto efficiente che nella pratica viene implementato non usando i gruppi ciclici ma usando la criptografia elliptica come idea e il risultato è uno degli algoritmi maggiormente utilizzati per la realizzazione di firme digitali che è lcdsa lc sta per elliptic curve dsa sta per digital signature algorithm quindi un firma digitale basato su fotografie elliptiche diciamo che nel corso degli anni un po' alla volta questo schema ha soppiantato buona parte di questi che sono invece quelli basati su RSA quindi più inefficienti ok un po' qua ah no ho scaricato desit risorio adesso vi anticipo solamente ma li vedremo poi nel pomeriggio vi introduco a grandi linee il problema quello andremo a studiare nel dettaglio il problema generale si inquadra nella famiglia dei protocolli di identificazione quindi protocolli il cui risultato finale alla fine sarà come vedremo uno schema di firma digitale alternativo rispetto a quello che abbiamo visto finora però partiamo dal problema di fondo che è appunto il quello di avere un protocollo che permetta di risolvere il famoso problema dell'identificazione come faccio a identificare un agente sapendo che è lui e non qualcuno che sta facendo finta di essere lui le soluzioni che vi farò vedere sono i primi esempi di protocolli crittografici un protocollo crittografico in generale non è altro che un handshake interattivo tra due o più agenti che si scambiano dei messaggi e al termine dello scambio di messaggi gli agenti avranno raggiunto un agreement su qualche condizione condivideranno delle informazioni avranno verifica fatto delle verifiche gli obiettivi cambiano di protocollo in protocollo ad esempio nel caso dei protocolli di identificazione l'obiettivo è identificare quindi gli obiettivi possono cambiare quello che non cambia il fatto che comunque gli agenti coinvolti nel protocollo seguono un handshake si scambiano i messaggi di solito nel shake e asimmetrico nel senso che non è che gli agenti mandano tutti gli stessi messaggi ognuno ha un ruolo diverso all'interno del protocollo ogni agente segue un algoritmo nello scambio di questi messaggi algoritmi che possono essere probabilistici ogni agente ha una memoria locale dove sarà i propri parametri che servono per l'esecuzione del shake ogni agente può eseguire più istanze contemporaneamente nello stesso protocollo ma lì ci può parlare può seguire un protocollo con bob ma al tempo stesso seguire un altro istanza del stesso protocollo con chass o con qualcun altro quindi c'è il problema della concorrenza nell'eseguire nell'eseguire protocollo crittografici e questo come vedremo creerà dei problemi per quanto riguarda la verifica delle proprietà di sicurezza dei protocolli vi farò vedere uno anche più di un esempio pratico di protocolli crittografici che sono sicuri finché facciamo l'assunzione che ogni agente esegue un'istanza alla volta del protocollo nel momento in cui diamo la libertà di agente di seguire contemporaneamente più istanza lo stesso protocollo gli saltano fuori le vulnerabilità la concorrenza e non determinismo sono fonti di problemi per quanto riguarda le proprietà di sicurezza dei protocolli e basta già ecco queste sono le condizioni generiche che stabiliscono che cos'è un protocollo in particolare un protocollo crittografico dove gli algoritmi che si utilizzano naturalmente fanno un'unica di primitive di primitive crittografiche il problema che vogliamo risolvere uno dei problemi più importanti nell'ambito della crittografia è appunto il problema della della condivisione della scusate dell'identificazione detto anche problema del login no la descrizione del problema è molto semplice abbiamo due agenti uno si chiama prover e l'altro si chiama verifier il prover avrà a sua disposizione una chiave segreta il verifier avrà a disposizione una chiave di verifica il compito del prover è dimostrare la propria identità al verifier usando in qualche modo la propria chiave segreta il verifier base all'end shake viene eseguito con il prover alla fine userà la chiave di verifica per confermare oppure no identità del prover ok quando fate login su gmail state eseguendo un istanza di un protocollo di identificazione perché in quel momento voi state fornendo voi siete il prover state fornite delle informazioni al verifier il verifier verifica queste informazioni e se tutto va bene alla fine dell'end shake il verifier accetta il vostro login quindi riconosce la vostra identità ma questi sono tutta una serie di possibili esempi in cui si utilizzano si possono utilizzare i protocolli di identificazione quindi aprire aprire lo sportello della vostra macchina col telecomando vi farò vedere qual è il protocollo che usano le automobili per questo tipo di problema quando voi usate il vostro telecomando della macchina per aprire lo sportello state eseguendo un istanza di un protocollo di identificazione in quel momento voi siete il prover e usate la chiave per dimostrare al verifier che è la macchina che siete voi non qualcun altro quindi quello è un esempio di problema di identificazione ma lo stesso succede anche con le porte il cui accesso è bloccato da un sensore su cui dovete passare il badge anche quello è un esempio di istanza di un protocollo di identificazione quando vi ritirate cash dal banco ma anche in quel caso state eseguendo un istanza di un protocollo di identificazione ok supportato da un dispositivo che è il banco che inserite nel lettore ed altre informazioni che digitate invece voi il pin però sono tutte informazioni e azioni che voi eseguite durante un handshake tra prover siete voi verifier che è il banco ma è al termine del handshake se tutto è andato bene il verifier vi riconosce quindi il problema dell'identificazione è uno dei più diffusi tanti contesti diversi e l'astrazione di base anche se a livello implementativo vedremo che le soluzioni sono diverse consiste nel fatto che il prover deve avere a propria disposizione una qualche informazione segreta che utilizzerà per dimostrare al verifier di essere chi dice di essere perché senza una informazione segreta senza una chiave segreta chiunque può dichiarare di essere qualunque persona qualunque gente quindi è chiaro che da parte sua il prover deve avere a disposizione l'informazione segreta così come è chiaro è altrettanto chiaro che dall'altra parte il verifier deve avere a disposizione un'informazione un'informazione di verifica da usare per verificare appunto l'identità del prover poi quelle che noi chiamiamo banalmente chiave segreta da una parte chiave di verifica dall'altra che siano diverse che siano uguali dipende dall'implementazione ok però fatto sta che ci devono essere se pensate a un classico login basato su password ecco che in quel caso la secret key del prover è la password la verification key del prover è la verifica che cosa sarà quindi la password stessa la password stessa quindi è un esempio di situazioni in cui secret key e verification key coincidono ok non è detto che sia sempre così ad esempio se che il verifier non mantiene l'elenco delle password ma contiene come abbiamo detto anche in passato gli hash delle password allora in quel caso la secret key del prover è la password la verification key del verifier è il digest della password quindi vedete un esempio in cui SK e VK non coincidono ok e in tutti questi casi d'uso vedremo diversi protocolli che implementano in maniera diversa questo concetto volendo classificare un po' i protocolli di identificazione in base a criteri ad alto livello di questo genere diciamo che i criteri di solito sono questi allora intanto un criterio banale riguarda il fatto che secret key e verification key siano uguali o diversi tra di loro ok va da sé che se secret key e verification key coincidono allora anche la verification key deve essere segreta come la secret key no? è chiaro perché se fosse pubblica allora dovrebbe meno la sicurezza del protocollo ok quindi un aspetto importante per classificare il protocollo di identificazione riguarda la natura della verification key ovvero la verification key è un'informazione che può essere pubblica cioè accessibile a tutti o deve essere segreta tanto quanto la secret key ok? ripeto è chiaro che se la verification key coincide con la secret key allora è ovvio che anche la verification key deve essere segreta in tanti altri casi come vedremo la verification key può essere pubblica quindi accessibile anche a un potenziale avversario ok? ok? ok? ok? ok? ok? ok? ok? ok? altri criteri di classificazione dei protocolli di identificazione riguardano la modalità di esecuzione del protocollo di handshaking cioè c'è lo scambio di messaggi che avviene tra prover e verify in particolare l'handshake può essere stateless oppure può essere stateful ok? stateless significa che nel protocollo di handshaking le due chiavi segrete e di verifica non cambiano mai sono sempre le stesse voi potete eseguire il vostro protocollo di identificazione un milione di volte e un milione di volte verranno usate la stessa secret key e la stessa verification key è quello che succede ad esempio quando fate il login su gmail no? ogni volta che fate il login voi almeno finché non la cambiate usate sempre la stessa spazio il che significa che dall'altra parte vennerà usata sempre la stessa verification key ok? ci sono casi invece in cui il protocollo di handshake è stateful non è stateful stateful significa che secret key, verification key cambiano a ogni istanza a ogni sessione ogni volta che voi eseguite il protocollo di identificazione cambia la coppia ok? vedremo esempi che appartengono a entrambe le categorie e infine il protocollo di identificazione può essere one side o mutual one side significa che il prover dimostra la propria identità al verifier ma non viceversa il verifier non ha bisogno di dimostrare la propria identità al prover ok? ad esempio quando voi vi autenticate su gmail siete voi che dite a chi siete non il contrario il protocollo di identificazione può anche essere mutual ovvero un protocollo dove entrambi devono dimostrare la propria identità all'altro ok? anche qui vedremo casi di vario genere quindi i protocolli di identificazione sono il primo esempio di protocollo criptografico che andremo a studiare dove per protocollo criptografico intendiamo quanto abbiamo definito qui quindi il coinvolgimento di due o più parti che partecipano alle sessioni o distanze del protocollo o run del protocollo sono tutti sinonimi queste ogni parte ha la propria memoria che conserva i parametri di configurazione dell'esecuzione del protocollo ogni parte esegue un algoritmo quindi sa quando deve mandare un certo tipo di messaggio dall'altra parte di solito quello che succede è che un protocollo viene eseguito per round quindi che ne so parte uno dei partecipanti l'altro rimane in attesa il primo partecipante manda un messaggio l'altro lo riceve lo elabora e risponde e così via l'ensec di solito va avanti per non più di due o tre round in questa maniera i protocolli criptografici sono sempre piuttosto brevi ok? pochi scambi di messaggi ok? quindi questo per quanto riguarda la natura del protocollo in particolare i protocolli di identificazione e il modo in cui li possiamo classificare l'ultima cosa che rimane da dire prima di descrivere nel pomeriggio alcuni protocolli di identificazione è riferirsi un attimo al comportamento dell'avversario ok? perché noi a un certo punto dovremmo dire se i nostri protocolli di identificazione sono sicuri oppure no ok? ma sicuri rispetto a cosa? bisogna sempre fare riferimento ad un attack model ad un modello dell'attaccante e del motivo per cui le nostre proprietà di sicurezza le abbiamo sempre definite rispetto agli attack game lo scopo dell'attack game è di descrivere formalmente con chi abbiamo a che fare cosa può fare l'attaccante per cercare di violare le proprietà di sicurezza quello è il motivo per cui tutte le proprietà di sicurezza le abbiamo sempre definite rispetto ad uno specifico attack game e qui succede qualcosa di analogo i protocolli di identificazione che andremo a introdurre sono sicuri rispetto a chi? rispetto a quale tipologia di attaccante? e noi ne considereremo tre ci fermiamo ai primi tre perché poi gli attacchi tipo medio e mezzo li affronteremo più avanti e sono via via tre modelli sempre più espressivi quindi partiamo considerando attaccanti poco espressivi e poi aumentiamo passo passo il potere espressivo dell'avversario gli attacchi meno espressivi sono quelli cosiddetti attacchi diretti ok? gli attacchi diretti sono quegli attacchi in cui l'attaccante prova a impersonare il puzzle e il suo obiettivo è quello di ingannare il verifier ok? e lo fa senza aver mai osservato nessuna istanza del protocollo quindi senza aver mai osservato il comportamento del pover questi sono gli attacchi diretti diretti il termine diretto significa proprio questo l'attaccante prova direttamente a interagire col verifier cercando di ingannarlo cioè cercando di convincerlo di essere chi non è ok? poi abbiamo gli attacchi di tipo e-vest dropping sono attacchi un pochino più sofisticati perché gli attacchi di tipo e-vest dropping l'avversario che cosa fa? prima ascolta alcune istanze del protocollo di identificazione quindi fa sniffing del canale osserva cedreziosamente alcune istanze in cui i prover e i verifier interagiscono e vede che cosa succede raccoglie informazioni cioè tutto quello che passa per il canale l'avversario lo ascolta e lo raccoglie poi in una fase successiva basandosi su quello che è delle informazioni che ha raccolto l'attaccante prova a impersonare il prover e ingannare quindi il verifier ok? quindi in pratica nell'attacco diretto l'avversario non sfrutta nessuna informazione nell'attacco di tipo e-vest dropping l'avversario ascolta tutte le sessioni del protocollo che vuole per poi agire per poi attaccare ok? infine c'è la terza categoria quella più significativa che è quella degli attacchi attivi negli attacchi attivi che cosa fa l'avversario? l'avversario in una prima fase finge di essere il verifier e dialoga con il prover cercando di estorcere al prover informazioni utili per l'identificazione una volta fatto questo l'attaccante che cosa fa? usa le informazioni che ha raccolto dal prover per provare a impersonare il prover con il verifier ok? qual è l'esempio tipico di attacco di questo genere che abbiamo visto in passato? quindi il fishing no? perché in un attacco di tipo fishing l'avversario che cosa fa? prima prova in una maniera più o meno sofisticata a convincere il prover a fare il login su una pagina creata dall'avversario quindi di fatto l'avversario sta facendo finta di essere il verifier ok? quindi il prover interagisce con il finto verifier e nell'interagire con il finto verifier magari fornisce delle informazioni dopodiché l'attaccante che ha raccolto queste informazioni che cosa fa? le usa per interagire col verifier genuino originale cercando di impersonare facendo finta di essere il prover ok? questo è un esempio di attacco attivo i protocolli che vedremo noi partiremo con protocolli banali robusti rispetto agli attacchi diretti ma non rispetto agli attacchi di waste dropping poi cercheremo di migliorarli per diventare robusti rispetto agli attacchi di tipo waste dropping ma vedremo che non basta per gli attacchi attivi e infine arriveremo ad una soluzione che ci permette di essere robusti anche rispetto agli attacchi attivi e l'ultima soluzione che vedremo è quel protocollo dovuto a Schnorr che poi è come abbiamo anticipato la base per un algoritmo di firma digitale diverso rispetto a quelli che abbiamo visto prima tutto questo non basta ancora per essere robusti rispetto agli attacchi di tipo man in the middle perché negli attacchi di tipo man in the middle questi sono ancora più sofisticati rispetto agli attacchi attivi perché sono attacchi che prevedono l'esecuzione contemporanea di diverse sessioni del protocollo di identificazione contemporaneamente cioè nel momento in cui se pensate l'unico esempio di attacco di tipo man in the middle che abbiamo visto è quello contro di Fielman in cui c'era l'avversario che contemporaneamente fingeva di essere un utente con il mittente e fingeva di essere un altro utente con il destinatario e quindi allo stesso tempo creava due sessioni con le due parti ingannandole entrambe quello è un esempio di attacco di tipo man in the middle questi sono attacchi ancora più sofisticati che per essere diciamo neutralizzati bisogna complicare ulteriormente le cose anche perché sono difficili da identificare questo tipo di vulnerabilità e quindi vedremo che c'è bisogno di un supporto automatico per riuscire a identificare vulnerabilità di tipo man in the middle in protocolli di identificazione o comunque protocolli crittografici in generale va bene io direi che per stamattina ci prendiamo qui dopodiché oggi pomeriggio iniziamo a vedere un po' di protocolli di identificazione ok grazie a tutti