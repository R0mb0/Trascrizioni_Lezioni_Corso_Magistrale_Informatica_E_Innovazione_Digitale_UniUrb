Ok, allora cominciamo. Dunque, come abbiamo anticipato ieri, l'authenticated key exchange, la tipologia di protocollo il cui obiettivo è quello di garantire due proprietà fondamentali. La prima è l'autenticità. Se l'agente P crede di aver completato un'istanza del protocollo con un agente Q, il cui risultato è la condivisione di una chiave di sessione K, allora deve essere effettivamente vero che P si è autenticato con Q e non con qualcuno che facesse finta di essere Q. Naturalmente vale anche il viceversa. L'altra proprietà è la segretezza, ovvero la chiave K condivisa alla fine dell'esecuzione di questo protocollo deve essere effettivamente confidenziale e quindi nota solo a P e a Q e a nessun altro. Quindi queste sono le due condizioni fondamentali. Abbiamo detto che il problema dell'authenticated key exchange si può risolvere in due modi. A seconda di come e quando interviene il cosiddetto TTP, trusted third party, che ci deve essere comunque in ogni caso, oggi noi parleremo delle soluzioni offline. Quindi quelle soluzioni che, come detto ieri, richiedono una sola interazione, una tantum con il TTP per la creazione di un certificato che leghi l'identità dell'utente alla sua chiave pubblica e dopodiché il TTP non deve più intervenire. Poi più avanti vedremo invece le soluzioni tipo online. Un po' di notazione che useremo nella descrizione formale delle diverse versioni dei protocolli di authenticated key exchange. Vedete che l'identità di un agente P la indichiamo in questo modo, i DDP. CertDP rappresenterà il certificato associato all'agente P e a noi quello che interessa è che questo certificato crei un legame indissolubile e non ambiguo tra quella particolare identità e la chiave pubblica usata da quella gente. A cosa serve quella chiave pubblica lì? Noi per semplicità assumeremo, che è un po' quello che si fa in realtà, assumeremo che quella chiave pubblica può essere usata sia per cifrare, usando un meccanismo di cifratura chiave pubblica, come il Gamalla ad esempio, ma anche per fare firme digitali, quindi per firmare documenti, usando uno schema di firma digitale, ad esempio ECGSA o quel che è. Chiaramente noi qui astraiamo dagli schemi che vengono utilizzati, quindi assumendo che la stessa chiave pubblica si può usare sia per uno schema di cifratura che per uno schema di firma, questo significa naturalmente che i due schemi devono essere compatibili, perché è chiaro che una chiave di un tipo, una chiave RSA, non la potete usare per il Gamalla, faccio un esempio banale. Quindi qui, ripeto, l'unica soluzione che facciamo è che la chiave pubblica la usiamo per entrambe le cose, poi come queste vengono implementate, l'unica soluzione che faremo appunto è che la cifratura la si deve fare usando uno schema di cifratura a chiave pubblica CCA sicuro, è il massimo livello di sicurezza che abbiamo a disposizione, e che invece la firma digitale venga fatta usando uno schema sicuro, anche in questo caso sono assoluzioni minimali. Ancpdm rappresenterà la cifratura fatta con la chiave pubblica di P di un messaggio, di un plaintext M, e sigpdm rappresenta la firma fatta con la chiave segreta di P su un plaintext M, e basta, queste più o meno sono le annotazioni che useremo nella descrizione del protocollo. Le chiavi appartengono a un dominio di chiavi di sessione, così come i nonce, anche queste appartengono a un dominio dei nonce. Questi domini si assume che siano super poli, per i soliti problemi legati al vantaggio dell'avversario. Bene, detto questo, ora andiamo a vedere la prima versione del protocollo di autentichette di exchange tra due agenti P e Q. Vediamo un po' come funziona. L'endshake è molto semplice. Uno scambio di un paio di messaggi, non di più. Dalla parte, vedete, abbiamo P, dall'altra abbiamo Q. P sceglie in maniera randomica un nonce R e lo trasmette a Q insieme al proprio certificato. Ok? Il proprio certificato, quello che ha ottenuto quando si è registrato con il TTP. No? Q riceve queste due informazioni, verifica il certificato, controlla se il certificato è valido. Ad esempio che non sia scaduto da chi è stato emesso, cose di vostro genere. Dopodiché cosa fa? Sceglie in maniera randomica la famosa chiave di sessione K che dovrà essere utilizzata per realizzare una VPN basata sull'autentichette di encryption tra P e Q. Dopodiché segue il paradigma encrypted d'un sign, come potete vedere, perché prima fa la cifratura e poi fa la firma. La cifratura che cosa contiene? La cifratura, vedete, viene fatta con la chiave pubblica di P, perché Q adesso deve mandare un messaggio cifrato a P. E quindi la cifratura la fa con la chiave pubblica di P. Questo per garantire che la cifratura la possa fare solo P. Quindi è un messaggio confidenziale per P. La cifratura che cosa contiene? Contiene K, perché vuole condividere la chiave di sessione, e contiene la propria identità. Ok? Quindi Q risponde con la cifratura della chiave di sessione e della propria identità. Insieme alla cifratura cosa manda anche? La firma, perché abbiamo detto che segue il paradigma encrypted d'un sign. La firma di che cosa? La firma fatta da Q, no? Quindi questa è la firma digitale fatta con la chiave segreta di Q. Di che cosa? Cosa viene firmato? Viene firmato il cifrtext, naturalmente. Ok? Ma viene anche firmato che cosa? Il nonso che P aveva mandato. Ok? E l'identità di P. Cifrtext e firma vengono spediti a P insieme a che cosa? Al proprio certificato. Ok? Ok? Fatto questo, Q è a posto. Ha terminato il proprio ruolo all'interno del protocollo e termina con successo. Ok? Ok? Quindi vedete, due scambi di messaggio. P riceve questa terna di informazioni e che cosa fa? Cosa deve fare P? Beh, deve verificare il certificato di Q. Ok? Se il certificato di Q è valido, cosa fa? Dal certificato legge che cosa? La chiave pubblica di Q che gli serve per verificare la firma che ha fatto Q. Ok? Se la firma è valida, no? Allora P procede decifrando il ciphertext con la propria chiave segreta. Il risultato della decifratura dovrà essere una coppia fatta da una chiave di sessione K e l'identità del DQ. Se così è, anche P termina l'esecuzione dell'istanza del nostro protocollo correttamente. Se entrambi gli agenti terminano con successo questo protocollo, alla fine di questo protocollo, P è convinto di aver parlato con Q e questo è vero. Q è convinto di aver parlato con P e questo è vero. E in più, diciamo, P e Q, resumendola in un'unica descrizione, P e Q sono convinti di condividere tra loro la chiave K, che è confidenziale, nel senso che non è nota a nessun altro. Ok? Perché bisogna evitare anche l'identità posita. Ti rispondo fra poco. Perché tutti gli ingredienti che stanno lì sono tutti indispensabili. Adesso quello che faremo sarà far vedere che togliendo anche solo l'ingrediente da uno qualunque di quei messaggi lì, il protocollo diventa vulnerabile. Quindi la risposta alla tua domanda è se tolgo quelle informazioni, il protocollo diventa vulnerabile ad un attacco. Ok? E poi vedremo quale. Ok? Quindi, volendo riassumere con un'unica frase, qual è la proprietà che questo protocollo soddisfa, è che alla fine dell'esecuzione del protocollo, P è convinto di condividere K con Q e Q è convinto di condividere K con P. E questa condivisione è confidenziale. Ok? Quindi abbiamo autenticazione e segretezza, confidenzialità. Ci siamo? Ok? Un paio di cose da osservare riguardo alla descrizione di questo protocollo. e nel protocollo in diversi punti c'è scritto che la gente può terminare con successo o può abortire. No? Vedete? Non so, molto poco avanti, scusate. Cosa significa questo? Quando è che può abortire il protocollo? Il protocollo chiaramente abortisce quando qualcuna di queste operazioni non va a buon fine. Ad esempio, P non riesce a validare la firma di Q o P non riconosce come valido il certificato di Q o viceversa, P non riconosce come valido il certificato di P. La decifratura che fa P non restituisce una coppia K e di Q. E così via. Quindi se una qualunque delle operazioni che abbiamo descritto all'interno del protocollo dovesse fallire, allora la gente abortisce la sessione. Ok? In tutti gli altri casi, se tutti i calcoli vanno a buon fine, chiaramente entrambi terminano con successo e se entrambi terminano con successo vale la proprietà che dicevamo prima. Ok? Il protocollo, come vedete, non è simmetrico, il ruolo di P è diverso dal ruolo di Q, però non ha importanza chi è che gioca il ruolo di P e chi è che gioca il ruolo di Q. Uno dei due inizia. Alla fine, in ogni caso, le proprietà che otteniamo valgono per entrambi, sia l'autenticazione che la segretezza. Quindi anche se il protocollo è asimmetrico non cambia nulla. E come dicevo anche ieri, dobbiamo immaginare, nel confrontarci rispetto ad attaccanti, ad avversari, che un certo agente possa tenere in piedi contemporaneamente diverse sessioni, diverse istanze di questo stesso protocollo, magari con agenti diversi. e di questa cosa se ne potrebbe approfittare l'avversario. L'avversario stesso potrebbe essere uno dei due agenti. Ok? Quindi il ruolo attivo dell'avversario è tale da permettergli di fatto di poter fare qualunque cosa. a livello di interazione, naturalmente. Chiaro che valgono le proprietà sottostanti che abbiamo sempre detto. Cioè, se lo schema di cifratura a chiave pubblica che viene usato è CCA sicuro, valgono le proprietà della CCA security. Quindi l'avversario non le può violare. E lo stesso discorso vale per la firma. Va bene. Adesso venendo alla domanda che hai fatto. Per quale motivo ci sono tutti questi ingredienti? Non potevamo prendere banalmente, che ne so, sign encryption e usarlo così com'è? O qualcosa del genere? Come detto ieri, potevamo prendere protocolli che abbiamo già visto e combinarli assieme senza elaborare un protocollo particolare. Il motivo c'è, il motivo è che se andiamo a modificare questo schema qua, saltano fuori delle vulnerabilità. Vediamo un po' alla volta. Lo vediamo su tutti gli ingredienti. Cosa succede ad esempio se Q non firma il ciphertext C? Ok? Quindi cosa succede se Q non firma la cifratura della chiave di sessione e della propria identità? Ok? Qui l'ho indicato, no? Indicando in rosso e sbarrando il ciphertext che viene tolto dalla firma. Ok? Bene. In questo caso un avversario può intercettare il primo messaggio proveniente da P. Ok? lo può modificare, nel senso che, cioè modificare, ne può creare una risposta, scusate, sono espresso male. Cioè l'avversario vede che P sta mandando una richiesta del primo messaggio dell'enshake a Q, lo intercetta e crea una risposta. Ok? Ci siamo. Può farlo perché comunque la cifratura è fatta con lo schema chiave pubblica e quindi con la chiave pubblica di P e quindi può fare questa cosa. No, scusate, cosa ho detto? Forse mi sono espresso male. L'avversario intercetta la risposta di Q. Ho detto che... Mi sono incartato. Ho detto che l'avversario intercetta la risposta... L'avversario intercetta la risposta di Q. Scusate. Quindi P manda la richiesta a Q. Ricapitoliamo, riprendiamo. P manda la richiesta a Q. Q confeziona la risposta, la manda a P, ma l'avversario la intercetta. Ecco, adesso ci siamo. Ok? Ora, siccome la firma... Quindi la... È questo il messaggio che viene intercettato dall'avversario. Ok? E in questo messaggio... La firma non protegge il ciphertext, perché abbiamo detto che non c'è più il ciphertext nella firma. Ok? Quindi... Cosa significa questo? Significa che se l'avversario adesso modifica il ciphertext... E può farlo, perché chiunque può creare un ciphertext... Ok? Per P. P non se ne accorge. È chiaro questo? No? Sì, però... Nulla impedisce all'avversario di confezionare un ciphertext come questo. che contiene una chiave scelta dall'avversario e l'identità di Q. È pubblica l'identità di Q. Quando fa la decreta... Allora, vediamo cosa succede se... Quando P riceve questo ciphertext modificato e riceve la firma originale fatta da Q, perché l'avversario modifica solo il ciphertext, non modifica la firma, ora, P verifica la firma e la firma è corretta, perché la firma è fatta sul nonce e sull'identità di P. Non c'è più il ciphertext dentro la firma. Quindi P non si accorge che il ciphertext non è integro. Ok? Quindi la firma viene accettata, dopodiché decifra. E la decifratura di C' dà come risultato una coppia chiave identità di Q. Quindi a quel punto P è convinto di condividere con Q che cosa? K' Che non è la chiave K che aveva scelto Q, ma è la chiave che ha scelto l'avversario. Quindi alla fine della sessione P è convinto di condividere K' con Q quando in realtà la condivide con l'avversario e Q è convinto di condividere K con P. Diciamo adesso? Diciamo adesso? ... Sì We ma questo intercambio occorre in la pubblica network. Quindi, nessuno può intercambi questo, può intercambi nessuno di queste messe. Ovviamente, un'adversario non può decrypare. Ma io posso intercambi e bloc un'adversario. Quindi, noi siamo assomati che l'adversario è attivo. Quindi, può intercambi, solo ridere o bloc, trope a cambiare, e poi forwarde lo che ha già stato. In questo caso, l'adversario intercambi C, blocci, e poi replaci C con C', e poi forwardi C' per P. Righ Oppoth è stato la mano di D'A 04 e poi andmui C' compute C' and then send to P C' Sigma and set co. Ok. Quindi è chiaro che agendo in questa maniera l'avversario riesce a cambiare la chiave e questa è una vulnerabilità piuttosto grave perché l'attacco si chiama T-exposure proprio perché di fatto viene violata sia l'autenticazione che la segretezza perché non è vero che P condivide K' con Q ma la condivide con l'avversario credendo che sia Q condivide K' con un agente che crede sia Q ma non lo è quindi è uno degli attacchi più gravi tutto questo perché perché la firma non protegge il ciphertext perché se la firma proteggeva il ciphertext P quando verifica la firma si accorge subito che il ciphertext è stato cambiato e quindi abortisce ok è chiaro? ci siamo adesso quindi la firma del ciphertext è importante proviamo invece a togliere dalla firma il nose quindi facciamo un giochino simile a quello di prima quindi firmiamo Q firma il ciphertext e l'identità di P ma non firma il nose che aveva scelto P ok? in questo caso l'avversario non fa nulla ascolta legge quello che passa ok? poi però che cosa fa? immaginiamo che più avanti P vuole avviare un'altra istanza del protocollo sempre con Q perché ha bisogno che ne so fra una settimana dopo una settimana P ha bisogno di parlare ancora con Q e quindi gli manda di nuovo la richiesta gliela manderà con un nose nuovo ovviamente perché il nose è scelto in maniera randomica ok? bene l'avversario che cosa fa? intercetta la richiesta e semplicemente la può bloccare non deve non deve non è necessario che inoltre nulla a a Q che quindi non è consapevole di cosa sta di che cosa sta succedendo e cosa fa? risponde al posto di Q inviando a P il messaggio che aveva ascoltato dalla sessione precedente ok quindi torniamo ve lo faccio vedere sul questo è il primo end shake questo qui questo è il primo end shake che va a buon fine ok? secondo end shake sempre fra sempre fra P e Q P manda la richiesta a Q l'avversario la blocca a Q non arriva niente poi cosa fa l'avversario? prende la risposta che Q aveva mandato a P nella sessione precedente e la manda a P quindi replica a P questo messaggio ok? P P non se ne accorge perché non se ne accorge? perché il nonce non viene firmato ogni richiesta al suo nonce allora immaginiamo che nella prima istanza il nonce che P aveva scelto era R la la seconda istanza il nonce era R' ok? quindi la seconda volta se fosse veramente Q a rispondere risponderebbe con un messaggio che è relativo al nonce R' non al nonce R' che è già stato usato prima però se noi togliamo il nonce dalla firma nella risposta di Q a P non c'è nessun riferimento al nonce non c'è più perché nella cifratura non c'è nella firma non c'è quindi la risposta che Q aveva dato a P nella prima istanza può essere riciclata dall'avversario anche nella seconda istanza P non se ne accorge e questo è un replay attack replay perché un messaggio che è stato letto dall'avversario in ascolto durante una sessione viene replicato dall'avversario in un'altra sessione ok? qual è il problema di questo replay attack? il problema è che quando P riceve la risposta questa è valida è valida perché la risposta era stata sviluppata da Q l'unico l'unico problema è che P non si accorge che questa risposta era relativa alla prima istanza e non dovrebbe essere relativa alla seconda istanza non se ne accorge perché? perché non c'è nessun riferimento al NOS ok? quindi alla fine che cosa succede? succede che P termina con successo il protocollo è convinto di aver completato una sessione con Q ed è convinto di condividere K con Q ok? e dov'è il problema? il problema è che se adesso P attiva una VPN e spedisce in autenticata di encryption un messaggio a Q cifrato con K ok? l'effetto qual è? l'effetto è che l'avversario si ritroverà per le mani a leggere diversi messaggi cifrati con la stessa chiave perché si ritroverà i messaggi della prima istanza ma anche quelli della seconda e questo potrebbe indebolire la chiave a seconda del sistema di cifratura che viene usato ad esempio se il sistema di cifratura è vulnerabile al to time pad come nel caso degli stream cipher o del randomized counter mode ecco che un tentativo di critanalisi a parte dell'avversario potrebbe avere successo e quindi questo comporterebbe una violazione della segretezza quindi in pratica con questo attacco l'obiettivo dell'avversario è convincere P a usare due volte la stessa chiave K questo attacco non sarebbe efficace appunto se la firma contenesse anche il nonce perché la seconda volta che P manda una richiesta Q la manda con un nos diverso da R diciamo un nos R' quindi Q l'avversario non può prendere la vecchia risposta di Q che conteneva la firma di R e usarla per convincere P che quella sia la risposta della nuova istanza perché perché in realtà dovrebbe contenere la firma di R' non di R e quindi P se ne accorge subito quando P verifica la correttezza della risposta che riceve si accorge subito che la firma che riceve riguarda R non riguarda R' allora si accorge subito che quello è un messaggio replicato e quindi lo ignora e abortisce ok quindi questo è il motivo per cui è necessario firmare per cui firmare anche il non questo permette di ed è un problema comune vedremo altri attacchi che sfruttano questa debolezza è sempre utile è sempre necessario avere un modo per collegare ogni messaggio di una specifica sessione perché altrimenti si è vulnerabili a replay attacchi cioè se osservando un messaggio non c'è modo di capire che quel messaggio fa riferimento a una sessione o un'altra allora questo lo espone ad attacchi di tipo replay da parte dell'avversario e qui il ruolo di R del non è proprio questo associare in maniera inequivocabile un messaggio ad una certa sessione quindi se vogliamo R lo potete interpretare come una sorta di identificatore di sessione ecco mettiamola così di esecuzione del protocollo ok c'è un altro attacco di tipo replay in questo protocollo che si può verificare nel caso in cui adesso non mi ricordo se questa era la domanda che mi avevi fatto prima nel caso in cui la cifratura non contenga l'identità di Q ok quindi immaginiamo che la cifratura contenga solo la cifratura scusate contenga solo K ok e non contenga i d di Q ok bene immaginiamo che una prima sessione tra P e Q vada a buon fine e viene completata ed eseguita una sessione in cui P e Q alla fine condividono K l'avversario ascolta copia i messaggi di questa sessione dopodiché più avanti che cosa succede magari P vuole iniziare a una nuova sessione con un altro agente e questo agente è malevolo ok quindi vedete prendiamo in considerazione anche scenari in cui l'avversario potrebbe essere uno dei due agenti coinvolti nel protocollo quindi immaginiamo dopo la sessione tra P e Q una sessione tra P ed R dove R è malevolo ok quindi P in questa nuova sessione P manderebbe la richiesta fatta così a R e R gli risponderebbe in che modo potrebbe rispondergli mandandogli lo stesso C che Q aveva mandato P lo stesso identico C ok la firma chiaramente sarebbe diversa sarebbe la firma fatta da R su R' primo C identità di P e poi il proprio certificato ok vedi anche questo è un reply attack perché l'avversario sta sfruttando un messaggio che aveva copiato da una sessione precedente P fa tutti i controlli del caso tutti validati niente va niente fallisce e quindi alla fine che cosa succede? alla fine succede che P si è autenticato con R e i due condividono che cosa? la stessa chiave che P aveva usato con Q ok in realtà in realtà R non conosce questa chiave no non la conosce perché non non è in grado di decifrare C però ciò che conta è che P è convinto di condividere K con R quindi quando P creerà la VPN e manderà un messaggio cifrato a R vale lo stesso discorso che abbiamo fatto prima R si ritroverà con un messaggio cifrato con una chiave K di cui ha anche altri messaggi mandati in precedenza da P a Q nella prima sessione cifrati con la stessa chiave e quindi se cifrare è vulnerabile al tuo time pad può fare critanalisi quindi alla fine l'obiettivo è sempre lo stesso indurre P a usare due volte la stessa chiave ok quindi anche questo un reply attack fatto con la stessa con la stessa finalità tutto perché manca l'identità dentro il ciphertext se ci fosse stata l'identità dentro il ciphertext chiaramente R non avrebbe potuto riciclare il ciphertext C creato da Q perché lì dentro c'è l'identità di Q ok ora voi direte vabbè questi ultimi due attacchi che hai che hai descritto si potevano evitare se P tenesse traccia delle chiavi che ha usato per cui se fa una sessione in cui il risultato è la chiave K poi più avanti fa un'altra sessione e vedi che il risultato è sempre la stessa chiave K allora vedi che c'è qualcosa che non va il punto è però che il materiale crittografico quindi chiavi non e quant'altro viene sempre cancellato quando una sessione viene chiusa per motivi di sicurezza chiaro non si mantengono mai quelle informazioni che domani potrebbero essere sfruttate da un avversario che viola fa penetration del mio sistema della mia macchina legge le chiavi di sessione e quindi potrebbe andare a decifrare tutte le vecchie conversazioni che ha avuto la gente ok quindi di solito le chiavi di sessione tutto il materiale crittografico di sessione incluse le chiavi di sessione viene sempre cancellato poi andiamo avanti ne abbiamo visti quasi tutti proviamo a vedere che cosa succede penso sia l'ultimo ma abbiamo provato a eliminare tutto dallo schema dal protocollo cosa succede se non firmo se Q non firma l'identità di P ma firma solo non e ciphertext anche qui ci si espone ad un attacco un po' più complicato fatto da un avversario che che crea un nuovo agente R R quindi un agente malevolo qui l'avversario deve riuscire a fare una cosa che non è detto che ci riesca però è plausibile in certi contesti ovvero l'avversario registra un nuovo agente con la stessa chiave pubblica di P ma come è possibile che io posso ottenere un certificato da una certification authority relativa alla chiave pubblica di qualcun altro questo è possibile se la certification authority quando vi registra non vi chiede la proof di conoscenza della chiave segreta associata a quella chiave pubblica ok e quindi in un contesto in cui la gente sceglie la coppia di chiavi pubblica e segreta e trasmette le proprie informazioni insieme alla chiave pubblica alla certification authority la certification authority verifica l'identità non fa nessun check sulla chiave pubblica e rilascia il certificato ecco che in quel caso io posso io l'utente potrei aver dichiarato qualunque chiave pubblica adesso questo fortunatamente con le certification authorities che ci sono in circolazione non succede non succede più è una cosa che non dovrebbe più capitare insomma però è una cosa che poteva capitare in certi contesti non è detto che capita ancora quindi immaginiamo che per colpa del TTP di una denigligenza del TTP l'avversario riesce a registrare un agente con la stessa chiave pubblica di P ok cosa succede? allora immaginate che ad un certo punto P avvia un'istanza con Q ok e quindi gli manda la richiesta R corredata dal proprio certificato e l'avversario R intercetta la richiesta la blocca e la sostituisce così cioè lascia il nonso ma sostituisce il certificato di P con il suo certificato ok ok P risponde notate che nella risposta di Q non c'è più nessun riferimento a P nella firma c'è solo il fatto che nella risposta usa una chiave pubblica che per Q è quella di R ma contemporaneamente anche quella di P ok l'avversario prende la risposta la inoltra così come è a P senza alterarla P la verifica e tutto va bene e quindi alla fine che cosa succede? Succede che P è convinto di essersi autenticato con Q quindi di condividere la chiave di sessione con Q invece Q pensa di parlare con R condividendo la stessa chiave di sessione ok quindi P e Q è vero che condividono la stessa chiave di sessione è vero che la chiave di sessione è segreta è confidenziale perché l'avversario in questo scambio non impara nulla della chiave no? però però non vale la proprietà di autenticazione perché è vero che P pensa di condividere K con Q ma non è vero che Q pensa di condividere K con P anzi pensa di condividere K con R e quindi questo è un cosiddetto attacco di tipo identity misbinding dove appunto l'attacco è rivolto all'autenticazione dato che uno degli agenti pensa di parlare con la persona sbagliata ok e questo in situazioni reali può essere piuttosto sconveniente perché adesso immaginate uno scenario in cui dopo questo handshake P apre una VPN basata su K per parlare con Q e gli manda un messaggio un messaggio arriva a Q il problema qual è? il problema è che Q pensa che quel messaggio non stia arrivando da P pensa che stia arrivando da R ok se P ed R sono clienti di una banca e Q è la banca questo significa che le richieste che arrivano dalla banca da P la banca le interpreta come se fossero le richieste che arrivano da R ok ok ci siamo anche in questo caso tutto chiaro? quindi direi che abbiamo esaminato tutte le componenti della firma la necessità di riportare le necessità di Q dentro il ciphertext quindi direi che le abbiamo viste tutte ah sì c'è un'altra versione un'altra versione ancora in cui ho provato a sostituire l'identità di Q nel ciphertext con il nonce che come intuizione ci può anche stare visto che l'abbiamo detto prima il nonce agisce come identificatore di sessione però il problema è che comunque anche facendo così nella risposta di la cifratura anche se anche se la firma uno pensa vabbè dentro il ciphertext non c'è più l'identità di Q ma chi se ne frega tanto il ciphertext viene firmato da Q no quindi perché devo inserire l'identità di Q dentro il ciphertext se poi tanto quel ciphertext è Q a firmarlo e la firma può essere verificata è giusto apparentemente è giusto però però in realtà è sbagliato è sbagliato perché che cosa può succedere in questo caso di nuovo l'avversario registra un nuovo agente R ok che quindi sarà malevolo immaginiamo che ci sia già stata una sessione completata correttamente tra P e Q ok come si comporta l'avversario quando P inizia una nuova istanza ok l'avversario che cosa fa crea una richiesta per Q una finta richiesta per Q perché perché sembra provenire da P quando in realtà proviene da ragione R ok quindi il manda questo ok quando Q risponde sostituisce la firma ok quindi Q risponde con la cifratura di K e di R con la chiave pubblica di P e a quel punto Q l'avversario sostituisce la firma la sostituisce in questo modo o può fare e inoltre a P questa risposta ok la cifratura che aveva creato Q la firma che ha creato lui e il proprio certificato alla fine di questo attacco P come vedete pensa di aver parlato con R Q invece pensa di aver parlato con P ok di nuovo l'avversario non sa nulla della chiave ma tanto a lui quello che interessa è aver imbrogliato sulle identità coinvolte anche qui l'impatto può essere devastante mettete caso che P Q ed R siano due clienti di una banca Q e la banca le cose l'impatto può essere devastante perché nel momento in cui si fa confusione sull'identità può succedere di tutto ok quindi vedete anche situazioni anche aggiustamenti del protocollo che potrebbero essere sembrare sensati in realtà hanno degli effetti devastanti a livello di sicurezza del protocollo stesso qui la lezione la lezione da imparare qual è è che bisogna mai lesinare sulle informazioni che vengono trasmesse nei messaggi mai risparmiare un'informazione in più nei messaggi che vengono trasmessi e in particolare bisogna sempre fare attenzione a ad avere un modo univoco di associare ogni messaggio ad una sessione questo per evitare gli attacchi tipo replay e l'altra cosa è di far sì che ci sia sempre chiarezza su chi è mittente o destinatario di un messaggio ok perché questo serve per evitare attacchi di costruzione qua ad esempio ad esempio in C ambiguità sul destinatario non ci può essere perché C è cifrato con la chiave pubblica di P ambiguità sul mittente invece ci può essere se omettiamo l'identità di CUD dal plaintext dentro C e questo è il motivo per cui nel protocollo non possiamo fare a meno di i dq dentro e che se lo sostituiamo con R o addirittura lo togliamo diventiamo vulnerabili in un attacco perché sia che lo togliamo sia che lo sostituiamo con qualcos'altro rendiamo quel ciphertext ambiguo rispetto al mittente ok non lo è rispetto al destinatario perché ripeto è cifrato con la chiave pubblica di P quindi ci sono problemi un discorso analogo vale sulla firma allora ambiguità sul mittente non ci può essere il mittente è Q perché la firma l'ha fatta Q ci può essere ambiguità sul destinatario se voi non firmate l'identità di P ok quindi i due fattori comuni a tutte le varianti deboli che abbiamo visto sono questi cioè sincerarsi che ogni messaggio sia associabile univocamente ad una certa sessione e sincerarsi che in ogni messaggio non ci sia ambiguità di mittente e destinatario bene questa è la prima versione del protocollo di authenticated key exchange che abbiamo visto che però non è ideale se volessimo soddisfare anche altre proprietà in particolare una delle proprietà che di solito è molto interessante è garantire la perfect forward secrecy cosa dice questa proprietà qual è l'obiettivo di questa proprietà che se un agente perde o si fa rubare la propria chiave segreta allora questo qual è l'effetto di questa di questa cosa l'effetto è che tutte le vecchie sessioni eseguite da quella gente sono compromesse a livello di confidenzialità se torniamo torniamo qui se se P perde la propria chiave segreta allora l'avversario che gliela ruba può decifrare C recuperare K e quindi compromettere la segretezza di tutte le comunicazioni che P e Q hanno fatto all'interno di quella sessione no e e questo chiaramente lo vorrei militare non è un'ipotesi così remota se la chiave segreta associata a questa cifratura è la stessa chiave di firma che usa la gente ed è quella che magari si trova sulla smart card che la gente ha ottenuto quando ha fatto il certificato digitale con una certification authority ok il problema il problema è che quella coppia di chiavi lì che trovate sulla smart card in questo protocollo viene usata sia per fare le firme che per fare le cifrature è quello il problema e la soluzione consiste nel disaccoppiare queste due operazioni quindi evitare che le chiavi di sessioni vengano cifrate usando la chiave pubblica ok la chiave pubblica la si dovrebbe usare solo per verificare le firme e mai per cifrare ok per cifrare si dovrebbe usare qualcos'altro e questo qualcos'altro dovrebbe morire insieme alla sessione esatto dovrebbe avere la stessa durata della session key ok e infatti l'idea qual è? l'idea è appunto di usare la chiave pubblica quella di lunga durata quella associata alla smartcard della gente solo per il discorso delle firme quindi si usa solo per fare la verifica delle firme quindi la chiave segreta della smartcard l'ha usata solo per firmare la chiave pubblica della smartcard l'ha usata solo per verificare le firme punto mentre invece per fare la cifratura che serve all'interno del protocollo quindi in particolare per cifrare la chiave di sessione k si usa un'altra coppia di chiavi che dopo essere stata usata per la sessione si cancella butta via ok questa nuova coppia che deve essere fresh nuova per ogni sessione quindi è una coppia anche questa non è una chiave di sessione ma una coppia chiave pubblica privata di sessione viene chiamata ephemeral effimera effimera perché perché è una coppia di chiavi associata alla sessione una volta che la sessione è stata creata quella coppia può essere cancellata e una volta che la cancellate se a posteriori anche se a posteriori un avversario dovesse andare a rileggere l'enshake del protocollo si ritrova un ciphertext che al cui interno dovrebbe esserci la chiave di sessione k quel ciphertext non è più decifrabile perché? perché è stato creato tramite una coppia di chiavi che non esiste più è stata cancellata ok? che è una coppia effimera no? quindi la variante è questa del nostro protocollo originale cambia pochissimo se non il fatto appunto che deve essere creata questa coppia effimera no? la coppia effimera è questa quindi è una coppia chiave pubblica chiave segreta che viene usata per la cifratura e decifratura ok? e a questo punto il nonce non serve più il nonce r non c'è bisogno di usarlo perché al posto del nonce useremo la chiave pubblica di questa coppia effimera perché tanto anche questa è randomica come lo sarebbe come lo era prima il nonce quindi è inutile avere tutte queste informazioni randomiche abbiamo la chiave pubblica usiamo quella tant'è che il primo messaggio che più manda e che prima era questo ok? questo era il primo messaggio che più mandava viene sostituito da questo ok? dove vabbè il certificato rimane la chiave pubblica effimera gioca il ruolo di nonce e verrà usata per la cifratura in più c'è un elemento in più vedete che è la firma fatta da P della chiave effimera ok? quindi questa roba qua quindi questo è il nuovo messaggio che P manda al posto di questo quando Q lo riceve apre il certificato verifica che sia che sia corretto se il certificato è corretto legge dal certificato di P la chiave pubblica di P che è usata solo come chiave di verifica per le firme a questo punto e tramite questa chiave di verifica controlla la correttezza della firma ok? ok? se la firma è corretta allora Q userà la chiave pubblica effimera per vedete per creare il cifr text lo stesso di prima ok? dopodiché la struttura della risposta di Q è la stessa di prima ovvero Q crea il cifr text di K e la propria identità dopodiché fa la firma di che cosa? prima faceva la firma del NOS del cifr text e della identità di P il NOS è stato sostituito dalla chiave pubblica effimera e il resto rimane com'è quindi vedete l'impianto dell'handshake è identico cambia solamente l'avvio dove il NOS è sostituito da una chiave pubblica effimera che Q userà per fare la cifratura perché è importante c'è un ingrediente che prima non c'era che è questo perché è importante che più firmi la chiave pubblica effimera prima non faceva la firma del NOS non c'era bisogno perché come? beh è ancora più semplice in realtà questa firma allora prima R veniva usato solo come NOS e quindi non aveva altri ruoli ok qui la chiave pubblica effimera oltre che a funzionare come NOS funziona anche come come chiave di cifratura ok quindi siccome Q deve cifrare la chiave di sessione usando questa chiave effimera deve avere la garanzia che quella chiave effimera appartenga a P ok prima questo problema non se lo poneva perché? perché il ciphertext lo creava con la chiave pubblica di P la prendeva dal certificato quindi aveva la garanzia che quel ciphertext potesse essere decifrato solo da P adesso non ce l'avrebbe più la garanzia che quel ciphertext venga effettivamente decifrato da P eh sì esatto e sostituire una esatto senza la firma l'avversario potrebbe intercettare la richiesta sostituire la chiave pubblica effimera con una creata da lui dopodiché quando Q risponde il ciphertext verrebbe decifrato dall'avversario non da P e quindi si violerebbe la segretezza di K ok si potrebbe comportare come un man in the middle che fa questa cosa e poi riconfeziona il messaggio contenente K da mandare da mandare a P così P completa il protocollo Q anche però condividono una chiave che conosce anche l'avversario ok quindi per garantire Q che questa sia effettivamente una chiave pubblica effimera scelta da P e non da qualcun altro ecco che interviene la firma di P su questa chiave effimera ok se no salterebbe il banco di nuovo ok il resto ripeto è assolutamente identico con questa versione noi garantiamo anche la perfect forward secrecy perché perché quando questo handshake finisce e P e Q cominciano a dialogare sulla VPN usando K no la coppia effimera questa non serve più a niente viene cancellata tanto P e Q hanno già condiviso K quindi la coppia effimera non serve più viene cancellata quindi questo significa che questo non potrà mai più essere decifrato e quindi un avversario non avrà modo di recuperare K in nessun modo ok quindi contrariamente a quello che avevo detto all'inizio non è buona cosa usare la stessa chiave pubblica con la corrispondente chiave segreta per fare sia cifratura che firme digitale ma è bene separare i due ruoli i due compiti e il motivo è quello che abbiamo appena visto non è finita manca ancora un'ultima un'ultima versione e se rivediamo questo ma anche la la versione precedente una cosa che possiamo notare è che i certificati viaggiano in chiaro no qui e qui quindi questo protocollo non non preserva in nessun modo la privacy tutti quanti gli avversari che ascoltano il canale sanno osservando questo protocollo che P e Q parlano ok questa è una violazione della privacy ma di più il protocollo non è proprio fair equo del tutto perché essendo asimmetrico Q impara che P vuole parlare con lui prima di completare il protocollo ok invece P impara di parlare veramente con Q solo quando termina il protocollo quindi la simmetria di questo protocollo rende un po' iniqua la situazione tra P e Q ok l'ideale sarebbe una versione in cui l'identità di ciascuna gente è protetta sia rispetto a potenziali avversari quindi sia rispetto al mondo esterno ma anche rispetto all'altro agente almeno fino a quando non siamo arrivati al termine e quindi al successo ok per poter garantire questo livello di privacy bisogna cambiare leggermente il protocollo e aggiungere l'uso di uno schema di cifratura a chiave simmetrica il cui obiettivo è quello di cifrare i certificati di fatto ok questa è la terza versione del nostro protocollo di autenticazione con chiave e vediamo che cosa succede inizia inizia P che come prima genera una coppia effimera e spara fuori la chiave pubblica ok solo quella non manda non manda nient'altro non manda il proprio certificato e quindi non mandando il proprio certificato non può neanche mandare una firma perché non sarebbe verificabile ok quindi spara direttamente la chiave pubblica effimera Q che cosa fa Q sceglie tre chiavi simmetriche quindi per un cifrario simmetrico una è la chiave di sessione che sarà quella che condividerà alla fine del protocollo ok le altre due invece servono per l'esecuzione stessa del protocollo e per cifrare le informazioni sensibili ok dopodiché che cosa fa crea questi questi messaggi qua vediamo un po' che cosa comprendono il primo è un cifrtext creato usando un cifrario a chiave pubblica e usando come chiave pubblica quella che aveva ricevuto dal mittente ancora non sa chi è il mittente no ancora non lo sa e che cos'è che cifra usando quella chiave effimera k k1 e k2 la chiave di sessione e le altre due chiavi accessorie ok poi fa una firma che cosa firma la chiave effimera che aveva appena ricevuto e che ha usato per la cifratura e chiaramente firma il cifrtext questo è un identificatore poi capiremo tra poco che cosa serve ok quindi di fatto k2 firma il cifrtext che ha appena creato e firma la chiave pubblica effimera che aveva ricevuto poi che cosa fa crea un altro cifrtext crea un altro cifrtext che serve per proteggere il proprio certificato no infatti vedete che usando un cifrario simmetrico con chiave k1 cos'è che firma firma scusate cos'è che cifra cifra la propria firma e il proprio certificato quindi ciò che viene sparato nel canale alla fine è qualcosa di completamente protetto perché sono due cifrtext non c'è niente che viaggia in chiaro ok il primo cifrtext contiene la cifratura con chiave pubblica di tutto il materiale crittografico simmetrico il secondo cifrtext contiene firma e certificato ok ok bene ora che cosa fa P? P riceve questi due cifrtext la prima cosa che fa P naturalmente è usando la chiave effimera segreta decifrare C ok quindi P inizia decifrando questo usando la chiave segreta corrispondente a questa chiave pubblica effimera qua quindi così facendo P recupera K K1 e K2 ok ora che ha recuperato K1 può decifrare C1 ok e quindi ottenere la firma di Q e il certificato di Q quindi a questo punto P verifica la validità del certificato di Q ne legge la chiave pubblica e di verifica e la usa per verificare la firma Sigma 1 ok firma che tutela garantisce l'integrità di di C del cifrtext C e della chiave pubblica effimera usata per cifrare C che è quella che aveva scelto P a questo punto P deve rispondere a sua volta P termina con successo è convinto di parlare con Q e allora gli risponde gli risponde con che cosa con una firma fatta sulla chiave pubblica effimera e sullo stesso cifrtext C che ha ricevuto da Q in pratica il ruolo di questa firma è di confermare a Q che quella chiave pubblica effimera lì proviene da P e non da qualcun altro e per confermare anche di aver ricevuto correttamente il cifrtext che contiene tutto il materiale crittografico quindi tutte le chiavi l'altro elemento è un cifrtext creato usando K2 l'altra chiave simmetrica e di che cosa? Beh della della firma che ha appena fatto e del proprio certificato dopodiché spara in output questo cifrtext e termina con successo dall'altra parte Q riceve il cifrtext lo decifra perché conosce K2 legge il certificato di P verifica che sia vaido dalla chiave di verifica del certificato controlla la validità di sigma 2 e se tutto va bene termina anche lui con successo quindi vedete in pratica qui dentro quali sono i messaggi che viaggiano questo è il primo messaggio una chiave pubblica effimera questo è il secondo messaggio due cifrtext questo è il terzo messaggio un cifrtext quindi dal punto di vista dell'avversario non si sa chi ha parlato con chi l'altra parte P quando è sicuro di avere parlato con Q gli svela la propria identità quindi vedete K1 e K2 servono per mantenere tutto diciamo protetto l'unica informazione in chiaro che viaggia è la chiave pubblica effimera però la sua paternità è la chiave pubblica a un certo punto viene svelata no viene svelata da sigla 2 ok quindi a un certo punto Q ha la certezza dell'origine di quella chiave effimera e solamente quando verifica quella firma Q termina con successo non prima e questo è importante perché altrimenti chiunque potrebbe generare una chiave pubblica effimera e far finta di essere P poi però a un certo punto deve poter firmare con la chiave di P quella chiave effimera e questo lo può fare solo P ok quindi Q accetta la terminazione con successo del protocollo solo dopo aver verificato la firma di P sulla chiave effimera ok il fatto che P firmi anche C è un'ulteriore tutela del fatto che Q si convince anche del fatto che P è d'accordo a condividere la chiave di sessione K perché C contiene K quindi con la verifica di sigma 2 Q non solo si convince di aver parlato con P ma si convince anche del fatto di condividere K con P che sono le due condizioni che ci interessano lato P lato P lui queste convenzioni le ha avute tutte da sigma 1 che è la firma che Q ha fatto sulla chiave effimera e su C ok perché P da questo messaggio qui P si convince che sta parlando con Q e si convince del fatto che Q è d'accordo con dividere K quindi vedete che entrambi alla fine sono convinti della stessa cosa no notate notate il le due firme no sigma 1 e sigma 2 sono firme fatte sulle stesse informazioni ok perché entrambi le firme vengono fatte su la chiave pubblica effimera e su C no allora qual è il ruolo di questo 1 qua su e di questo 2 qua giù serve solo per distinguere no i due messaggi cioè questo 1 qui sta a significare che sigma 1 è la firma che io posso trovare nella risposta dal destinatario Q al mittente P ok questo 2 qua invece sta a significare che quella firma si riferisce alla risposta che l'ittente P dà al destinatario Q perché ci mettiamo anche questi identificatori beh come al solito per evitare dei replay attack perché e non ne sappiamo gli effetti però potrebbero essercene un avversario potrebbe immaginate che non ci sia questo ok immaginiamo ora il ruolo di sigma 1 qui è chiaro è la firma che Q fa in risposta ad una richiesta di P ma se noi togliamo l'1 un avversario prende questo messaggio e lo replica qua in un'altra istanza cambia ruolo cambia completamente il ruolo perché diventa no ripeto qui diventa la risposta la firma che il destinatario di una sessione manda al mittente qua invece è la risposta che il mittente manda al destinatario nell'ultima fase di una sessione se voi li scambiate state cambiando il ruolo di mittente al destinatario e usandoli all'interno di un'altra sessione in un attacco di tipo replay potrebbero succedere delle cose strane invece con quelli due identificatori lì è chiaro che un messaggio di un tipo non può essere replicato in un'altra fase del protocollo di un'altra sessione quindi questa è un'ulteriore tutela rispetto al discorso del replay attack ok questa è l'ultima anzi la penultima versione ce n'è un'ultimissima ma che cambia di poco ce la faccio vedere perché è una banalità poi invece la prossima volta vi faccio vedere che di fatto questo protocollo che abbiamo appena descritto è quanto viene implementato in TLS vi farò vedere con poche differenze però il sistema è questo l'ultima versione riguarda il discorso della mutua autenticazione ora questa versione qui è la più completa perché è una versione in cui sia P che Q si autenticano reciprocamente Q fa vedere il proprio certificato a P P fa vedere il proprio certificato a Q ma non sempre i protocolli A che sono protocolli di mutua autenticazione spesso sono invece protocolli di one side authentication cioè autenticazione fatta solo da uno dei due rispetto all'altro tipicamente Q ok immaginate che questa sia una comunicazione client server P è il client Q è il server ok di soliti i server del certificato ce l'hanno quindi Q Q il certificato ce l'ha quando mai P ha un certificato a volte ce l'ha a volte no quando voi eseguite questo protocollo per istanziare una sessione sul vostro home banking o sul vostro server di posta o su un altro servizio qualunque il server con cui interagite il certificato ce l'ha quindi lui si autentica nei vostri confronti lui è Q ma voi non avete un certificato quindi voi non vi autenticate ok l'autenticazione voi la fornite dopo in un altro modo ad esempio login con login quindi in una situazione di quel genere che cosa succede voi siete il client eseguite questo protocollo col server quindi voi siete il client P il server è Q eseguite questo protocollo senza autenticarvi voi non avete un certificato ma il server si autentica ok quindi alla fine di questa sessione voi sapete che state parlando con il vostro home banking con il vostro server di posta con Amazon con qualunque servizio server rappresenti lui ancora non sa con chi sta parlando però se voi non avete esibito non avete un certificato di esibire però vi siete avete condiviso una chiave K di sessione a quel punto ok e usando quella chiave potete aprire una VPN e dentro quella VPN a quel punto voi vi dovete identificare dire chi siete e lo fate con i metodi classici ad esempio eseguendo un protocollo di identificazione tramite lo viene e passo allora a quel punto una volta eseguito il protocollo di identificazione anche il server che sta dall'altra parte saprà con chi sta parlando chiaro ok però ripeto raramente succede che eseguendo questo protocollo entrambi hanno un certificato se entrambi ce l'hanno l'abbiamo visto basta eseguire questo e l'autenticazione è reciproca ok se P non ha un certificato però questo protocollo dobbiamo poterlo eseguire lo stesso è chiaro che l'autenticazione non sarà reciproca ma sarà solo one side cioè sarà solo Q che si è autenticato rispetto a P ma non viceversa ma quello è un problema che verrà risolto eventualmente dopo ok questo è quello che succede quando ad esempio entrate sul vostro Amazon quando entrate sul vostro Amazon che cosa succede prima cosa viene eseguito questo protocollo qui senza l'uso di un certificato da parte vostra ok alla fine dell'esecuzione di questo protocollo voi condividete in quella sessione una chiave di sessione con Amazon che viene usata per creare una VPN in autenticato di encryption all'interno della quale voi inserite le vostre credenziali con la password e allora a quel punto Amazon vi riconosce ok questo è tutto automatico nel senso che quando voi vi collegate su Amazon l'indirizzo è un HTTPS quindi vuol dire che c'è TLS sotto che fa questa roba qua crea la VPN quindi esegue questo protocollo non in mutua ma in one side authentication perché solo corsa autentica P&O e dopo che è stata creata questa sessione a quel punto voi inserite login e password allora a quel punto Amazon sa che quella VPN è stata creata con un utente specifico però finché non inserite le credenziali il server non lo sa con chi sta parlando sono documentari sinurso distante combinazione io in questa fase propondo l'initiale creation ovviamente locking c'è Quindi questa è l'idea del protocollo H client server, cioè one side. Q si autentica, P invece no, perché Q ha un certificato, P non ce l'ha. E questa è la versione del protocollo dove appunto solo Q si autentica. Facciamo un attimo il confronto con quella di prima. Voi immaginate di prendere questo e trasformarlo in una versione in cui P non si autentica. Quindi cos'è che non può fare P? P non può creare una firma, perché non ha un certificato. Quindi è inutile che C2 mandi una firma e un certificato, perché P non li ha. Quindi in teoria, in questa fase, P non dovrebbe fare niente. Allora, per rendere usabile lo schema di questo protocollo, anche quando P non ha un certificato, si fa così. Nell'ultimo step, quello in cui P dovrebbe mandare la cifratura di firma e certificato, P manda una cifratura di che cosa? Di due template vuoti. Dammi sono due template vuoti. Qui dovrebbe starci la firma e qui dovrebbe starci certificato. Poi chiaramente qui ci dovrebbe essere anche la firma, ma la firma non ha una firma da mandare. La risposta viene mandata comunque come acknowledgement, che fa terminare l'andshake esattamente come nella versione two side. Quindi in questa versione qui succede la stessa roba che è successa prima, con l'unica differenza che P non si autentica. Però in ogni caso, Q si è autenticato con P, P sa che sta parlando con Q, Q ancora non sa con chi sta parlando, P e Q condividono K. Allora a quel punto, in autenticata di encryption, si crea una VPN, encrypt the MAC, MAC then encrypt, e a quel punto P attraverso il canale protetto manderà le informazioni che gli consentono di identificarsi. Ok? Ad esempio basandosi su un meccanismo di identificazione di quelli che abbiamo visto l'altra settimana. Ok? E questo è tutto. Anzi, l'ultima slide, visto che è l'ultima, vi faccio vedere anche questa. Abbiamo parlato di chiave di sessione, K, associata alla sessione. In genere, a ogni sessione viene associato anche un identificatore. Ok? Cioè un valore univoco che di fatto è legato alla sessione e ne rappresenta l'identità. E che cos'è questo identificatore di sessione? Beh, è un qualunque valore fresh che è associato univocamente a quella sessione. Ora, di valori randomici fresh che viaggiano all'interno del protocollo ce ne sono tanti. Basta usare quelli come identificatore di sessione. Ok? Di solito, di solito, l'identificatore di sessione è una tupla che chiaramente contiene informazioni su chi sono i due host coinvolti. Ok? Più valori randomici che sono associati univocamente a quella sessione. Ad esempio, nella primissima versione del protocollo, il nonse R e il ciphertext sono valori randomici. E quindi potrebbero far parte dell'ID di sessione. Nella versione 2 successiva, dove si sostituisce, si utilizza la chiave, la coppia di chiavi effimere, la chiave pubblica effimera ha un valore randomico e quindi può essere usato come identificatore di sessione, perché sessioni diverse useranno chiavi effimere diverse. e idem per il ciphertext. Quindi fino ad arrivare all'ultima versione, che è quella che abbiamo visto qui, dove come ID di sessione di solito si usa questa coppia di valori unitamente alle due identità. e questo serve per associare, dare un'identità, dare un identificatore a tutto quello che riguarda una specifica sessione. Ok? Una sorta di token di sessione che la identifica. Bene. Direi che ci possiamo fermare qua, ho finito anche lo slide. Quindi siamo a questa. Prossima volta vi faccio vedere come questa roba qui è implementata dentro TLS. Noi ci vediamo mercoledì prossimo pomeriggio. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie a tutti.