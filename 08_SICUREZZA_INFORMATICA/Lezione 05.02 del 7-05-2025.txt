Allora, quindi come dicevamo stamattina, ora vi mostro come qualunque protocollo sigma interattivo può essere trasformato in una versione non interattiva, cioè una versione in cui non è necessario interagire con il verifier per costruire la conversazione, ma la versione in cui la challenge viene autonomamente calcolata dal prover in maniera tale da continuare a preservare però le proprietà di existential soundness e 0 knowledge. La costruzione è analoga all'esempio che abbiamo già visto stamattina, cioè di come il protocollo di identificazione di Schenor può diventare un protocollo, uno schema di firma digitale e consiste nel sostituire la scelta randomica della challenge da parte del verifier con il digest che risulta dall'applicazione della funzione hash. Questa costruzione è dovuta a Fiat e Shamir che l'hanno proposta appunto per creare protocolli di sigma non interattivi e di conseguenza anche schemi di firma digitale ed è quella che vediamo qui. Quindi si parte da un protocollo sigma che si basa su un prover, sull'algoritmo seguito da un prover e l'algoritmo seguito da un verifier caratterizzato da una certa relazione binaria sui due insiemi x e y dove x è il witness, y invece è la componente pubblica e come abbiamo visto stamattina l'esecuzione del protocollo nella sua versione interattiva fornisce come risultato una conversazione, una conversazione del tipo commitment t, challenge c e risposta z, dove nella versione interattiva noi sappiamo che t è il commitment scelto dal prover, c e la challenge scelta dal verifier z è la risposta finale che il prover calcola sulla base delle informazioni che sono state scambiate e sulla base della conoscenza del witness x. In questa costruzione si utilizza come dicevo prima anche una funzione hash che viene applicata appunto per generare la challenge dato che vogliamo costruire una conversazione non interattiva. Quindi come funziona la costruzione? Partiamo dal presupposto appunto di avere una coppia x, y che tale per cui y fa parte del linguaggio della nostra relazione binaria. Il prover che è l'unico a partecipare alla costruzione della conversazione a partire dalla coppia x, y che cosa fa? Calcola il commitment come nella versione interattiva, poi a differenza della versione interattiva non c'è un verifier che calcola la challenge ma c'è un ulteriore calcolo fatto dal prover che calcola la challenge applicando la funzione hash. Quindi la challenge è l'hash di che cosa? È l'hash della concatenazione di due valori. Quali sono questi due valori? Sono il valore y della coppia e il commitment. Quindi le due informazioni su cui si applica la funzione hash sono le due uniche informazioni note pubblicamente fino a quel punto. y li hanno noto tutti, t è appena stato chiaramente calcolato dal prover, quindi è reso pubblico dal prover, quindi sono le uniche informazioni che possiamo prendere per appunto generare una challenge randomica, dato che se usiamo una funzione hash sicura il suo risultato è imprevedibile. Questo significa che per il modo in cui viene calcolata la challenge, che il prover non ha nessun modo di influenzare il valore della challenge, di sceglierlo, perché il risultato dell'applicazione della funzione hash sicura è impredicibile. Quindi questo significa che c è tale quale ad una scelta randomica. Quindi questo ci dà la garanzia che il prover non possa fare una scelta mirata di uno specifico valore di c che possa dargli un qualche vantaggio nel costruire una conversazione che possa violare la correttezza esistenziale. Quindi il passo due che vediamo qui è del tutto equivalente ad una scelta randomica di c fatta dal verify. Dopodiché va avanti come al solito. Quindi il prover calcola la risposta eseguendo il proprio algoritmo, che dipende da commitment, dal challenge e chiaramente dalla conoscenza del witness X. E infine spara in output, commitment e risposta. Quindi di fatto la prova, la proof, che chiunque può verificare consiste nella tripla YTZ. Chiunque conoscendo queste tre informazioni può verificare che questa sia una prova esistenzialmente corretta di DX, del witness X, senza naturalmente svelarne l'identità. Come avviene questo? A partire da Y e da T ci si può costruire la challenge e quindi ricostruire la conversazione T-CZ. Dopodiché questa viene verificata. L'accettazione di questa conversazione implica appunto che la prova è valida, è corretta, la prova di esistenza di X è valida e corretta. Un po' come abbiamo visto nel protocollo di identità di Schnorr. Se lo andiamo a rivedere... Dunque, aspetta, non ce l'ho qui. Non ce l'ho qui, non andiamo a prendere... qua. Vediamo cosa stiamo condividendo. Ok. Come abbiamo visto stamattina nel protocollo di Schnorr, l'idea qui è che la conversazione, posto che la coppia XY è, nel caso di Schnorr, questa coppia, è la conversazione. Ok. La conversazione è tale per cui il commitment T è G alla beta. Ok. Poi dovrebbe venire questa operazione qua, da parte del verifier, che sceglie la challenge. In questo caso, se vogliamo fare una prova interattiva, non interattiva di Schnorr, la challenge non la facciamo scegliere dal verifier, ma la calcoliamo noi in che maniera. Come l'hash di che cosa? Del commitment e di Y. Quindi nel nostro caso dovremmo applicare una funzione hash alla concatenazione di questi due valori. dove questo è Y e questo è il commitment. Quindi questa è la challenge. Dopodiché la risposta Z sarà il famoso gamma, calcolato in questa maniera qua. Ok. Quindi la prova che io posso pubblicare e che chiunque può verificare è la coppia G alla beta gamma. Commitment e risposta. Qualunque verifier che vede questa prova la può verificare. Come fa a verificarla? calcola la challenge come hash di G alla alfa, G alla beta, G alla alfa è noto, perché è il nostro Y. Dopodiché una volta che ho commitment, challenge e Z, quindi ho tutte le informazioni che mi servono, per verificare la correttezza della prova sappiamo che dobbiamo fare questo calcolo qua. Ok. Quindi nel caso di Schnorr l'algoritmo che il prover segue per determinare la risposta è il calcolo di gamma, no? Invece nel caso del verifier l'algoritmo è quello che fa la verifica di questo bias. ed ecco che abbiamo in questo modo una versione non interattiva del protocollo di identificazione di Schnorr dove si determina la challenge usando la funzione hash. Ok. Ma questo l'abbiamo poi visto sempre stamattina, alla fine non è molto diverso rispetto alla versione del protocollo di Schnorr usato come schema di firma digitale. Il principio è esattamente lo stesso. Ok. L'unica differenza se ci fate caso sta nel modo in cui viene calcolata la challenge che non è l'hash di G al Alpha, G al Beta ma è l'hash del del messaggio che vogliamo firmare concatenato con G al Beta. Ok. perché il messaggio deve essere deve far parte del processo visto che in questo caso l'idea è di creare una firma e la firma fa sempre riferimento a un messaggio. Quindi torniamo alla alla costruzione di Fiat e Shamir di cui abbiamo visto una di cui abbiamo visto una istanza particolare nel caso del protocollo di Schnorr ma questo si può adattare in generale a qualunque protocollo sigma. Ok. Quindi è una costruzione utile interessante proprio per questo. Qualunque protocollo sigma che prendiate potete applicare questa costruzione e farlo diventare non interattivo o uno schema di firma digitale. Poi ci sono due teoremi che dicono che se il protocollo sigma interattivo di partenza è sound e zero knowledge allora anche la sua versione interattiva costruita usando il procedimento di Fiat e Shamir a sua volta soddisfa la soundness e la zero knowledge. Ok. Quindi è una costruzione che preserva le le proprietà. Ok. e questo è quello che dicono questi due questi due teoremi. Come vi ho anticipato stamattina esistono tanti diversi protocolli sigma che si utilizzano nella nella pratica e noi abbiamo visto quello di Schnorr che lavora su relazioni di questo tipo questo è quello di Schnorr quindi sulla relazione binare di questo tipo bene sono altri che non vi ho raccontato ma adesso ne citerò uno quando vi farò vedere l'esempio del protocollo di voto elettronico però tanto per fare un po' di chiarezza ad esempio il protocollo di Okamoto è simile a quello di Schnorr e cambia leggermente la relazione che lavora sempre sugli ingredienti di D.F. Hellman quindi su gruppi ciclici infatti vedete che c'è un elemento di questo tipo qua così come quello di John Pedersen che tra poco lo useremo che lavora su triple di D.F. Hellman in quanto la relazione lavora su coppie del tipo beta e poi su triple del tipo G alla alfa G alla beta G alla alfa beta è la classica tripla di D.F. Hellman e poi l'ultima che invece è un protocollo sigma che si basa questo ve l'avevo già accennato a coppie che derivano dall'uso di RSA quindi diciamo che per tutte le primitive a chiave pubblica che abbiamo visto ci sono diverse varianti di protocolli sigma che fanno uso di questi di quegli ingredienti per realizzare appunto un protocollo sigma e per chiudere il discorso relativo ai protocolli sigma vi faccio un esempio abbastanza semplice che però fa parte di una categoria di protocolli piuttosto complessi forse più complessi in assoluto nell'ambito della crittografia che sono i protocolli di voto i protocolli di voto sono estremamente complicati perché sono tante le proprietà di diversa natura che questi devono garantire un protocollo di voto deve garantire la confidenzialità nel voto nel senso che il voto di ogni votante chiaramente non deve essere svelato devono garantire l'integrità del voto cioè i protocolli devono garantire che il contenuto del voto sia corretto e non sia nullo ad esempio vi farò vedere un esempio di che cosa questo può significare in particolare deve essere un protocollo che tutela la privacy l'anonimato dei votanti cioè il sistema di voto terze parti così come il sistema di voto stesso non devono essere in grado di collegare un certo voto a un certo votante ok si deve garantire il fatto che ogni avente diritto voti una volta sola non posso votare più di una volta si deve garantire il fatto che ogni voto venga è conteggiato ok garantendo tutte le proprietà che abbiamo detto prima non è banale quindi le problematiche da gestire nei sistemi di voto sono tante a fronte di avversari che possono essere esterni ma che a volte può essere anche il sistema di voto stesso perché comunque si tratta di quasi sempre sistemi centralizzati noi non vedremo tutti questi problemi metto in evidenza un paio semplici in un caso di un sistema di voto estremamente banale il classico referendum prendiamo come esempio un referendum dove la gente deve votare sì o no dove per noi il sì o il no sono il bit zero il bit uno che è una cosa estremamente banale quindi senza tirare in ballo le complicazioni che vengono fuori in sistemi di voto politico dove ci sono le preferenze dove si possono mettere combinazioni di voto che devono soddisfare determinati requisiti non entriamo nel merito di queste complicazioni quindi immaginiamo un sistema estremamente banale dove abbiamo n votanti n aventi diritto ognuno deve votare 0-1 ok sì o no è un referendum abbiamo un sistema centrale di cui tutti si fidano che è il vote telling center che è il centro di conteggio dei voti questa sarebbe la produzione letterale di di quel VTC e assumiamo che il VTC abbia una coppia generata da un algoritmo probabilistico di chiavi di cui una è la chiave pubblica e l'altra la chiave segreta come nei sistemi di cifratura a chiave pubblica non ha importanza qual è il sistema che viene utilizzato ok può essere un'implementazione di RSA può essere il GAMAL quello che volete quella è la coppia di un sistema di cifratura a chiave a chiave pubblica nella versione che vi faccio vedere io però faccio riferimento ad un cifrario che è la versione semplificata di El Gamal una versione un po' più semplice di El Gamal che avevamo già visto quando vi ho fatto vedere l'analogia con la crittografia ellittica ok in questa versione semplificata di El Gamal la chiave segreta è un esponente alfa per il nostro generatore del gruppo ciclico quindi un elemento ZQ la chiave pubblica invece è GAL alfa chiaramente al solito assumiamo che valga la soluzione relativa al problema dell'ogaritmo discreto per cui dato GAL l'alfa non è possibile risalire all'alfa ok quindi la coppia è la solita che abbiamo sempre visto nel caso del lo schema di cifratura di El Gamal la cifratura è semplificata non si usano altri ingredienti come funzioni hash o cifrari simmetrici ma dato un plaintext M che vogliamo cifrare la sua cifratura è data da questa coppia ok dove V è G alla beta dove beta è un valore randomico che viene scelto da chi fa la cifratura e che non viene reso pubblico e l'altro elemento è invece G all'alfa beta per moltiplicato per il plaintext ok questo è il modo in cui viene la la cifratura ok giochino un po' al solito mettetevi nei pagni di chi vuole fare una cifratura usando questo sistema allora chi vuole fare la cifratura che cosa fa sceglie randomicamente un beta ok calcola G alla beta e questa è un'informazione che verrà pubblicata perché è il primo elemento del ciphertext dopodiché che cosa faccio uso la chiave pubblica G alla alfa per calcolare G alla alfa beta perché prendo G alla alfa e lo levo alla beta e questa quantità la moltiplico per il plaintext che voglio cifrare questo è quello che fa chi vuole cifrare dall'altra parte la decifratura come avviene passa per il calcolo di G alfa beta perché chi vuole decifrare deve fare E diviso G alla alfa beta per ottenere M ok ma come faccio a calcolare G alla alfa beta ebbè il caso sono due o conosco beta ma beta lo conosce solo chi ha fatto la cifratura o conosco alfa ma alfa è la chiave segreta quindi la conosce solo il proprietario della chiave segreta quindi la decifratura la può fare chi possiede la chiave segreta perché chi possiede la chiave segreta che cosa fa prende G alla beta che fa parte del ciphertext lo eleva all'alfa che è la chiave segreta e quindi il risultato G all'alfa beta ed ecco che posso completare il calcolo e risalire il printex questa è l'operazione che farà il VTC il VTC ha questa coppia e l'idea di base è che ciascun votante usa questa versione di El Gamal per cifrare il proprio voto adesso vedremo come in particolare ok quindi immaginate che io che voglio votare prendo il mio voto e lo cifro in questa maniera ok quindi ogni votante sceglie un beta usa la chiave pubblica del VTC e calcola G alla beta e calcola G alla alfa beta per M e trasmette la coppia questo cypertext calcolato in questa maniera al VTC ok in particolare il voto perché dobbiamo chiarire come viene rappresentato il voto no M dovrebbe essere il voto viene rappresentato come vedete nel passo 1 ok quindi prendiamo un votante che vuole votare il suo bit 0 1 che cosa fa usa la cifratura di El Gamal che abbiamo appena descritto per cifrare vedete questo valore questo è il valore che viene cifrato G elevato G è il generatore del nostro gruppo ciclico G elevato al bit ok quindi l'M che viene cifrato quanto vale o vale 1 se il bit è 0 perché G alla 0 fa 1 oppure G se il bit è 1 perché G alla 1 fa G quindi di fatto il votante cifra uno di questi due valori ok e il risultato della cifratura comanda al VTC ok l'importante è che ogni votante scelga randomicamente il proprio beta no il proprio valore di beta che deve rimanere segreto ok quindi intanto vediamo facendo così quali problemi risolviamo e quali rimangono in sospeso no e quindi se ogni votante calcola questa coppia nel modo che abbiamo appena visto e la trasmette al VTC sicuramente la la confidenzialità è garantita è garantita perché perché come dicevamo prima l'unico modo di recuperare questa informazione consiste nel conoscere o beta ok ma beta la conosce solo il votante o alfa ma alfa lo conosce solo il VTC perché è la sua chiave segreta chiunque altro l'avversario che ascolta il canale per poter decifrare il ciphertext deve riuscire a costruire G alla alfa beta ma lo può fare solo conoscendo G alla beta che fa parte del ciphertext e G alla alfa che è la chiave pubblica del VTC ma noi sappiamo e lo dice l'assunzione di Fierman computazionale che queste due informazioni da sole non bastano per ricostruire questa questa è la classica assunzione la classica computational di Fierman Assumption quindi per quanto riguarda la confidenzialità siamo tranquilli ok nessun nessun altro votante nessun avversario è in grado di decifrare il voto di ciascun di ciascun votante chiaramente è importante che ogni votante scelga randomicamente il proprio beta è importante che questo dominio sia superpoli quindi Fierman sia molto grande perché la probabilità che due votanti scelgano randomicamente lo stesso beta deve essere negligible chiaro perché se due votanti scelgono lo stesso beta allora uno può vedere il voto dell'altro e quindi bisogna che la appunto la probabilità di conflitto sui valori di beta sia trascurabile e questo è possibile solamente se il dominio di questi beta quindi zq è superpoli quindi rispetto a osservatori esterni garantiamo la confidenzialità spostiamoci sul VTC ok ci possiamo possiamo dire altrettanto del VTC possiamo dire che il voto è confidenziale rispetto al VTC ok perché il vot telling center riceve questa coppia dal votante i e la può decifrare certo che la può decifrare la chiave segreta quindi in teoria il VTC può decifrare il voto di ciascun votante e quindi sapere cosa ha votato ciascun votante ok quindi se il VTC è curioso di sapere io cosa ho votato lo può lo può imparare cosa che non dovrebbe essere no allora noi adesso facciamo la prima delle diverse assunzioni semplicistiche per poter andare avanti con il nostro con il nostro protocollo ovvero il fatto che ci fidiamo ci fidiamo del fatto che il VTC non sia curioso il VTC è trusted ok quindi ci fidiamo che il VTC non sia curioso e ci fidiamo del fatto che quando il VTC riceve questa coppia non la decifra ok ok chiaro stiamo facendo una soluzione un po' forte ok però questo ci permetterà di andare avanti con il nostro discorso ok quindi per garantire l'anonimato del voto adesso noi ci fideremo del fatto che il VTC non decifra il ciphertext quando gli arriva ok perché se lo facesse imparerebbe qual è il voto di ogni singolo votante bene ipotizziamo che il VTC sia onesto ok adesso qual è il problema quindi ipotizziamo che il VTC non decifra ogni singolo voto come si contano i voti il problema è quello anche se il VTC è onesto e non decifra ogni singolo voto come cavolo fa a contare i voti visto che non può decifrare ogni singolo voto anche se possiamo fidarsi del fatto che non decifra ogni singolo voto allora come fa a calcolare il risultato della votazione e questo lo vediamo in quello che qui viene chiamato passo di conteggio il Tulling Stage il cui obiettivo è quello di aggregare in qualche modo tutti i voti cifrati ok quindi il VTC che cosa fa raccoglie i voti cifrati non li decifra ma li aggrega ok è chiaro? ci siamo fin qui cioè li combina insieme in qualche modo adesso dobbiamo vedere in che modo prima cosa che fa moltiplica tutti i V di ok quindi fa questo prodotto no? allora questo è il G di beta del primo votante lo moltiplica per il G di beta 2 del secondo votante e così via fino al G di beta N perché N sono i votanti ok quindi tutti questi li moltiplica insieme ok e il risultato lo chiamiamo V stella no? prende il primo elemento del cifrtext di ogni votante li raccoglie tutti e li moltiplica la stessa cosa facciamo col secondo elemento del del cifrtext cioè prendiamo tutti queste tutte queste quantità G alla alfa beta 1 per G di beta 1 per G alla alfa beta 2 per G di beta 2 B2 e così via così via così via li moltiplichiamo tutti no? facciamo questa operazione qua ok? e il risultato lo chiamiamo E stella ok? quindi calcoliamo questa coppia V stella E stella dove V stella è la produttoria dei primi elementi di tutti i voti che ha ricevuto e stella è la produttoria di tutti i secondi elementi dei voti che sono stati ricevuti ok? ora facciamo un po' di conti no? allora partiamo da V stella V stella è il prodotto di tutti questi G alla beta I no? ma applicando le proprietà dell'allamento a potenza possiamo dire che V stella è G alla beta 1 più beta 2 più beta N no? ok? se noi chiamiamo beta stella la somma di tutti i beta I allora abbiamo che quel V stella è questa quantità G alla beta stella ok? no? è G alla somma elevato alla somma di tutti i beta I quindi G alla beta stella ok? ci siamo? ok? per i vari passaggi bene facciamo un ragionamento analogo su estella estella è la produttoria di tutti gli edi che sono G alla alfa beta I per G B I ok? ora di nuovo usando le proprietà dell'allamento a potenza questa roba qui a che cosa è uguale? a G all'alfa per beta stella no? che è la sommatoria di tutti i beta I come prima non abbiamo fatto per V che moltiplica G per la somma di tutti i B di quindi stesso stesso discorso di prima ok? la somma di tutti i B la chiamiamo sigma diamo un nome alle cose quindi il nostro estella la produttoria di tutti gli edi è uguale a questa espressione ok? è il bit del voto no? il vale 0 1 a seconda di quello che io voglio è il voto che io sto cifrando ok? quindi abbiamo fatto un po' di aggregazioni usando le proprietà dell'allamento a potenza morale della favola facendo questa aggregazione di voti il VTC si è calcolato questa coppia g alla beta stella virgola g alla alfa beta stella per g alla sigma questa è la coppia che si è calcolato il VTC aggregando tutti i ciphertext in che maniera? tramite la moltiplicazione aggregazione dei ciphertext significa moltiplicarli fra di loro chiaramente è una moltiplicazione pairwise elemento della coppia per elemento della coppia corrispondente ok? ora guardiamo questa coppia dove ripeto questo beta stella l'abbiamo detto è la somma di tutti beta i e questo sigma è la somma di tutti i bi ok? che cos'è sigma in particolare? eh? no no no sigma sigma non alfa sigma è il risultato che ci serve è il conteggio dei voti no? è la somma dei voti sigma quindi è lui che dobbiamo trovare ok? chiusa la parentesi riguardiamo la coppia che ha che ha ottenuto il VTC no? confrontate questa coppia con lo schema di cifratura di Elgamal questa coppia che cosa rappresenta? confrontate questa coppia con questa definizione questa è la definizione di cifratura di M fatta con la nostra versione semplificata di Elgamal ok? quindi questo è il modo in cui si fa la cifratura di M ora guardate questa coppia qua questa coppia qua che cosa rappresenta? è una cifratura non di sigma di G alla sigma questa coppia è la cifratura di G alla sigma dove il beta randomico è beta stella ok? e il resto vedete che sono esattamente le operazioni di cifratura ok? quindi aggregando tutti i voti tramite la moltiplicazione il vtc si è costruito la cifratura di G alla sigma ok? quindi adesso il vtc che cosa può fare? è l'unico che può decifrare perché conosce la conosce alfa quindi il vtc adesso può prendere questo ciphertext decifrarlo no? in che maniera? beh il vtc conosce alfa quindi può prendere G alla beta stella che è il primo elemento del ciphertext elevarlo alla alfa che è la sua chiave segreta e quindi il risultato sarà G alla alfa beta stella dopodiché prende il secondo elemento del ciphertext lo divide per G alla alfa beta stella e il risultato è G alla sigma morale dalla favola il vtc ottiene G alla sigma dove sigma è il risultato dell'elezione ci siamo? ok? vi avete seguito fin qui? ora G alla sigma ancora non mi dice nulla di sigma perché no in linea di principio vale vale la soluzione di Diffie elman che abbiamo sempre detto cioè io vi do oggi la sigma voi non potete ricavare delle informazioni relative a sigma questo è vero quando l'esponente fa parte di un insieme super poli no? perché la soluzione di Diffie elman che mi dice che dato G alla alfa con alfa appartenente a zq ok? io non riesco a recuperare alfa questo implica che alfa faccia parte di un insieme di valori molto grande per cui anche se io mi metto lì perché una cosa che potrei fare è provare con la ricerca forza brutta io provo tutti gli alfa prendo G lo levo a un alfa lo levo a un altro finché non trovo quello giusto ok? però quello è un attacco che io in generale su Diffie ma lo non posso fare se questo è super poli ok? ma lo stesso discorso non vale per sigma sigma non è un valore che fa parte di un dominio super poli sigma al massimo quanto vale ma quindi quindi il dominio il dominio di di sigma è zeta n ok? perché sigma sarà un valore compreso fra 0 se tutti hanno votato no a n se tutti hanno votato sì e n non è super poli ok? il numero dei votanti è un numero un po' il numero inonialmente limitato quindi il VTC può fare una ricerca forza brutta prova tutti i valori compresi fra 0 e a n e vede qual è quello che mi restituisce il G alla sigma che ho appena decifrato ok? quindi morale della favola cosa ha fatto il VTC? ha preso tutti i voti cifrati li ha aggregati attraverso la moltiplicazione il risultato di questa moltiplicazione che cos'è? è la cifratura del conteggio dei voti che è esattamente quello che il VTC ha bisogno di sapere per stabilire il risultato del referendum ok? per tirare fuori sigma una volta che ho decifrato questo ciphertext che mi sono costruito aggregando i voti che cosa faccio? faccio un attacco a forza brutta su sigma ok? risultato finale so qual è il risultato del referendum senza aver cifrato ogni singolo voto quindi se il VTC è onesto non va a decifrare ogni singolo voto ma aggrega tutti i voti in modo che abbiamo visto e riesce comunque a recuperare il risultato dell'elezione ok? ora per risolvere il problema del trust sul VTC ci dovrebbe essere un controllore che verifica che il VTC faccia questi calcoli qua e non si metta a decifrare i singoli voti oppure si usano delle tecniche crittografiche ancora più complicate ancora più sofisticate che consentano al VTC di fare questo calcolo qua no? questa aggregazione senza avere gli strumenti però per decifrare ogni singolo voto questo è un po' è è l'idea noi non affrontiamo questo problema qui di di come avere a che fare con un VTC curioso ma affrontiamo un altro problema che risolviamo con il Sigma Protocol ovvero che succede? adesso noi stiamo assumendo che tutti i votanti siano onesti no? ma in che modo un votante potrebbe imbrogliare secondo voi in questo protocollo? un votante che vuole falsificare il risultato del referendum come potrebbe fare? la scheda bianca beh noi stiamo assumendo noi stiamo facendo una soluzione molto forte noi stiamo assumendo che ogni votante cifra 1 o G no? cifra 1 se il suo voto è 0 cifra G se il suo voto è 1 ok? noi stiamo assumendo questo e chi impedisce al votante di cifrare qualcos'altro? cioè cosa succede se un votante cifra G alla 7? se ne accorge il VTC? sì sì perché guardate chi è sigma? sigma è la somma e conta come 7 voti se un votante se un votante cifra G alla 7 e il VTC non se ne accorge perché non decifra il il singolo ciphertext ma aggrega e alla fine abbiamo visto che il VTC si ritrova come risultato la cifratura di G alla sigma sigma è la somma dei voti allora se un votante cifra G alla 7 il suo voto conterà 7 chiaro? intanto alla fine alla fine che cosa si ritrova? nel VTC con la somma dei voti ma se c'è un votante che ha votato per sé ha votato 7 un altro che ha votato 12 così via VTC fa la somma se ne accorge solo se la somma supera N ok? ma se la somma non supera N non si accorge ok? quindi abbiamo bisogno di un modo per garantire al VTC che ogni voto è valido senza andare a decifrarlo o girando girando il discorso il prover scusate il votante ogni votante deve dimostrare in questo caso al VTC che è il verifier che ciò che ha cifrato è un valore valido cioè 0 1 cioè 1g ok? ma questa è una prova che noi vogliamo ottenere in zero knowledge no? il votante è il prover il VTC è il verifier il votante deve dimostrare al VTC che il suo voto è valido senza fargli vedere il voto perché il VTC il voto non lo vede vede solo il ciphertext ok? quindi in altre parole che è uno dei problemi di cui parlavamo anche stamattina tra le varie applicazioni dei protocolli sigma cioè io vi faccio vedere un ciphertext voi non lo potete decifrare però e io devo riuscire a dimostrarvi che il plaintext associato a quel ciphertext ha qualche proprietà nel nostro caso qual è la proprietà che vogliamo dimostrare? che quel plaintext o ha il voto 0 o il voto 1 ok? quindi questo è un classico esempio di applicazione di un protocollo sigma che abbiamo già discusso no? ok? ora di di di di tutte le varianti dei protocolli sigma che abbiamo elencato prima vabbè noi abbiamo visto in dettaglio solo quello di Schnorr gli altri vi ho detto solo che esistono però ce n'è ce n'è uno di questi che è quello di John Pedersen quello che lavora sulle triple di Diffie Hellman che è esattamente il protocollo sigma che si usa in questo caso qua per permettere al votante di costruire una prova non interattiva della correttezza del suo voto ok? non interattiva per motivo è ovvio non possiamo immaginare che eh ogni votante debba interagire col VTC per dimostrare la correttezza del suo voto è una scala questa cosa deve essere efficiente quindi la prova se la costruisce in maniera non interattiva ogni votante quindi con il suo commitment la challenge calcolata come un certo hash è la risposta Z ok? quindi il votante si costruisce la prova e la manda al VTC insieme al voto cifrato quindi il VTC da ogni votante riceve due informazioni riceve la cifratura del voto e riceve la proof riceve la prova in zero knowledge la prova corretta è in zero knowledge che quel ciphertext riguarda un plaintext che ha una certa proprietà ovvero essere un voto valido cioè 0-1 quindi il VTC che cosa farà a quel punto? prima verifica la prova si comporta da verifier verifica la prova se la prova è corretta ci dimostra che il voto è valido che è esattamente quello che succede nello spoglio classico delle schede quando gli scrutinatori prendono una scheda dall'urna la aprono e vedono se è un voto valido in questo caso il VTC non ha bisogno di aprire il voto per vedere se è valido deve solo verificare la proof che il votante ha costruito quindi senza dover aprire il voto il VTC ha modo di verificare che il voto sia valido cioè sia un voto binario 0-1 se il voto è valido allora lo aggiunge nella mucchia dei prodotti se un voto non è valido viene cestinato voto non valido non viene conteggiato ok? questa è l'idea di come un protocollo di sigma come quello che ho citato viene utilizzato entrando giusto così a titolo giustificativo la la relazione che sta alla base del protocollo sigma di John Pedersen che viene usato dentro il sistema di voto è questa qua dove questo è il witness x cioè la parte segreta fateci caso in ciascun voto la parte segreta in cosa consiste? nel bit che il votante vota cioè b e nel valore randomico beta perché anche quello è il segreto quindi il witness è la coppia b beta mentre invece la parte pubblica quella che vede il vtc è sostanzialmente la il ciphertext quindi ci sarà questo elemento che è g alla beta no? perché fa parte del ciphertext ci sarà qui un elemento generico u che nel caso del sistema di voto è g alla alfa ok che è la chiave di verifica del vtc e ci sarà l'elemento mancante che è questo che è g alla alfa beta moltiplicato per g alla b ok quindi e questo è il nostro y quindi il nostro y è tutto ciò che vede il vtc cioè la propria chiave pubblica g alla beta e questa roba qua g all'alfa beta per g alla b quindi questa è la parte pubblica compone y x invece il witness è la parte segreta voto e beta perché sono le informazioni scelte dal votante il protocollo sigma di chan pedersen che non abbiamo visto ma che di cui che funziona più o meno come cuore shinor è un protocollo che è in grado di costruire delle prove existential sound e in zero knowledge di questa relazione qua ok con la condizione ricordiamoci che è questa ovvero queste non sono coppie qualunque ma sono coppie dove b appartiene all'insieme 0 1 deve appartenere all'insieme all'insieme 0 1 ok quindi in altre parole usando un protocollo sigma non interattivo con questo y e questa x ogni votante può costruire in zero knowledge e in maniera existential sound una proof cioè una conversazione tcz del fatto che un certo y cioè la cifratura del del suo voto unitamente alla chiave pubblica del vtc ha un witness x corretto cioè voto binario e valore randomico beta del votante punto quindi eseguendo la verifica vtc ha la prova di correttezza del voto quindi vedete abbiamo affrontato in maniera molto superficiale solamente due problemi dei sistemi di voto cioè come fa il vtc a calcolare il risultato della votazione senza senza decifrare i singoli voti e l'abbiamo semplificato assumendo di fidarci del fatto che il vtc non va ad aprire i singoli voti però ripeto lo si può complicare in maniera tale da rendere impossibile al vtc di aprire i singoli voti ma di poter comunque calcolare il valore aggregato usando la moltiplicazione quindi anche se non ci fidiamo del vtc c'è modo di rendergli impossibile la decifratura di ogni singolo voto senza compromettere il calcolo del conteggio e l'altro problema che abbiamo affrontato invece è il discorso di come gestire la presenza di votanti di cui non ci fidiamo e quindi obbligarli a fornire una prova di validità del loro voto senza obbligarli a esibire il voto chiaramente questo è questo è il discorso detto questo di problemi ce ne sono tanti altri che riguardano i sistemi di votazione questi non sono neanche più complessi uno dei problemi più difficili da risolvere è la proprietà che ci garantisce che ogni singolo voto sia effettivamente conteggiato ed è anche questa è una prova sempre in zero knowledge che ogni votante deve poter verificare ok ogni votante deve poter verificare che nel risultato finale della votazione nell'aggregazione diciamo da qui si tira fuori il voto il risultato finale ci sia anche il suo voto perché di nuovo immaginate un VTC disonesto che quando va ad aggregare i voti ne trascura qualcuno ok invece anche lui deve fornire una prova non interattiva in zero knowledge in base alla quale noi possiamo verificare che ogni il voto di ogni votante faccia parte dell'aggregazione ok e tutto questo complicato dal fatto che bisogna garantire la privacy dei votanti quindi l'anonimato rispetto a ogni singolo voto e così via ok ma ripeto molti alcuni di questi problemi non hanno una dimostrazione formale di di correttezza ok ci sono solo delle prove empiriche quindi questo è il motivo per cui i sistemi di voto elettronico si si utilizzano però non essendoci una prova formale ma solo empirica della loro correttezza difficilmente vengono utilizzati in contesti politici ad esempio ma in contesti dove c'è più tolleranza rispetto a questo tipo di situazioni ci sono un pari di paesi al mondo che hanno sperimentato il voto politico in maniera elettronica pochi insomma e sono state sperimentazioni che sono anche poi esaurite insomma non sono state mantenute è successo in Nituania mi pare in Olanda hanno fatto delle sperimentazioni su un voto elettronico ma poi le hanno le hanno anche abbandonate che non c'entra niente col voto per corrispondenza non c'entra niente col voto fatto localmente attraverso un dispositivo elettrico che non funzionava però lì devi dimostrare però dall'altra parte c'è anche il problema che chi propone quel sistema non ti può esibire una prova inconfutabile del fatto che quel sistema è una prova di bomba quindi alla fine c'è sempre una componente di fiducia che tu metti ma che ha dei limiti ecco insomma i sistemi di voto hanno dei limiti da questo punto di vista va bene questo chiude il discorso relativo ai protocolli sigma e alle loro applicazioni ce ne sono molti di interessanti perché il problema di fondo dei protocolli sigma è molto sfidante cioè riuscire a dimostrare di conoscere qualcosa senza farlo vedere ci sono tante applicazioni di tati che secondo me è uno degli argomenti che può fornire molti molti spunti per degli approfondimenti o per delle o per delle tesine da questo punto di vista il prossimo argomento che è un po' il culmine del dei protocolli criptografici riguarda riguarda la l'implementazione dell'autenticata ed encryption nel contesto dei sistemi a chiave pubblica quindi andando nel concreto come si instaura una VPN una quindi una connessione protetta tra due parti che non hanno mai interagito prima tra di loro e che quindi non condividono segreti a priori questo è il problema di fondo dalla primissima lezione che abbiamo lasciato in sospeso e a cui arriviamo finalmente adesso ok questo è un problema che abbiamo risolto con questo è un problema che abbiamo risolto in parte con l'autenticata di encryption ok cioè le costruzioni di encrypt e mac e mac dell'encrypt ma quelle sono soluzioni che risolvono solo il problema di confidenzialità e integrità e che si basano sul presupposto che le due parti condividano già un segreto ok e adesso dobbiamo risolvere il problema che sta a monte come fanno due parti ad arrivare a condividere un segreto senza che si conoscano settimana scorsa o giù di lì abbiamo affrontato in parte questo problema parlando di sign encryption che è la versione dell'autenticata di encryption nel mondo della criptografia a chiave pubblica anche lì invece delle dell'encrypt del mac o not dell'encrypt c'è l'encrypt del sign o sign dell'encrypt però c'è il problema a monte ovvero come faccio ad arrivare a far condividere la la mia chiave pubblica no ad una controparte che non mi conosce ok quindi arriviamo a quello che è il problema fondamentale della delle comunicazioni sicure in rete un attimo che vogliamo ricondividere ancora qua quindi vediamo quello che è il problema di fondo che abbiamo lasciato in sospeso fin dall'inizio che è questo abbiamo come obiettivo la creazione di un canale di comunicazione protetto sicuro una vpn tra due agenti che hanno anche il problema di identificarsi a vicenda e quindi hanno il problema di arrivare a condividere quel segreto che gli permetterebbe di instaurare tramite autentichetta di encryption la nostra la nostra cosiddetta vpn e questo è il problema fondamentale no ora per risolvere questo problema dell'authenticated key exchange perché si chiama così authenticated key exchange perché come abbiamo detto l'obiettivo di fondo è far arrivare a condividere un segreto una chiave quella che chiameremo chiave di sessione a due parti però per arrivare a far condividere questo segreto le due parti è necessario che le due parti si autentichino tra di loro no se vogliamo creare una vpn di questo tipo tra Alice e Bob non basta che i due seguano un protocollo alla fine del quale una chiave k di sessione viene condivisa tra loro in maniera privata senza che altri la conoscano ma è anche necessario che durante l'esecuzione di questo handshake Alice sia autentichi rispetto a Bob e Bob sia autentichi rispetto a Alice cioè Alice deve avere la certezza che è Bob l'utente con cui sta mettendo in piedi un protocollo per arrivare a condividere una chiave di sessione k e lo stesso discorso vale per Bob quindi uno scambio che porta i due a condividere una chiave che sia però autenticato che garantisca l'identificazione delle due parti da qui il nome autentichetto di chi exchange ok ora ci sono due modi in letteratura di risolvere il problema dell'autentichetto di chi exchange di base uno fa uso della cifratura della criptografia chiave pubblica l'altro invece invece no uno fa entrambi fanno uso ed è sempre purtroppo necessario di una terza parte che funga da garante quella che noi chiameremo trusted third party TTP il TTP è un terzo agente di cui tutti si fidano ok senza un rapporto di fiducia con un terzo agente non c'è modo di risolvere il problema dell'autenticato di chi exchange tra due parti che non si conoscono quindi come terreno comune come base di partenza i due devono fidarsi entrambi di un TTP ok poi i due approcci che studieremo si diversificano tra loro a seconda di come interviene e quando interviene il TTP oltre che per la tipologia di operazioni di primitive e crittografiche che vengono usate ok in una in un tipo di soluzione il TTP è offline cosa vuol dire offline vuol dire che quando Alice e Bob vogliono creare una VPN privata tra loro due non c'è bisogno che il TTP intervenga durante lo scambio che c'è del shake che c'è tra loro l'unica condizione l'unico requisito necessario è che entrambi sia Alice che Bob abbiano interagito almeno una volta con il TTP per registrarsi ok quindi entrambi devono avere seguito seguito almeno una volta un protocollo di registrazione col TTP durante il quale lo dice il termine stesso l'utente si registra presso il TTP che funge da Certification Authority e l'obiettivo di questa registrazione è emettere un certificato associato all'utente ok un certificato che cosa dirà dirà che la chiave pubblica dell'utente X è il valore XYZ no come avviene la registrazione la registrazione avviene seguendo uno qualunque dei protocolli che vedremo a un certo punto vi dirò benissimo questo protocollo lo potete usare per far fare la registrazione a un utente nei confronti del TTP sarà un passaggio abbastanza semplice di solito quello che succede è che durante il protocollo di registrazione un utente crea una VPN col TTP per creare questa VPN con TTP in realtà l'unico dei due che sia autentica è il TTP perché è l'unico che ha a monte già una chiave pubblica chi si registra ancora non ce l'ha quindi non si può autenticare no dopodiché all'interno della VPN che è stata creata tra utente e certification authority la certification authority richiede all'utente delle informazioni ad esempio che lo so chiede mandami il tuo documento di identità lì dipende dalle certification authority quante e quali informazioni vengono richieste che consentano poi al TTP di emettere un certificato ok ad esempio vi faccio il mio esempio personale anni fa avevo bisogno della firma digitale e quindi avevo bisogno di un certificato che una certification authority rilasciasse per me e io lì non ho interagito direttamente con la certification authority ma ho interagito con un intermediario intermediario nel caso nel caso nostro intermediari che non so possono essere le poste l'ufficio postale può essere un'associazione di categoria la conf artigianato la conf industria un qualunque ente che sia riconosciuto a livello pubblico no può essere anche un ente privato se è a sua volta certificato e cosa succede? succede che voi vi presentate fisicamente presso l'ente che fa da garante andate lì col vostro documento io sono Alessandro Dini questa è la mia carta di identità quindi avviene il riconoscimento fisico della persona dopodiché l'ente garante interagisce con l'ente certificatore e gli dice guarda rilascia un creo una coppia di chiavi no pubblica e private usando l'algoritmo in un certo schema lo creo e dico bene questa è la coppia di chiavi della persona che ho appena identificato rilascia un certificato a quella persona e che certifica che ha quella chiave pubblica dopodiché a me cosa mi viene dato dall'ente certificatore mi viene dato a suo tempo era una smart card adesso sono altri tipi di soluzioni che possono essere completamente software o in parte software e hardware a quel tempo era una smart card che al suo interno cosa conteneva conteneva la chiave privata ok per cui ogni qualvolta io volevo fare una firma digitale non devo fare altro che usare la smart card per firmare ad esempio documenti quindi applicare la trance segreta usando egamala o usando il cdsa quello che era secondo se l'obiettivo era cifrare o firmare attraverso un software con cui la smart card poi andava per agire quello è un modo di registrarci vi presentate fisicamente a un ente che è un garante direttamente un certificatore che vi identifica in tutti i modi che ritiene opportuni dopodiché crea la vostra coppia di chiave pubblica e privata e poi l'ente certificatore preposto creerà il certificato che associa voi la vostra identità alla chiave pubblica che è stata generata ok questo passaggio questo protocollo di registrazione può avvenire fisicamente come vi ho raccontato può avvenire anche online no e lì cambia naturalmente le modalità con cui poi avviene riconoscimento della persona è il passaggio necessario per realizzare l'autenticata del key exchange nel caso di TTP offline perché ripeto offline perché perché torno a ripetere la registrazione è l'unico momento in cui voi interagite con il TTP nel momento in cui il TTP vi rilascia il certificato da quel momento in avanti voi con il TTP non dovete più interagire almeno fino a quando non scade il certificato quindi ogni qualvolta volete eseguire un protocollo di autenticata di key exchange con un altro utente per creare una VPN non avete bisogno lì per lì di interagire con il TTP quindi questo è il motivo per cui stiamo parlando di soluzioni offline naturalmente per far funzionare questo tipo di soluzioni dobbiamo utilizzare primitive criptografiche che si basano sulla cifratura chiave pubblica ok quindi se vogliamo da una parte il vantaggio è che il TTP non è un collo di bottiglia TTP con il TTP interagite una volta sola e poi lo salutate quindi le comunicazioni con il TTP non sono un bottleneck e quindi dal punto di vista dell'efficienza questo è molto positivo la controparte è che dobbiamo utilizzare i meccanismi di cifratura chiave pubblica che sappiamo non essere particolarmente efficienti rispetto naturalmente ai meccanismi basati sulla cifratura simmetrica quindi questi sono un po' i pro e contro delle soluzioni cosiddette offline con TTP offline l'altra alternativa che vedremo dopo dopo la prima prevede invece il TTP online cosa vuol dire questo vuol dire che ogni qualvolta voi volete eseguire un protocollo di autentichetta di exchange con un altro utente il TTP deve partecipare al handshake quindi è coinvolto direttamente ogni volta che eseguite il protocollo ok questo rende il TTP un collo di bottiglia perché significa che è obbligato a intervenire ogni volta che bisogna creare un VPN tra due utenti quindi è un problema che riduce molto la scalabilità di questo tipo di soluzioni in contesti diciamo limitati può essere una buona soluzione limitati vuol dire dove ci sono pochi utenti un numero limitato di utenti e un numero limitato di connessioni questo tipo di soluzione può funzionare in un contesto aperto dove gli utenti sono tanti e chiunque potrebbe voler parlare con chiunque non è un tipo di soluzione che può scalare ok di contro il vantaggio di questo tipo di soluzione è che è implementabile usando solo ed esclusivamente i meccanismi di cifratura chiave simmetrica ok un esempio di sistemi di autenticato exchange con TTP online è Kerberos che è uno dei sistemi più antichi che funziona a questo scopo di fatto è un sistema il cui obiettivo è quello di distribuire chiavi di sessione tra tutti i colori che vogliono creare fra loro una doppia di anni ve li farò vedere entrambi ve li farò vedere sia le soluzioni offline che le soluzioni online per quanto riguarda le soluzioni offline l'esempio pratico che vi farò vedere è TLS la versione 1.3 di cui qualche tempo fa vi ho fatto vedere il protocollo di autenticato di encryption cioè come fa TLS a creare una VPN su cui eseguire l'encrypt del MAC no? però lì avevamo fatto l'ipotesi che le due parti condividevano già un segreto e come si fa ad arrivare a condividere questo segreto? Bisogna eseguire un protocollo di autenticato exchange quello di TLS è un protocollo offline e quindi vi farò vedere quello come esempio pratico prima vi farò vedere come funzionano in generale i protocolli di autenticato exchange quello che è importante osservare è che ogni volta che viene eseguita un'istanza di un protocollo di questo tipo viene creata una chiave di sessione fresh quindi ogni VPN avrà la sua chiave di sessione fresh che è quella che i due concorderanno in maniera autenticata e sulla base delle quali si implementerà l'autenticato di encryption con l'encrypt del mac ad esempio no in questo contesto e poi chiudiamo la proprietà che ci interessa verificare questa qua immaginate di avere due utenti P e Q Alice e Bob che vogliono realizzare una VPN su cui comunicare la proprietà che vogliamo garantire è questa qua una l'autenticità ok l'autenticità ci dice che se P crede di avere eseguito l'authenticato di key exchange con Bob quella stessa deve essere vero ok vale anche il contrario se Bob crede di aver eseguito l'autenticato di key exchange con Alice anche questo deve essere vero deve essere veramente Alice non qualcuno che sta facendo finta di essere Alice e viceversa quindi Alice e Bob devono avere la prova di autenticazione dell'altro quindi la prova di mutua autenticazione ognuno deve avere la certezza dell'identità dell'altro ok quindi questa è l'autenticità chiaramente la segretezza riguarda che cosa riguarda il risultato dell'autenticata di key exchange e il risultato dell'autenticata di key exchange è la chiave di sessione quindi quel segreto quel valore k che rappresenterà poi il punto di partenza per realizzare l'autenticata di encryption e quindi la nostra famosa VPN no quindi le due proprietà fondamentali da garantire sono l'autenticazione delle parti e la segretezza della chiave di sessione che alla fine del protocollo le due parti devono condividere ok tutto questo autenticazione e segretezza devono essere garantiti rispetto ad un avversario attivo quindi se prendiamo in considerazione gli attacchi di cui abbiamo parlato per i protocolli di identificazione attacchi diretti passivi attivi quelli che ci interessano non sono i più espressivi in assoluto quindi attacchi attivi quindi attacchi dove l'avversario può fingere di essere chi vuole quindi può interagire con con P ma anche con Q può rifare ciò che passa nel canale quindi raccogliere tutto il materiale che vede passare riutilizzarlo ok se può manipolarlo chiaramente e quindi di fatto l'avversario con cui abbiamo a che fare è il più potente in assoluto può anche comportarsi come un man in the middle come qualcuno che contemporaneamente interagisce con P e sfrutta ciò che fa con P per pilotare un'altra sessione che esegue con Q quindi ipotizzeremo anche che dello stesso protocollo possono essere in piedi più sessioni contemporaneamente perché il man in the middle si realizza in questa maniera qua quando c'è un avversario che contemporaneamente tiene in piedi due diverse sessioni una con l'utente e una con l'altra e farlo potrebbe permettervi trarre qualche vantaggio vi farò vedere esempi di protocolli che apparentemente sono perfettamente funzionanti sono corretti rispetto a confidenzialità interità tutto quello che volete però nel momento in cui li eseguite in un contesto concorrente di questo tipo qua no? quindi protocolli di cui ci sono possono essere tante sessioni di esecuzione contemporaneamente ecco che la sicurezza salta ok? questo renderà praticamente impossibile definire degli attack game rispetto ad avversari così sofisticati e quindi questo rende molto complicata la verifica formale delle proprietà di sicurezza di protocolli di questo genere ok? quindi questo renderà necessario l'utilizzo di strumenti di verifica automatici vi farò vedere un esempio di come funzionano le cose da questo punto di vista ok? e niente direi che ci possiamo fermare qua perché poi domani iniziamo a vedere i primi protocolli con questa conclusione ovvero combinare in maniera sequenziale o più o meno furba protocolli che abbiamo studiato fino adesso anche se questi sono sicuri non è detto che la loro combinazione dia come risultato un sistema sicuro questo l'ho detto e ripetuto tante volte le proprietà di sicurezza non sono di base composizionali voi non potete prendere due protocolli sicuri dimostrabilmente sicuri combinarli in sequenza in qualche altro modo e ottenere un protocollo che a sua volta è sicuro no questo non si può fare solo sotto certe condizioni particolari quindi ad esempio per risolvere il problema del dell'authenticated key exchange non è che potete prendere che ne so un protocollo di key exchange come RSA puro o di Fielman puro combinarlo con un protocollo di identificazione come quelli che abbiamo visto la settimana scorsa in qualche maniera più o meno banale dire ecco il risultato è un protocollo di autenticata di key exchange che soddisfa autenticazione e segretezza no questo non si può fare qualunque soluzione voi costruite dovete dimostrare che è sicura senza potervi affidare a quelle che sono le proprietà di sicurezza delle sue componenti ok lì ho messo una citazione di due crittografi famosi che sostanzialmente dice proprio questo no non pensate l'essenza di quella citazione è non pensate che sia sufficiente combinare ingredienti sicuri per ottenere un sistema sicuro ok non è così che si fa insomma purtroppo non è sufficiente lo dimostra il fatto che uno dei due stessi è stato vittima di di questa leggerezza perché vi farò vedere un protocollo sviluppato proposto da lui basato su ingredienti sicuri che però la sua costruzione ha delle vulnerabilità di cui né lui né altri si erano accorti ci sono voluti 17 anni per trovare la vulnerabilità su questo per darvi un'idea di quanto sia complesso verificare le proprietà di sicurezza su protocolli anche semplici nel momento in cui utilizziamo modelli avversari complessi come quelli che garantiscono gli attacchi di tipo ma in demand va bene direi che per oggi ci possiamo fermare qua e ci vediamo domani ok vi anticipo che prossima settimana faremo una sola lezione delle tre previste ovvero faremo solo quella del mercoledì pomeriggio e in particolare vi volevo anticipare che la prossima settimana il motivo per cui non facciamo lezione giovedì è che giovedì c'è il career day ok voi non lo conoscerete il career day non so se qualcuno ma magari durante la triennale ve ne ho parlato il career day è la fiera delle aziende per dirla in estrema sintesi è un momento in cui studenti laureati laureati possono incontrare le aziende e vedere se c'è matching di opportunità competenza opportunità no adesso a margine del career day la prossima settimana ci saranno dei workshop e dei laboratori di orientamento e di preparazione quindi chi ad esempio vuole farsi correggere il curriculum o cose di questo genere c'è un programma completo di questi laboratori sul sito di Ateneo anzi adesso se andate sul sito di Ateneo avete presente il banner centrale quello che scorre con gli eventi in evidenza tra quelli c'è career day cliccate lì e venite mandati direttamente sulla pagina del career day che è hello.uniorb.it slash career day ok lì c'è il programma completo di tutti gli eventi collaterali che cominciano lunedì prossimo fino ad arrivare alla fine dell'azienda che è giovedì 15 se volete partecipare a quelli e quelli eventi vi potete registrare online o anche presentarvi direttamente non è obbligatorio sì sì per il curriculum check bisogna prenotarsi perché se altrimenti vai lì e fai la fila il curriculum check lo fanno a San Girolamo bravissimo fantastico fantastico e comunque anche alcuni laboratori sono molto interessanti a parte il CV check ce ne sono di molto interessanti alcuni che riguardano ad esempio il profilo LinkedIn cose utili di questo genere mentre invece l'appuntamento con le aziende è giovedì prossimo tra l'altro qui di sotto al primo piano di collegio Rafferlo dove ci sono le sali comunali ci sono una cinquantina di aziende io quello che ho fatto è stato pubblicare sul forum delle comunicazioni degli studenti in Blended se non siete registrati andateci o se non me lo chiedete io li ho pubblicato l'annuncio del 3D e ho messo come allegato un pdf dove c'è l'elenco di tutte le aziende che partecipano con i profili a cui loro sono interessati quindi andate lì dateci un'occhiata se non lo trovate me lo dite me lo mando su Blended nel forum non so se è ancora aperto qui allora comunicazioni voi no questo non mi interessa vabbè eccolo qua questo pubblicazione per studenti LM18 eccolo qui l'ho messo lì in evidenza il primo rimane rimane in evidenza vediamo se c'è ecco vedete c'è un pdf in allegato e non so che può dire questa cosa dove siamo qua ok quindi siamo nel nel forum del corso comunicazioni per studenti e qui trovate anche questo è il link alla pagina dove c'è il programma che è questa qui trovate il programma completo con tutti gli eventi e prenotabili no poi come dicevo prima in questo pdf provate i profili di tutte le aziende e le opportunità che loro portano qua sempre attraverso il portale se volete potete prenotare un colloquio con l'azienda durante la la fiera o altrimenti venite durante la fiera e quando trovate lo stand libero vi proponete ok quindi non è obbligatorio prenotarsi diciamo che se vi prenotate avete la possibilità ad esempio di mandare in anticipo il vostro curriculum così l'azienda lo vede e quando andate lì a parlare sanno già chi siete se no andate lì e fate due chiacchiere con loro è interessante anche perché nel nostro ambito a parte che ci sono un sacco di profili per informatici da parte di tante aziende ma poi è chiaro che in prima battuta le aziende vengono perché sono interessate a fare recruitment ma prendono anche tirocinanti ok quindi non pensate che sia solo un'occasione per trovare lavoro ma spesso o l'intero queste aziende offrono offrono anche semplicemente dei tirocini per studenti e questo è particolarmente vero nel nostro ambito perché c'è scarsezza di laureati in informatiche quindi molto spesso le aziende sono contente anche di interagire con tirocinanti ok io sarò lì quindi potete anche chiedere a me informazioni e consigli la fiera ci svolgerà appunto giovedì prossimo mattina e pomeriggio ed è qua quindi approfittatene per per fare un giro anche insomma magari anche per fare un po' di di di passaparola di questa cosa qua va bene questo è ok ci vediamo domani con