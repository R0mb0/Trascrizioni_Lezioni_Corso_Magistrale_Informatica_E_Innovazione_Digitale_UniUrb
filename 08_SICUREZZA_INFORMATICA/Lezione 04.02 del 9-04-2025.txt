Ok, allora eccoci qua. Dunque, fino alla volta scorsa abbiamo visto i principi della cifratura a chiave simmetrica, sia per risolvere il problema della confidenzialità che il problema dell'intervità. Quindi metodi basati sul fatto che si usa la stessa chiave per cifrare e decifrare, così come per segnare con lo scopo di creare un tag e quindi verificare il tag. Oggi cambiamo approccio e andiamo a vedere invece come sono fatti i sistemi di cifratura a chiave asimmetrica, ovvero sistemi che, come vedremo, utilizzano chiavi diverse per cifratura e decifratura. Sistemi di questo genere li useremo per risolvere questo problema, ovvero il problema dell'anonymous key exchange, che è un problema fondamentale anche per i sistemi che abbiamo visto fino alla settimana scorsa, perché se vi ricordate, una ipotesi che abbiamo sempre fatto, un'assunzione che abbiamo sempre fatto, è che, ad esempio, Alice e Bob, se vogliono comunicare usando, ad esempio, l'authenticata da encryption, quindi garantendo sia confidenzialità che integrità, devono conoscere a priori un master secret, devono condividere una chiave, più chiavi, da utilizzare per le operazioni criptografiche che devono essere eseguite. Come fanno a condividere questo master secret a priori? Noi abbiamo sempre assunto che c'era già, che era già condiviso, adesso invece dobbiamo vedere quali metodi possiamo usare per arrivare a far condividere da Alice e Bob un master secret. Quindi il problema è appunto quello di permettere a due utenti che non condividono informazioni segrete, di arrivare a stabilire una comunicazione sicura, quindi arrivare a condividere un segreto comune. Ok? Le assunzioni che faremo è che non c'è nessuna garanzia sull'identità degli utenti che devono risolvere questo problema, poi dell'identità ne parleremo più avanti, e l'obiettivo naturalmente è quello che abbiamo appena detto, ovvero Alice e Bob non condividono niente, nessun tipo di informazione segreta tra loro, però vogliono eseguire un protocollo di comunicazione al termine del quale Alice e Bob e nessun altro condivideranno un segreto K, il master secret di cui abbiamo parlato già diverse volte in passato. Ok? Vi mostrerò due approcci diversi, due modi piuttosto diversi di risolvere questo problema. Il primo si basa su linea di principio, poi può essere implementato in vari modi e di implementazioni ve ne mostrerò una sola. Il principio fondamentale si basa su quello che viene chiamato schema di funzione contractor. Come vedremo, l'idea di questo schema è di utilizzare funzioni che... Torniamo l'attimo indietro, ripensiamo le funzioni hash con chiave, ok? Facciamo questo esempio, no? Nelle funzioni hash con chiave noi sappiamo che utilizzando appunto la chiave, applicandola all'input, è possibile ottenere un digest che non è invertibile, ok? Naturalmente per chi non conosce la chiave. Quell'idea è un po' simile, nel senso che si utilizza una chiave applicata al messaggio per ottenere un qualche cosa, un output che non è invertibile, ok? Nemmeno conoscendo la chiave che è stata usata per ottenerlo, questo output. Però per consentire di recuperare, a partire dall'output, a partire dalla cifratura, il messaggio di partenza, assumeremo che nella funzione c'è quella che chiamiamo trapdoor, quindi una sorta di backdoor, che consente di invertire l'output, ok? Solo conoscendo la trapdoor sarà possibile invertire l'output. Questa è un po' l'idea. E la trapdoor prende la forma di un'altra chiave, diversa da quella usata per la cifratura, la cui conoscenza consente di invertire la funzione, ok? Quindi di nuovo avremo a che fare con funzioni che a meno della conoscenza della trapdoor non sono invertibili e quindi funzioni che garantiranno la segretezza dell'informazione che può essere recuperata solo ed esclusivamente conoscendo la trapdoor, cioè conoscendo quell'informazione necessaria per invertire la funzione. in gergo le chiavi, le diverse chiavi che vengono utilizzate sono la chiave pubblica, la cosiddetta chiave pubblica per quella che sarà la cifratura e la chiave segreta che invece è l'informazione necessaria per invertire la funzione, cioè l'informazione che rappresenta la trapdoor, la nostra backdoor. Questa è un po' l'idea. Formalmente uno schema di funzione con trapdoor è una tripla fatta di tre algoritmi, ok? Abbiamo l'algoritmo per la generazione delle due chiavi, delle due informazioni che ci servono per applicare la funzione e la sua inversa e poi abbiamo le due funzioni, i due algoritmi, ok? Che chiamiamo F e D, quindi andiamo a vedere come si comportano questi tre algoritmi. G, abbiamo detto, è l'algoritmo che serve per generare le chiavi, ok? Quindi G è una funzione probabilistica, quindi il risultato di G è randomico, che ha il compito appunto di generare due chiavi, la chiave pubblica e la chiave privata, la chiave segreta, ok? Pk, sk. Pk è la public key, sk è la secret key, ok? Tra queste due chiavi vedremo c'è un legame, c'è una relazione che è quella che scopriremo andando a vedere come sono fatti i due algoritmi, che sono appunto rispettivamente F e I, ok? F è l'algoritmo deterministico che prende in input un messaggio, X, prende in input la chiave pubblica e come output restituisce un valore Y appartenente al codominio di riferimento del nostro schema, ok? Quindi F è la funzione che mappa l'input X dell'output Y per effetto dell'applicazione della chiave pubblica, ok? Ok? Ok? Come dicevo prima a livello intuitivo F dovrebbe in teoria essere non invertibile, cioè l'idea è che conoscendo Y non dovrebbe essere possibile recuperare X, l'X che l'ha generato, anche se io conosco la public key, ok? per invertire Y e recuperare X ci vuole una trapdoor, questa trapdoor è la chiave segreta e qui entra in gioco l'algoritmo, la funzione I che è quella funzione come vedete che prende Y e conoscendo la chiave segreta SK è in grado di recuperare X, ok? l'input cioè l'input che aveva generato Y usando F ok? quindi se vogliamo I rappresenta la funzione inversa di F con una particolarità ovvero per applicare F dobbiamo conoscere la chiave pubblica per applicare I dobbiamo conoscere la chiave segreta questa è la idea generale di questo tipo di schemi ok? poi abbiamo la proprietà di correttezza naturalmente che dice che uno schema fatto così è corretto se vale questa questa condizione qua che ci dice appunto che se noi applichiamo la funzione F all'input X e usando la chiave pubblica Pk prendiamo il risultato e lo diamo in pasto alla funzione I che però deve usare la chiave segreta allora dobbiamo recuperare l'X di partenza ok? quindi riassumendo la chiave pubblica ci serve per mappare X nell'output corrispondente Y la chiave segreta ci serve per a partire da Y recuperare X ok? ok? se questo schema se in questo schema voi assumete che X e Y cioè dominico dominio sono uguali allora lo schema che abbiamo descritto è uno schema di permutazione permutazione perché perché l'algoritmo F non farà altro che mappare un elemento dell'insieme X in un altro elemento dello stesso insieme X quindi si comporta come una permutazione ok? sì sì sì lo scopo lo scopo dell'algoritmo G è appunto generare una coppia randomica chiave pubblica chiave segreta che naturalmente soddisfa la condizione di correttezza quindi fra quelle due chiavi c'è un legame univoco per cui una certa chiave segreta sarà in relazione con una sola chiave pubblica viceversa in maniera tale da soddisfare la proprietà di correttezza ok? poi come implementare l'algoritmo G dipende dai vari metodi noi ne vedremo ne vedremo ne vedremo uno solo ecco ok? quindi viene creata la coppia di chiavi dopodiché abbiamo i due algoritmi quello che usa la chiave pubblica per mappare x in y e quello che usa la chiave segreta per mappare y in x ok? ora come per tutti le diciamo gli schemi i meccanismi fotografici che abbiamo studiato c'è una nozione di sicurezza ok? legata a questo tipo di schemi che si basa come al solito su una tag game no? quindi su una strategia dell'avversario ok? e intuitivamente è piuttosto semplice la tag game nel senso che abbiamo il challenger no? che usa l'algoritmo g per creare la coppia di chiavi ok? e dopodiché sceglie i x da cui applicare la funzione f e che cosa fa? manda all'avversario la chiave pubblica perché quella la possono conoscere tutti ok? e gli manda la codifica di x no? tramite la chiave pubblica pk usando l'algoritmo f ok? quindi gli manda y il nostro y quindi all'avversario all'avversario arrivano arriva questa coppia ok? quindi l'avversario sa che il challenger ha usato questa chiave per mappare un x che non conosce in un output che è y quindi l'avversario conosce y conosce la chiave pubblica ok? il compito dell'avversario l'obiettivo dell'avversario è cercare di recuperare x cioè invertire y ok? chiaramente l'avversario fa tutto quello che vuole esegue un suo algoritmo efficiente l'unica cosa che non sa è naturalmente quanto vale la chiave segreta oltre che x queste cose non le sa l'avversario fa il suo guess fa il suo tentativo e chiaramente il suo vantaggio è la probabilità di indovinare qual è qual è l'x che ha usato il challenger ok? noi diciamo che il nostro schema è one way secure quindi è non invertibile no? se il vantaggio dell'avversario è negligible per tutti gli avversari efficienti cioè in pratica l'avversario in pratica non è in grado se non conosce la trapdoor che è la chiave segreta non è in grado di recuperare h ok? ora se noi abbiamo uno schema di questo genere che sia one way secure possiamo risolvere il problema che abbiamo detto all'inizio cioè quello dell'anonymous key exchange cioè come fanno Alice e Bobo che non si conoscono non condividono nessuna informazione a eseguire un protocollo al termine del quale condividono un segreto ok? la soluzione se abbiamo uno schema di questo genere che sia one way secure è molto semplice ve la faccio vedere con un esempio ok? quindi immaginate di avere uno schema one way secure quindi uno schema non invertibile ok? Alice che cosa fa? Alice usa l'algoritmo G per generare la coppia di chiavi chiave pubblica chiave segreta manda la chiave pubblica a Bob ok? a questo punto Bob che cosa fa? sceglie randomicamente un x ok? se lo tiene per sé lo conosce solo lui no? e cosa fa? calcola y in questo modo ok? quindi usa la chiave pubblica che gli ha mandato Alice per mappare x in y e a questo punto manda y ad Alice ok? ora cos'è successo qui? vediamo l'andshade Alice Bob Alice ha scelto questa coppia e ha mandato la chiave pubblica a Bob ok? Bob ha scelto x e ha mandato y ad Alice dove y è no? l'output di x rispetto alla chiave pubblica pk ok? quindi chi osserva il canale in trasmissione vede passare la chiave pubblica pk pk e vede passare y ma se il nostro schema è one way secure quindi vuol dire che se torniamo alla tag game di prima l'avversario che sta qua in mezzo vede pk vede y non vede x non vede la chiave segreta quindi la sua probabilità di indovinare x è negligible se lo schema è one way secure ok? quindi questo significa che solo Alice è in grado di recuperare x perché quando riceve y Alice non deve fare altro che applicare il terzo algoritmo l'algoritmo i che usa la chiave segreta rispetto a y e recupera x ok? quindi a questo punto Bob conosce x perché lo ha scelto x conosce x perché è riuscito a invertire in ventine y nessun altro conosce x ok? quindi alla fine di questo scambio solo Alice e Bob conoscono x quindi x è un master secret che conoscono solo Alice e Bob e quindi magari da questo momento in avanti possono usare x per come chiave come chiave per un per l'autentichetta di encryption che abbiamo visto la volta scorsa ok? in realtà come vedremo le cose sono un po' più complicate di così perché è vero che alla fine di questo scambio solo Alice e Bob condividono x però nessuno dei due ha garanzia dell'identità dell'altro ok? questo è un problema che affronteremo più avanti exactly Alice è non sicuro about the fact che è parlare con Bob e viceversa ok? ma è un problema all'attività bene bene tutto chiaro? ci siamo? benissimo ora come implementare questo questo schema di in maniera da perché l'idea è va bene cerchiamo G, F e I in modo tale da soddisfare la One Way Security ok? e lo schema che vi racconto anche se non voglio entrare in dettagli matematici per lo meno a livello di giustificazione è un esempio di schema di permutazione con Trapdoor il primo uno dei primi proposti che è appunto RSA abbastanza famoso RSA che appunto prende il suo nome dagli iniziali dei tre che lo hanno inventato Rivest Shamir e Adelman Rivest e Shamir sono due criptografi Adelman un matematico e lo schema risale a la pubblicazione dello schema risale dal 1977 quindi anche decisamente vecchiotto ormai e vi mostro senza giustificare troppo i risultati matematici che ci stanno sotto come funziona G cioè l'algoritmo che genera le due chiavi e poi vi faccio vedere come funzionano le due funzioni F per mappare x in y e I per mappare y in x la seconda della chiave che si usa partiamo dall'algoritmo G ok allora l'algoritmo G per generare le due chiavi che si chiama RSA gen l'algoritmo per generare le chiavi RSA vuole due parametri il primo parametro L rappresenta la lunghezza dei valori numerici che vengono usati per generare le chiavi e quindi la lunghezza delle chiavi ok quindi L se vogliamo dipende dal famoso parametro lambda che stabilisce il livello di sicurezza del nostro meccanismo criptografico più grande è meglio è ok come al solito l'altro parametro è un numero intero E che come vedremo è parte della chiave pubblica ok come funziona l'algoritmo a partire da questi due da questi due parametri l'algoritmo deve generare due numeri random entrambi primi di lunghezza L bit ok questi due numeri primi li chiamiamo P e Q ok in genere L è un valore piuttosto grande quindi poi faremo due conti questi due numeri primi devono avere una caratteristica ovvero il massimo comune divisore tra P meno 1 e l'intero E così come il massimo comune divisore tra Q meno 1 e l'intero E deve essere uguale a 1 quindi P meno 1 Q meno 1 ed E non hanno divisori comuni a parte naturalmente l'1 ok chiaramente P e Q devono essere diversi tra di loro quindi prima cosa che fa l'algoritmo è scegliere due numeri primi di questa lunghezza e che soddisfano queste due condizioni dopodiché l'algoritmo calcola il prodotto di questi due numeri primi P per Q ok dopodiché calcola l'inverso di E modulo la linea aritmetica modulare modulo P meno 1 per Q meno 1 ok chi è l'inverso no ecco il particolare numero tale per cui E per D modulo P meno 1 per Q meno 1 1 fa 1 ok quindi non è il classico inverso a cui siamo abituati no quando parliamo di inverso non è questa roba qua no per inverso intendiamo il fatto che è soddisfatta questa relazione quando naturalmente moltiplichiamo in modulo questa quantità qua ok il risultato finale dell'algoritmo che abbiamo appena visto è questa coppia ok quindi siamo partiti da un parametro che mi dice quanto devono essere lunghi i numeri con cui stiamo lavorando un intero E e il risultato è N che è il prodotto di due numeri primi e D che è l'inverso di E modulo P meno 1 per Q meno 1 dove P e Q sono quei due numeri primi in cui il prodotto fa N ok l'ultima cosa che ho detto qual è stata non mi ricordo più di chi ho detto che N è il prodotto di due numeri primi scelti dall'algoritmo e D è l'inverso di E modulo P meno 1 per Q meno 1 dove P e Q sono i due numeri primi in cui il prodotto è perché tutte queste condizioni perché adesso come vedremo tra poco sono condizioni che ci permettono di definire chiave pubblica e chiave privata e ci permettono di definire funzione F e funzione I in maniera tale da soddisfare le condizioni degli schemi di permutazione con Trapdon non invertibili che alla fine è il nostro obiettivo ok quindi ricordiamoci i vari parametri no siamo partiti da questi due no in input poi P e Q i due numeri primi no che soddisfano questa condizione sulla loro divisibilità rispetto a E poi abbiamo tirato fuori D che è l'inverso di E modulo P-1 come 1 e infine abbiamo detto che è N P per Q ok bene cosa ce ne facciamo di queste informazioni nel processo di costruzione delle chiavi andiamo a vedere ok quindi vedete questo è lo step che abbiamo eseguito no siamo partiti da L e da E e applicando l'algoritmo G che abbiamo appena discusso abbiamo prodotto questi altri due valori ok bene ora la chiave pubblica è la coppia N ok la chiave segreta è la coppia N D o detta se vogliamo più semplicemente E è la chiave pubblica D è la chiave segreta posto che tutti siano d'accordo su chi è N alla fine N è un'informazione pubblica visto che fa parte della chiave pubblica quindi l'informazione veramente segreta è D ok questa è quindi questa è la coppia di chiavi perché questa coppia di chiavi funziona rispetto alla proprietà di correttezza del nostro schema di promotazione e contratto dobbiamo vedere come sono fatti F di ok F è fatta così poi dimostreremo la proprietà di correttezza D è fatta così I è fatta così quindi l'algoritmo F prende l'input X e vedete lo eleva alla E che è la chiave pubblica in ZN ok siamo sempre in aritmetica modulare in ZN l'algoritmo I prende Y e lo eleva alla D D è la chiave segreta sempre in ZN ok ora per dimostrare che questa tripla di algoritmi soddisfa le condizioni di correttezza ok in pratica dobbiamo dimostrare che X alla E tutta elevata alla D mi restituisce X ok o dette in altri termini X alla E D uguale a X ok cioè questo dobbiamo dimostrare questo se dimostriamo questa modulo N perché siamo in aritmetica modulo N se dimostriamo questa cosa qui abbiamo dimostrato la correttezza di RSA ok e per dimostrare la correttezza di RSA useremo tutte le proprietà che abbiamo che derivano dal modo in cui abbiamo costruito D a partire da a partire da dalla scelta di P e Q e di E naturalmente ok andiamo a vedere la prova di correttezza ok allora torniamo un attimo indietro ok abbiamo detto che dobbiamo dimostrare questa cosa qui ok noi sappiamo che è il prodotto di P per Q ok e l'anello di congiunzione tra le due è questa condizione qua ok in virtù di come avevamo dove è equivalente sta per l'equivalenza ok vuol dire che sono equivalenti danno lo stesso risultato ok questo per come abbiamo definito D no perché D è l'inverso D modulo P meno 1 P meno 1 ok quindi veniamo alla dimostrazione di correttezza l'ipotesi è che E per D è equivalente a 1 modulo P meno 1 Q meno 1 perché D è l'inverso di E ok questa è l'ipotesi no per come abbiamo calcolato D ok quindi D è l'inverso di E quindi per ipotesi E per D è uguale a 1 modulo P meno 1 Q meno 1 ok questo che cosa implica adesso vediamo i vari passaggi questo implica che E per D è un multiplo di P meno 1 per Q meno 1 più 1 ok no perché E per D è 1 modulo P meno 1 per Q meno 1 quindi vuol dire che che ne so facciamo un esempio pratico se siamo in modulo 7 ok 4 per 2 fa 8 e quindi è 1 modulo 7 quindi vuol dire che 4 per 2 è un multiplo di di 7 più 1 e infatti è 1 più 7 ok quindi E per D è un multiplo di P meno 1 per Q meno 1 quindi vuol dire P meno 1 per Q meno 1 moltiplicato un certo numero di volte più 1 no proprio in virtù di questa ok ora facciamo un po' di passaggi algebrici che sono quelli che vedete qui no no allora noi vogliamo dimostrare che X alla ed ha una certa proprietà che adesso dovremmo vedere quindi scomponiamo X alla ed no che è uguale a questa roba qui grazie a questa ipotesi ok applichiamo un po' di proprietà del dell'avamento a potenza e otteniamo questo ok perché questo X per è quell'1 lì il resto è X elevato alla P meno 1 elevato alla K P meno 1 ok perché facciamo questa scomposizione perché adesso vogliamo sfruttare questo teorema dimostrato da Fermat ok e applicando questo teorema noi arriviamo qui perché X alla P meno 1 modulo P fa 1 ok ma X moltiplicato 1 alla bla bla bla fa sempre X quindi cosa abbiamo dimostrato abbiamo dimostrato che X elevato alla ed è uguale a equivalente a X modulo P con un po' di passaggi algebrici ok ma se voi invertite il ruolo di P e di Q nella stessa maniera possiamo anche dimostrare questa uguaglianza ok voi invertite il ruolo di P e di Q fate gli stessi passaggi quindi così come abbiamo dimostrato che X alla ed è uguale a X modulo P possiamo dimostrare anche che X alla ed è uguale a X modulo Q ok quindi cosa vuol dire vuol dire che X alla ed è un multiplo sia di P che di Q più X ok poi in altre parole X alla ed meno X è un multiplo sia di P che di Q quindi un multiplo di N perché N è il prodotto di P e Q ok quindi cosa vuol dire questo che X alla ed è uguale a X modulo N perché abbiamo detto che X alla ed meno X divide sia P che Q quindi è un multiplo sia di P che di Q ma se è un multiplo sia di P che di Q è anche di N quindi vuol dire che X alla ed è equivalente a X mod 1 ok che è esattamente quello che volevamo dimostrare dato che X alla ed è il risultato della applicazione della funzione f e della funzione i quindi vale la proprietà di correttezza quindi abbiamo dimostrato che RSA è corretto per come abbiamo scelto D a partire da E alla luce dei numeri primi P e Q che ci stanno sotto ok semplicemente con un po' di passaggi algebraici perché alla fine il cuore della dimostrazione sono questi passaggi algebraici qui ok che dipendono da questa ipotesi che dipende dal fatto che D è l'inverso di E modulo P-1 come 1 tutto qua quindi alla fine i passaggi sono due niente di niente di strano o troppo complicato quindi RSA è corretto questa è la conclusione che a noi interessa vi ho fatto vedere passaggi matematici che ci stanno sotto i risultati che ci stanno sotto ma quello che interessa è che RSA è corretto dove ripeto quello che ci interessa ricordare è quello che vediamo qui ovvero ricordandoci come funziona RSA come si calcola D a partire da E passando per la scelta di due numeri primi P e Q dopodiché sappiamo che la definizione di F è questa che abbiamo visto cioè si prende X e lo si eleva la E modulo N è per quello che nella definizione delle due chiavi ci portiamo dietro anche il valore di N perché? perché N ci serve per capire in che modulo applicare e ci serve sia qui che qui quindi per questo motivo si dice che N fa parte sia della chiave pubblica che della chiave segreta perché è un valore che serve sia in F che in I ok dopodiché questa è un'informazione pubblica questa invece non lo è questo è segreto ok quindi a noi quello che ci basta ricordare è quali sono come si usano le due chiavi si fa l'elevamento potenza ok facciamo un esempio banale banale che segue l'idea dello scambio tra Alice e Bob di cui parlavamo prima ok quindi partite da Alice Alice deve scegliere le due chiavi ok quindi immaginiamo un gioco molto semplice che Alice sceglie L uguale a 6 quindi le chiavi hanno sono di lunghezza 6 bit ok quindi i valori che possiamo rappresentare sono fino a 2 alla 6 sono pochini pochini ok e sceglie E un intero dispari uguale a 3 ok a questo punto Alice deve eseguire l'algoritmo RSA Gen che dice scegli due numeri primi tali che il loro predecessore non ha divisori comuni con E ad esempio scegliamo 11 e 3 sono due numeri primi il predecessore di 11 e 10 10 e 3 ok non hanno divisori comuni sono coprimi tra di loro così come 2 che è il predecessore di 3 e 3 sono coprimi tra di loro quindi 11 e 3 vanno bene come numeri primi poi scegliamo N calcoliamo N che è il prodotto di P e Q cioè 33 ok 11 per 3 ok a questo punto dobbiamo calcolare l'inverso di E modulo P meno 1 Q meno 1 ok cioè dobbiamo calcolare quel valore tale per cui 3 per D è uguale a 1 modulo P meno 1 per Q meno 1 P meno 1 è 10 Q meno 1 è 2 quindi modulo 20 ok quindi dobbiamo cercare quel D che soddisfa questa uguaglianza ok qui è facile vedere che se D è uguale a 7 7 per 3 21 e 21 è 1 modulo 20 ok quindi D quindi D è 7 quindi ora abbiamo la chiave pubblica che è la coppia 33 3 cioè N ed E e la chiave segreta che è la coppia 33 7 cioè N e D ok queste sono le due chiave quindi Alice fin qui non ha fatto altro che applicare l'algoritmo di generazione in maniera randomica perché comunque le scelte che sono state fatte sono randomiche e a questo punto abbiamo visto nell'esempio di prima che Alice deve mandare a Bob la chiave pubblica Bob riceve la chiave pubblica sceglie un segreto ok lo sceglie in Z in Z 33 perché lavoriamo in Z ok quindi ipotesi sceglie 14 se lo tiene per sé ok a questo punto deve applicare l'algoritmo F a 14 quindi quell'algoritmo che prende la chiave pubblica no che è quella che ha ricevuto da Alice prende 14 e ne tira fuori il valore e come avviene il calcolo di come avviene come funziona l'algoritmo F dobbiamo fare 14 elevato alla E perché è quello che fa l'algoritmo F ok quindi 14 alla 3 modulo 33 siamo sempre in modulo siamo sempre in ZN modulo 33 se fatti i conti con la calcolatrice 14 da 3 modulo 33 fa 5 ok quindi Y è 5 a questo punto Bob manda Y ad Alice Alice per recuperare X non deve far altro che prendere 5 e elevarlo a D alla D che è la chiave segreta modulo 33 siamo sempre in ZN e quindi deve fare 5 alla 7 modulo 33 e il risultato è 14 ok quindi vedete tutto quanto è piuttosto complesso dal punto di vista dei calcoli da fare perché ci sono da fare operazioni di elevamento a potenza in aritmetica modulare che sono operazioni piuttosto costose implementare sia come soluzione hardware ma anche come soluzione software problemi di questo genere è piuttosto costoso quindi RSA è un algoritmo non efficiente dal punto di vista delle performance proprio per la quantità di calcoli che devono essere effettuati quindi ricordiamoci questo è uno dei motivi per cui come vedremo poi la cifratura basata su questo tipo di schemi viene usata al minimo indispensabile poi non appena si condivide un master secret l'idea è di tornare a usare l'autenticata di encryption che è molto più efficiente ok bene abbiamo dimostrato ho fatto vedere con un esempio che RSA è corretto è corretto perché in questo caso X alla E alla D modulo 33 ci restituisce di nuovo X ok quindi abbiamo la proprietà di correttezza ma cosa possiamo dire invece rispetto alla One Way Security quindi rispetto all'hautal game della sicurezza possiamo dire che RSA è sicuro rispetto rispetto a questa proprietà di sicurezza possiamo dire che un avversario che conosce solo E e conosce l'output Y e quindi non conosce X non conosce D ha una probabilità negligible di recuperare X quindi vale la One Way Security per RSA da un punto di vista prettamente formale non esiste un teorema che ci dice questo matematicamente parlando non possiamo dimostrare che non possiamo non esiste una dimostrazione del fatto che RSA è One Way Secure ok perché non si possa un altro discorso però sicuramente non esiste però ci sono delle prove empiriche ok cioè dal 1977 a oggi tutti i tentativi che sono stati fatti per violare la Huawei Security di RSA ci hanno fatto capire alcune cose intanto l'algoritmo più efficiente conosciuto che è in grado di invertire la funzione dell'RSA ok senza conoscere la chiave consiste nel recuperare il valore di P di Q a partire da N ok N è pubblico no N è pubblico e sappiamo che è P per Q a P per Q non sono pubblici non li conosce solo Alice che ha generato le chiavi ok ora è chiaro che se l'avversario a partire da N riesce a recuperare P e Q ha già risolto il problema perché perché D è l'inverso di E modulo P meno 1 meno 1 quindi se io conosco P e Q conosco il modulo E è pubblica quindi conosco E conosco il modulo calcolare l'inverso di E rispetto a quel modulo è un gioco da ragazzi è facile ok quindi sicuramente un modo per hackerare invertire la funzione dell'RSA senza conoscere la chiave segreta consiste nel recuperare P e Q ovvero risolvere un problema matematico classico che è la scomposizione di fattori primi perché N è il prodotto di numeri primi quindi il problema che dobbiamo risolvere è la scomposizione di N in fattori primi ok no ora la scomposizione di intero i fattori primi è un problema che per quanto se ne sa oggi non si risolve polinomialmente ok ma ha una complessità esponenziale per cui se N è sufficientemente grande ok ovvero se L è sufficientemente grande perché N è un numero intero a L bit no perché L è il parametro che ha scelto Alice all'inizio il parametro di sicurezza ok quindi se N è un numero un numero sufficiente di bit visto che la sua scomposizione in fattori primi è una complessità esponenziale rispetto ai metodi noti naturalmente un algoritmo efficiente capace di scomporre N fattori primi non c'è se N è sufficientemente grande oggi sufficientemente grande significa un valore di L compreso fra 1000 e 1500 quindi stiamo parlando di 1000 1500 bit numeri esprimibili da 1000 e 1500 bit ok per il valore di N poi di conseguenza un discorso analogo vale naturalmente per la chiave pubblica e la chiave privata perché alla fine tutte quante dipendono no torniamo torniamo alla definizione dell'RSA siccome lavoriamo in ZN ok quindi anche X e Y anche X e Y saranno in ZN e per quanto riguarda E e D di nuovo siamo lì attorno perché E D è l'inverso di E in Z P-1 Q-1 siamo nello stesso ordine di grandezza di N visto che N è P per Q quindi stiamo parlando di numeri molto grandi quindi stiamo parlando di operazioni come X alla E e Y alla D molto costose perché stiamo parlando di numeri molto grandi ok quindi è opinione comune che se si sceglie un valore di L compreso fra 1000 e 1500 siamo ragionevolmente sicuri rispetto ad un avversario che cerca di risolvere l'inversione il problema dell'inversione della funzione dell'RSA fattorizzando N nei suoi fattori primi quindi cercare chi sono P e Q ok quindi partiamo da un risultato certo ovvero il fatto che è difficile scomporre N in fattori primi per arrivare a dire che un avversario che cerca di rompere RSA scomponendo N in fattori primi non ce la fa un avversario efficiente non ce la fa se N è sufficientemente grande ok però non esiste nessun teorema che dice questo è l'unico modo di rompere RSA sicuramente un modo per rompere RSA è scomporre N fattori primi ma scomporre N fattori primi è difficile è hard se N è sufficientemente grande e quindi da quell'altro punto di vista siamo safe ok però nessun teorema ci garantisce il fatto che non ci siano altre vulnerabilità qua dentro dentro scusate dentro dentro questo algoritmo cioè dentro la generazione delle due chiavi e dentro la definizione di FD ci sono altre vulnerabilità che permetterebbero ad un avversario di invertire la funzione F senza conoscere la chiave segreta non si sa ok non si sa l'unica cosa che sappiamo è che un avversario che cerca di scomporre N fattori primi un avversario efficiente che cerca di scomporre N fattori primi non ce la fa con probabilità non negligible se N è sufficientemente grande detto questo non sappiamo nient'altro ok quindi per questo diciamo che la one way security di RSA si affida in parte alla difficoltà di un problema matematico che è la scomposizione di fattori primi e in parte alle prove empiriche perché dal 1977 a oggi altri modi di violare RSA non sono stati trovati ok per cui oramai si pensa che ha metodi per accelerare la scomposizione di anni fattori primi ma anche lì almeno finché siamo nell'ambito del metodo di sito classici non c'è soluzione la soluzione ci sarebbe efficiente se avessimo i computer quantistici tanto per fare un esempio perché con un computer quantistico risolveremmo la scomposizione di fattori primi di n in tempo polinomiale però lì si tratta di un modo basato sulla potenza di calcolo di un sistema piuttosto che sulla effettiva debolezza di vulnerabilità di RSA questa è un po' l'idea ok quindi piuttosto che un teorema esiste una congettura una soluzione che è appunto la congettura dell'RSA che ci dice che se effettivamente vale quello che abbiamo detto cioè il fatto che la scomposizione dei fattori primi hard se n è grande non esiste un'altra vulnerabilità allora siamo ragionamente sicuri del fatto che l'avversario abbia una probabilità negligible efficiente abbia una probabilità negligible di rompere RSA invertendo l'output senza conoscere la chiave segreta D però oltre questo non possiamo dire quindi siamo nell'ambito delle congetture nel campo delle pure congetture che finora però hanno funzionato quindi abbiamo visto RSA come un modo per implementare gli schemi di permutazione con trapdoor che sono un modo per risolvere il problema dell'anonymous key exchange poi vedremo tra poco che schemi di permutazione con contratto come RSA si possono usare per fare cifratura ok quindi per risolvere il problema della confidenzialità però contrariamente a quello che possiamo pensare non lo possiamo usare così com'è non sarebbe semantica un cifrario che usa RSA così com'è non è semanticamente sicuro lo vedremo con il classico attack game ok bisogna implicarlo un pochettino vedremo come ok quindi prima di arrivare a parlare di cifratura vi faccio vedere quello che rimane dall'edizione di oggi invece un modo alternativo di risolvere l'anonymous key exchange che non si basa sugli schemi con trapdoor è un modo completamente diverso nato e proposto più o meno nello stesso periodo in cui è nato RSA ok ed è un metodo che come vedremo è implementato è stato implementato da due criptografi e che si basa su una idea generale che adesso andiamo a vedere cioè così come RSA si basa sull'idea generale degli schemi di permutazione con trapdoor l'altro metodo che andremo a vedere si basa su un'idea generale che è questa che vediamo rappresentata in questa slide avete Alice da una parte Bob dall'altra ok Alice sceglie randomicamente un valore alfa Bob sceglie randomicamente un valore beta ok poi dovrebbero esistere base a questo schema delle funzioni un po' come negli schemi per mutazione con trapdoor abbiamo l'algoritmo F e l'algoritmo I che hanno certe caratteristiche qui analogamente abbiamo due funzioni due algoritmi che sono E ed F ok e è una funzione che viene usata per mascherare alfa o beta infatti vedete che Alice non manda a Bob direttamente alfa perché altrimenti lo imparerebbero tutti i valori di alfa ok invece lo scopo di Alice è tenere un segreto ok quindi che cosa fa Alice applica una funzione ad alfa e manda il risultato di questa funzione a Bob Bob fa la stessa cosa usando beta ok le assunzioni che riguardano E sono che dovrebbe essere facile dato alfa calcolare E alla alfa quindi E dovrebbe essere un algoritmo efficiente che consente ad Alice di calcolare l'output in maniera in maniera in maniera rapida ok quindi questa è la soluzione che riguarda E poi andiamo avanti vediamo che cosa succede dopo quindi Bob riceve un valore che è una sorta di valore mascherato di alfa quindi l'output che ha prodotto E analogamente Alice riceve E di beta ok a questo punto Alice userà un altro algoritmo che chiamiamo F ok applicato ad alfa e applicato al valore mascherato di beta quindi questi due che sono i valori che conosce Alice vengono combinati all'interno della funzione di un algoritmo F che quindi dipende da alfa e da beta e che dà un certo risultato dall'altra parte Bob fa la stessa cosa solo che come input Bob usa questi due e usando questi due dovrei ottenere lo stesso risultato che ottiene Alice ok quindi in pratica poi cerchiamo di capire perché devono valere queste condizioni però in pratica che cosa succede qui dentro succede che Alice usando alfa e il valore l'output di e di beta è in grado di calcolare il risultato finale Bob lo stesso risultato finale deve poterlo calcolare usando non alfa e di beta ma usando beta ed e di alfa quindi lo stesso risultato finale deve poter essere calcolato in due modi diversi a seconda delle informazioni che hanno a disposizione da una parte Alice e dall'altra Bob questi calcoli devono essere facili da fare quindi l'algoritmo e l'algoritmo F devono essere efficienti perché altrimenti non sarebbe praticabile e perché tutto questo sia sicuro è necessario che nessun altro a parte Alice e Bob deve essere in grado di calcolare l'output finale ok quindi l'output finale è questo F di alfa beta ok questo è l'output finale sarà il master secret ok questo schema mi sta dicendo che per calcolare questo valore devo conoscere o questa coppia oppure devo conoscere questa coppia non ci devono essere altri modi di calcolare questo risultato modi efficienti ok questi devono essere gli unici due modi per calcolare l'output ora questo è il modo che userà Alice questo è il modo che userà Bob nessun altro riesce a recuperare questo questo valore perché perché un avversario che cosa vede passare nel canale un avversario nel canale vede passare questi due ma conoscendo quei due l'avversario non deve essere in grado di recuperare il risultato finale quindi se in generale valgono queste condizioni quindi esiste un algoritmo E ed esiste un algoritmo F che garantisce queste condizioni abbiamo per le mani uno schema che garantisce l'anonymous key exchange perché perché per quello che abbiamo detto solo Alice e solo Bob anche se in modi diversi riescono comunque entrambi a calcolare lo stesso risultato e allora a quel punto quel risultato diventa il master secret condiviso tra loro due ok questo è lo schema generale poi un problema come per nel caso di prima il problema diventa capire se esiste un modo di definire E e di definire F in maniera tale da soddisfare tutte queste condizioni qua ok un modo esiste lo hanno definito due cryptography Diffy ed Hellman da cui viene appunto il nome del protocollo Diffy-Hellman che sfrutta questa idea qua no sulla base di una certa scelta dell'algoritmo E e dell'algoritmo F che adesso andremo a vedere ok quindi è chiaro lo schema generale adesso non ci interessa sapere come è fatta E e come è fatta F è importante capire lo schema generale e perché questo schema è sicuro sotto le condizioni che abbiamo elencato qua ok ok ci siamo bene allora se è chiaro questo andiamo a vedere come Diffy-Hellman definiscono E ed F ok anche loro analogamente all'RSA usano alcuni risultati matematici noti che aiutano appunto a garantire queste queste condizioni ok e vediamo un po' come funziona allora ci sono alcuni elementi simili a RSA intanto il fatto che si parte anche in questo caso da due numeri primi ok i due numeri primi sono P e Q P in genere molto più grande di Q quindi si parla di per P di stringhe a 2000 a 48 bit di solito per Q si parla di stringhe a 256 bit RSA si parlava di di stringhe tra i 1000 e i 1500 bit sia per un valore che per l'altro quindi tanto per fare un paragone stiamo parlando di numeri molto più grandi rispetto a quelli cui eravamo abituati per la cifratura a chiave simmetrica pensate a S usa chiavi a 128 bit quindi numeri molto più piccoli rispetto a quelli che sono in ballo adesso questo ci fa capire un po' l'idea del salto di efficienza comunque tornando a Dichfield Hellman P e Q sono due numeri primi non sono due numeri primi qualsiasi deve valere questa condizione qua ok quindi Q deve essere un divisore di P-1 ora non ci interessano i dettagli quello che ci interessa sapere è che esiste un teorema dovuto a Lagrange che dice la seguente cosa esiste sempre un numero in Zp quindi un numero compreso tra 0 e P-1 tale che sempre dentro Zp valgono alcune condizioni quali sono queste condizioni la prima condizione è questa G alla Q fa 1 in Zp ok l'altra condizione è che tutti questi numeri G alla 0 G alla 1 G alla 2 G alla 3 fino ad arrivare a G alla Q-1 quindi in tutto quanti sono questi numeri sono Q ok sono tutti diversi tra di loro e tutti diversi da 0 ok quindi prendete G alla 0 G alla 1 G alla U-1 prendete questo insieme siamo in Zp ok questo insieme appunto grazie a un teorema dovuto alla Grange non contiene valori ripetuti in tutti i diversi tra di loro questo insieme prende il nome è un sottinsieme di Zp naturalmente prende il nome di gruppo ciclico perché gruppo ciclico perché tutti questi non solo sono diversi tra di loro ma se voi provate ad andare avanti quindi calcolate G alla Q per il teorema di Lagrange cosa succede? succede che di fatto è ricominciato da capo no perché allora G alla 0 G alla 1 G alla Q meno 1 sono tutti diversi tra di loro ok poi provate ad andare avanti G alla Q ma G alla Q quanto vale? lo dice Lagrange vale 1 ma 1 è il primo elemento del gruppo ciclico e quindi avrete che G alla Q più 1 equivale a questo G alla Q più 2 è rivale alla G alla seconda e così via quindi ciclico per questo motivo perché diciamo che questo è l'insieme più grande possibile di potenze di G tutte diverse tra di loro perché delle altre non ce ne sono perché ricominci da capo ok è chiara questa caratteristica quindi questo insieme che indicheremo sempre con questa G fatta così prende appunto il nome di gruppo ciclico contiene Q elementi no perché vedete ce ne sono Q che fanno parte di Z e hanno questa caratteristica sono tutti potenze di G G è la base viene chiamata base del nostro generatore del gruppo ciclico ok Q è la cardinalità del gruppo ciclico si chiama anche ordine il numero di elementi di G è l'ordine la sua la sua cardinalità e cosa ce ne facciamo di questo gruppo ciclico beh ha delle proprietà molto interessanti dal punto di vista matematico talmente interessanti che ci permettono come vedremo adesso di realizzare quei due algoritmi dello schema di prima ok cioè l'algoritmo E e l'algoritmo F in che modo andiamo a vedere nello schema di prima sappiamo che Alice deve scegliere un alfa tenerlo segreto e mandare a Bob una mappatura di alfa usando l'algoritmo E ok cosa fa Alice in particolare Alice come valore di alfa sceglie un elemento in ZQ quindi sceglie una di queste potenze uno degli scusate uno degli esponenti ok dopodiché calcola G alla alfa quindi G alla alfa sarà qua dentro no perché alfa alfa è seguito da Q è compreso fra 0 e Q meno 1 quindi vuol dire che G alla alfa è dentro un gruppo ciclico ok e lo manda Bob quindi il famoso la famosa funzione E di alfa del slide che abbiamo visto prima la realizziamo in questa maniera qui vediamo alfa calcoliamo G alla alfa calcolare G alla alfa è facile assumendo che G sul gruppo ciclico Alice e Bob si sono messi d'accordo prima quindi Alice e Bob prima di iniziare dicono che gruppo ciclico usiamo vabbè scegliamo P scegliamo Q e poi scegliamo visto che esiste ce lo garantisce la grange scegliamo un generatore G e quindi ci costruiamo un gruppo ciclico quindi sono tutti i parametri del metodo ok dopodiché parte il protocollo Alice sceglie alfa calcola G alla alfa e lo manda Bob Bob vedete fa la stessa cosa cioè sceglie un beta quindi sceglie un esponente del gruppo ciclico perché è ZQ e manda ad Alice G alla beta ok quindi che cosa vuol dire vuol dire che da una parte abbiamo Alice che conosce alfa perché l'ha scelto lui dall'altra abbiamo Bob che conosce beta perché l'ha scelto lui ok cos'altro conosce Alice beh sappiamo che Bob manda G alla beta ad Alice quindi Alice conosce non solo alfa ma conosce G alla beta dall'altra parte però sappiamo che Alice manda G alla alfa a Bob e quindi Bob conosce oltre che beta G alla alfa ok adesso che cosa fa Alice beh prende G alla beta che ha ricevuto da Bob e lo eleva all'alfa Bob da parte sua che cosa fa prende G alla alfa che l'ha ricevuto da Alice e e lo eleva alla beta ma queste due quantità sono entrambe uguali a che cosa? a questo ok quindi vedete esattamente valgono esattamente le condizioni che avevamo visto prima cioè a partire da informazioni diverse sia Alice che Bob sono in grado di calcolare la stessa quantità che è questa quindi alla fine di questo protocollo Alice e Bob conoscono entrambi G alla alfa beta che sarà un altro elemento sempre del gruppo ciclico solo che Alice lo ha calcolato a partire da alfa e G alla beta Bob Bob invece lo ha calcolato a partire da beta e G alla alfa ok solo loro possono calcolare questa quantità in questi modi perché alfa lo conosce solo Alice beta lo conosce solo Bob un avversario che cosa conosce ciò che si scambiano ovvero queste due quantità G alla alfa e G alla beta però come vedremo tra poco c'è un risultato matematico che ci dice che se il gruppo ciclico è abbastanza grande no non esiste un modo efficiente di calcolare questo a partire da questi due ok non esiste quindi l'unico modo efficiente per calcolare questa quantità qui è conoscere uno dei due segreti alfa oppure beta ma alfa lo conosce solo Alice beta lo conosce solo Bob quindi gli unici due che possono calcolare G alla alfa beta sono Alice Bob quindi G alla alfa beta diventa il master secret questo è l'idea poi vedremo tra poco che per proprietà dei gruppi ciclici così come li abbiamo definiti se un avversario legge vede passare G alla alfa anche se conosce G e G lo può conoscere perché è un parametro pubblico anche se conosce G da G alla alfa non può recuperare alfa beta da G alla beta non può recuperare beta e quindi non riesce a calcolare G all'alfa beta questa è l'idea che sta dietro alla robustezza del protocollo di Diffie Hellman vedremo che vale un discorso analogo a quello che abbiamo visto per RSA non c'è un teorema che ci dice che Diffie Hellman è sicuro sappiamo che certi problemi matematici che ci stanno sotto cioè l'invertibilità di un elemento del gruppo ciclico sono problemi hard da risolvere in matematica voi prendete un qualunque valore del gruppo ciclico G alla I anche se conoscete G non esiste un modo efficiente di recuperare I e quindi sfruttando la difficoltà di questi problemi matematici basiamo la sicurezza del protocollo di Diffie Hellman quindi come per RSA si sfruttano problemi matematici difficili per mettere in piedi un protocollo che garantisca l'anonymous game exchange questo è l'idea quindi di questo protocollo le cose interessanti da ricordare è che Diffie Hellman si basa sull'agreement tra le due parti di un gruppo ciclico cos'ha un gruppo ciclico l'abbiamo appena visto un insieme di potenze di G dove G si chiama generatore il gruppo ciclico contiene Q elementi tutti gli elementi del gruppo ciclico fanno parte di ZP dove P e Q sono i famosi due numeri primi scelti scelti di inizio e la caratteristica che sfruttiamo dei gruppi ciclici è che se voi prendete un qualunque elemento del gruppo ciclico anche se conoscete G non riuscite a non è possibile invertire l'operazione di allenamento potenza cioè l'esponente non riuscite a recuperarlo questo permette usando un handshake che abbiamo appena visto di far di far condividere ad Alice Bob un master secret G alla alfabeta senza che un avversario che osserva cosa viene trasmesso sul canale sia in grado di fare altrettanto ok l'ultima cosa poi ci torneremo sopra per vedere le ah no qui qui qui vedete qui vi faccio vedere le scusate i problemi matematici di hard che stanno alla base di Fielman ok che sono due fondamentalmente uno è il problema del logaritmo discreto ok cioè il problema del logaritmo discreto che cosa ci dice ci dice che se io vi do questa quantità ok ho scelto P e Q numeri primi tali che come abbiamo visto più bla bla bla come abbiamo visto prima ho scelto un generatore il gruppo civico associato con il generatore come abbiamo detto prima quindi detto tutto questo se io vi do questa quantità sapendo che il generatore lo conoscono tutti ma alfa lo conosco solo io ok recuperare alfa da G all'alfa è un problema hard non esiste un algoritmo efficiente che con probabilità non negligible vi permette di recuperare alfa partire da G questo è un problema importante la difficoltà di questo problema è importante perché beh l'abbiamo visto nel nel shake di prima siccome sul canale viaggia G all'alfa e l'avversario può intercettare G all'alfa sappiamo grazie a questa assunzione qui che da G all'alfa non riesce a recuperare alfa così come da G alla beta non riesce a recuperare beta e quindi non riesce a calcolare G all'alfa beta l'altra assunzione altrettanto importante è quella che dice che anche se l'avversario conosce sia questo che questo perché li vede passare sul canale conoscendo solo questi due non è in grado comunque di calcolare questo ok quindi ripeto come è venuto prima l'unico modo cioè di modi efficienti per calcolare questa quantità ce ne sono due cioè combinate questo con beta oppure combinate questo con alfa solo che il primo modo è quello che può usare Bob il secondo modo è quello che può usare Alice l'avversario non ha nessun modo ok quindi sulla base di queste due di questi due problemi hard possiamo dire che di Fielman è sicuro analogamente a prima quando abbiamo detto che il re è sicuro se è difficile il problema della fattorizzazione in fattori primi tutto qua ok quindi abbiamo visto l'analogia tra i due metodi che sono diversi fra di loro ma seguono principi abbastanza simili dicevo l'ultima cosa che vi volevo dire per oggi per stamattina poi riguardo una caratteristica di di Fielman a cui vedete la tag game formale che si basa sulle due soluzioni che abbiamo appena detto prima però è un discorso analogo a quello di di RSA cioè io scelgo se io scelgo i due segreti e faccio vedere all'avversario queste due quantità no questo è il segreto di Alice questo è il segreto di Bob e l'avversario non li vede ok l'avversario vede passare solo questi due no allora il compito l'obiettivo dell'avversario è conoscendo questi due recuperare questo ok ma se valgono le due assoluzioni che abbiamo detto prima allora non ci riesce quindi la probabilità che ha di risolvere questo questo puzzle è negligible per tutti gli avversari efficienti ok ci vogliono le due soluzioni di prima perché perché la prima soluzione ci dice che da questo io non ricavo alfa e da questo io non ricavo beta e quindi se non riesco a ricavare né alfa né beta non posso applicare il metodo che usano Alice e Bob per calcolare g all'alfa beta e l'altra soluzione ci dice che questi due combinati insieme cioè conoscendoli entrambi non mi permettono comunque di calcolare in modi diversi g all'alfa beta e quindi queste condizioni qui messe insieme ci garantiscono che l'unico modo per calcolare g all'alfa beta è conoscere o alfa o beta che è qualcosa che è noto solo ad Alice o a Bob a seconda del valore ok quindi di Fielman è sicuro rispetto se prendiamo per buone le assunzioni l'ultima roba che vi dico riguardo di Fielman poi la prossima volta vediamo come usare RSA di Fielman per costruire un cifrario semanticamente sicuro è questa mentre RSA lo possiamo usare per l'anonymous key exchange è l'esempio che abbiamo visto è questo quindi usando il metodo descritto attraverso questo esempio noi possiamo usare RSA per fare anonymous key exchange tra Alice e Bob ok di Fielman non lo possiamo usare per fare anonymous key exchange e il motivo è questo esempio qua dove siamo aspetta ho perso questo esempio è il motivo per cui non si può usare di Fielman per fare anonymous key exchange dobbiamo complicare un po' le cose lo vedremo la prossima volta cosa succede in questo esempio allora abbiamo Alice dalla parte Bob dalla parte opposta in mezzo c'è l'avversario ok Alice che cosa fa Alice sceglie alfa e quindi sappiamo che calcolerà G al alfa per mandarlo Bob Bob dall'altra parte sceglie beta e quindi calcola G alla beta da mandare ad Alice per realizzare l'idea che Alice dovrebbe calcolare G al alfa beta come G al alfa elevato alla beta e Bob dovrebbe calcolare G al alfa beta come G al alfa elevato alla alfa ok ora però nel mezzo c'è un avversario l'avversario che cosa fa intercetta e blocca G al alfa che è partito da Alice direzione Bob e lo sostituisce con un G al alfa primo dove alfa primo lo ha scelto lui ok quindi io sto mandando G al alfa al destinatario interviene l'avversario blocca il messaggio e lo sostituisce con un altro ok dall'altra parte fa la stessa cosa ovvero blocca il G al al beta che Bob sta mandando da Alice e lo sostituisce con un G al al beta primo scelto da lui a questo punto Alice calcola questo valore seguendo di Fiedman cioè calcola G al alfa elevato scusate G alla beta primo elevato all'alfa e ottiene questa quantità ok e questa quantità la condivide con l'avversario perché l'avversario farà il calcolo G al alfa che ha ricevuto da Alice elevato alla beta primo e quindi ottiene lo stesso valore dall'altra parte Bob calcola questo G al alfa primo beta perché ha ricevuto dall'avversario G al alfa primo eleva alla beta ma lo stesso calcolo lo può fare l'avversario perché l'avversario che riceve G alla beta da Bob lo eleva all'alfa primo quindi morale di questa di questa storia di questa favola triste è che Alice condivide questo master secret con l'avversario Bob condivide un altro master secret sempre con l'avversario ok Alice e Bob non condividono niente ok Alice che magari pensa di condividere il master secret con Bob mentre Bob pensa di condividere il master secret con Alice in realtà ciò che condividono lo condividono con l'avversario quindi questo questo è un classico esempio ne vedremo tanti di comportamento di tipo man in the middle perché l'avversario è un man in the middle perché si sta mettendo in mezzo tra l'hand shake condotto da Alice da Bob facendo credere all'Alice di essere Bob e a Bob di essere Alice e questo è il risultato finale mentre con RSA Alice e Bob fanno partire l'hand shake e alla fine di quel l'hand shake il master secret è condiviso da Alice e Bob e non ci può essere un man in the middle per come funziona il RSA se mettete un man in the middle la cosa non funziona qui invece succede questo ok quindi attenzione così come ho detto prima che RSA così come non lo potete usare per fare cifratura qui hanno lagamento un discorso vale per Diffie che non lo potete usare così come per fare anonymous exchange entrambi li possiamo usare per fare cifratura a chiave pubblica come dobbiamo complicare un po' i metodi di poco e lo vedremo domani quando vi farò vedere i due algoritmi di cifratura a chiave pubblica che si basano uno su RSA e l'altro su Diffie di Fierman ok va bene noi ci rivediamo più tardi sempre qui che facciamo il lavoratorio di implementiamo il buffer overflow attack lo Cuore l' Emperoronnorsa più tardi etc Grazie a tutti.