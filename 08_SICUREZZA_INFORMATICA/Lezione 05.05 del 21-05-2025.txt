bene allora la volta scorsa abbiamo finito di presentare i protocolli anche di authenticated key exchange in diverse versioni con ttp online con ttp offline basati o meno su password e tutti sono caratterizzati naturalmente da aspetti che rendono complicato verificare in maniera rigorosa le proprietà di sicurezza che ci interessano quindi la static security o la perfect forward security quindi autenticazione segretezza conoscenza perdita della della confidenzialità della chiave a lungo termine quella per le firme ci sono diversi algoritmi che entrano in gioco quando si verificano protocolli di questo genere ci sono gli agenti che hanno ruoli diversi la maggior parte della maggior parte dei casi gli schemi sono asimmetrici quindi ogni agente ha un ruolo diverso c'è il ttp che anche lui è un terzo agente che ha il suo il suo ruolo ci sono gli algoritmi per la stabilire le chiavi di sessione e diverse di conseguenza sono le cose che un avversario può fare per interferire con questi protocolli ne sappiamo che prendendo in considerazione dell'avversario più potente che abbiamo a disposizione cioè l'avversario attivo c'è un avversario che ha controllo della rete vede tutto quello che passa può intercettare i messaggi li può bloccare li può manipolare cercando di cambiare a proprio piacimento può partecipare ai protocolli stessi come agente corrotto può controllare un pool di agenti corrotti quindi sono tante le cose che che può fare attraverso attacchi più o meno sofisticati quello più sofisticato in assoluto è l'attacco di tipo ma in the middle che può eseguire quando diverse sessioni dello stesso protocollo vengono eseguite contemporaneamente ok e tutto questo rende complicato definire e dimostrare definire degli attacchi game relativi alle proprietà di sicurezza che ci interessano e dimostrare che questi che questi protocolli soddisfano le proprietà che ci interessano non ve li farò vedere vi mostro un paio di teoremi basati su attacchi game estremamente complessi che ad esempio dimostrano che la prima versione dell'autenticato e del chi exchange con ttp offline è sicura esteticamente sicura purché lo spazio dei non sia super poli e lo schema di cifrattura chiave pubblica che si utilizza sia cc a sicuro così come lo schema di firma che si utilizza sia a sua volta sicuro quindi sono requisiti condizioni abbastanza standard analogamente il protocollo di autenticato e che exchange con ttp online anche questo è sicuro se lo spazio di non super poli e lo schema di cifrattura che si utilizza che a chiave simmetrica ricordo è cpa sicuro e il mac che si utilizza per i tag a sua volta è sicuro quindi condizioni requisiti standard il prima prima versione del protocollo di autenticato e che exchange menzionato nel primo teorema è esteticamente sicura ma come avevamo già visto non garantisce la perfect for world secrecy perché se l'avversario entra in possesso della chiave a lungo termine del chiave segreto lungo termine del di uno degli agenti riesce a violare la confidenzialità di tutte le conversazioni passate e quindi avevamo visto le versioni successive che garantivano questa proprietà utilizzando le chiavi effimere ovvero una coppia di chiavi pubblica e segreta nuova per ogni per ogni per ogni sessione tant'è che appunto c'è un teorema che formalmente ci dimostra che queste versioni garantiscono la perferta for world secrecy purché lo schema di cifrattura che si utilizza sia cc a sicuro e lo schema di firma c'è la sua volta sicuro quindi teoremi diciamo che stabiliscono risultati standard che ci potevamo anche aspettare i requisiti sono i soliti però ripeto in generale al di là degli esempi che abbiamo visto è estremamente complicato dimostrare teoremi come questi per protocolli rispetto a quali ci interessano proprietà di sicurezza robuste rispetto ad attaccanti ad avversari attivi e vi farò vedere esempi di paio di esempi di situazioni in cui protocolli apparentemente sicuri in realtà in certi contesti non lo sono per per risolvere questo tipo di problema nel corso degli anni si è cercato di automatizzare attraverso l'uso di tool la verifica delle proprietà di sicurezza di protocolli crittografici ok questo però ha reso necessario basarsi su delle assoluzioni che adesso vedremo il cui obiettivo è quello di semplificare un po i requisiti delle condizioni di sicurezza e quindi abbandonare l'approccio basato su definizione di attacchi in definizione di algoritmi efficienti e quindi dimostrazione estremamente complesse la soluzione diciamo che semplifica un po l'approccio la verifica dei protocolli crittografici e che è sempre stata utilizzata per sviluppare modelli matematici di verifica automatica è un'assoluzione proposta qualche decina di anni fa da dole e yao due due ricercatori che appunto fanno questa proposta dicono va bene dobbiamo verificare le proprietà di sicurezza di un protocollo crittografico interattivo come gli acche protocol che abbiamo visto le volte scorse benissimo concentriamoci sull'hand shake verifichiamo la sicurezza le proprietà di sicurezza del modo in cui gli agenti interagiscono ok assumendo a monte che le primitive crittografiche che questi protocolli utilizzano siano sicure cosa significa sicure beh assumiamo che la crittografia sia perfetta ok quindi assumiamo che ad esempio lo schema di cifratura che è la che protocollo utilizza sia effettivamente perfetto perfetto vuol dire che un ciphertext a tutti gli effetti dal punto di vista dell'avversario è una scatola nera la black box per cui dall'analisi del ciphertext l'avversario non può dedurre nulla relativamente alla chiave al plaintext e cose di questo genere se noi facciamo questa soluzione di base quindi vuol dire che possiamo abbandonare tutti quei discorsi relativi agli algoritmi efficienti cosa può fare un avversario efficiente in tempo polinomiale possiamo abbandonare tutti i discorsi relativi al fatto che c'è la probabilità di certi eventi deve essere negligible rispetto a tutti gli avversari efficienti quindi accantoniamo mettiamo da parte tutti questi discorsi ok e facciamo la soluzione che chiaramente una soluzione forte ma facciamo la soluzione che le primitive crittografiche che vengono utilizzate sono perfette in termini di sicurezza se facciamo questa soluzione allora verificare che un protocollo crittografico soddisfi determinate proprietà di sicurezza nel modo in cui ad esempio viene eseguito l'end shake rispetto ad avversari attivi che possono fare mal in the middle tutto quello che vogliono diventa un compito verificabile in maniera automatica ok in che maniera utilizzando gli strumenti tipici tipici della semantica formale dei linguaggi di programmazione e quindi faccio un esempio ad alto livello poi non entrerò nel dettaglio di questi metodi anche se vi farò vedere un tool che a titolo di esempio è in grado di fare di modellare e di verificare in maniera automatica protocolli crittografici se avete se vi ricordate qualcosa relativamente alla semantica formale dei linguaggi di programmazione bene se no è lo stesso perché comunque quello che vi farò vedere adesso è abbastanza di alto livello e self-contained ora immaginate quindi assumendo che la teutografia sia perfetta immaginate di stabilire delle regole logiche che determinano cosa può fare un avversario ok e qui vedete degli esempi di come possono essere determinate queste regole scritte sotto forma di regola di differenza che cos'è una regola di differenza la regola di differenza stabilisce quelle che sono delle premesse e stabilisce quella che è una conclusione se le premesse sono vere allora vale la conclusione ciascuna di quelle regole che vedete lì dove avete le premesse sopra la barra orizzontale e le conclusioni sotto la barra orizzontale stabiliscono che se vale la premessa o le premesse allora vale la conclusione e ognuna di quelle regole stabilisce di fatto cosa può fare l'avversario cosa può fare chiunque quindi compreso l'avversario sotto certe condizioni in queste regole i messaggi vengono trattati come se fossero dei termini di un'algebra di un linguaggio algebrico ok qui t t1 t2 sono stringe rappresentano stringe messaggi ok però rappresentano messaggi in forma stratta quindi al di fuori dei modelli computazionali su cui abbiamo basato gli attack game ok prendete la prima regola in alto a sinistra che ha quella premessa t appartiene a m t è un termine astratto che rappresenta un qualunque messaggio dove quella m è l'insieme di possibili messaggi ok la premessa t appartiene a m che cosa sta a significare sta a significare beh se t è un messaggio per la premessa allora io posso dedurre t quella conclusione ti voglio notare le cose la penna lasciata qua ok quindi questa questa è la premessa t è un messaggio se ti un messaggio la conclusione cosa dice che io posso dedurre t ok questa con questa notazione noi stiamo rappresentando il fatto che ti è deducibile ok quindi questa regola di base che dice fondamentalmente che tutti i messaggi sono deducibili poi come vengono utilizzati quello l'altro è un altro discorso però tutti i messaggi sono deducibili cioè in altre parole posso costruire un qualunque messaggio ok chiunque può costruire un qualunque messaggio no e le altre regole dicono in questo esempio come possono essere manipolati i messaggi che poi faranno parte delle informazioni scambiate durante un protocollo no ad esempio prendete la seconda regola la seconda regola che cosa dice si guardate le premesse le premesse dicono se io posso dedurre un messaggio t1 e posso dedurre un messaggio di 2 allora io che cosa posso dedurre un messaggio che è la coppia la coppia fatta di t1 e t2 cioè cosa dice questa regola questa regola dice che io posso creare coppie di messaggi perché è utile questa regola perché durante l'hand shake di un protocollo criptografico effettivamente spesso del entiere succede questo io prendo diversi elementi e crea una dupla di questi elementi ad esempio che ne so l'abbiamo visto anche nei protocolli anche dell'altra volta in un messaggio magari mi interessa trasmettere l'identità di un messaggio ma magari si è in un messaggio che si sa che si sa che ci puoi Ad esempio, che ne so, l'abbiamo visto anche nei protocolli anche dell'altra volta, in un messaggio magari mi interessa trasmettere l'identità di un agente, mi interessa trasmettere un nonce, mi interessa trasmettere un plaintext e così via. E come faccio a creare un messaggio che contiene tutti questi elementi? Creo la tupla, dove ogni elemento della tupla è un diverso messaggio. Quella regola mi dice fondamentalmente questo, che io posso creare una coppia di messaggi a partire da due singoli messaggi. E di conseguenza le altre due regole che cosa ci dicono? Che da una coppia io posso estrarre, posso dedurre i suoi elementi. Quindi queste quattro regole, se le prendessimo da soli in isolamento, sono regole che ancora non hanno niente a che fare con la criptografia, sono delle regole che sostanzialmente ci dicono come si possono manipolare le stringhe. Ok? Perché la prima regola mi dice che qualunque stringa appartenente a un dominio M è un messaggio. La seconda regola mi dice che se ho due messaggi li posso accoppiare. E la terza e la quarta regola mi dicono che se ho una coppia di messaggi io posso estrarre da questa coppia o l'uno o l'altro elemento. Quindi queste sono regole che in maniera sistematica mi dicono come si manipolano i messaggi. Ok? Chiaro? Quindi stiamo descrivendo le regole alla base della costruzione degli elementi di un linguaggio formale. A noi interessa descrivere messaggi che possono essere manipolati usando primitive criptografiche. Quindi ci servono delle regole che descrivano cosa succede quando uso operazioni criptografiche. Ok? E queste regole devono essere le più semplici possibili. No? Perché abbiamo detto che noi vogliamo mettere da parte tutto il discorso relativo agli algoritmi efficienti, alle probabilità negligible di due qualcosa, vogliamo estrarre tutto questo. E quindi abbiamo bisogno di regole piuttosto semplici. E quindi vedete alcune, anche questo è un esempio, no? Però sono regole che ci dicono che cosa succede quando usiamo, applichiamo operazioni criptografiche sui messaggi. No? Ad esempio una regola come questa che cosa mi dice? Mi dice che se io riesco a dedurre, come premessa, io riesco a dedurre un messaggio T, per qualche motivo, ok? Allora cosa posso fare? Posso dedurre l'hash di quel messaggio, H è la funzione hash. Cioè in pratica quella regola mi dice che io posso calcolare il digest di qualunque messaggio che conosco. Ok? Vi faccio notare che manca una regola come questa. Questa regola non c'è. Perché se ci fosse questa regola, cosa vorrebbe dire? Che dall'hash di un messaggio io posso dedurre il messaggio, ma questo sappiamo che non è vero. Sappiamo che non è vero se la funzione hash è sicura. Esatto. Siccome noi stiamo assumendo che la criptografia è perfetta, quindi noi stiamo assumendo che H è una funzione hash sicura, e quindi non la posso invertire. E quindi questo giustifica il fatto che una regola come questa non ci può essere. Ok? Quindi in pratica mettiamoci nei panni di un avversario, di un osservatore. Un osservatore che riesce a dedurre questo perché lo vede passare nel canale può costruire questo. Ma un osservatore che vede passare nel canale questo non riesce a dedurre questo. Ok? Perché? Perché manca questa regola qua. No? Quindi cominciamo a entrare nel meccanismo per cui l'espressività dell'avversario la definiamo attraverso un insieme di regole. Le regole che l'avversario può applicare per dedurre informazioni. Ok? Questa regola qua che cosa descrive? Descrive come funziona... Ah, è un esempio di regola che descrive come funziona la cifratura. Anc è l'algoritmo di cifratura. Qui ho usato una notazione abbastanza semplice, ovvero Anc è l'algoritmo di cifratura. Questa è la chiave che uso per fare la cifratura. Questo è il plaintext che vado a cifrare. Ok? Questa regola che cosa mi sta dicendo? Mi sta dicendo che se io conosco T1 e T2, perché li ho dedotti in qualche modo, allora io posso usare T2 come chiave per cifrare T1. Ok? Quindi in altre parole questa regola sta dicendo che chiunque può prendere, scegliere una chiave e usarla per cifrare un messaggio. Ok? Qui sto astraendo, non sto facendo distinzione fra cifratura a chiave pubblica o a chiave simmetrica. T2 è una chiave, Anc potrebbe essere, se Anc è l'algoritmo di cifratura come, che ne so, AS128, allora T2 sarà una chiave simmetrica e quindi sappiamo come si comporta. Però qui stiamo astraendo, ok? Quindi non ci interessa entrare nel dettaglio dello schema di cifratura. Quindi una regola di quel tipo mi sta dicendo che chiunque può fare cifratura. No, se ha una chiave a disposizione, chiunque può fare cifratura. Questa regola qua invece sta dicendo, sta stabilendo sotto quali condizioni io posso fare decifratura, perché vedete che ribalta un po' premesse e conclusioni, perché le due premesse cosa dicono? Questa premessa mi dice, io riesco a dedurre un certo cifrtext, ok? Perché questa è una cifratura, quindi questo è un cifrtext, ok? Qui ho usato una notazione, penso abbastanza semplice dal punto di vista intuitivo, perché questa T2 alla meno 1 rappresenta la chiave di decifratura corrispondente a T2, ok? Quindi se siamo nell'ambito della cifratura a chiave simmetrica, T2 e T2 alla meno 1 coincidono, ok? Se siamo nell'ambito della cifratura a chiave pubblica, T2 potrebbe essere la chiave pubblica, allora in quel caso T2 alla meno 1 è la chiave segreta corrispondente, oppure viceversa, T2 potrebbe essere la chiave segreta e T2 alla meno 1 potrebbe essere la chiave pubblica corrispondente, ok? Quindi ho usato questa notazione per farvi vedere un'unica regola che copre tutti i casi, no? E quindi la regola che cosa dice in pratica? La regola dice che se io ho dedotto un ciphertext e conosco la chiave per decifrare quel ciphertext, allora cosa posso concludere? Che conosco il plaintext, no? Quindi quella regola mi sta dicendo hai un ciphertext, hai la chiave adatta per decifrare quel ciphertext, allora puoi dedurre il plaintext, no? Non fa una piega. Questa regola va bene in tutti i casi, ripeto, se anche un algoritmo di cifratura a chiave simmetrica, T2 e T2 alla meno 1 coincidono, e quindi quella regola vi sta dicendo che per decifrare un ciphertext ottenuto con la chiave K, dovete conoscere K, ok? Se invece siamo nel mondo della cifratura a chiave pubblica, allora se T2, poniamo che sia la chiave pubblica, e T2 alla meno 1 la chiave segreta corrispondente, questa regola vi sta dicendo che per decifrare un ciphertext ottenuto con una certa chiave pubblica, vi serve conoscere la chiave segreta corrispondente, ok? Ma questa regola funziona anche per le firme digitali, no? Perché vi sta dicendo che se questa è la firma di T1 fatta con la chiave segreta, e voi conoscete la chiave pubblica corrispondente, allora potete verificare la firma sul plaintext. Quindi è una regola che potete interpretare in tutti i contesti, ok? Ok, là vi faccio notare che non c'è una regola di questo tipo. Questa non c'è. Perché questa regola cosa implicherebbe? Che voi potete decifrare un ciphertext senza conoscere la chiave. E vale il discorso che abbiamo fatto prima, siccome noi assumiamo che la criptografia è perfetta, una cosa del genere non si può fare. Ok? Ora, cosa ce ne facciamo di un insieme? Chiaramente a seconda del contesto, poi le regole possono essere più o meno complicate, però cosa ce ne facciamo di regole di questo genere? Ce ne facciamo perché queste regole definiscono il sistema logico. Ok? Stabiliscono cosa posso dedurre. Io ci posso costruire un algoritmo sopra per fare verifica usando regole di questo genere? assumendo che... assumendo che... prendo... prendo... chiaramente devo avere... dopo vi farò vedere un esempio... devo avere una descrizione logica di come funziona il protocollo. Ok? Il protocollo mi dice che vengono scambiati i messaggi. quindi tutti i messaggi che vengono scambiati diventano la base di conoscenza dell'osservatore, compreso l'avversario. usando tutte queste regole, in tutti i modi possibili, a partire dai messaggi che l'osservatore vede passare, possiamo cercare di capire se, a partire dai messaggi che l'osservatore vede passare, riesce a dedurre qualcosa che invece deve rimanere segreto. ok? Ok? E questo discorso, il meccanismo lo posso automatizzare. Voi date in pasto ad un sistema automatico la base di conoscenza, ok? Cioè tutto quello che è pubblico, gli date in pasto questo, la descrizione del protocollo, espresso in qualche sistema logico formale, gli date quali sono le regole, e lui in automatico vede se, a partire dalla base di conoscenza e usando determinate regole, riesco a dedurre qualcosa che dovrebbe essere segreto. No? Non so se questo meccanismo vi ricorda un po' come funziona, che ne so, il metodo di risoluzione della logica proposizionale, così come dalla logica dei praticati. E infatti, il meccanismo è esattamente quello. Voi avete una base, l'idea di solito qual è? Voi avete una base di conoscenza, avete delle regole, volete vedere se una certa cosa è derivabile oppure no, la negate, la mettete in congiunzione con la base di conoscenza e vedete se ciò che ottenete è insoddisfacibile oppure no, usando il metodo di risoluzione, usando altri metodi. Ok? E questo è un po' l'idea. Se voi avete, volete verificare la segretezza di un plain text nell'ambito di un protocollo criptografico che deve garantire la confidenzialità, voi non dovete fare altro che verificare che, a partire dalla base di conoscenza che l'avversario ha, a partire dalla descrizione del protocollo criptografico e delle regole che abbiamo appena definito, che stabiliscono cosa si può decifrare, cosa no, dovete verificare se la base di conoscenza, in congiunzione con l'informazione che volete dire che rimanga segreta, rappresenta un superset di conoscenze soddisfacibile. Soddisfacibile in che senso? Vuol dire derivabile a partire dalle regole, usando le regole a partire dalla base iniziale. Questo è un po' l'idea. Se è insoddisfacibile, cosa vuol dire? Vuol dire che non c'è un modo per l'avversario, usando queste regole, di derivare l'informazione segreta a partire dalla base di conoscenza iniziale. Ora, le cose sono un po' più complicate. Dipende sempre dalla... È chiaro che se l'informazione segreta ha parte della base di conoscenza, quella è un avversario da me, ma già, no? Così come se una certa informazione passa per il canale, quella entra a far parte della base di conoscenza. Ok? Cioè tutto quello che viaggia sul canale è pubblico, no? Noi per base di conoscenza intendiamo le informazioni pubbliche, no? Di solito tra queste informazioni cosa c'è? Ci sono le identità degli agenti, quello che viaggia in chiaro, informazioni di questo genere. In questo... Non abbiamo più bisogno di definire la tag game, perché la tag game viene sostituito dalle regole che noi decidiamo di applicare e che descrivono il potere espressivo dell'avversario, perché queste regole che abbiamo definito descrivono di fatto che cosa può fare l'avversario. Allora, l'avversario cosa può fare? Può combinare messaggi, può calcolare digest, può cifrare e sotto certe condizioni può decifrare. Basta, non può fare nient'altro. Ok? Quindi, usando diciamo, le opportunità di queste regole, l'avversario che cosa fa? Vede passare dei messaggi, su tutti i messaggi che vede passare prova ad applicare queste regole e vediamo cosa salta fuori. Ora, fare questa cosa a mano è un lavoro difficile perché c'è un'esplosione esponenziale di quelle che sono le possibili interferenze dell'avversario in un contesto in cui questa cosa non l'ho sottolineata, ma dobbiamo sempre considerare il fatto che noi non ci dobbiamo limitare a considerare avversari passivi. Allora, se l'avversario è passivo, voi avete due agenti, i due agenti parlano seguendo le regole del protocollo, l'avversario osserva i messaggi, questi messaggi che osserva rappresentano la base di conoscenza e in quel caso basterebbe verificare a partire da quella base di conoscenza applicando queste regole che abbiamo appena visto se un'informazione confidenziale può essere dedotta dall'avversario. Questo è relativamente facile. Quello che è difficile invece è quando noi dobbiamo prendere in considerazione scenari in cui l'avversario è attivo. Un avversario attivo, l'abbiamo visto, può far finta di essere un agente onesto. Allora, in quel caso, il protocollo non viene più eseguito da due agenti onesti che sono osservati dall'avversario, ma il protocollo viene eseguito da un agente onesto e l'avversario. Ok? E se l'avversario è un agente attivo del protocollo, interagisce con l'altro agente, fa cose, produce messaggi, non solo li osserva. Ok? Essendo un partecipante attivo è lui stesso che produce dei messaggi. non si limita semplicemente a osservarli. E come si può comportare questo avversario? Può fare tutto quello che vuole. Riusciamo a esaminare tutte le cose possibili che lui può fare? A mano non lo possiamo fare una cosa di questo genere. Dobbiamo anche considerare che stiamo ragionando su un'esecuzione del protocollo. Ma se l'esecuzione del protocollo ce ne sono n simultanee e in queste n esecuzioni simultanee del protocollo ci sono che ne so tre agenti onesti e uno disonesto. Quali sono tutti i scenari possibili in cui questi questi agenti possono scambiarsi messaggi? Sono imprevedibili ed è questo il motivo per cui abbiamo bisogno di uno strumento automatico che fa che verifica queste cose al posto nostro. Ok? E la caratteristica comune di questi strumenti ve ne farò vedere uno, ripeto, è che abbiamo bisogno di un set di regole come queste abbiamo bisogno di descrivere in maniera attraverso un sistema logico mettiamola così cosa fa il protocollo e dopodiché abbiamo tutto quello che ci serve perché abbiamo una descrizione matematica formale del protocollo e delle regole e quindi possiamo verificare le proprietà. Questo è un po' è l'idea. Ok? Ma ripeto tutto questo funziona sotto l'assunzione che dicevamo prima di Dolev e Yao che semplifica tutto molto in base alla quale assumiamo che la criptografia sia perfetta per cui le regole sono di questo tipo qua. Così non ci dobbiamo preoccupare di attacchi di criptanalisi di chiavi che vengono indovinate con una certa probabilità ignoriamo ignoriamo tutto tutto questo. Ok? Questa è l'idea. Ok? Ora ci sono tanti tanti insomma c'è un discreto numero di tool che fanno questo cioè vi permettono di modellare un protocollo criptografico e sulla base di regole che sono stabilite verificano se il protocollo è vulnerabile rispetto a certe proprietà di sicurezza in maniera automatica. Io ve ne farò vedere un esempio di uno di questi di come si usa uno di questi qui ve ne ho citati diversi anche seguendo un po' l'ordine cronologico storico perché il primo di questi strumenti che è questo c'è SPFDR risale alla prima metà degli anni 90 ed era uno strumento abbastanza semplice perché è uno strumento in grado di lavorare solo su un numero limitato di termini dove i termini sono quei T di cui parlavamo prima quindi i messaggi le chiavi non li descriviamo mai sotto forma di stringhe reali ma astraiamo e li rappresentiamo come termini ok e quindi questo primo tool che risale negli anni 90 è un tool che è in grado di lavorare con un numero limitato di termini e con un numero limitato di esecuzioni del protocollo ok e già così si riescono a trovare dei attacchi interessanti dopo vi farò vedere un esempio di un protocollo crotografico piuttosto semplice ok e ritenuto che è sempre stato ritenuto sicuro rispetto a certe condizioni e che risale agli anni 70 poi quando è uscito questo tool qui nel primo anno del 90 l'hanno provato su quel protocollo ed è saltata fuori la vulnerabilità ok da quando era nato il protocollo a quando è venuto fuori quel tool lì sono passati erano passati 17 anni in 17 anni nessuno aveva trovato la vulnerabilità sul protocollo che tanto e tanto per darvi un'idea di che cosa significa fare verifica automatica poi con gli anni questi strumenti si sono perfezionati sono in grado di lavorare su numero illimitato di termini usando meccanismi simbolici fino ad arrivare addirittura a scenari in cui i tool riescono a lavorare su un numero illimitato di termini e su un numero potenzialmente illimitato di esecuzione del protocollo quindi riescono a trovare attacchi che si possono verificare in scenari in cui c'è un numero potenzialmente illimitato di esecuzioni contemporanea del stesso protocollo questo è quello di cui vi farò vedere un esempio si chiama Proverif è un buon compromesso fra usabilità ed efficienza ultimamente ne sono usciti anche di abbastanza user friendly come tool tant'è che hanno un linguaggio per la descrizione dei protocolli estremamente verboso facile perché chiaramente il linguaggio usato da questi protocolli non è un linguaggio di programmazione è un linguaggio che serve per descrivere gli handshake dei protocolli crittografici quindi è un linguaggio abbastanza quasi naturale insomma e quindi sono tool che diciamo che sono abbastanza semplici da utilizzare insomma con poca poca esperienza si riesce a capire come funzionano e a provare a descrivere anche diventa facile provare a descrivere protocolli che poi vengono verificati tant'è che questo potrebbe essere un argomento di progetto estremamente interessante prendere uno di questi tool e provare a modellare e verificare un protocollo vi faccio vedere l'esempio di cui vi parlavo prima questo è un protocollo di scambio di tre messaggi quindi estremamente banale che Nida e Meshroder hanno proposto nel 1978 per garantire la proprietà di autenticazione si basa sul fatto che i due agenti A e B abbiano a disposizione ciascuno una coppia di chiavi pubblica e segreta ok qui la notazione è una notazione che si trova in letteratura abbastanza standard ovvero questo è un messaggio che viene mandato da A B e questo messaggio in cosa consiste? questa è la cifratura fatta usando la chiave pubblica di B e questo è ciò che andiamo a cifrare quindi il primo messaggio lo manda A a B è un messaggio cifrato con la chiave pubblica di B contiene un nonce questo è un nonce è un nonce scelto da A quindi un valore fresh randomico scelto da A e questa è l'identità di A ok quindi A manda B un nonce la propria identità tutto cifrato con la chiave pubblica di B l'ho riscritto usando la notazione che abbiamo già usato in passato ok e così via come va avanti il protocollo B risponde ad A gli rimanda indietro che cosa il nonce che l'aveva scelto più un nonce che B ha scelto tutto cifrato con la chiave pubblica di A ok perché gli rimanda indietro questo ok allora allora il nonce è cifrato viaggio cifrato e viaggio cifrato con la chiave pubblica di B quindi B è l'unico che può decifrare il nonce ora siccome lo scopo di questo protocollo è garantire l'autenticazione se B risponde ad A rimandandogli indietro il nonce che A aveva scelto in pratica gli sta dimostrando di essere stato capace di decifrare il nonce quindi gli sta dimostrando di essere B ok quando quando A riceve questo e A è l'unico che può decifrarlo perché è un messaggio cifrato con la chiave pubblica di A e vede che qui dentro c'è questo A si convince di aver parlato con B perché perché solo B poteva decifrare questo e poi quindi restituirlo ok quindi questo nonce qui di fatto dal punto di vista di A è la prova di autenticazione di B ok perché A oltre al nonce ha mandato a B anche la propria identità per informare B chi è il mittente il protocollo lo avvia lo avvia A vuole parlare con B ok quindi gli manda questa è una sorta di challenge ok quindi gli manda la challenge per verificare se è veramente B quello con cui si è messo in contatto e poi gli manda la propria identità gli dice guarda io sono A voglio parlare con te ok B decifra questo vede chi gli vuole parlare e quindi usa la sua chiave pubblica qui astraiamo facciamo finta che non sia problematico accedere alle chiavi pubbliche dei vari agenti perché ci sono i certificati a disposizione quindi immaginiamo che non ci siano ambiguità nel binding tra chiave pubblica e identità quindi per qualche motivo che noi ignoriamo astraiamo quando B vede questa identità qui non c'è dubbio su come debba essere scelta la chiave pubblica con cui cifrare il resto quindi B fornisce la prova perché restituisce la challenge e quindi fornisce la prova di autenticazione ad A e poi gli manda una propria challenge perché anche B manda una challenge ad A non è sicuro di aver parlato con A allora quando A riceve la risposta di B è sicuro di aver parlato con B però ancora B non è sicuro di aver parlato con A come? eh ma io potrei questo è un messaggio che può preparare chiunque anche uno che non è A perché le identità sono pubbliche ok? quindi io che faccio finta di essere A ad esempio posso mandare questo messaggio a B dicendo guarda io sono A voglio parlare con te il problema il problema qual è? il problema è che B che ritiene di parlare con A gli manda mi manda un messaggio cifrato con la chiave pubblica di A io a questo messaggio a questo punto non sono in grado di decifrarlo se non sono A ok? e se non sono in grado di decifrarlo non sono in grado di rispondere a B restituendogli il suo nonce la sua challenge e quindi non sono in grado di dimostrare a B di essere veramente A se invece sono veramente A riesco a decifrare questo e riesco a rispondere a B restituendogli il nonce quindi ogni nonce è una challenge che uno dei due manda all'altro per avere la prova di identità e quindi di autenticazione ok? Alla fine dell'esecuzione di questo protocollo no? A è convinto di aver parlato con B se tutto è andato bene e B è convinto di aver parlato con A e le cose stanno veramente così quindi vale l'autenticazione il che è vero se A e B sono entrambi onesti e ok? E l'avversario è passivo o anche se l'avversario è un attacco diretto ok? Cioè un avversario che fa quello che ho appena detto io faccio finta di essere A no? O anche se io facessi finta di essere B non ha importanza cioè quindi se io cerco direttamente di eseguire questo protocollo con uno dei due agenti onesti si può dimostrare ed è quello che è stato fatto da Lidl & Schroeder nel 1978 cioè loro hanno non è che erano sproveduti hanno dimostrato che rispetto ad attacchi diretti ad attacchi passivi questo protocollo è sicuro garantisce l'autenticazione ok? Però non è sicuro rispetto ad attacchi attivi no? Cioè attacchi in cui l'avversario può inscenare qualunque agente in una situazione in cui ci sono diverse istanze del protocollo di esecuzione ok? E' lì il tema lì la cosa difficile perché ripeto finché ragioniamo su una singola istanza dell'esecuzione di questo protocollo è facile dimostrare che il protocollo è sicuro ed è quello che hanno fatto loro due qualunque cosa faccia l'attaccante il problema nasce quando siamo in un mondo in cui ci sono A e B che da una parte stanno eseguendo quel protocollo poi magari ci sono C e D che stanno eseguendo lo stesso protocollo simultaneamente da un'altra parte e magari lo stesso succede ad A e B stessi magari A sta eseguendo il protocollo con B ma contemporaneamente magari lo sta eseguendo anche con C quindi se caliamo questo protocollo in un contesto concorrente ok dove ci possono essere esecuzioni simultanee abbiamo gli stessi problemi che sapete benissimo che ci sono quando si passa dalla programmazione sequenzale alla programmazione concorrente programmazione sequenzale è tutto quello che va bene lo mettete nell'ambito della programmazione concorrente all'improvviso non lo metto bene perché che ne so salta fuori il deadlock salta fuori la starvation salta fuori qualche proprietà che in un contesto concorrente non vale più e qui succede la stessa identica cosa un protocollo che in isolamento no è sicuro ed è dimostrabilmente sicuro lo mettete in un contesto concorrente in cui lo stesso protocollo può avere diverse istanze eseguite contemporaneamente ecco che non è più sicuro solo che vulnerabilità di questo tipo sono difficili da identificare perché mettere questo protocollo in un contesto concorrente significa andare a cercare a esaminare tutti gli scenari possibili e immaginabili A è onesto B non lo è A è disonesto B è onesto ho un'istanza tra A e B ho due istanze tra A, B, C e D ho tre istanze del C sono abici c'è l'esplosione combinatoria di scenari possibili e diventa impossibile esaminarli tutti a meno che ripeto non abbiamo uno strumento automatico che lo fa per noi che automatizza il check ok che è quello che ha fatto cspfdr il tool che abbiamo estenato prima quando gli hanno dato in pasto la descrizione di questo protocollo e sulla base di regole simili a quelle che abbiamo visto prima lui ha fatto model checking ha verificato che il modello del protocollo soddisfacesse oppure no la proprietà di sicurezza che ci interessava e il risultato è stato questo il protocollo non è sicuro e questo è l'attacco perché il bello di quei tool è che se una proprietà non vale vi fa vedere il controesempio come succede per la verifica tipica delle proprietà di model checking e questo è il controesempio ok ripeto in 17 anni a mano questo nessuno l'aveva visto e qui che cosa succede qui succede che ci sono tre agenti coinvolti ok a b sono onesti e è disonesto allora qui vedete che ci sono due distanze simultane del protocollo di autenticazione una tra a ed e e l'altra tra e e b ok quindi a si vuole autenticare con e ok e come vedremo tra poco allo stesso tempo contemporaneamente e finge di essere a per autenticarsi con b come ci riesce vediamo i vari passaggi allora abbiamo detto che questo è il primo messaggio dell'autenticazione tra a ed e ok ok a vuole autenticarsi con e cifra con la chiave pubblica di e non che ha scelto lui e la propria identità cioè è a che sta dicendo ad e voglio parlare con te ok a questo punto b scusate e ne approfitta e che cosa fa inizia una sessione di autenticazione con b facendo finta di essere a e che cosa gli manda gli manda il contenuto del messaggio che ha appena ricevuto da cifrato con la chiave pubblica di b ok perché è chiaro che e ha ricevuto questo lo può decifrare e usarlo per creare un ciphertext da mandare a b quindi e sta mandando a b un messaggio una richiesta dove dichiara di essere a ok a questo punto b risponde no e manda un ciphertext creato con la chiave pubblica di a perché pensa di parlare con a che contiene la risposta al challenge e una propria challenge e ora e apparentemente è fregato perché non è in grado di decifrare questo messaggio ok non lo può decifrare però che cosa fa lo manda ad a perché a è ancora lì che sta aspettando di completare l'autenticazione con e ricordiamoci che a aveva mandato questo messaggio ad e e adesso e che cosa fa risponde come previsto dal protocollo cioè gli manda un messaggio cifrato con la chiave pubblica di a che contiene la risposta alla challenge più una sua challenge però vedete non è e che ha creato questo messaggio lo ha creato b e lo usa in un'altra sessione ok cioè sta utilizzando il messaggio di una sessione all'interno di un'altra sessione ok ora ad a arriva questo lo decifra va tutto bene il controllo sulla challenge funziona e quindi a questo punto a risponde ad e la cifratura della challenge della della challenge che secondo lui e aveva creato che invece proveniva da b ora adesso qui l'autenticazione fra da e finisce a si è autenticato con e ok in questo momento e finalmente diventa capace di recuperare il nonce di b perché fino a quel momento non lo sapeva no perché e aveva ricevuto questo cifrato in una maniera che per lui non era decifrabile ok però di fatto se l'è fatto decifrare da il nonce di b perché a lo ha decifrato e poi lo ha restituito ad e protetto con la chiave pubblica di e quindi qui finalmente e decifra il nonce di b e quindi è in grado di rispondere a b e quindi chiudere anche l'autenticazione con b alla fine di questa di questo di questo scenario che è uno scenario veramente concorrente abbiamo due istanze dello stesso protocollo eseguite contemporaneamente in interleaving i messaggi del shake sono mescolati e alla fine di questo protocollo la proprietà di autenticazione salta perché b è convinto di essersi autenticato con a e invece si è autenticato con e ok quindi vedete anche con protocolli banali perché il protocollo di niger schroder è un protocollo di tre messaggi diventa estremamente difficile verificare le proprietà di sicurezza rispetto a tutti gli finali possibili ok un modo per risolvere questa vulnerabilità consiste nell'aggiungere nella risposta di b ad a non solo i due nonce ma anche la propria identità ok se aggiungete qui questa informazione qui e non può più usare la risposta di b inoltrandola ad a perché se così facesse a si accorgerebbe che quella risposta deriva da b non da e perché perché c'è l'identità dentro e quindi questa cosa qui e non potrebbe farla ok quindi questo è un modo di risolvere la vulnerabilità usando tool come questo anche in anni recenti sono state trovate vulnerabilità nelle primissime versioni di tls tanto per fare un esempio fino ad arrivare a quella attuale che è stata validata formalmente usando tamarin che è uno degli strumenti che vi ho citato prima che appunto è stato utilizzato per verificare formalmente che tls 1.3 è sicuro e quindi non soffre di quel tipo di vulnerabilità lo stesso tool ad esempio è stato utilizzato per trovare tre diverse vulnerabilità nel protocollo di teleram di cui vi avevo già accennato qualche tempo fa sempre usando lo stesso tool faccio vedere un altro esempio che mette in evidenza quanto possono essere subdole le vulnerabilità questo è lo stesso è lo stesso protocollo di autenticazione di needle and shoulder con un'unica differenza che dal punto di vista della funzionalità non dovrebbe cambiare assolutamente nulla l'unica differenza sta nel fatto nel modo in cui è confezionato il primo messaggio vedete questa è la versione originale il messaggio prevede il primo messaggio prevede la cifratura di un nonce e dell'identità ok in questa versione gli elementi della coppia sono stati invertiti prima l'identità poi il nonce ok il contenuto informativo del messaggio è esattamente lo stesso per cui supponiamo che questo sia sicuro lasciamo perdere l'attacco che abbiamo appena descritto se questo è sicuro anche questo intuitivamente dovrebbe essere sicuro perché l'unica cosa che ho fatto è stato invertire la posizione che due elementi occupano dentro la coppia però il messaggio è sempre quello ok purtroppo non è così perché scambiando gli elementi della coppia salta fuori questo attacco che è stato trovato più recentemente nel 2008 e che ha dato origine a un filone di attacchi cosiddetti di type flow cioè vulnerabilità legate ai tipi poi adesso capiremo perché vediamo che cosa succede no? allora partiamo da questo no? quindi il primo messaggio che va da A e B è la cifratura di identità di identità e non allora prendete un avversario E che finge di essere B e inizia un'attenticazione con A ok? e gli manda questa coppia lui dovrebbe mandargli la propria identità e un nonce cosa gli manda? l'identità di B perché vuol far finta di essere B e come nonce come nonce usa la propria identità il nonce ma allora l'andorico ci posso mettere dentro quello che mi pare lui ci ha messo la propria identità per cui se B non fa un check sul nonce e tipicamente questo non succede B pensa che questo sia il nonce che B ha scelto per autenticarsi con lui ok? questo è quello che pensa A no? A gli è arrivato sto messaggio quindi pensa che questa richiesta arrivi da B e che questo sia il nonce che B ha scelto quindi che cosa fa? risponde e la risposta è questa no? perché devo restituire la challenge e aggiungere la mia di challenge ok? quindi questa è la risposta che A manda ad E ok? E questa risposta non è in grado di aprirla perché è cifrata con la chiave pubblica di B e cosa fa? la prende E e la manda così com'è vedete la manda così com'è a B per iniziare una nuova sessione del protocollo ok? a B gli arriva questo messaggio e cosa deduce? deduce che E vuole autenticarsi con lui e che questa è la challenge ok? quindi gli risponde gli risponde restituendo la challenge e creandone una sua ok? a questo punto E diventa capace di recuperare il nonso che aveva scelto A cosa che prima non poteva fare ok? e quindi cosa fa? è in grado di rispondere ad Adas a seconda del messaggio allora qui in questo messaggio di E viene interpretato come se fosse un nonso qui invece viene interpretato come identità qui e qui anzi a dirla per bene qui è un nonso qui anche è un nonso perché questa è la risposta che A manda ad E credendo che sia B e dal punto di vista di A questa è la risposta a questa challenge quindi in questi due messaggi i di E è un nonso il problema è che adesso E usa questo stesso messaggio interpretandolo in maniera diversa per mandarlo come primo messaggio di una nuova sessione con B quindi è vero che sintatticamente questi due messaggi sono uguali ma non lo sono semanticamente ok perché qui è la risposta quindi è il secondo messaggio di una sessione qua invece è il primo messaggio di un'altra sessione quindi qui i di E è un'identità qua i di E è un nonso ok ed è questa ambiguità che consente ad E di montare questo attacco qua come eravamo arrivati a dire E è in grado di decifrare il nonso che l'aveva scelto quindi può rispondere ad A poi risponde a B morale della favola E e B si sono autenticati normalmente mentre invece E si è autenticato con A facendo finta di essere B ok e scoperto questo attacco qui basato sull'ambiguità in particolare basato sull'ambiguità di di che cosa dell'interpretazione di questo valore in questi due messaggi perché ripeto qui è un nonso qua è un'identità ok quindi basandosi su questa ambiguità si è scoperto che esistono tanti attacchi a tanti protocolli no e la soluzione generale per risolvere questo tipo di ambiguità consiste nel taggare i valori quindi quando dentro un messaggio voi dovete trasmettere dentro un ciphertext dovete trasmettere un certo messaggio il messaggio viene sempre taggato con il tipo quindi quando dovete creare un ciphertext ok con una certa chiave di un plaintext m davanti al plaintext si mette sempre un tag che stabilisce di che tipo è quel plaintext come deve essere interpretato esatto quindi con questo arricchimento qui qua vi ritrovereste una roba del tipo id c'è il tipo identità due punti no scusate vi ritrovereste nonce due punti ide qui dentro perché qui dentro ide è un nonce quindi immaginiamo che esista il tipo nonce e quindi quando e e quando a crea la risposta per b cifrerebbe questa roba qua ok e ora questo messaggio qui un po' più essere riciclato da e qui come primo messaggio di una nuova autenticazione con b perché b non l'accetterebbe b accetta qualcosa che qui ha il tipo identity non ha il tipo nonce ok quindi vedete sono tante le le le sottigliezze da prendere in considerazione quando quando si va a esaminare un un protocollo crittografico ed è qui che appunto si coglie l'importanza di poter usare strumenti strumenti automatici io adesso in una mezz'oretta vi faccio vedere un esempio di come si usa uno strumento come Proverif ad esempio per fare la verifica automatica di un protocollo crittografico se interessa l'argomento poi in realtà ci sono un altro paio di tool che sono ancora più semplici di Proverif e quindi si potrebbero utilizzare perché Proverif comincia ad essere anche abbastanza vecchio e non è proprio user friendly il protocollo che andremo a modellare è un protocollo abbastanza complesso così vi faccio vedere anche un po' l'espressività di un linguaggio come quello di di Proverif ve lo spiego molto brevemente giusto per farvi capire come funziona Landshake è un protocollo complesso perché ci sono 4 5 diversi agenti coinvolti Landshake è questo per dire ok arriveremo a capire pensate a quanto è complesso questo rispetto a questo qui qui ci sono due agenti con tre messaggi qui ce ne sono quanti sono 1 2 3 4 sono 4 agenti e 9 messaggi ok quindi esaminare a mano cosa succede qui dentro non è non è praticabile chi sono questi 4 agenti che sono di fatto questo per usare gli stessi nomi sono segnati qua questo questo e questo ok allora i due agenti che vedete dentro l'area tratteggiata sono due app su dispositivo mobile quindi sul telefono ok i due agenti aggregation service e voucher registry invece sono due server ok qual è l'idea di questo protocollo l'idea è che la strago molto sul mio smartphone c'è un'applicazione che è questo connection tool che raccoglie dati di qualunque genere ad esempio che ne so facciamo un caso molto semplice i miei spostamenti se il gps è attivato il collection tool memorizza i miei spostamenti e li salva da qualche parte poi per qualche motivo io sono interessato a condividere i miei dati generati dal mio collection tool con un server centrale che è l'aggregation service perché lo faccio? pensate ai scenari di crowd sensing dove ad esempio i servizi per il monitoraggio del traffico quando voi usate google maps per spostarvi da qualche parte e vedete gli itinerari e vedete che gli itinerari vi danno anche tempi di percorrenza vedete il tragitto che è o blu giallo rosso a seconda di quanto è congestionato il traffico in quel momento lungo quel tragitto e come fa google maps a sapere queste cose raccoglie le informazioni dei vari dispositivi quindi l'idea è la stessa quindi c'è un dispositivo ad esempio il mio smartphone che condivide con un server le sue informazioni perché partecipo collettivamente a un certo tipo di servizio ok e quindi c'è questa trasmissione delle informazioni ora tutto questo non avviene tra virgolette gratis io condivido le mie informazioni per avere qualcosa in cambio ok cosa ottengo in cambio beh in cambio ottengo dei voucher che io potrò spendere per che ne so faccio un esempio banale accedere gratuitamente ai parcheggi avere uno sconto al bar qualunque genere di servizio ok quindi il server l'aggregation service che raccoglie le mie informazioni una volta che ha verificato che sono informazioni corrette che cosa fa informa un altro servizio web che è questo voucher registry che è il servizio che emette i voucher quindi l'aggregation service dice io ho un utente che mi ha condiviso i suoi dati questo utente merita di ottenere dei voucher lo dico al voucher registry ok e gli dico guarda emetti dei voucher ok perché questo doppio passaggio perché non viene gestito tutto l'aggregation service sono servizi separati perché chi emette i voucher non deve sapere chi li otterrà c'è la privacy ok infatti l'aggregation service dirà c'è qualcuno che ha fatto qualcosa per cui merita dei voucher tu emetti voucher poi ci sarà qualcuno che ti riverrà a chiedere per reclamarli ottenerli in maniera anonima ok sì ma è questo questo questo ah perché hai parlato con digit sì tu usi ah ma questo è il meccanismo su cui si basano i uom perfetto questo è il meccanismo su cui si basano i uom se li conoscete perfetto che abbiamo verificato formalmente usando proverif quindi il registry emette i voucher poi c'è un'altra applicazione sempre nello smartphone nello stesso smartphone di prima che si chiama pocket che viene usata per raccogliere i voucher che poi verranno spesi qua c'è tutta la fase in cui vengono spesi a noi questa non qui adesso non ci interessa quello che ci interessa è verificare dal punto di vista delle proprietà cartografiche di sicurezza che cosa succede con entro ok sono garantite le proprietà di sicurezza oppure no allora qui un po' di ipotesi di lavoro il l'applicazione dello smartphone che raccoglie i dati condivide una chiave simmetrica che è stata decisa in fase di installazione della dell'applicazione con il servizio che raccoglie le informazioni quindi questa è una chiave simmetrica per la cifratura i due servizi non condividono chiavi ma hanno dei certificati e quindi hanno delle chiavi pubbliche ok e quindi l'aggregation service ha la sua chiave pubblica il registro il registry ha la sua chiave pubblica e quindi loro due per dialogare useranno un protocollo H ok basato su fotografia chiave pubblica e basta queste sono le ipotesi di base ora come funziona il protocollo che permette garantendo le proprietà di confidenzialità adesso vedremo quali sono le proprietà che ci interessano di eseguire questo flusso in maniera in maniera sicura andiamo a vedere brevemente come funziona il protocollo che cosa succede il collection tool l'app sullo smartphone deve condividere i dati che ha raccolto con l'aggregation service quindi usa la chiave simmetrica condivisa con lui per creare un ciphertext da mandare che contiene i dati questi sono in maniera stratta i dati che io voglio condividere ok in più aggiungo quello che dobbiamo considerare una password considerata un nonce ok è una password ma di fatto è un nonce ok molto semplice no trasmissione su un canale protetto basato su autentichette encryption perché c'è una chiave condivisa c'è un master secret che i due condivido bene in questa fase qui abbiamo e qui questi tre messaggi ricalcano il protocollo di Needham e Schroeder l'aggregation service si autentica col registry per dirgli guarda io ho dei dati bisogna che tu crei i voucher per questi dati ok quindi gli mando i dati gli mando questo nonce che ho avuto dal collection tool gli mando un nonce che è quello del protocollo di Needham e Schroeder e gli mando la mia identità come il primo messaggio dell'autenticazione di Needham e Schroeder il registry vedete che risponde tutto naturalmente cifrato con la chiave pubblica del registry il registry risponde alla challenge basata su questo nonce ok e la propria identità perché non vogliamo essere vulnerabili all'attacco che abbiamo visto prima e questo che questo one time code di fatto è un link one time dove collegarsi per scaricare i voucher è one time quindi è fresh come un nonce può essere considerato un nonce tant'è che per completare l'autenticazione l'aggregation service manda l'ultimo messaggio al registry di restituire il one time code per dimostrare di essere stato in grado di aprirlo e quindi con questi tre messaggi noi abbiamo la mutua autenticazione tra i due server i due servizi ok adesso cosa succede succede che l'aggregation service ricomincia a parlare col collection tool e gli dice guarda io col con il registry ci ho già parlato ok vi ho già detto di creare i voucher tu questi voucher li devi reclamare usando questo one time code che io ti trasmetto cifrato in autenticazione di encryption con la chiave che condivido con te con la master circuit che condivido con te ok il collection tool dice benissimo memorizza il one time code dentro il pocket no quindi glielo passa la comunicazione interna tra i due tra le due app all'interno del telefono ok successivamente il pocket cosa fa deve dialogare con il registry per riclamare i voucher e quindi usando la chiave pubblica del registry gli dice guarda io voglio reclamare dei voucher usando questo one time code ok in più ti do anche questa password che è quella che era stata decisa qua e che il registry conosce ok quindi ti do il one time code e la password in più ti do anche una chiave di sessione il registry decifra questo messaggio e usa la chiave di sessione per trasmettere i voucher al pocket dopodiché per chiudere il registry manda un messaggio di conferma all'aggregation service dicendogli i voucher sono stati reclamati ok quindi questo è come funziona il protocollo che tra le altre cose dovrebbe garantire l'autenticazione tra i due server coinvolti l'aggregation service e il registry dovrebbe garantire la confidenzialità dei voucher e alla fine di questo protocollo solo lui scusa non lui cioè solo il dispositivo che ha avviato il protocollo in questa maniera qua attraverso il pocket deve essere in grado di recuperare i voucher ok quindi proprietà di confidenzialità dei dei voucher ok più altre che adesso non vi sto a menzionare comunque almeno queste due proprietà come facciamo a verificare che queste proprietà sono soddisfatte abbiamo preso Proverif e abbiamo modellato questo protocollo dentro Proverif dopodiché i controlli ne ha fatti lui vi faccio vedere brevemente la la specifica scritta in Proverif di questo protocollo qua ok tanto per darvi l'idea però ripeto esistono linguaggi anche meno meno complicati vado vado abbastanza velocemente poi vi faccio vedere il risultato del model checking della verifica questi sono i tipi i tipi di dati coinvolti no c'è il tipo nonce non dicevamo prima per fare il tagging c'è il tipo pk che sta per chiave pubblica il tipo sk che sta per chiave chiave segreta poi c'è una variabile channel no una variabile ch di tipo channel che rappresenterà il canale di comunicazione il canale su cui trasmettere i vari messaggi più altre informazioni vedete qui c'è una variabile data che è una stringa questo sta a significare che quella stringa è privata inizialmente è privata la conosce solo chi la genera ok è un'informazione confidenziale rappresenterà i dati che il collection tool vuole mandare all'aggregation service così come i voucher sono stringhe di bit inizialmente private e noi vorremmo che rimanessero tali ok e così via quindi ci sono un po' di variabili di vario di vario tipo questa è una funzione che stabilisce che c'è un legame tra chiave pubblica e chiave segreta ovvero la funzione si chiama pk ok e quando applicata ad una chiave segreta prestituisce la chiave pubblica corrispondente vedremo come utilizzarla e poi ci sono le funzioni di cifratura asimmetrica e di cifratura simmetrica con le regole di correttezza che sappiamo che abbiamo sempre studiato la proprietà di correttezza cioè la proprietà di correttezza dice che se io cifro un plaintext con una chiave e il risultato lo decifro con la chiave corrispondente riottengo il plaintext ok e queste sono le due funzioni che definiscono questo intuitivamente sono abbastanza chiare perché a encrypt è una funzione che prende una stringa prende una chiave pubblica e restituisce una stringa ok cosa fa qui e qui vedete la proprietà di correttezza che dice che per tutte le stringhe e le chiavi segrete se io prendo una stringa e la cifro usando la chiave pubblica associata a quella chiave segreta e il risultato lo do in pasto ad un'altra funzione che è quella di cifratura che usa la chiave segreta riottengo il plaintext cioè questa è una descrizione della proprietà di correttezza che già conosciamo qui nella stessa abbiamo la proprietà di correttezza per la cifratura simmetrica se io cifro una stringa usando una chiave e il risultato lo decifro con la stessa chiave riottengo x ok non sto mettendo tutto il codice ad esempio non ho messo la definizione di s-decrypt e ad-decrypt che sono di tipo analogo a encrypt e s-encrypt questo è uno stralcio insomma però tanto per darvi un'idea di che cosa significa dichiarare funzioni e tipi poi c'è una sezione in cui dichiaro quali sono le condizioni relative alla conoscenza di base ad esempio queste sono dichiarazioni che mi dicono che alcune informazioni non fanno parte della conoscenza di base pubblica ad esempio la chiave segreta la master secret che collection tool e l'aggregation service condividono non è l'informazione pubblica quindi non fa parte della base di conoscenza iniziale così come le chiavi segrete dei due server che poi non sono pubbliche la password che sceglie collection tool non è pubblica quindi ci sono una serie informazioni che inizialmente non sono pubbliche poi magari mi interessa verificare se durante l'esecuzione del protocollo diventano pubbliche per colpa dell'avversario però inizialmente non lo sono ok poi qui ci sono altre dichiarazioni che riguardano sempre la confidenzialità di certi termini questi li tralascio così come questa è un'altra proprietà di sicurezza che riguarda la confidenzialità dei voucher lasciate perdere così come queste invece sono le regole che stabiliscono le condizioni di autenticazione anche qui non entro nei dettagli però in pratica queste regole cosa dicono? Dicono che se un agente termina l'autenticazione con un certo agente A allora quell'agente A aveva a sua volta iniziato l'autenticazione quindi una sorta di binding tra la chiusura e l'avvio di un'autenticazione adesso anche qui non ci interessa entrare nei dettagli diamo per assunto che siano regole che stabiliscono come determinare la proprietà di autenticazione quindi finora sappiamo che c'è una sezione della specifica che riguarda i tipi di dati e di funzioni una sezione della specifica che parla delle proprietà e della base di conoscenza iniziale cosa è nota all'inizio e quali sono le proprietà che ci interessano ad esempio confidenzialità e autenticazione specificate in un qualche modo poi c'è la specifica cioè c'è la descrizione del protocollo e qui vi faccio vedere all'interno della specifica prove RIF il codice che descrive le diverse fasi del protocollo ok il codice il flusso del codice non è basato sul sulla sequenza dei messaggi che vengono scambiati durante nel shake ma il focus nella specifica sono gli agenti ok quindi nella specifica non troverete l'elenco di queste nove di questi nove messaggi che vengono scambiati ma troverete che ne so la descrizione della procedura collection tool e tutto quello che quella gente fa e quella gente che cosa fa qui ad esempio mi sono concentrato su collection tool perché questa procedura qua descrive cosa fa collection tool collection tool cosa fa manda il primo messaggio riceve il quinto e manda il sesto quindi è coinvolto in tre messaggi e in questa descrizione che trovate sulla destra che è una descrizione diversa da uno stile classico di linguaggi imperativi perché è una descrizione che di fatto ci racconta come in base a quale flusso il collection tool partecipa è Alan Sheik quindi mandando un messaggio ricevendone un altro e poi mandandone un altro ancora ok nel linguaggio il linguaggio specifico è abbastanza verboso cioè non è difficile vedere la corrispondenza tra quello che ha scritto qui e i tre messaggi in cui il collection tool è coinvolto andiamo a vedere qualche dettaglio allora intanto l'agente è descritto è descritto come una procedura un processo quindi questo let process ct sta a dire definiamo una procedura process ct che ha degli argomenti in ingresso che sono questi adesso cerchiamo di capire perché sono questi e che si comporta in un certo modo e il suo comportamento è dettato da che cosa? output di messaggi input di messaggio ma questo non fa mica nient'altro ok quali sono gli argomenti del collection tool? beh l'abbiamo detto all'inizio il collection tool condivide la master secret con con l'aggregation service questa master secret la chiamiamo sk ct a s ed è una chiave segreta ok un'altra informazione no in possesso del collection tool è quella famosa password quel nonce che deve mandare all'inizio quindi anche quello è un argomento ok dopodiché il comportamento di un agente è dettato fondamentalmente dall'uso di due funzioni out e in out è un messaggio in uscita in descrive un messaggio in entrata ok allora andiamo a rivedere il protocollo il collection tool prima manda un messaggio in uscita il numero questo qui poi più avanti aspetta un messaggio in entrata e poi spara un altro in uscita e qui vedete la sequenza di questi tre messaggi il primo messaggio in uscita è questo out dove dove lo trasmette il messaggio sul canale sul canale ch l'avevamo dichiarato prima una variabile di tipo canale è il canale trasmessivo quindi collection tool trasmette in uscita sul canale un messaggio cos'è questo messaggio è la cifratura simmetrica dei dati e della password fatta con la chiave segreta ed è esattamente quello che trovate scritto qui data lo vedremo dopo è una variabile globale ok quindi cifratura la funzione è s-encrypt dei dati e della password usando la chiave segreta ok poi il numero 5 è un input ok in sequenza il punto e virgola qui è l'operatore di composizione sequenziale c'è un out e poi c'è un in questo è l'input su un sul solito canale di un messaggio come lo chiamo questo messaggio lo chiamo il message l'ho chiamato il message 5 per rappresentare il fatto che è il messaggio che dicevo qua quindi ricevo un messaggio che è una stringa di bit ok ora questo messaggio mi aspetto che sia una cifratura quindi io lo devo decifrare ed è ciò che faccio qui questo comando mi dice sia questo che è un messaggio questa variabile ottcgenx la stringa che io ottengo come risultato della decifratura di questa stringa che io ho ricevuto in input usando questa chiave quindi in pratica questo comando che cosa mi dice? mi dice prendi message 5 che è la stringa che è appena ricevuto dal canale decifrala usando la chiave segreta e il risultato lo chiamiamo ottcgenx poi che cosa c'è? poi c'è questo output no? che è esattamente questo l'output sul canale di ciò che ho appena decifrato quindi vedete è abbastanza verboso come linguaggio una sequenza di out e in e delle operazioni che descrivono ciò che avviene nel protocollo ok adesso così magari vi faccio vedere brevemente un altro esempio ma sono tutti più o meno così ok ad esempio questo è l'aggregation service la sua descrizione è molto più lunga perché lo vedete in rosso l'aggregation service è coinvolto in sei diversi fasi dell'inshake che corrispondono a vedete questo è l'input che riceve qui questo è l'output che viene trasmesso qui poi c'è questo input e questo output e infine no questo output era questo e questo input e questo qua ok forse non ne ho messo in evidenza ah no me l'ho perso questo era questo o forse voglio cancellare le cose che lo rifaccio allora questo è questo è il processo sì questa questa è l'input che è questo ok e questo ve lo dico dopo questo è l'output che va qui questo è l'input che è lui questo è l'output che è lui questo è l'output che è lui e poi c'è l'ultimo input che è questo ho ricostruito i vari accoppiamenti non vi ho commentato questo perché questo è l'input che consente al processo di leggere la chiave pubblica del registro che vi serve per confezionare questo messaggio qua ok e in più in mezzo c'è qualcos'altro che serve per identificare i momenti relativi all'autenticazione però anche questo sono technicalities invece quello che ci interessa andando avanti vabbè abbiamo l'aggression service abbiamo il registry vedete anche lui è coinvolto in sei messaggi abbiamo il pocket che è coinvolto in tre e poi abbiamo infine la dichiarazione di come è fatto il sistema le diverse fasi della specifica sono la dichiarazione dei tipi la dichiarazione delle proprietà le varie specifiche e qui trovate invece la descrizione della topologia del sistema cosa dice questa descrizione intanto istanza va a distanziare i valori di quelle informazioni che a priori sappiamo che sono segrete perché l'abbiamo detto in fase di dichiarazione quindi la chiave la master secret condivisa tra collection tool e aggregation service la password che sceglie la collection tool e questa è interessante guardate questa che cosa rappresenta questa è una dichiarazione che dice che l'aggregation service ha una chiave segreta di cui questa è la corrispondente chiave pubblica questo questo new SKS SQ significa creiamo una nuova chiave segreta che la diamo in pasto l'aggregation service come argomento in ingresso quindi la corrispondente su voi e questa let PKS è la chiave pubblica corrispondente a quella chiave segreta ma la chiave pubblica deve essere pubblica a tutti e quindi viene sparata sul canale ok per renderla nota a tutti e questo è il motivo per cui per sapere qual è la chiave pubblica di un'altra gente avevamo una ING della specifica sia del register del register e questo è l'analogo dell'altro servizio il register questa è la sua chiave segreta questa è la chiave pubblica corrispondente che viene pubblicata a tutti e queste sono le copie dei diversi processi cioè abbiamo il processo con l'action tool che vedete ha come argomento in ingresso questo e ha la password e questi l'avevamo dichiarato all'inizio sono privati quindi li conosce solo lui ok poi abbiamo l'aggregation service che anche lui conosce questa ha la chiave è l'unico ad avere questa la sua chiave segreta mentre la chiave pubblica corrispondente la conoscono tutti e poi gli diamo in passo la chiave pubblica del registry perché c'era un controllo che non vi ho commentato poi abbiamo il registry e poi abbiamo il pocket quindi ognuno ha le proprie informazioni questo bang questo punto isclamativo qui davanti sta a rappresentare il fatto che nel sistema in rete c'è potenzialmente un numero illimitato di collection tool no? perché l'obiettivo è proprio verificare che cosa succede quando ci sono tanti collection tool tanti che sono service tanti registry tanti pocket e chiunque tra questi potrebbe essere un avversario ok dopodiché il resto l'ho fatto tutto il tool lo lanciate e lui vi dà risultato sulla versione originale del protocollo avevamo trovato una vulnerabilità la descrizione della vulnerabilità è questa qua riguarda queste fasi del protocollo vedete nel primo il protocollo parte così la vulnerabilità nel collection tool la sua descrizione era questa ok collection tool manda questo ciphertext poi poi riceve questo e lo trasmetto al pocket ok qui c'è una vulnerabilità simile all'attacco che vi ho fatto vedere prima sul protocollo di video machine perché mettetevi nel pang dell'avversario che manda in questa fase ok un messaggio che è la replica di questo ok cioè prendete un avversario passivo l'avversario passivo vede passare questo ok più avanti quando siamo qui e il collection tool aspetta questo messaggio l'avversario che cosa fa blocca questo messaggio e lo sostituisce con questo sono entrambi ciphertext creati usando una certa chiave ok ora da qui a qui il collection tool l'abbiamo visto che cosa fa l'abbiamo visto prima decifra questo e lo trasmette al pocket ma se quello che ha ricevuto qui non è questo ma è questo e lui in automatico decifra e inoltre qual è il risultato che nel passo 6 non viene trasmesso un notice gen ma viene trasmesso una stringa che contiene la password perché sia sta roba qui che questa roba qui sono delle bit string se non c'è un controllo sui tipi come nell'esempio che avevo fatto vedere prima questi due possono essere scabbiati e beh in questo caso l'attaccante potrebbe essere semplicemente un attaccante man in the middle un attaccante attivo che vede passare questo ok quindi lo memorizza poi quando vede passare questo lo blocca e lo sostituisce con questo quindi in questo caso l'attaccante non è uno dei partecipanti ma è un agente esterno che intercetta e blocca e fa un attacco di tipo replay e facendo così dopo vede questo che però in realtà è questo che continua a passo dal punto di vista del collection tool questi due potrebbero essere indistinguibili sono bit string allora lì ci vuole il type tagging che dice guarda questa è una stringa di un certo tipo quest'altra invece è una coppia fatta di due stringhe di un certo tipo anche quella e infatti la soluzione consiste proprio nell'aggiungere questo tipo di controllo e noi per simulare questo tipo di controllo aggiunto guardate la differenza qua di quello che fa il collection tool qui decifra la bit string e la spara in uscita così com'è che è quello che succede se non c'è il type checking ok invece nell'altra versione che è questa abbiamo aggiunto un controllo che simula il type checking ho aggiunto questo controllo qui quindi decifro la mia bit string e poi guardo che formato ha questo è un controllo che va a verificare se ciò che ho decifrato è una coppia è una astrazione per simulare il fatto che io sto facendo type checking su questo e su questo per verificare che siano del formato che mi aspetto e quindi con questo faccio questo controllo prima di spararlo fuori in questo modo i controlli di sicurezza sono tutti superati ok quindi ho astratto da molti delle proprietà di sicurezza come si formalizzano vi ho fatto vedere l'impianto generale però l'idea è appunto quella di mettere in evidenza che è possibile usando strumenti automatici descrivere in maniera più o meno verbosa come funziona il protocollo stabilire quali sono le proprietà che vi interessano e fare verifica del protocollo fare model checking e quindi verificare che quel protocollo soddisfa le proprietà di sicurezza che vi interessano più o meno tutti i tool lavorano in questa maniera qua cambia il linguaggio di specifica cambia il modo di scrivere le proprietà ma l'obiettivo è sempre quello ci sono tool più o meno semplici più o meno user friendly però vengono usati sempre più diffusamente proprio perché ci permettono di verificare le condizioni di sicurezza di protocolli complessi come quello che vi ho appena fatto vedere ok va bene per stamattina direi che siamo andiamo qui oggi pomeriggio invece vi faccio la nozione sui bitcoin domani anche domani l'ultimo domani l'ultimo sì perché volevo fare oggi pomeriggio quella sui bitcoin il world non è facile e domani invece vorrebbero farne una sui classificatori sui classificatori di immagini quindi sulle vulnerabilità del del deep learning quando viene usato per fare classificazione binaria delle immagini sì bravo bravo quel tipo di vulnerabilità lì che