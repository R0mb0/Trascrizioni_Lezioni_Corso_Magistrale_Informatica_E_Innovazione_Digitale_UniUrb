Eccoci qua. Allora, stamattina cominciamo a parlare di un'altra famiglia di cifrari, abbiamo visto la volta scorsa gli StreamCypher, cioè gli cifrari a flusso. Oggi vediamo una famiglia alternativa su cui si basano, come vedremo, la maggior parte di cifrare chiave simmetrica in letteratura, ovvero i cifrare blocco, i block cipher. Ora, l'idea dei block cipher è piuttosto semplice. Come dice il nome, l'intuizione si basa sul fatto di prendere il messaggio che vogliamo cifrare, dividerlo a blocchi, tutti della stessa dimensione, e poi andare a sostituire ogni blocco seguendo una funzione di permutazione, fondamentalmente, come vedremo, quindi prendere un blocco e sostituirlo con un altro, dove la sostituzione naturalmente è guidata dalla chiave. Quindi solamente chi conosce la chiave sa con quale blocco viene sostituito ciascun blocco. Questo è un po' l'idea di fondo. Quindi, nell'ambito di questo tipo di cifrari, sia i plaintext che i ciphertext sono suddivisi in blocchi tutti di uguale dimensione. Quindi quell'insieme X che vedete menzionato lì è appunto l'insieme dei blocchi. Un blocco può essere 128, 512 bits, insomma il range, l'intervallo, il nostro modo, di solito è quello. Poi vedremo degli esempi pratici di cifrare blocchi che lavorano su blocchi di diverse dimensioni. Quindi, da un punto di vista, diciamo, squisitamente matematico, un blocco cipher lo possiamo vedere di fatto come l'implementazione di una funzione di permutazione, che prende un blocco e lo sostituisce con un altro. Da un punto di vista rigoroso, vediamo la definizione, un blocco cipher è un cifrario che ha la sua funzione di cifratura e la sua funzione di decifratura, tale che la cifratura prende la chiave, prende in input un blocco e a seconda della chiave che viene utilizzata sostituisce il blocco in input con un altro blocco che viene restituito in output. Quindi lo vediamo qui. Vediamo se riesco a scrivere. Questa volta... Questa è la funzione che di fatto è una permutazione. Quindi una funzione che prende in input un blocco e a seconda della chiave che viene utilizzata restituisce uno e un solo blocco. Chiaramente la funzione di decifratura fa l'operazione inversa. Ok? Se vogliamo... L'idea è abbastanza simile a quella dei cifrari per sostituzione che abbiamo visto in una delle prime elezioni. Vi ricordate il cifrario di Cesare? No? Era un cifrario che prendeva ogni lettera dell'alfabeto e la sostituiva con un'altra in base a una funzione di permutazione. Qui il discorso è abbastanza simile. Non parliamo di lettere dell'alfabeto che vengono sostituite con altre. Parliamo di blocchi di bit che vengono sostituiti con altri blocchi di bit. E questa sostituzione vedremo in qualche modo è guidata dalla chiave. Ok? Chiaramente come vedremo adesso nell'Attack Game che definisce la sicurezza dei blocchi cifr, l'idea qual è? L'idea è che la permutazione di ciascun blocco che otteniamo a seconda della chiave che viene scelta, e assumeremo sempre che la chiave è scelta randomicamente, deve apparire dal punto di vista di un osservatore esterno come una permutazione del tutto casuale. Ok? Questa è la solita condizione che ci fa, come vedremo, ci farà garantire che i blocchi cifr sono sicuri. Ok? Ora, perché lavorare con le permutazioni? Beh, perché basta fare due conti. Ovvero se questo è l'insieme di tutti i blocchi, che ha una certa cardinalità, il numero di diverse permutazioni su questo insieme è il fattoriale della cardinalità di x. Ora, se lavoriamo, ad esempio, come ho citato prima, con blocchi di 128 bit, le diverse permutazioni che lavorano su blocchi di queste dimensioni sono un numero super poli, molto molto molto grande. Ok? E quindi chiaramente questo è buono perché, rispetto al discorso dell'impredicibilità, che poi rivedremo nella tag game. Ok? Sì. La funzione di encryption e di encryption. Sì. Il secondo argomento di cos'è? La chiave. Ah, no, no, scusami, questo è l'input, è il blocco. Ok. Ok? Cioè, la funzione di encryption prende la chiave e un blocco e restituisce un altro blocco. Sì, è un elemento in X grande. Infatti, qui, la signature di DF in maniera alternativa, è definita in questa maniera qua, F è una funzione parametrica sulla chiave, perché chiaramente la permutazione dipende dalla chiave, che prende l'input un blocco e restituisce un altro blocco. Sì. Sì. Sì. Sì. In base alla chiave ottengo una permutazione diversa. Sì. Sì. Sì. Ogni chiave mi darà una permutazione diversa. Quindi, se io non conosco la chiave e dovessi andare per tentativi, dovrei provare un po' tutte le permutazioni possibili. Ma se il numero delle permutazioni è un numero molto grande, super poli, allora la cosa diventa impraticabile per un avversario efficiente. Ok. Quindi questa è l'idea. Il cifrario, a seconda della chiave che abbiamo in input, permuta il blocco, cioè lo sostituisce con un altro blocco. Questa è l'idea. L'attack game che usiamo per definire la sicurezza dei block cipher è molto simile all'attack game che abbiamo visto anche per la sicurezza semantica. L'intuizione, in assoluto, è sempre quella, come vedremo. In questo attack game, come nel gioco della sicurezza semantica, abbiamo un esperimento che il challenger segue. L'avversario non sa qual è l'esperimento che viene seguito, lo deve indovinare. Questo è il suo obiettivo. Il challenger che cosa fa? A seconda dell'esperimento in cui ci troviamo, il challenger usa, oppure no, il block cipher. In che modo? Allora, se siamo nell'esperimento 0, il challenger sceglie casualmente una chiave e sa che deve usare la funzione di cifratura con quella chiave. Se invece siamo nell'altro esperimento, il challenger non usa il block cipher, ma applica delle permutazioni random. Questo è, immaginateci, questo è l'insieme di tutte le possibili permutazioni, che sono 2 alla 2, alla 135, se abbiamo blocchi di 128 bit. Nell'esperimento 1, immaginate che il challenger, in maniera del tutto casuale, prende una di quelle permutazioni e l'appica. Quindi non usa il cifrario. Quindi nel primo esperimento il challenger usa il cifrario con una chiave scelta randomicamente. Nel secondo esperimento il challenger non usa il cifrario, ma sceglie a caso una permutazione. Il compito dell'avversario, come al solito, è quello di capire cosa sta facendo il challenger, cioè se siamo in un esperimento piuttosto che nell'altro. Come fa per cercare di capirlo? Quali sono le attività dell'avversario? L'avversario non fa altro che inviare una sequenza a suo appiacimento, di sua scelta, di blocchi al challenger. Quanti lo decide lui? Chiaramente N è un numero polineumalmente limitato perché le capacità dell'avversario sono, come al solito, limitate da questo punto di vista. Parliamo sempre di avversario efficiente. Quindi l'avversario manda dei blocchi al challenger. Ok? Il challenger come risponde? Risponde calcolando che cosa? F del blocco. Dov'è F e che cos'è? F è la funzione di cifratura se siamo nell'esperimento 0. È una permutazione scelta randomicamente se invece siamo nell'esperimento 1. Quindi se siamo nell'esperimento 0, il challenger fa la cifratura del blocco che gli ha sottoposto l'avversario. Ok? Se siamo nell'esperimento 1, il challenger molto semplicemente prende il blocco che gli ha mandato all'avversario e lo sostituisce con uno scelto randomicamente. Quindi senza fare alcuna cifratura. Ma una scelta random. Ok? A questo punto l'avversario riceve, di ritorno dal challenger, questa sequenza di blocchi. e lui deve cercare di capire se questi blocchi sono stati generati secondo l'esperimento 0 usando il block cipher con una chiave randomica o se invece sono semplicemente dei blocchi random. Ok? L'avversario è efficiente, quindi esegui il suo solito algoritmo limitato polinomialmente, esamina tutti i blocchi che gli arrivano, fa il confronto con quelli che aveva inviato al challenger, fa tutto quello che vuole. Alla fine deve cercare di capire qual è l'origine dei blocchi che ha ottenuto di ritorno dal challenger. Sono ciphertext o sono blocchi random? Ok? Questa è l'idea. E come al solito, per misurare la capacità dell'avversario di distinguere questi due scenari, calcoliamo quello che viene chiamato appunto il suo vantaggio, che è al solito la differenza tra le probabilità dei due eventi, ovvero questa è la probabilità che l'avversario dia una certa risposta quando l'esperimento è il primo, questa è la probabilità che l'avversario dia la stessa risposta quando l'esperimento è il secondo. È chiaro che se queste due probabilità sono molto molto simili o addirittura uguali, vuol dire che l'avversario non è in grado di distinguere un esperimento dall'altro. Tanto maggiore è la differenza tra queste due probabilità, tanto maggiore è la capacità dell'avversario di distinguere i due esperimenti. Quindi la definizione di sicurezza per il block cipher che otteniamo è sempre la solita, cosa ci dice? Che il block cipher è sicuro se il vantaggio dell'avversario, calcolato in questa maniera qua, è trascurabile, è negligible per tutti gli avversari efficienti. Qual è l'intuizione di questo attack game? è che se il block cipher è sicuro, vuol dire che dal punto di vista dell'avversario, tutti i blocchi che riceve, che gli vengono restituiti dal challenger, sono casuali. Perché non è capace di distinguerli rispetto invece alle cifrature genuine di quei blocchi che il challenger fa usando la chiave. Ma se dal punto di vista dell'avversario questi blocchi sono casuali, potrà mai dedurre qualcosa sulla chiave, che eventualmente è stata utilizzata? Chiaramente no. Un po' come nell'attack game della semantic security. In quell'attack game lì, se vi ricordate, l'idea era che dal punto di vista dell'avversario il cybertext era indistinguibile rispetto ad una sequenza casuale di bit. Ma lo stesso tipo di ragionamento l'avevamo fatto sulla sicurezza dei PRG. Anche lì il discorso è analogo. L'avversario vede una sequenza pseudo-random, se dal suo punto di vista questa è indistinguibile da una veramente casuale, allora vuol dire che non è in grado di ridurre nulla sul modo in cui, a partire dal seme, viene generata una sequenza pseudo-casuale. Quindi l'idea è sempre quella, riuscire a capire se dal punto di vista dell'avversario ciò che osserva è indistinguibile da un qualcosa che è puramente casuale. Se così è, vuol dire che l'avversario non è in grado di ridurre nulla su quella che è la chiave che nell'esperimento zero il challenger utilizza per fare la citatura. Ok? Ci siamo? Quindi cambiano le tecniche ma alla fine la proprietà di sicurezza che andiamo a definire si basa sempre sullo stesso concetto. Da notare alcune cose relative al comportamento dell'avversario. Qui viene detto che l'avversario sceglie una sequenza lunga piacere di blocchi da sottoporre al challenger e questa sequenza è adattiva. Cosa vuol dire adattiva? Vuol dire che l'avversario non è che la sceglie subito fino all'inizio l'intera sequenza. Ok? L'avversario magari sceglie un blocco lo manda al challenger il challenger risponde l'avversario osserva la risposta la esamina fa quello che vuole fa il confronto rispetto a confronto a y con x fa tutti quelli che vuole poi successivamente sceglie se mandare un altro blocco quindi andare avanti con la sequenza e nel caso decide di andare avanti mandando un altro blocco decide in quel momento che blocco mandarli. Ok? Quindi può scegliere i blocchi successivi da inviare magari anche in base al risultato che ha ottenuto nei passi precedenti. Questo significa essere adattivi. Ok? Quindi diamo di fatto all'avversario tutti i vantaggi che gli possiamo dare da questo punto di vista nella scelta della sequenza da sottoporre al challenger. Ma un blocco alla volta? Cioè l'avversario sceglie il primo blocco l'avversario sceglie il primo blocco lo manda lo manda al challenger il challenger il challenger calcola FNX1 dove F a seconda dell'esperimento o è la funzione di cifratura o è una permutazione del tutto casuale e risponde. A questo punto l'avversario fa i suoi calcoli fa le sue considerazioni dopodiché può decidere di fermarsi e di fare il suo gas quindi sparare il suo output che è quel di cappuccio oppure decide di sottoporre un altro blocco. l'esperimento è sempre lo stesso siamo sempre l'esperimento viene deciso monte quindi finché finché l'avversario non decide di fermarsi sparando su output l'esperimento non cambia ok e questa cosa va avanti va avanti finché appunto l'avversario non decide a un certo punto di interrompere la sequenza e decide di sparare il suo il suo bet ok questa nozione di sicurezza ne implica tante altre un po' come ho detto anche in passato con la sicurezza semantica in particolare questa nozione di sicurezza per i block cipher ci garantisce che un block cipher sicuro sia anche un block cipher impredicibile dove la nozione di impredicibilità è simile a quella che avevamo visto per i PRG ok cosa vuol dire impredicibile in questo caso vuol dire che cambiamo leggermente il contesto immaginiamo di essere sempre nell'esperimento vero ok quindi l'avversario sa che ciò che riceve di ritorno dal challenger sono le cifrature dei blocchi che gli invia quindi il suo obiettivo chiaramente non è capire se il challenger ha usato il cifrario oppure no perché sa che lo sta usando ma il suo obiettivo diventa dopo aver inviato una sequenza di blocchi ok anche in questo caso lunga piacere indovinare quale sarà la cifratura del blocco successivo quindi a un certo punto immaginate una sequenza come quella che abbiamo appena descritto lunga a piacere a un certo punto il compito dell'avversario è dire bene questo è il prossimo blocco che io vorrei mandare al challenger prova a indovinare qual è la sua cifratura se ci riesco vuol dire che di fatto ho capito qual era la chiave che sta usando il challenger chiaramente ok la sicurezza che abbiamo appena definito per i blocchi cifre garantisce l'impredicibilità quindi vuol dire che l'avversario non è in grado con probabilità non trascurabile di riuscire a predire la cifratura di un blocco di sua scelta quindi di nuovo l'intuizione è non riesco a intuire nessuna informazione riguardo riguardo la chiave ok così come in una variante di questo stesso di questo stesso tag game l'attaccante piuttosto che provare a indovinare la cifratura del blocco successivo potrebbe direttamente provare a indovinare la chiave ma non otteniamo una definizione diversa rispetto a quella che abbiamo appena dato ok in ogni caso non è in grado di farlo quindi un blocco cipher sicuro è un blocco cipher per cui l'avversario non riesce a perdire la cifratura dei blocchi e non è in grado di indovinare la chiave se non chiaramente sempre sottointeso l'avversario può indovinare la chiave che probabilità uno su la cardinalità dell'insieme delle chiave no quello è c'è sempre quella probabilità lì di indovinare la chiave no quindi che è la probabilità di di vincere la lotteria di avere il biglietto vincente indovinare indovinare a caso qual è qual è il biglietto vincente ok quindi quella probabilità c'è sempre no però quando è che quella probabilità lì è trascurabile è trascurabile se il dominio delle chiavi è molto molto grande super fuori quindi questa è una condizione che non può mai venire che non può mai venire a mancare e c'è una variante di questo tag game in cui l'avversario può non solo mandare blocchi da farsi cifrare ma può anche decidere di mandare blocchi da farsi decifrare no visto che la cifratura è una permutazione io posso percorrere la permutazione in un senso o nell'altro ok quindi a un certo punto l'avversario può dire guarda il blocco che ti sto mandando non me lo devi cifrare me lo devi decifrare ok non cambia nulla anche anche se diamo questa libertà ulteriore all'avversario non cambia assolutamente nulla la nozione di sicurezza che otteniamo è comunque sempre sempre quella ok quindi questa è la nozione di sicurezza su cui si basano i blocciper un esempio di utilizzo di blocciper che però vi sconsiglio per il motivo che vedremo tra poco è il cosiddetto ecb mode l'electronic codebook è molto in realtà molto molto semplice perché consiste banalmente nell'applicare il block cipher a ogni blocco che compone il plaintext ok quindi voi immaginate di avere un plaintext di una certa lunghezza comunque polinomialmente limitata ok quindi immaginate di avere un plaintext che può avere al massimo un certo numero di blocchi quindi la condizione è questa ok l'ecb mode molto semplicemente che cosa fa prende il plaintext lo spesta in tanti blocchi e applica la cifratura a ciascuno dei blocchi ok vedete usando sempre la stessa chiave prendo il messaggio e cosa faccio cifro usando sempre la stessa chiave ogni blocco del messaggio che come abbiamo visto nella sostanza cosa consiste consiste nel prendere il blocco e per mutarlo in base a quello che è in base al valore della chiave la decifratura funziona chiaramente in maniera inversa ok questo tipo di cifratura è assolutamente da evitare indipendentemente dal fatto che il bloccifer sia sia sicuro ok è da evitare perché soffre dello stesso problema di cui soffriva il cifrario per sostituzione ricordate qual era il problema del cifrario per sostituzione no il fatto che se nel cifrtext avevate due simboli uguali questo voleva dire che i simboli corrispondenti del plaintext erano anche loro uguali e qui succede la stessa cosa solo che il problema non riguarda i simboli ma riguarda i blocchi se voi prendete un cifrtext no e osservate che due blocchi del cifrtext sono uguali cosa vuol dire vuol dire che i blocchi corrispondenti del plaintext dovevano essere anche loro uguali tra di loro e questo è più che sufficiente per rendere il blocchi il cifrario ecb costruito in questa maniera qua semanticamente insicuro ok chiaramente se voi avete la garanzia che tutti i blocchi del plaintext sono diversi tra di loro allora siete contenti tutto funziona senza problemi ok infatti c'è un teorema che dice che ecb cioè la costruzione che abbiamo appena visto sotto la condizione che il plaintext sia composto di blocchi tutti diversi tra di loro e sotto la condizione che il blocciper che usiamo sia sicuro rispetto alla tag game che abbiamo visto prima quindi sotto queste due condizioni ecb è un cifrario semanticamente sicuro ok quindi ripeto ecb è semanticamente sicuro se il cifrario il blocciper che usiamo è sicuro e i plaintext che andiamo a cifrare sono composti di blocchi tutti diversi tra di loro sotto queste due condizioni abbiamo un cifrario che è semanticamente sicuro chiaramente la condizione evidenzata in rosso sulla natura dei plaintext è abbastanza restrittiva nella pratica possiamo sempre garantire che i plaintext non possono avere al loro interno blocchi identici ok e quindi questo è il motivo per cui ecb di fatto in questa maniera qua non si utilizza ok come si costruiscono i blocciper in pratica in maniera tale da realizzare quella famosa permutazione di cui parlavamo all'inizio all'inizio abbiamo detto che il cifrario di un blocciper di fatto che cosa fa permuta i blocchi cioè prende un blocco e lo trasforma in un altro blocco secondo una funzione di permutazione ma già come realizziamo questa questa funzione di permutazione e come realizziamo il blocciper in maniera tale da evitare il problema di ecb che abbiamo visto che abbiamo visto prima il modo tipico di costruire i blocciper è quello che vediamo qui l'idea di base consiste fondamentalmente nel reiterare applicare più volte il blocciper sul blocco che dobbiamo cifrare usando una sequenza di chiavi diverse tra di loro in che maniera? noi partiamo da un blocciper semplice come quelli che abbiamo introdotti prima quindi un cifrario che permuta i blocchi in gergo questi blocciper vengono chiamati round cipher round perché sono cipher che vengono applicati più di una più di una volta poi che cosa si fa? si prende la chiave che è stata scelta randomicamente e la si allunga come si fa ad allungare la chiave? l'abbiamo visto l'altra volta possiamo usare un PRG ok? quindi usiamo la chiave come seme da dare in input a un PRG ok? il risultato è una sequenza pseudo-random di una certa lunghezza l'abbiamo visto l'altra volta come funzionano i PRG questa sequenza pseudo-random la spezzettiamo in modo tale da ottenere tante diverse chiavi ok? quindi indicate da questa lista ok? quindi il PRG applicato a K mi restituisce questa sequenza ok? ora quella sequenza che otteniamo chiaramente se il PRG è sicuro è pseudo-random quindi non è predicibile dall'avversario ora cosa me ne faccio di questa sequenza? cioè perché la chiave che avevo l'ho trasformata in una sequenza di chiavi perché l'idea è di per fare la cifratura applicare il block cipher non una volta sola ma applicarlo di volte ok? quindi fare di round di cifratura dove ad ogni round applico una chiave diversa quindi la costruzione è questa quindi vedete che cosa succede? guardate primo round primo round prendo il blocco x che è il plaintext che devo cifrare e lo cifro usando la funzione di cifratura del mio block cipher tramite la chiave k1 ok? quindi vado a rappresentare in questo modo abbiamo x il mio blocco prendo la chiave k1 gli do in pasto alla funzione di cifratura del mio block cipher e otterrò una cifratura chiamiamola c1 ok? poi la cosa non finisce qui va avanti va avanti in che modo? adesso prendo questo e ho appena ottenuto cifrando x con k1 e lo cifro un'altra volta stavolta però usando k2 quindi cambia la chiave ok? e vado avanti e vado avanti quanti round faccio in questa maniera? ne faccio di tanti quanti sono le chiavi che ho ottenuto applicando all'inizio il mio prg a k quindi nella pratica per ottenere un block cipher sicuro non mi accontento di applicare la cifratura al mio plaintext ok? ma la cifratura in cascata la applico di volte faccio di round e a ogni round cambio la chiave ok? ok sì così ho cifrato solo un blocco chiaramente perché è x il plaintext il mio plaintext di riferimento è il blocco x e per ottenere la cifratura di x in realtà mi servono di round lo cifro una volta il risultato lo cifro un'altra volta il risultato lo cifro un'altra volta ancora e così via ok? perché faccio questo? è perché non ci sono teoremi in proposito però da un punto di vista sperimentale si è visto che reiterando più volte le operazioni di un blocco x si ottiene un meccanismo che soddisfa la proprietà di sicurezza che abbiamo definito prima ok? per tornare indietro si parla sempre dalla per tornare indietro allora chiaramente siamo nell'ambito di separatura che è simmetrica quindi mi tento e destinatario condividono k ok? quindi entrambi sono entrambi sia emittente che destinatario possono applicare il PRG a k per ottenere k1 kd ok? quindi mentre l'emittente parte da x per costruire la catena che abbiamo appena visto dall'altra parte l'ultima cifratura sarà c del round d no? dall'altra parte il destinatario ripercorre questa catena ritroso sì assolutamente perché esatto perché il destinatario deve prendere la cifratura che riceve il blocco che riceve e la deve decifrare usando l'ultima chiave della sequenza per ottenere il ciphertext precedente poi ritrodo questo passaggio finché uno risale a x infatti se vedete la definizione di decifratura ritrovate le stesse operazioni della cifratura ma in ordine inverso infatti la prima operazione che fa il mittente è questa cioè prendere il ciphertext che ha ricevuto decifrarlo con l'ultima chiave della sequenza pseudo random per ottenere un qualcosa che poi a sua volta dovrà essere decifrato con la chiave precedente fino ad arrivare a riottenere x ok e dopo lo vediamo la scelta di di di tutti i parametri vediamo dopo attraverso qualche esempio quindi questo sarebbe una parte del del plaintext sì sì sì fatto di tanti blocchi sì sì sì sì ok quindi il punto di partenza è un block cipher che chiameremo round cipher perché lo chiamiamo così perché viene eseguito di volte in ogni round viene riapplicato per arrivare a ottenere quella che si ritiene essere la cifratura sicura di un certo di un certo blocco ok qui l'intuizione del motivo per cui viene ritenuto sicuro sta nel fatto che in realtà non stiamo usando una sola chiave in realtà ne stiamo usando di di chiave no e quindi questo complica il compito di un eventuale avversario ora siccome le di chiavi sono state generate usando un prg a partire da k k quindi funge da seme se il prg è sicuro chiaramente la sequenza delle di chiavi è impredicibile e quindi l'avversario non può dedurre nulla su queste a meno che non conosca il seme di partenza cioè k ok questo è il modo in cui i block cipher vengono costruiti nella pratica qui vedete un po' di esempi dal punto di vista della scelta dei parametri ok dove nelle varie colonne vedete appunto la lunghezza della della chiave k quella di partenza quella che usiamo come seme del prg vedete poi la dimensione del blocco ok quindi su su quali sequenze di vite il block cipher lavora il numero di round e l'ultima colonna dice un po' quelle che sono le le performance in termini di capacità di cifratura per al secondo in questo caso qui ho riportato alcuni alcuni cifrari costruiti secondo l'idea delle iterated block cipher il primo nato storicamente è il DES che sta per data encryption standard sviluppato dall'IBM negli anni 70 è diventato uno standard di via breve e lo è rimasto per parecchi anni non lo è più non lo è più poi adesso rompo più nel dettaglio non tanto perché sia vulnerabile ad attacchi di vario genere che poi andremo a raccontare analizzare ma più che altro è oramai deprecato per via della lunghezza delle chiavi perché chiavi in 56 bit con le risorse computazionali di oggi sono un problema perché un attacco a forza bruta in tempi abbastanza ragionevoli riesce a trovare la chiave vi ricordate in una delle prime lezioni avevo fatto l'esempio di quello che dovrebbe essere lo sforzo computazionale di un avversario che lavora contro chiavi a 128 bit e veniva fuori una cosa abbastanza impraticabile dal punto di vista dell'avversario avevo fatto l'esempio con lo sforzo computazionale che globalmente si fa per minare bitcoin come pietra di paragoni quindi 128 bit al giorno d'oggi è una lunghezza ragionevole per per blockcyper ora per questo problema legato alla lunghezza delle chiavi a un certo punto si è pensato di prendere DES ed estenderlo 3 DES non è altro che la variante del DES in cui il DES viene applicato in cascato tre volte questo per complicare il lavoro per l'avversario e rendere vano l'attacco forza brutta infatti se osservate le chiavi 3 DES sono il triplo delle chiavi DES così come triplica anche il numero di round i blocchi sono sempre gli stessi a 64 bit però vedete che le performance calano drammaticamente è stato uno standard 3 DES per un po' di tempo però è stato rapidamente poi messo da parte non per motivi di sicurezza ma per motivi di efficienza per motivi prestazionali se mi chiedete per quale motivo da DESS si è passato a 3 DES senza passare per 2 DES 2 DES il motivo è che 2 DES è vulnerabile ci sono degli attacchi noti contro 2 DES che in tempo polinomiale lo rendono insicuro mentre invece questo lo succede con 3 DES quando poi nella pratica ci si è accorti che non era utilizzabile appunto per motivi prestazionali in breve tempo si è diciamo fatto tabula rasa nel senso che si è cercato di ridefinire un block cipher da zero completamente diverso rispetto a DESS questo risale al lavoro fatto tra la fine degli anni 90 e i primi anni 2000 ci fu una call a livello mondiale alla ricerca tra i vari gruppi di ricerca chi voleva sottoporre un block cipher nuovo candidato per diventare il nuovo standard questa call venne vinta dalla scuola dei criptografi belgi dell'università di Leuven che svilupparono un block cipher completamente nuovo e diverso rispetto a DESS che si chiama Rindail e che divenne il nucleo per il nuovo standard che ha preso il nome di Advanced Encryption Standard AS che vale tuttora è uno standard tutt'oggi c'è sia la versione a 128 bit che la versione a 256 bit per quanto riguarda la lunghezza delle chiavi i blocchi sono il doppio rispetto a quelli del DESS si fanno molti meno round vedete bastano nel caso della versione a 128 bit bastano 10 round invece che i 16 di DESS e chiaramente avere meno round significa aumentare le prestazioni e infatti lo vedete in termini di efficienza che è addirittura il doppio più veloce rispetto al DESS originale ok e tenete conto del fatto che queste performance poi ogni tanto bisognerebbe rifarle perché però si basano su su questo considerazione qua ovvero il fatto che una singola operazione di ciclatura si assuma che porti via qualche non più di qualche centinaia di cicli di clock ok e il discorso su quanto sia complesso per un avversario cercare di violare una chiave a 128 bit con un attacco a forza brutta l'avevamo già visto la volta le volte scorse ok ora così per motivi storici voglio farvi vedere come questo meccanismo qui è implementato dentro DESS è il più semplice da vedere quindi tutti i block cipher che vi ho citato e elencato si basano su questo sul meccanismo generale di questo slide quindi avere un block cipher semplice di base che è il nostro round cipher che viene reiterato di volte e ogni volta viene applicato usando una chiave diversa nella astrazione che vi ho fatto vedere ciascuna delle chiavi che viene usata ad ogni round non è altro che il pezzettino una porzione della stringa pseudorandom che è stata generata usando un PRG a partire dal seme K nella realtà DESS non usa un PRG fa una cosa molto più semplice come vedremo tra poco comunque andiamo a vedere che cosa fa DESS a livello di meccanismo di cifratura allora come abbiamo visto qua DESS lavora su chiave a 56 bit ricordiamoci questo chiave a 56 bit blocchia a 64 bit e fa 16 round ricordiamoci questi numeri ora il block cipher di base che viene reiterato 16 volte prende dentro DESS prende il nome di permutazione di Feistel un block cipher fa permutazioni quindi chiaramente quello che ci aspettiamo di vedere a livello di funzione di cifratura è un permutatore una funzione che permuta un blocco in un altro in particolare la permutazione di Feistel prende il blocco che deve permutare lo spessa a metà e fa l'operazione che vedete qui quindi queste sono le due metà di un blocco quindi immaginate un blocco sia questo ok ora dato che per DESS i blocchi sono a 64 bit vuol dire che X e Y sono le due metà da 32 bit la prima metà e la seconda metà di un blocco e l'operazione che la permutazione fa è questa ovvero prende le due metà le scambia di posizione quindi la seconda metà la sposta nella prima metà senza modificarla la prima metà la sposta nella seconda metà modificandola vedete che Y non è cambiato l'ho semplicemente spostato di posizione invece X viene sostituito con un'operazione complessa questa operazione complessa è l'oxor tra X stesso e una certa manipolazione di Y quell'F di Y lo vedremo tra poco è il risultato di una certa funzione applicata a Y ok questo è quello che fa la permutazione di Festel cioè questo è quello che fa des a ogni round ok e dobbiamo definire questa F qui cosa fa questa F qui ok F è quella parte della permutazione dove interviene dove si usa la chiave perché finora la chiave io non ve l'ho mostrata nella definizione di permutazione di Festel la chiave ancora non compare mentre invece noi sappiamo che un block cipher è sì una funzione di permutazione ma è una funzione di permutazione che dipende dalla chiave ok dove compare la chiave compare quando viene usata qua dentro e la definizione di Festel è questa che vedete qua sotto ovvero la funzione F applicata a un blocchettino di 32 bit fa questa operazione qua F grande adesso vi farò vedere il circuito logico che rappresenta F grande ve lo mostrerò F grande è quindi un circuito che prende in input la chiave prende in input il blocchettino di 32 bit e lo trasporta ok ora chiaramente vedete qui perché ho messo K di perché I è l'indice che mi rappresenta il round che sto eseguendo perché come abbiamo visto prima la chiave deve cambiare ogni round quindi al primo round userò K1 al secondo round K2 al sedicesimo round K16 ok come deriva da K no non lo usa adesso ci arrivo ci arrivo non ve l'ho ancora detto nella nella nella generalizzazione che vi ho fatto vedere prima la chiave con divisa K viene usato come seme di un PRG che mi spara tutte le KI che mi servono è complicato quando hanno realizzato DES negli anni 70 hanno fatto una cosa molto molto molto più semplice ovvero KI ogni KI è una diversa maschera di K che cambia a seconda del round quindi in pratica KI è la proiezione di alcuni bit di K ok voi immaginatevi che ogni round è associato ad una maschera questa maschera viene applicata K e serve per proiettare alcuni bit della chiave ogni KI come vedremo è lunga 48 bit ok quindi ogni KI proietta da K e K noi sappiamo che di bit ne ha 56 quindi ogni KI proietta 48 diversi bit dalla chiave K quindi ci sono 16 diverse maschere che sono utilizzate per filtrare da K 48 dei suoi 56 bit quindi vedete una cosa molto più se vogliamo basso livello e dozzinale rispetto a quanto avevamo ipotizzato prima di utilizzare un PRG ok quindi riassumendo a ogni round Desk che cosa fa applica la permutazione di Feistel la permutazione di Feistel che cosa fa prende il blocco scambia la prima metà con la seconda ok nel fare questo però la prima metà viene manipolata in che modo viene manipolata viene combinata in XOR con una certa funzione della seconda metà ok questa funzione tra poco vi farò vedere il circuito che la realizza che cosa fa prende la chiave del round corrente la combina in qualche modo come vedremo con l'input per permutare l'input e trasformarlo in qualcosa ok chiara la procedura diciamo ora vi devo far vedere come è realizzata questa funzione F grande attraverso un circuito che è questo astratto chiaramente non vi faccio vedere le porte logiche vi faccio vedere come funziona in astratto ok partiamo quindi dalla considerazione che la mia funzione che adesso andiamo a commentare prende la chiave del round corrente che è una stringa di 48 bit che è stata estratta applicando una certa maschera da K e prende un blocco X la cui lunghezza è 32 bit cioè la metà di un blocco no perché il blocco intero è questo ed è solamente su una metà del blocco che si applica la trasformazione ok quindi l'input per il mio circuito sono una chiave di 48 bit e una sequenza di 32 bit ok e li vedete quassù ok questa questa è la chiave del round questa è il blocchettino che deve essere permutato ok allora la prima operazione che si fa è applicare quella che si chiama una funzione di espansione della risparmio che prende in maniera deterministica i 32 bit del blocco e li fa diventare 48 sono le semplicemente delle operazioni aritmetiche che servono per espandere in maniera prevedibile qui non c'è nessuna impredicibilità i 32 bit li fa diventare 48 ok perché li fa diventare 48 perché adesso dobbiamo fare lo XOR tra questi 48 bit e quelli della chiave come nel come i noti p ok una volta che ho fatto lo XOR tra queste due sequenze i 48 bit vengono spezzati in 8 sequenze da 6 ok ognuna di queste sequenze da 6 viene data in input in pasto ad una diversa tabella di lookup le tabelle di lookup che vengono chiamate Sboxes non sono altro che delle tabelle che mappano sequenze di 6 bit in sequenze di 8 bit scusate 4 quindi un Sbox a tutti gli effetti è una tabella una tabella che ti dice guarda la sequenza 1 0 1 0 0 0 diventa questa trasparando vita caso non me ne ricordo memoria del tabella di un capo e così via quindi sono grandi queste tabelle no? perché chiaramente per ogni per ogni sequenza di 6 di 6 bit vi dice qual è la corrispondente sequenza di 4 e ripetizione sono 8 di queste diverse tabelle no? quindi il risultato dell'Oxor è una sequenza di 48 bit che viene spezzata in 8 sequenze da 6 ognuna di queste viene andata in pasto ad una diversa tabella di lookup che fa questo mapping che di fatto riduce i 6 bit a 4 ok? inizialmente l'IBM aveva ottenuto segrete queste tabelle poi quando attraverso diversi lavori di ricerca si è iniziato a a trovare delle piccole vulnerabilità nel nell'argomento di cifratura di Udessa allora l'IBM ha deciso di pubblicare le 8 tabelle mettere a disposizione di tutti per verificare se effettivamente studiando le tabelle fosse possibile individuare delle vulnerabilità quindi sono note le le 8 tabelle i risultati delle mappature quindi sono 8 sequenze di 4 bit quindi guarda caso sono i 32 bit che mi servono perché siamo partiti da un blocco di 32 il risultato deve essere un blocco di 32 ok? poi in realtà questi 32 bit vengono permutati un'altra volta applicando una funzione anche questa nota diciamo che dal punto di vista della sicurezza questa è abbastanza ininfluente non conta poco e niente probabilmente l'hanno messa solamente per per incidere sulle performance delle implementazioni software di DAS perché implementare una permutazione a livello a lato software è gravolo costa ok? mentre invece le permutazioni si realizzano in maniera molto rapida nelle soluzioni di hardware e quindi siccome volevano privilegiare le implementazioni in hardware del cifrario piuttosto che del software questi erano dei trucchi che usavano per favorire l'una piuttosto le altre quindi le implementazioni di hardware di DAS erano molto più efficienti rispetto a quelle software diciamo che l'intero meccanismo si basa fondamentalmente sul fatto che la chiave segreta va in XOR col blocco che dobbiamo permutare e poi intervengono queste tabelle per mescolare ulteriormente i valori e quindi aumentare il livello di impredicibilità e questo è il modo in cui funziona adesso quindi questo circuito qui rappresentato in astratto veniva ripetuto appunto 16 volte per ciascun round in cui veniva invocata la permutazione di Feister ok diciamo che tutt'oggi nel corso degli anni si sono diciamo studiati anche realizzati degli attacchi contro il DAS che è stato critanalizzato in tutti i modi possibili immaginabili perché negli ultimi 50 anni lo hanno rivoltato come un guanto nonostante questo a tutt'oggi l'attacco più efficiente contro il DAS è quella forza brutta sulla chiave ha delle vulnerabilità a livello di criptanalisi come poi ti dirò così un pochino più nel dettaglio però sono comunque più inefficienti rispetto all'attacco forza brutta quindi di fatto il motivo per cui DAS è stato soppiantato è legato praticamente in misura esclusiva al discorso della lunghezza della chiave e non ad altre considerazioni che dipendono da questa struttura qui che abbiamo appena visto che funziona bene nonostante appunto sia vecchio di 50 anni tanto per darvi un'idea di che cosa nella pratica si è arrivato a poter fare contro DAS già più di 20 anni fa si è realizzato che chiavi di 56 di 56 bit non non fossero adeguate questi sono i risultati che sono andato a rivedere da da quella che era una challenge una sfida che una un'organizzazione americana che è l'RSA Data Security Group e questo è il sito dell'ente lanciava periodicamente per sfidare tutti i cristallisti in giro per il mondo a rompere a rompere il DAS la sfida si ripeteva sempre secondo le stesse modalità ovvero RSA pubblicava tre blocchi tre plaintext e pubblicava i tre ciphertext corrispondenti e la sfida consistiva nell'individuale la chiave che era stata usata per trasformare questi tre blocchi questi tre plaintext in questi tre ciphertext perché tre blocchi non uno non due non cinque non dieci perché tre è il più piccolo numero di blocchi che garantisce con una probabilità significativa che non ci possano essere due chiavi diverse che maffano quegli stessi tre blocchi nei tre ciphertext che sono stati pubblicati questo è importante perché perché RSA voleva avere la garanzia con una probabilità molto vicina a uno che ci fosse una sola chiave che mappasse quei tre plaintext e tre ciphertext corrispondenti perché se le chiavi erano due i risultati della challenge erano in qualche modo falsati no? perché se ci fossero più chiavi candidate chiaramente il compito è più semplice per chi doveva individuarla ok? e e lì vedete i risultati della challenge dalla prima ne ha fatte tre perché dopo la terza si sono resi conto che non era più il caso di andare avanti con con Dess perché già dopo la terza challenge vedete che in meno di un giorno la chiave veniva veniva individuata ok? sempre adottando attacchi basati sulla ricerca forza brutta quindi niente di più sofisticato di questo e anche qui vedete un altro calcolo che ho fatto anche qui per darvi un'idea di quale sia invece la difficoltà pratica nel cercare di effettuare una ricerca forza brutta su chiavi 128 bit qui chiaramente il paragone l'ho fatto in maniera un pochino astratta cioè ho fatto il conto basandomi sulle risorse computazionali di 25 anni fa no? impiegate nella ricerca a forza brutta di una chiave non a 56 bit ma a 128 bit facendo semplicemente una proporzione nel 99 22 ore erano sufficienti per cercare una chiave qui dentro usando le stesse risorse computazionali e cercare la chiave qua dentro significa aspettare una quantità di tempo che supera ampiamente il tempo che è trascorso dal Big Bang a oggi ok? è chiaro che le risorse computazionali sono cresciute negli ultimi 25 anni ma non sono cresciute esponenzialmente sono cresciute polinomialmente quindi vuol dire che quella quantità lì non è cambiata così significativamente ecco insomma è un po' più bassa ma siamo sempre nell'ordine del super poli ok? vi ho parlato di attacchi contro BlockCypher come adesso e vi ho detto che in tutti questi casi gli attacchi più efficienti sono risultati sempre essere quelli basati sulla ricerca a forza bruta ok? quindi provare tutte le possibili chiavi non vi ho detto in cosa consistono invece attacchi più sofisticati che ci sono in letteratura ok? gli attacchi ai BlockCypher comunque ai Cypher in generale si dividono fondamentalmente in tre categorie ok? abbiamo gli attacchi algoritmici sono gli attacchi di critanalisi classici in cosa consistono? beh molto semplicemente torniamo al nostro esempio del DES un avversario che vuole fare critanalisi di DES in via algoritmica che cosa fa? prende questo schema che è noto e pubblico lo potete andare a recuperare così come potete andare a recuperare le 8 S-Box e lo studiate in che maniera lo studiate? beh andate a vedere se utilizzando certi plaintext e scegliendo voi la chiave come vi pare trovate una qualche relazione che esiste e che è osservabile tra plaintext chiave e l'output finale che ottenete perché è chiaro che se se il cifrario è sicuro l'output che osservate è indistinguibile rispetto a una stringa casuale e se è indistinguibile rispetto a una stringa casuale vuol dire che non ha nessuna relazione col plaintext ok questo è evidente lo dicono tutte le nostre di sicurezza che abbiamo appena visto no? quindi se un block sulfur o un un cifrario in generale ha qualche vulnerabilità vuol dire che non è proprio vero che il ciphertext è completamente scorrelato rispetto al plaintext e alla chiave ma studiandoli magari facendo qualche analisi tipo statistico provando tanti plaintext provando tante chiavi andando a confrontarli con i ciphertext è chiaro che più dati ho a disposizione e meglio è quindi in linea di principio io potrei dare questa struttura in pasto anche la rete neurale o se non altro potrei semplicemente prendere tutti i possibili plaintext che riesco a testare con tutte le chiavi che riesco a testare e i ciphertext che saltano fuori quindi m k e c ok ne prendo tanto di queste triple tutte quelle che riuscite a produrre date tutto in pasto ad una rete neurale la addestrate con che obiettivo con l'obiettivo di vedere di stabilire se esiste un qualche legame tra i tre elementi ok è chiaro che anche uno strumento di deep learning tra i più sofisticati non lo trova un legame se il cifrario è sicuro perché se il cifrario è sicuro abbiamo la dimostrazione matematica del fatto che questo elemento è a tutti gli effetti dal punto di vista di chi osserva qualcosa di assolutamente indistinguibile rispetto alla nostra lingua pseudo-casuale ok quindi non ha alcun legame né con m né con k ok è chiaro ripeto che se invece il cifrario che usiamo è vulnerabile qualche legame ci deve essere magari faccio un esempio stupido salta fuori che che ne so quando l'ultimo bit del plaintext è uno zero e il primo bit della chiave è un uno allora la probabilità che un certo bit del cifrtex sia uno zero è significativamente diversa rispetto al 50% questo è un esempio stupido ok però se vale una condizione di questo genere che cosa vuol dire vuol dire che osservando una certa porzione del cifrtex riesco a dedurre con una certa probabilità informazioni proprietà che riguardano la chiave il plaintext ok questo è questo è quindi chi fa crit analisi cerca se ci sono di individuare delle relazioni che esistono tra plaintext chiave e cifrtex facendo analisi tipo statistico siccome i cifrari sono open source chiunque può fare questo tipo di lavoro voi prendete desk lo aprite gli date in pasto plaintext scegliete la chiave vedete il cifrtex che salta fuori e cominciate a fare analisi statistiche e cominciate a vedere se ci sono dei legami all'interno di queste triple se la trovate vuol dire che l'avversario ha una qualche probabilità significativa di analizzare il cifrtex senza conoscere la chiave dedurre qualcosa sulle proprietà del plaintext violando la semantic security che invece ci dice che questa cosa non si deve poter fare questo è è lo scopo di chi fa critoanalisi ok dopo vi faccio vedere una spazio in tempo la formalizzazione matematica di che cosa significa da un punto di vista statistico capire che ad esempio una certa porzione della chiave è una certa porzione del plaintext sono in relazione con una certa porzione del cybertext ok poi ci sono altri tipi di attacchi non algoritmici perché questi li potete condurre su carta tra virgolette nel senso che prendete il cifrario prendete M scegliete una chiave K applicate il cifrario quindi eseguite l'algoritmo e vedete il C che vi salta fuori e cominciate a fare le analisi statistiche ok gli altri tipi di attacchi invece non sono di natura algoritmica ma sono strettamente legati all'analisi del comportamento dell'hardware che esegue il codice relativo al vostro cifr in particolare abbiamo i cosiddetti side channel attacks ok il cui obiettivo è quello di andare sempre attraverso analisi statistica ma osservare informazioni che non c'entrano niente con l'algoritmo di cifrature in sé per sé ma informazioni che invece riguardano l'utilizzo dell'hardware quindi ad esempio faccio due esempi banali il tempo di esecuzione il consumo di energia chi fa side channel attack tipicamente che cosa fa prende un chip dove è implementato DESS faccio un esempio e comincia a usarlo per cifrare plain text di sua scelta con chiave di sua scelta per vedere ad esempio quanto tempo ci mette a sparare fuori il cypher text oppure applicando dei misuratori esterni a vedere quanta energia viene consumata dal chip per generare il cypher text allora idealmente se noi vogliamo rispettare l'idea della sicurezza semantica qualunque sia il plain text che voi cifrate con qualunque chiave scelta randomicamente idealmente i tempi di esecuzione e i consumi di energia dovrebbero essere sempre gli stessi se così non è vuol dire che esaminandoli l'avversario può dedurre delle informazioni relative alle proprietà della chiave o del plain text il motivo per cui esistono i side channel attacks no il motivo una delle conseguenze del fatto che esistono i side channel attacks sta nel fatto che chi scrive gli algoritmi di cifratura quindi chi implementa strutture meccanismi come quella che abbiamo visto nel DESS che sia un'implementazione al lato software o che sia un'implementazione al lato hardware deve comunque stare molto attento a evitare tutte quelle politiche che tipicamente un programmatore adotta per migliorare il proprio codice ad esempio le politiche di ottimizzazione e voi siete abituati che quando scrivete un programma cercate di ottimizzarlo al massimo quindi spremere tutte le risorse che avete a disposizione ridurre il più possibili tempi di esecuzione ok ma le ottimizzazioni creano disparità di solito ogni volta che apportate un miglioramento un'ottimizzazione dal vostro software magari migliora le performance in certi casi mantenendoli inalterati in altri ok e magari questo vi va bene perché vi interessa che il vostro software sia veloce nei casi più comuni magari se è più lento nei casi più rari che se ne frega nell'ambito della criptografia questo deve evitare nell'ambito della criptografia le ottimizzazioni no anzi nell'ambito della criptografia bisogna cercare di livellare sempre tutto alle stesse performance è chiaro che l'efficienza è importante l'abbiamo visto prima uno dei motivi per cui 3DS è stato messo da parte è perché era inefficiente e quindi si è ricominciato da capo fino ad arrivare a produrre AS però una volta che avete una soluzione che funziona è pericoloso ottimizzarla proprio per questo motivo qua perché le ottimizzazioni potrebbero creare dare origine a delle vulnerabilità legate ai side channel attacks poi abbiamo i font injection attacks che sono come idea simili ai side channel perché anche anche in questo caso non osservo direttamente il comportamento dell'algoritmo ma gli effetti che ne produce l'esecuzione ok i fault injection attacks sono però più sofisticati perché in questo tipo di attacchi si cerca di forzare un malfunzionamento ok nell'esecuzione dell'algoritmo quindi che ne so se si cerca di forzare un segmentation fault o si si introducono appositamente degli errori durante durante l'esecuzione dell'algoritmo e questo perché si fa questo per vedere se forzando determinati errori si arriva ad una situazione che possa in qualche modo fornire delle informazioni significative all'attaccante ad esempio che ne so si potrebbero individuare dei valori spuri in memoria a seguito di un segmentation fault che potrebbero rivelare delle informazioni interessanti sulla natura del plain text o del ciphertext che si stava generando ma che non era ancora completo o della chiare stessa quindi anche in questo caso l'obiettivo è quello di provare a dedurre qualche informazione significativa chiaramente per realizzare attacchi tipo side channel o fault injection bisogna avere a disposizione l'attrezzatura per intanto bisogna avere a disposizione l'implementazione fisica del cifrario poi bisogna avere a disposizione anche dell'attrezzatura significativa per fare le misurazioni per forzare gli errori anche a livello fisico forzare un errore a livello fisico potrebbe significare che ne so compromettere una parte del circuito durante l'esecuzione dei round e vedere che cosa succede vedere se magari da qualche parte si trovano delle informazioni temporanee dei dati temporanei nei registri piuttosto che nella cache o da qualche altra parte che leggendole possa in qualche modo fornire informazioni significative quindi sono attacchi piuttosto complessi da condurre vediamo se finire questa parte qui qui vi faccio vedere in questa slide vi faccio vedere che cosa significa da un punto di vista statistico individuare vulnerabilità facendo criptanalisi allora prima vi ho detto che intuitivamente fare criptanalisi algoritmica significa cercare se ci sono dei legami tra plaintext chiave e sefertext legami di che tipo come dicevo prima ad esempio capire che una certa porzione del plaintext ha un legame con una specifica porzione della chiave o e con una specifica posizione del sefertext ok questa è idea chi fa analisi statistica va a fare calcoli di questo genere come quelli che vediamo qua qui in particolare si va a definire sotto quali condizioni legami di questo genere non si trovano quali sono queste condizioni beh intanto qui vengono definite quelle che sono delle maschere queste sono non sono altro che delle maschere che individuano delle porzioni di di plaintext piuttosto che di chiave piuttosto che di di sci-fi text ad esempio adesso commentiamo un po' alla volta questa equazione che vediamo qua giù questo m di s 0 che cos'è non è altro che una porzione del plaintext estratta proiettata dal plaintext applicando la maschera s 0 s 0 è una maschera che dice guarda prendi che ne so il primo il terzo il quinto bit questa è una maschera ok quindi s 0 è una maschera qualunque applicata al plaintext per estrarre alcune parti del plaintext lo stesso discorso si fa sulla chiave si usa un'altra maschera per estrarre una porzione della chiave ma la stessa cosa si fa sul ciphertext ok quindi questi tre ingredienti che vedete qui sono tre diverse porzioni di plaintext ciphertext e chiave ok come faccio a capire se tra queste tre porzioni c'è un legame cioè i valori dell'uno influenzano i valori dell'altro allora mi serve un'operazione per combinare queste diverse porzioni è l'operazione che si usa all'oxone ok quindi andiamo a vedere questa equazione qua quest'uguaglianza che cosa mi dice mi dice che una certa porzione del plaintext la combino in XOR con una certa porzione del ciphertext e il risultato è una certa porzione della chiave ok adesso semplifichiamo consideriamo porzioni di un bit così semplifichiamo un po' le cose ok quindi se assumiamo finestre di un solo bit qui stiamo dicendo che un certo bit del plaintext in XOR con un certo bit del ciphertext gli dà un certo bit della chiave ok qual è la probabilità di questa equaglianza secondo voi quale dovrebbe essere la probabilità di questa equaglianza qual è secondo voi la probabilità faccio un caso specifico quale dovrebbe essere secondo voi la probabilità che il primo bit del plaintext in XOR col primo bit del ciphertext vi dia come risultato il primo bit della chiave 50% perché perché se il ciphertext è random come dovrebbe essere ok quindi indistinguibile nella stringa pseudo casuale che un bit del plaintext in XOR con un bit del ciphertext vi dia un bit della chiave specifico dovrebbe essere il 50% ok se questa probabilità invece che il 50% fosse il 100% voi sapete con certezza che esempio il primo bit del plaintext combinato col primo bit del ciphertext vi dice qual è un certo bit della chiave se voi avete questa informazione qui conoscendo il ciphertext ottenete molte informazioni su quella che può essere la chiave su quello che può essere il plaintext ok quindi avere delle informazioni su questo tipo di dipendenze di questo tipo di relazioni vi dà delle informazioni che di fatto vanno a violare la sicurezza semantica allora questa definizione qua che cosa vi va a dire vi va a dire che qualunque sia il plaintext qualunque sia la chiave qualunque siano le porzioni che voi prendete da plaintext chiave e ciphertext corrispondente in ogni caso in ogni caso ciò che vi aspettate è che la probabilità che ci sia quella corrispondenza di cui parlavamo tra plaintext chiave e ciphertext dovrebbe essere all'incirca all'incirca un mezzo 50% perché è esattamente il valore che in un mondo puramente casuale mi aspetto ok nella pratica non sarà mai pari al 50% così come nel gioco della sicurezza semantica non non perteniamo mai la sicurezza perfetta ma tolleriamo delle proprietà negligible ok e qui succede la stessa cosa questo epsilon qui è una quantità negligible che noi possiamo trascurare siamo disposti a trascurare quindi ci sta che la probabilità di quella di quell'uguaglianza sia diversa da un mezzo ma non deve essere tanto lontana da un mezzo ok deve essere in un certo intorno trascurabile di di un mezzo ok è chiaro che se le cose non stanno così ovvero se la probabilità di questa uguaglianza è maggiore rispetto alla soglia trascurabile che ci siamo posti vuol dire che tra plaintext chiaro e ciphertext c'è un legame no c'è una dipendenza che viene chiamata in gergo in questo caso relazione lineare lineare perché l'equazione è lineare non è un polinomio di grado 1 ok e quindi il compito di chi fa critanalisi è individuare relazioni lineari eventuali relazioni lineari tra certi plaintext certi chiavi e certi ciphertext ok perché se le trovo allora trovo quel famoso legame che mi spessa la condizione della sicurezza semantica è chiaro che per individuare dei controesempi cioè per individuare delle relazioni lineari io quanti plaintext devo esaminare quante chiavi devo esaminare più possibile sperando che ci sia da qualche parte una relazione lineare è chiaro che se non c'è posso star lì secoli non la trovo ma se c'è esaminando la maggiore quantità possibile di plaintext e di chiavi prima o poi la trovo questo è quello che fanno i critanalisti quindi fanno analisi statistica sulle triple plaintext chiave ciphertext per cercare di individuare delle relazioni lineari come definite in questa maniera qua che servirebbero appunto per rompere la robustezza del del cifrario quindi quando sentite parlare leggete di attacchi di critanalisi lineare vuol dire che qualcuno ha trovato una relazione di questo genere qua rispetto a un certo surface poi esistono evoluzioni quindi esistono tecniche di critanalisi ancora più sofisticata non lineari quindi di grado maggiore ok DES è vulnerabile ad alcuni attacchi di critanalisi lineare ci sono delle relazioni lineare ve lo dico così a scopo statistico le relazioni lineari che sono state trovate indes dipendono da che cosa dipendono da questo sbox qua ok perché ora il compito degli sbox è quello di mescolare le carte in maniera apparentemente impredicibile che ha fatto che l'analisi lineare ha scoperto che s5 ha un comportamento che non è poi tanto impredicibile ma che è approssimabile da una funzione lineare cioè esiste una funzione lineare matematica che prende in input i possibili 6 bit di s5 e vi approssima il risultato dei 4 bit in uscita questo è sufficiente per individuare una relazione lineare tra input output e chiave però si tratta comunque di attacchi che per essere implementati costano comunque di più in termini di tempo rispetto al brute force attack e questo è significativo AES non presenta tuttora vulnerabilità di questo tipo qua non sono note relazioni lineari per AES a livello grittico non sono state ancora trovate a sto punto si pensa che non ce ne siano perché AS comincia ad essere vecchiotto come cifrari e basta poi adesso il resto sono cose che vi ho già detto quindi sui side channel vi ho già detto che si va a misurare il tempo di esecuzione si fanno anche misurazioni un po' più sofisticate come ad esempio i tempi di accesso alla memoria a seconda che siano accessi alla memoria centrale piuttosto che alla cache perché in quel caso si riescono a trovare delle relazioni di natura temporale tra la natura del plaintex alle chiavi e i tempi di esecuzione alcune implementazioni di AES che chiaramente sono state ritirate soffrivano di questo tipo di side channel quindi andando a effettuare le misurazioni e lo stesso vale per l'analisi del consumo di potenza anche in questo caso esistono implementazioni di AES vulnerabili rispetto a side channel di questo genere chiaramente ogni qualvolta si è trovato un attacco di questo genere attacco di questo genere non significano che è sbagliato l'algoritmo di ciclatura significa che l'errore sta nella implementazione materiale quindi o nel software o nell'hardware quindi basta cambiare quella senza toccare nulla dell'algoritmo e il problema è risolto ed è sempre quello che è successo ad esempio negli anni con AES questo ci permette di concludere che cosa intanto di usare solo ed esclusivamente algoritmi che sono standard ufficiali ok quindi andando naturalmente a verificare che lo standard che state usando non sia troppo vecchio e non sia deprecato anche adesso era uno standard non lo è più ok quindi prima cosa usare solo ed esclusivamente cifrari standard ok seconda cosa anche se scegliete di adottare un cifrario standard non lo dovete implementare voi perché implementarlo significa quasi sicuramente esporlo ad attacchi di tipo side channel come quelli che abbiamo citato primo quasi sicuramente ok quindi non vi dovete accontentare di adottare uno standard ma dovete anche utilizzare implementazioni fornite da librerie established in letteratura quindi ampiamente utilizzate in letteratura se lo sono vuol dire che sono state esaminate analizzate lungo e largo rispetto a tutte le possibili vulnerabilità e quindi in teoria non dovrebbero essere vulnerabili a attacchi tipo side channel come quelli che abbiamo visto prima ok quindi algoritmi standard e implementazioni fornite da librerie standard non uscire da queste da queste due regole va bene ci fermiamo qui e ci rivediamo nel pomeriggio il per l'ho situat nonooibilities ma che anche proIL Grazie a tutti.