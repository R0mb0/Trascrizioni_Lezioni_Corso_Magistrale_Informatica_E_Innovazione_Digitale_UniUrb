Grazie a tutti. Una cosa che volevo ricordare e che ci servirà oggi per confrontarci con l'argomento che vedremo tra poco è che in generale la funzione di cifratura di un bloc cipher è di fatto una funzione di permutazione. Quindi una funzione che prende elementi di un dominio che è l'insieme dei blocchi di una certa dimensione e restituisce come elemento un blocco appartenente allo stesso insieme. La funzione, essendo una permutazione, sarà sia iniettiva che soggettiva, quindi è una biestione, una funzione obiettiva. Ogni blocco viene mappato in un altro. Chiaramente questo mapping dipende dalla chiave. Perché ricordare questo? Perché adesso vedremo come generalizzare questa assunzione assumendo di poter lavorare con funzioni qualsiasi, quindi non solo con permutazione. In particolare con funzioni che possono avere dominio e codominio correlati tra di loro. Ok? Ok? Questa è l'idea che vedremo adesso e che si basa su un concetto appunto di funzione generica che prende il nome di funzione pseudorandom. L'acronimo è PRF. Ok? Cosa sono le funzioni pseudorandom? Sono funzioni che sulla base di una determinata chiave, esattamente come abbiamo visto ieri per il block cipher, mappano blocchi di un certo dominio, il dominio lo chiamiamo X, in blocchi di un dominio non necessariamente uguale a X. Ok? Quindi vedete, abbiamo preso la definizione di funzione di cifratura dei block cipher e l'abbiamo generalizzata abbandonando le condizioni che abbiamo visto ieri, ovvero il fatto di essere obiettivi, ovvero il fatto di essere obiettiva e il fatto di lavorare su dominio e codominio uguali da di loro. Ok? Perché questo tipo di generalizzazione? Beh, perché l'insieme di tutte le funzioni che vanno da un dominio X a un dominio Y ha una cardinalità molto molto grande, che è appare questa quantità qua. Ok? Quindi, indovinare quale funzione viene utilizzata per realizzare questo mapping, chiaramente è un problema la cui probabilità di successo è trascurabile. Ok? Questo è il motivo fondamentale. Ora, ci si può chiedere se, come trasporre nell'ambito delle funzioni pseudo-random, le nozioni di sicurezza che abbiamo visto ieri nel caso delle funzioni di permutazione che stanno alla base dei block cipher. Naturalmente questo si può fare a partire da quello che è l'attack game, che ci permette di stabilire sotto quali condizioni un PRF, una funzione pseudo-random, è sicura. Ok? Poi vedremo che le funzioni di cifratura dei block cipher sono in caso particolare. Un PRF. La tag game è esattamente, direi, identica a quello che abbiamo visto ieri per i block cipher. L'unica differenza appunto sta nel fatto che la funzione che il challenger sceglie nell'esperimento zero è un PRF, non è un block cipher. Questa è l'unica differenza. Quindi una funzione generica che sulla base di una certa chiave, scelta randomicamente, mappa blocchi del dominio in blocchi del codominio. Per il resto la struttura dell'attack game è identica, quella che abbiamo visto ieri, così come identico il comportamento dell'avversario, che sceglie una sequenza adattiva di blocchi, se li fa cifrare dal challenger, o perlomeno il challenger li cifra se siamo nell'esperimento zero. Il challenger applica una scelta randomica, se invece siamo nell'esperimento uno. Al solito l'obiettivo del challenger, dell'avversario, è quello di stabilire se ci troviamo nell'esperimento zero o nell'esperimento uno. e il suo vantaggio è la solita differenza tra le probabilità di quei due eventi che rappresentano appunto la probabilità che l'avversario restituisca un certo risultato quando è in uno o nell'altro esperimento. La nozione di sicurezza è quella solita. Un PRF è sicuro se il vantaggio dell'avversario è trascurabile per tutti gli avversari efficienti. Quindi, ripeto, rispetto a quanto abbiamo visto ieri, non abbiamo cambiato nulla nella definizione di sicurezza, abbiamo semplicemente ampliato la gamma di funzioni che si possono prendere in considerazione per fare la cifratura. I blocciper si basano su permutazioni, i PRF si basano su funzioni generiche, le più generali possibili, perché vedete non c'è nessuna condizione nella definizione di PRF su quelle che sono le proprietà della funzione stessa. Ok? Ora, vista l'analogia tra BlockCypher e PRF, viene naturale chiedersi qual è il legame tra queste diverse tipologie di funzioni di cifratura e le relative nozioni di sicurezza. Ok? In altre parole, visto che le funzioni che si usano per i BlockCypher sono un sotto insieme di quelle che si usano per i PRF, la prima cosa che ci si può chiedere è se un BlockCypher sicuro è anche un PRF sicuro. Intuitivamente non sarebbe portato a pensare che la risposta è sì. Un BlockCypher sicuro è anche un PRF sicuro. In realtà non è così. In realtà non è così o perlomeno non lo è in generale. Perché non lo è in generale? Perché assumete che la cardinalità assumiamo che la cardinalità del poi mi encanta sulla pelle assumete che la cardinalità del dominio sia piccola. Piccola cosa vuol dire? Posso elencare in tempo polinomale tutti i suoi elementi. Ok? Quindi non è super poli. Ora, qual è la probabilità per l'avversario di osservare due ciphertext identici nei due attack game che abbiamo visto. Quello di ieri e quello di oggi. Se siamo nell'esperimento 0 o se siamo nell'esperimento 1. partiamo dall'ultimo attack game che abbiamo visto che è quello di oggi. Ok? Se siamo nell'esperimento 1 la funzione è casuale tra tutte le possibili funzioni che vanno da x a y. Tutte. Qualunque genere di funzione. Quindi anche quelle che mappano due blocchi nello stesso output. no? Cioè, fra tutte le possibili funzioni ci può essere anche quella tale per cui f di x è uguale a f di x primo. Ok? Su f non ci sono soluzioni. Torniamo alla tag game di ieri. Nella tag game di ieri la condizione è la stessa però f non è qualsiasi. F è una funzione di permutazione. perché i block cipher usano funzioni di permutazione. Ora, qual è la probabilità che due blocchi vengano mappati nello stesso output? Se f è una funzione di permutazione. È vero. Per definizione di funzione di permutazione non ci possono essere due blocchi che vengono mappati nello stesso output. altrimenti non sarebbe una permutazione. Chiaramente. Ok? Quindi se noi applichiamo questo tag game quello che abbiamo visto oggi nel caso dei block cipher noi sappiamo che in questo esperimento blocchi mappati nello stesso output non li possiamo avere. Perché? Perché in questo esperimento noi usiamo la funzione di cifratura e se per funzione di cifratura ho usato un block cipher un block cipher è un permutatore quindi blocchi diversi mappati nello stesso output non li avrete mai. La probabilità è zero. Ok? invece se siamo in questo esperimento la probabilità è diversa di zero perché il secondo esperimento sceglie qualunque genere di funzione randomica e quindi posso avere anche situazioni di questo genere qua. Ok? Quindi se voi applicate questo tag game laddove in questo esperimento usate un block cipher allora vuol dire che in questo esperimento non potrete mai vedere due blocchi mappati nello stesso valore perché state usando un block cipher. In questo esperimento siccome state usando una funzione generica potete vedere due blocchi mappati nello stesso output. Ok? Quindi qui la probabilità è zero dell'evento che abbiamo appena detto qui è diversa da zero. Quanto diversa da zero? Qui vale la soluzione che abbiamo detto prima. Se il dominio dei blocchi non è super poli ok? Questa probabilità qui non è negligible. E quella è esattamente la probabilità che voi avete che l'avversario ha di scegliere nella sua sequenza due blocchi che la funzione mapperà nello stesso output. Ok? Ma se questa quantità qui non è trascurabile proprio perché la cardinalità di x non è super poli allora vuol dire che i due diversi esperimenti sono associati a eventi la cui differenza di probabilità è osservabile non è trascurabile perché in un caso è zero nell'altra è uno fatto dalla cardinalità di x uno fatto dalla cardinalità di x non è trascurabile e quindi la differenza tra i due esperimenti non è trascurabile. Questo è il motivo per cui in questo attack game qui quello per i PRF che si usa per i PRF dove ripeto si fa questa soluzione qui nell'esperimento 1 i block cipher non sono sicuri come PRF ok a meno che il dominio dei blocchi non sia super poli perché è chiaro che se il dominio dei blocchi è super poli allora vuol dire che questa quantità qui è negligible e quindi di nuovo i due esperimenti tornano ad essere indistinguibili dal punto di vista dell'avversario. Infatti c'è un teorema che dice questa cosa qua se voi prendete un block cipher ok e un block cipher lo possiamo vedere come un caso particolare di PRF ok quindi se prendete un block cipher lo interpretate come un PRF e assumete che il dominio dei blocchi sia super poli allora quel block cipher sarà sicuro se solo se è un PRF sicuro perché tutto questo discorso beh prima abbiamo detto che introdurre i PRF generalizzando le funzioni che possiamo usare aumenta la sequenza perché aumenta il numero di funzioni che possiamo prendere in considerazione per la cifratura ok quindi lavorare con i PRF intuitivamente è meglio no ieri però abbiamo parlato dei block cipher sono quelli che sono implementati e usano meno funzioni usano le permutazioni e quindi allora ci si chiede va bene ma usare i block cipher invece dei PRF è limitante dal punto di vista della sicurezza oppure no o dobbiamo buttarli via e sostituirli con l'implementazione di PRF che però sono più inefficienti allora la risposta sotto certe condizioni abbiamo visto adesso che è no ovvero se voi prendete un block cipher sicuro e lo fate lavorare su un dominio di blocchi super poli ecco che quel block cipher contemporaneamente è anche un PRF sicuro quindi siamo ulteriormente più robusti ieri se vi ricordate avevamo visto che un block cipher per essere sicuro deve lavorare su un dominio delle chiavi super poli perché se no l'attacco a forza brutta in tempo polinomiale ha una probabilità non trascurabile di dominarla la chiave e rompere il block cipher quindi ieri la prima considerazione che abbiamo visto è un block cipher è sicuro bene il dominio delle chiavi deve essere super poli oggi abbiamo visto che se anche il dominio dei blocchi su cui lavora il block cipher è anche lui super poli non solo il block cipher è sicuro in quanto block cipher ma è sicuro anche se lo interpretiamo come PRF quindi di fatto limitarci ai block cipher cioè a funzioni di cifratura che sono permutazioni non è limitante dal punto di vista della sicurezza rispetto invece a considerare funzioni di cifratura basate su funzioni matematiche qualunque non solo le permutazioni questa è un po' è la morale di questo discorso che ripeto ha una praticità perché perché implementare il block cipher l'abbiamo visto ieri è efficiente le performance sono buone e quindi sotto le condizioni che abbiamo appena visto abbiamo anche la garanzia di robustezza e quindi non non serve di fatto andare a realizzare funzioni di cifratura più complesse basate su funzioni diverse rispetto alle permutazioni e quindi PRF generici proprio perché come abbiamo appena visto non non perdiamo nulla in termini di sicurezza limitarsi alle funzioni di permutazione non ci fa perdere nulla in termini di sicurezza ok ripeto purché il dominio del block cipher sia un insieme super poli ad esempio se lavoriamo con blocchi di 128 bit il numero di blocchi possibile è 2 alla 128 e questo è un numero molto molto molto grande e quindi un block cipher che lavora su blocchi di 128 bit è non solo un block cipher sicuro ma se le chiavi sono sufficientemente lunghe ma è anche un PRF sicuro ok questo un po' è il senso del discorso il PRF le funzioni pseudo random da un punto di vista teorico sono molto interessanti perché ci sono dei risultati che stabiliscono dei ponti tra il PRF e altre primitive criptografiche ok quindi ripeto d'ora in avanti noi dobbiamo vedere il block cipher come l'abbiamo introdotto ieri come una implementazione specifica dei PRF ok che sotto certe condizioni sono tanto sicuri quanto i PRF quindi laddove noi dimostriamo dei risultati teorici per i PRF a livello implementativo possiamo usare i block cipher per implementare queste soluzioni ok un risultato ponte interessante che vi faccio vedere è quello che mette in relazione PRF con PRG quindi le funzioni pseudo random con i generatori pseudo random che stanno alla base degli string cipher ok e il risultato ponte dice che se voi partite da un PRF sicuro sicuro rispetto all'hatta game che abbiamo visto prima allora usando quel PRF potete costruire un PRG il quale a sua volta sarà sicuro sicuro rispetto all'hatta game per i PRG che abbiamo visto settimana scorsa quindi in altre parole da un PRF sicuro voi potete costruire un PRG sicuro ok e questa costruzione è la più semplice costruzione che soddisfatteremo che abbiamo appena detto ci dice appunto come passare da un PRF a un PRG questo è interessante questo lo ribaderemo tra poco per quale motivo perché sfruttando questo teorema cosa possiamo fare possiamo prendere un block cipher sicuro che lavora su domini di blocchi super poli sotto questa condizione un block cipher sicuro è anche un PRF sicuro abbiamo appena detto prima ma se è un PRF sicuro lo possiamo usare con questa costruzione qui per realizzare un PRG sicuro ma una volta che abbiamo un PRG sicuro che cosa abbiamo abbiamo uno stream cipher sicuro quindi questa catena di passaggi di risultati ci permette di dire bene io posso prendere che ne so AS AS128 che è un block cipher sicuro lavora su blocchi di 128 bit quindi il dominio dei blocchi è super poli quindi AS128 lo possiamo vedere come un PRF sicuro ma se è un PRF sicuro usando la costruzione che adesso andiamo a commentare possiamo usare AS128 per costruire un PRG e il PRG che avremo costruito sarà sicuro e quindi sulla base di quel PRG sicuro potremo avere uno stream cipher sicuro ok come fatta la costruzione è molto semplice voi prendete appunto qualunque PRF da questo dominio a questo codominio non dovete fare altro che generare randomicamente o deterministicamente non ha nessuna importanza l'unica cosa che dovete fare appunto è generare una sequenza di blocchi da dare in input al PRF ripeto la scelta di questi blocchi non necessariamente deve essere randomica può essere anche deterministica nota a tutti non ha nessuna importanza ok ciò che conta è che la chiave del PRF deve essere segreta no e poi che cosa fate beh semplicemente applicate il PRF con la sua chiave a ciascuno di questi blocchi e poi concatenate i risultati no vedete apri quel PRF con la mia chiave al primo blocco al secondo fino all'ennesimo concateno tutti i risultati e ciò che ottenete è una stringa ed è esattamente la stringa del nostro PRG quindi il nostro PRG è di fatto una funzione che data la chiave applica usando quella chiave il nostro PRF ad una sequenza di blocchi e concatena i risultati ok qui nell'esempio suggerisce un modo semplice per scegliere i blocchi x1 x2 xl ok ogni blocco può essere banalmente la codifica binaria dell'intero che parametriza il pedici quindi il blocco x1 può essere semplicemente una sequenza di zeri con un 1 in fondo a destra e blocco x2 può essere semplicemente una sequenza di zeri con un 1 in penultima posizione e uno 0 in penultima posizione quindi la codifica binaria del del pedici ok quindi ripeto non non ci deve essere un criterio di confidenzialità nella scelta di questi blocchi l'unico segreto è la chiave ok e questa costruzione banalissima perché semplicemente per costruire un PRG non fa altro che applicare un certo numero di volte un PRF su input diversi questo è è una costruzione sicura quindi vale quel teorema che dicevamo prima se per questa costruzione usate un PRFF sicuro allora il PRG G definito in questa maniera qua a sua volta è sicuro questo risultato nella pratica si utilizza si utilizza sfruttando quella catena di passaggi che dicevamo prima e che in letteratura prende un nome ben preciso che è appunto il deterministic counter mod in cosa consiste il deterministic counter mod consiste proprio nello sfruttare il risultato che abbiamo appena visto per costruire uno stress cipher sicuro a partire da un block cipher sicuro non dobbiamo fare altro che concatenare i risultati sui PRF che abbiamo appena descritto ok e com'è la concatenazione? esattamente quella che dicevamo prima voi prendete un block cipher ok un block cipher sicuro sicuro rispetto alla tagging che abbiamo visto ieri no? e ad esempio è presto fatto no? prendete che ne so AS 128 ok l'altra condizione che dovete rispettare è che la cardinalità del numero dei blocchi dell'insieme dei blocchi su cui lavora il block cipher deve essere super poli e questa è una caratteristica che è AS128A l'abbiamo visto ieri quindi AS128 è un block cipher sicuro con dominio super poli quindi c'è il teorema che abbiamo visto prima che dice che AS128 avendo queste caratteristiche è un PRF sicuro no? perché un block cipher sicuro che lavora su un insieme di blocchi super poli è un PRF sicuro ok? e questo già lo sappiamo è il primo risultato che abbiamo visto oggi poi c'è l'altro teorema quello della slide precedente che dice che da un PRF sicuro nel modo che abbiamo visto prima voi potete costruire un PRG sicuro la procedura l'abbiamo appena vista voi scegliete una sequenza di blocchi prendete il PRF e lo applicate ai blocchi nel caso concreto è come dire fissate una chiave segreta io non devo fare altro che scegliere una sequenza di blocchi che possono essere quelli che dicevamo prima la codifica binaria degli interi da 1 a n se ho bisogno di n blocchi ok? e ciascuno di questi blocchi lo vado a cifrare con AS128 usando la mia chiave segreta il risultato di queste cifrature io li vado a concatenare quindi prendo la cifratura del primo blocco lo cancateniamo con la cifratura del secondo blocco del terzo e così via il risultato è una stringa pseudo random che è l'output del nostro PRG ok? il PRG che ottengo è sicuro quindi quella stringa che ho ottenuto è pseudo pseudo random distinguibile da una totalmente random e di conseguenza la posso usare per uno string cipher sicuro l'ultimo passaggio no? usando il PRG costruito in questa maniera ottengo uno string cipher semanticamente sicuro quindi morale della favola voi potete usare un bloc cipher come AS128 per realizzare un cifrario a flusso semanticamente sicuro ok? quindi ripeto scegliete una lista di blocchi in maniera deterministica ciascuno di questi ricifrate con AS128 usando la chiave segreta concatenate tutti questi cipher che avete ottenuto il risultato sarà una string pseudo random questa andrà in XOR con il plaintext che volete cifrare perché usate la definizione degli string cipher ok? questa modalità di cifratura ripeto prende il nome di deterministic counter mode ed è semanticamente sicuro sotto le condizioni che abbiamo appena visto senza ulteriori restrizioni quindi molto meglio ad esempio dell'ECB mode che avevamo visto ieri che è un modo nativo e brutale di usare un bloc cipher per fare cifratura no? l'ECB mode che abbiamo visto ieri dice semplicemente hai un plaintext da cifrare? bene prendi il plaintext lo spezzi in tanti blocchi e ciascun blocco lo cifri ad esempio con AS128 va bene questo? no non va bene perché il problema è lo stesso di cifrare per sostituzione se mi ritrovo due blocchi uguali nel plaintext mi ritroverò due blocchi uguali anche nel ciphertext e non va bene quindi morale della favola non potete usare un bloc cipher sicuro come AS128 per cifrare brutalmente il plaintext così com'è perché? perché la modalità ECB vista ieri non è sicura in presenza di blocchi ripetuti ok? mentre invece un modo corretto per usare un bloc cipher e fare cifratura è il deterministic counter mode che abbiamo appena visto in cui qual è la differenza? nelle ECB che abbiamo visto ieri usate direttamente il AS per cifrare il plaintext invece nel deterministic counter mode c'è un passaggio in più il block cipher AS non lo usate per cifrare direttamente il plaintext lo usate per cifrare una sequenza di blocchi nota a priori la cifratura che ottenete la usate come string pseudorandom che andrà in XOR con il plaintext e il risultato finale sarà il vostro ciphertext ok? nei protocolli crottografici ci sono diverse implementazioni di AS in deterministic counter mode ok? poi ci sono altri risultati ponte che non vi racconterò nel dettaglio vi cito solamente che esistono sono meno interessanti il più interessante è quello che va dai blocks alf alprf alprf perché ha una rilevanza pratica dal punto di vista teorico ci sono altri risultati che ad esempio ci dicono che se avete un prf sicuro da quello potete tirare fuori un block cipher sicuro cioè risultato contrario rispetto a quello che abbiamo appena visto ok? ha meno rilevanza pratica perché nella pratica i prf generici non si realizzano mai quindi non ha senso partire da un prf che è un qualcosa di complesso per tirare fuori un block cipher ne abbiamo già i block cipher sicuri efficienti però teoricamente parlando è interessante sapere che partendo da un prf sicuro potete realizzare un block cipher sicuro chiusa la parentesi non aggiungo altro così come è possibile l'altro passaggio inverso ovvero prendere un prg sicuro e trasformarlo in un prf sicuro anche questo si può fare anche questo ha meno rilevanza pratica diciamo che a livello pratico il passaggio più interessante è quello dei block cipher agli stream cipher piuttosto che il contrario però sappiate che si può fare anche il passaggio inverso avete un prg sicuro lo potete usare per costruire un prf sicuro ok questo chiude il discorso relativo al iblock cipher e come è corretto usarli per fare cifratura di messaggi ok sempre sotto la solita assunzione la chiave segreta che utilizza per fare cifratura la uso una volta sola per cifrare un solo messaggio siamo sempre sotto quell'ipotesi lì perché poi dovremmo complicare un po' le cose nel momento in cui vogliamo usare la stessa chiave per cifrare più plaintext ci siamo ok bene prima di chiudere il capitolo block cipher al solito volevo farvi un esempio pratico di protocollo che in questo caso particolare fa uso di un prf sicuro per risolvere un problema no e quando parliamo di prf sicuro sappiamo già come realizzarlo no basta prendere ripeto per l'ennesima volta basta prendere un qualunque block cipher sicuro che lavora su un dominio superpolico ok come AS128 e qual è il problema che vi propongo oggi è in realtà sono due uno è il problema ma è l'altro una sua derivazione una sua applicazione il problema di base molto comune è quello di far condividere a due agenti una sequenza lunga piacere di dati confidenziali a partire dal fatto che i due inizialmente condividono un solo segreto sotto forma di una chiave detta più più più semplicemente se Alice e Bob condividono una chiave come faccio a far condividere loro un numero a piacere di chiavi questo è il problema e la soluzione estremamente banale consiste ad usare un PRF in maniera analoga a come abbiamo visto nella costruzione di prima che lega i PRF e i PRG ovvero ogni volta che Alice e Bob hanno bisogno di condividere una chiave nuova segreta cosa fanno? si mettono d'accordo su un indice i e calcolano il PRF di i usando la chiave k condivisa tra voi quindi partiamo dall'ipotesi iniziale Alice e Bob condividono k ok e di fatto non la usano come chiave per la cifratura dei messaggi ma ne vogliono usare una diversa da k ogni volta che hanno bisogno di dialogare ok e quindi che cosa fanno? beh a partire da k usano un PRF per calcolare nuove chiavi i può essere benissimo l'input del PRF quell'indice i può essere benissimo un contatore che conta quante volte i due hanno bisogno di condividere una chiave quindi la prima volta che i due hanno bisogno di condividere una chiave diversa da k che cosa fanno? calcolano entrambi f di k1 la seconda volta calcoleranno f di k2 poi f di k3 e così via cioè ogni volta applicano il PRF usando la chiave segreta a un input diverso basta che si mettano d'accordo sull'input e se usiamo un contatore allora la cosa diventa sistematica per entrambi ok se il PRF che i due usano è sicuro rispetto alla tag game che abbiamo visto prima noi sappiamo che cosa che l'output di un PRF è indistinguibile rispetto ad una stringa random quindi mettete nei panni di un avversario chiaramente non conosce k magari sa che Alice e Bob usano i come input però non conoscendo k anche se l'avversario conosce l'indice che rappresenta l'input per il PRF non ha un'idea di quale possa essere l'output che il PRF spara quando usa la chiave k sull'input i tutti tutti gli output sono i più probabili dal punto di vista dell'avversario questo cosa significa significa che l'avversario non ha un'idea di quanto valga questo valore qua se conosce solo i k lo conoscono solo Alice e Bob ok e quindi cosa vuol dire vuol dire che l'output del PRF può essere usato da Alice e Bob come una chiave segreta ok nella pratica usiamo un block cipher sicuro che lavora su due mini super poli come AS128 AS1296 perché possiamo sfruttare quel risultato che ci dice quando è che un block cipher sicuro è anche un PRF sicuro ok l'applicazione di questo problema che vi faccio vedere un esempio anche questo abbastanza tipico che è il confronto di informazioni private informazioni confidenziali Alice conosce un valore segreto A privato Eden Bob conosce un'informazione privata B Alice e Bob vogliono sapere se A e B sono uguali ok se non lo sono nessuno dei due vuole svelare all'altro il proprio valore Alice e Bob devono imparare se condividono lo stesso valore se i due valori sono diversi a dice Bob non devono imparare nulla sul valore dell'altro ok faccio un esempio pratico di cosa potrebbero essere A e B immaginate che A e B rappresentino la posizione geografica di Alice e di Bob ok A rappresenta le coordinate di dove si trova Alice B rappresenta le coordinate dove si trova Bob Alice e Bob vogliono sapere se si trovano nello stesso posto ok quindi vogliono sapere se A e B ad esempio perché se sanno di sapere nello stesso posto magari si mettono d'accordo per incontrarsi ok però se sono imposti diversi nessuno dei due vuole che l'altro sappia dove si trova perché ci tengono la privacy quindi l'unica cosa che vogliono sapere è se A è uguale a B e non sono interessati a svelare altro è chiaro il problema con questo esempio bene usando di PRF possiamo immaginiamo che questo questo problema lo vogliamo risolvere tante volte non una volta sola che magari una volta alla settimana Alice e Bob vogliono risolvere questo problema un modo per farlo che adesso vi racconterò fa uso di chiavi una chiave diversa ogni volta che il problema si ripropone e per avere tante chiavi a disposizione Alice e Bob usano la soluzione che abbiamo appena visto cioè partiamo dall'ipotesi iniziale che Alice e Bob condividono una chiave K ok usando quella chiave K e usando un PRF sicuro generano una chiave diversa ogni volta che eseguono questo protocollo ok e all'interno di ogni sessione del protocollo useranno una chiave nuova che garantirà come vedremo tra poco la la soluzione sicura del problema ok andiamo a vedere come quindi partiamo dal presupposto come dicevo prima che Alice e Bob condividono a priori un segreto una chiave K ogni volta che vogliono eseguire un'istanza del protocollo usano un PRF sicuro per creare quella che possiamo chiamare chiave di sessione no cioè una chiave usata nella sessione corrente dopodiché si butta via ok questa è l'ipotesi no immaginiamo che la la chiave di sessione che è stata generata invocando il PRF su un certo input a partire dalla chiave segreta la la spezziamo a metà la dividiamo in due parti ok le due parti le chiamiamo K0 e K1 ok ora andiamo a vedere come funziona il nostro protocollo allora dalla parte abbiamo Alice che conosce l'informazione A dall'altra abbiamo Bob che conosce l'informazione B adesso assumeremo che A e B sono due interi per semplicità ok e che tutti i calcoli che vedete in questo protocollo si sono eseguiti in aritmetica modulare ok quindi tutte le addizioni le sottrazioni che vedete qua si calcolano modulo P dove P è un numero molto grande ok ora per poter eseguire questo protocollo abbiamo bisogno di un abbiamo bisogno di un terzo agente di cui sia Alice che Bob si fidano quindi quello che in gergo viene chiamato trusted third party ok bene come funziona il protocollo allora andiamo a vedere è asimmetrico il protocollo Alice e Bob fanno cose diverse come vedremo durante la sua esecuzione comincia Alice comincia Alice che calcola questa somma e e la manda al TTP al trusted third party ok il TTP la tiene per sé non la svela a Bob perché se se il TTP svelasse a Bob quelli di informazione Bob imparerebbe subito il valore di A perché Bob conosce K0 quindi se ricevesse questa variabile qua basterebbe sottrarre K0 ed ecco che impara il valore di A questo lo vogliamo evitare ok Bob da parte sua che cosa fa? fa un qualcosa di un po' più complicato come potete vedere ovvero sceglie randomicamente un valore R un valore casuale lo invia al TTP insieme a un'altra variabile questa calcolata in questo modo qua R per B più K0 il tutto più K1 ok di nuovo il TTP riceve R riceve XB ma non li svela ad Alice perché se li svelasse ad Alice Alice potrebbe recuperare banalmente il valore di B ok l'unica cosa che fa il TTP è calcolare questa differenza e inviarla ad Alice dopo di che l'unica cosa che deve fare Alice è questo test se il test ha successo Alice impara che A è uguale a B se il test non ha successo impara che A è diverso da B ma non impara nulla il valore di B adesso facciamo la dimostrazione di questa cosa vedete il protocollo è asimmetrico perché eseguendolo Alice impara se A è uguale a B Bob non impara niente quindi per far imparare qualcosa anche a Bob bisogna rieseguire questo stesso protocollo a ruoli invertiti però lo si fa con un'altra chiave di sessione per questo motivo è utile avere un PRF per generare tante chiavi di sessione allora quali sono i passaggi che ci dimostrano il risultato allora abbiamo detto che il TTP deve calcolare RXA quindi deve calcolare RXA RXA è questa roba qui no meno XB che è questa roba qua giusto? questa roba qui è uguale RA più RK0 meno RB meno RK0 meno K1 questo e questo vanno via rimangono R per R per A meno B meno K1 questa è il valore che arriva da Alice Alice cosa deve fare? deve aggiungere K1 quindi buttare via questo e vedere se ciò che rimane è 0 ma questa roba qui che è ciò che rimane è 0 solamente se A è uguale a B in tutti gli altri casi sarà una quantità diversa da 0 quindi come dicevamo prima se il risultato del test che fa Alice è 0 allora Alice impara che A è uguale a B se quella quantità è diversa da 0 allora Alice impara che A è diverso da B ma non sa quanto sono diversi non sa quanto sono diversi perché? perché la loro differenza è moltiplicata per un valore random che è stato scelto da Bob e che Alice non conosce per questo è importante che TTP sia onesto non trasmetta informazioni che non deve trasmettere ok poi ripetete a ruoli invertiti lo stesso protocollo usando una nuova chiave di sessione quindi una nuova coppia K0 e K1 ed ecco che fate imparare la stessa cosa anche a Bob chi ha un esempio? mi torna chiaramente per far funzionare nella pratica qualcosa di questo genere quindi un protocollo che magari è eseguito tante volte però in ogni istanza va eseguito due volte abbiamo bisogno di tante chiavi di sessione diverse tra di loro e se Alice e Bob condividono una sola chiave come faccio a ottenere tante diverse chiavi di sessione uso diciamo per un PRF bene questo chiude la parte relativa ai bloc cypher e ai PRF la prossima volta cominceremo a estendere il discorso relativo alla cifratura chiave simmetrica rilassando quella condizione importante che abbiamo visto fin dall'inizio ovvero il fatto che la chiave viene usata per la cifratura di un solo plaintext vogliamo rilassare questa condizione e poter usare cifrari che non cambiano la chiave ma che rimangono comunque sicuri questo ci comporterà il dover usare qualche qualche trucco e oggi invece volevo andare avanti riprendendo la kill chain dalla versione di pomeriggio e andando avanti a vedere che cosa succede lungo lungo la kill chain quindi andiamo a ripescare le slide allora eccoci qua ieri abbiamo iniziato a vedere quali sono le diverse fasi della kill chain a partire da la ricerca delle vulnerabilità nel perimetro della vittima e a seguire la costruzione di un vettore di attacco che ci permetta di fare breccia nel perimetro una volta penetrato il perimetro muoversi all'interno del sistema target se necessario scalando autorizzazioni privilegi fino ad arrivare all'asset che vogliamo compromettere e quindi con relativo danno che viene che viene inflitto abbiamo parlato di tecniche di riconoscimento esterne così come interne le abbiamo menzionate diverse sia in un caso che nell'altro pensiamo arrivati a dire quale tipologia di vettori di attacco tipicamente il red team poi utilizza in base alle vulnerabilità che sono state scoperte ok qui avevamo dato un primo un primo elenco che tiene conto naturalmente del diverso tipo di scenario in cui ci troviamo no se la vulnerabilità era una password debole o un utente poco attento l'exploit che si utilizza sarà il furto delle credenziali ok se la vulnerabilità che abbiamo individuato riguarda il fatto che il sistema adotta software obsoleto o privo di alcune patch importanti di sicurezza allora il vettore d'attacco sarà l'exploit sarà probabilmente un brano di codice malware spesso volentieri preconfezionato adatto per quel particolare tipo di vulnerabilità che tool automatici ci aiuteranno a confezionare senza che noi dobbiamo preoccuparci più di tanto ok questo si ricollega naturalmente ad altri ad altri scenari in cui appunto si utilizzano degli strumenti per confezionare i vettori d'attacco se la vulnerabilità che abbiamo individuato è una vulnerabilità nuova che nessuno aveva mai sottato prima allora devo cercare di confezionare un attacco completamente nuovo quelli che si chiamano zero day zero day attack individuato la vulnerabilità spesso volentieri il vettore di attacco che io trovo lo sfrutto anche per realizzare attacchi più sofisticati o in composizione con attacchi diversi a seconda di quello che è l'obiettivo che voglio ottenere faccio un esempio che abbiamo visto anche anche ieri la vulnerabilità potrebbe essere legata alla debolezza dell'agente umano che io riesco a individuare facendo social engineering e sfruttando come vettore un email di phishing ecco che riesco a convincere l'agente umano a fare qualcosa che non dovrebbe ad esempio cliccare su un link però questa è la prima fase dell'attacco l'altra fase importante qual è montare un vettore che si attacco un exploit che si attiva nel momento in cui l'utente fa quello che non dovrebbe una volta che l'utente ha cliccato dove non doveva cliccare che cosa succede allora probabilmente in quel caso l'attaccante deve aver anche confezionato un malware che si attiva nel momento in cui la gente esegue una certa azione come cliccare da qualche parte ok quindi questo è un esempio di situazioni in cui vettori come il phishing basati sullo studio di certe vulnerabilità diventano una volta un mezzo per mettere in piedi un attacco più importante ok questo vale anche ad esempio in situazioni in cui sempre attraverso il phishing o altri strumenti basati su social engineering io riesco a convincere la gente umano a eseguire software che è sotto il mio controllo che contiene un malware che contiene un virus situazioni di questo genere dopodiché il vettore che poi porta questo malware alla vittima cosa farà anche qui dipende da quali che sono gli obiettivi dell'attaccante l'obiettivo potrebbe essere semplicemente quello di sfiltrare delle informazioni dal sistema vittima oppure può anche essere quello di prendere controllo del sistema vittima ad esempio o installando delle applicazioni o configurando il sistema vittima in maniera tale da consentire da quel momento in avanti un accesso privilegiato all'avversario faccio un esempio tipico per esempio banale anche un po' shock per esempio per esempio un sistema acquisisco privilegi di admin e con quei privilegi crea un utente che ha l'autorizzazione ad accedere a trovare su una share remota a certi servizi del sistema bypassando tutti gli altri controlli questa è una situazione tipica quindi sono innumerevoli i modi in cui è possibile sfruttare le vulnerabilità individuate durante il riconoscimento è anche difficile elencarle tutte la cosa migliore che possiamo fare a un certo punto è mostrare qualche esempio dei casi più significativi il problema del lacheraggio dell'identità l'avevamo già discusso abbiamo parlato di attacchi a forza brutta il caso del phishing vi ho fatto vedere l'esempio del pass di hash ieri oggi volevo continuare a farvi vedere qualche altro esempio pratico di che cosa significa sfruttare la vulnerabilità a proprio a proprio favore uno dei vettori di attacco più comunemente utilizzati sfrutta le tecniche di injection ovvero tecniche mirate attraverso i dati o attraverso applicazioni forzare il sistema a determinati comportamenti tipicamente disattesi disattesi cosa significa? significa che il programmatore che ha progettato il sistema non l'ha fatto certamente con l'intento di svelare certe informazioni semplicemente se lo stile di programmazione che ha utilizzato non è stato sufficientemente accorto il sistema probabilmente è in grado di svelare di più di quello che intende fare e vi faccio vedere tre esempi a seconda del tipo di injection che è coinvolto in diversi in diversi casi gli esempi più tipici più frequenti si hanno nell'ambito del fondamentalmente del del programmazione web e nell'ambito dei DBMS ok tant'è che il primo esempio che vi faccio vedere è un classico caso di injection nell'ambito delle query SQL ok esempi che semplici come questo o anche più complessi non so se vi è mai capitato di vederli in questo caso l'injection consiste nell'alterare lo schema di una query che viene sottoposta a DBMS ok e ha successo se l'applicazione che gestisce ed esegue la query non fa un controllo sulla struttura della query ok non fa quelle operazioni cosiddette di sanitizzazione dell'input necessarie per ripulire l'input della query in maniera tale da evitare situazioni antipatiche come quella che andiamo a vedere ok immaginate di prendere un brano di codice che potreste trovare in un client scritto in PHP o in JavaScript o qualunque altro linguaggio adatto all'uso e quindi immaginate di avere questo client che chiede all'utente di indicare come input l'identificatore dell'utente su cui eseguire una certa query ok la query è select asterisco from users where user id uguale a un certo valore dove quel valore deve essere fornito attraverso un'interfaccia web ad esempio ok cosa fa quella select restituisce tutti i dati dalla tabella degli utenti relativi all'utente che è stato indicato tramite l'interfaccia ok magari quel valore viene automaticamente generato nel momento in cui chi usa l'interfaccia sia autentica e quindi viene associato a un id e quel id è esattamente il valore che verrà assegnato alla variabile user id ok la query di solito modo semplice per costruire la query è quello che vedete qui c'è una parte fissa della query cioè tutto quello che è scritto tra doppi apici concatenato con la parte variabile che è quella sono i valori che sono inseriti dall'utente il problema sta nella mancanza di controlli su come è fatto questo contenuto ok se non si fa un controllo su quel contenuto quel contenuto potrebbe essere scelto a piacimento ok quindi un utente malevolo che invece di riportare semplicemente un user id che gli interessa ok ad esempio che ne so 105 per cui il text dovrebbe essere semplicemente questa stringa e quindi la query sarebbe legittima un utente malevolo che inserisce quest'altra stringa di fatto ottiene un effetto diverso rispetto a quello inteso dalla query originale perché se vi ricordate un po' di semantica della clausola where di SQL quel where user id uguale 105 or 1 uguale a 1 dà come risultato true perché 1 è uguale a 1 ok e il risultato true vale per tutti i record della tabella naturalmente no perché quella query lì dice seleziona dalla tabella degli utenti tutti i record che rendono vera la clausola where ma la clausola where è vera sempre perché 1 è sempre uguale a 1 quindi qual è il risultato di questa select ti visualizza l'intero contenuto della tabella ok questo è un esempio banale poi ce ne sono di più di più sofisticati però perdete in considerazione anche questo secondo caso qui scusate abbiamo già visto vedete questo se il testo se il testo che inserite è questo voi di fatto voi di fatto state creando la concatenazione di due comandi una select e una drop perché la query diventa select se esco from users where user id uguale 101 punte virgola drop table users questo è ancora peggio di quello di prima perché quello di prima viola magari la confidenzialità la price questo viola l'integrità ok perché? perché l'effetto di cancellare la tabella ora queste cose si possono evitare anche abbastanza facilmente se tutte quante le applicazioni che interagiscono con i dvms sono scritte come di a comanda nel senso che si utilizzano dei check alcuni sono automatici nel senso che potete usare funzioni di librerie apposite per verificare una cosa banale per ovviare al secondo tipo di attacco basta verificare che nella stringa che l'utente inserisce non ci siano caratteri speciali come gli apici punte virgola o tutti quei caratteri che potrebbero far sospettare l'utilizzo di situazioni che portano a una composizione di query o comandi che hanno una semantica più estesa rispetto a quella del formato standard previsto dall'applicazione quindi eliminando tutti questi caratteri cosiddetti speciali o trasformandoli in caratteri non speciali mettiamola così si riesce a ovviare a tutta una serie di problemi da questo punto di vista però ci sono anche tentativi di injection un po' più sofisticati allora lì bisogna fare un pochino più attenzione ora l'injection nasce in questo contesto perché le prime applicazioni web che si sono viste erano applicazioni che interagivano con database la pagina interattiva e dinamica tipicamente interagisce con database persone volentieri e quindi la prima vittima di questo tipo di attacco sicuramente sono stato il DBMS e quindi il linguaggio da una parte è il linguaggio SQL ma dall'altra è il linguaggio che si occupa della gestione delle interrogazioni di solito PHP in molti contesti è la vittima predestinata di questo tipo di situazioni l'injection però si può usare anche in tanti altri contesti che esulano dai DBMS dai linguaggi di interrogazione ma al principio è sempre lo stesso ok ora voi immaginate di avere una una pagina web con questo schema di URL no capita abbastanza spesso ok siete arrivati in una pagina dove vi siete autenticati ok quindi è stato creato un token per la gestione della sessione durante la quale voi interagite con il sito web e che si può e che che consente all'autoserver di tenere traccia di tutta una serie di informazioni durante la navigazione all'interno del sito quindi a un certo punto può capitare di ritrovarvi in una pagina che ha quest'url almeno una volta poteva capitare abbastanza tranquillamente adesso è un po' più difficile cioè un sito dove in coda alla alla pagina che in quel momento viene navigata ci sono dei metadati dei parametri ereditati dalla visita di pagine precedenti quindi quell'url potrebbe rappresentare il fatto che in questo momento la pagina accounts.php sta visualizzando i dati del conto corrente dell'utente con il d101 perché il d101 è un valore che è stato passato dalla visita di una pagina precedente legata all'autenticazione ok in questo modo rendiamo la pagina parametrica perché se se l'utente di interesse non è il 101 ma è un altro cambia il parametro qui ma la pagina è sempre la stessa una pagina parametrica da questo punto di vista ok possiamo immaginare che all'interno noi non conosciamo il codice di account.php però possiamo immaginare come può essere fatto magari al suo interno è ragionevole pensare che ci sia una query di questo genere magari non proprio quella perché perché io non so niente della struttura del database del codice di accounts.php però so posso aspettarmi che al suo interno ci sia una qualche query che nella clausola where abbia una condizione che riguarda questo valore perché se no questo valore che cosa serve? un parametro quindi all'interno della pagina quel parametro probabilmente viene utilizzato ok bene ora io non so nulla di come è fatta la pagina della struttura del DBMS delle tabelle che ci sono dentro ma voglio imparare qualcosa del suo contenuto che cosa faccio? beh provo a verificare se quella pagina è sensibile all'injection in che modo? beh vado a vedere se alterando questo parametro il codice della pagina se ne accorge oppure no se ne accorge e reagisce oppure no se non se ne accorge e quindi io posso pilotare come mi pare questo input ecco che posso pilotare alcuni dei comandi che il codice gli induirà e quindi cominciare ad acquisire informazioni ad esempio sulla struttura del DBMS su quali sono le sue tabelle come interrogarle i diritti di accesso e quindi andare a recuperare informazioni a cui non dovrei avere accesso come faccio a sapere se la pagina è sensibile oppure no a tentativi di injection mi basta molto banalmente iniettare l'input in questa maniera qua ad esempio ok se il codice della pagina accounts.php non fa nessun controllo sull'input una query che ha un predicato nella clausola where sul valore di diventa una clausola where che non solo verifica il valore di un certo attributo rispetto a questo parametro ma aggiunge un altro controllo ho messo un end e questo controllo è sempre è sempre falso ok quindi questo cosa significa significa che se questa injection ha successo la pagina cosa mi restituisce niente qualunque sia la struttura della select se la clausola che io non conosco se la clausola where è falsa ok io cosa ottengo come risultato una pagina vuota e se ottengo una pagina vuota ho la conferma che quella pagina è vulnerabile all'injection ok e da lì posso cominciare a sofisticare il mio attacco renderlo più complesso ok con lo scopo di imparare a conoscere un po' quella che è la struttura ad esempio delle tabelle di BMS se riesco a reperire informazioni confidenziali questo è un esempio di come si conduce una tentativa di injection cieco cieco perché io non so nulla nella struttura dei dati al lato vittima comincio a interrogarla e se vedo che è vulnerabile all'injection da lì in avanti un po' alla volta faccio escalation e recupero tutte le informazioni che voglio l'injection è un problema di cui anche se ci sono le soluzioni purtroppo ancora uno degli strumenti di grande successo negli attacchi tra l'altro se volete approfondire questo tema trovate nel su Blended in una cartella apposita ho messo un po' di approfondimenti ai vecchi progetti ok in almeno un paio di questi il tema era l'injection quindi lì potete andare a sbirciare a vedere come come sono fatti attacchi di injection più sofisticati e se vi interessa il tema a partire da quello magari potete proporre voi degli approfondimenti per il vostro di progetto è uno dei temi su cui trovate riferimenti ora gli esempi che abbiamo mostrato sono esempi di injection di di dati fondamentalmente ok in parte di comandi però sempre sotto forma di input per il linguaggio di interrogazione ok ma l'injection funziona non solo con i dati funziona anche con i comandi il principio è sempre lo stesso ok ora conoscete il comando cat sotto linux no vi ho riportato il codice dal codice si capisce poco in realtà però se andiamo a vedere poi il sorgente di strcat diventa un po' complicato però l'effetto di questo comando è di visualizzare il riportare a terminale l'intento qual era? quello di riportare a terminale il contenuto di che cosa? del parametro che viene fornito al comando in questo caso ad esempio il comando cat il parametro che gli viene fornito è un file el.lob.txt quindi il comando che cosa fa? va a prendere il file el.lob.txt e ne visualizza il contenuto a terminale se dentro il file el.lob.txt c'è scritto el.lob.word ecco che a terminale vi ritrovate il messaggio el.lob.txt ok quindi l'obiettivo con cui è nato il comando cat è questo mostrare a terminale il contenuto dei file che vengono passati come parametro al comando ok ora se io ne faccio un uso malevolo riesco a fargli fare cose non previste qual è? in che modo? beh prendete questa stringa no è un'estensione della stringa originale ho fatto injection come negli esempi basati su SQL ok quindi io al cat non sto passando solamente el.lob.txt ma sto passando il no.txt concatenato con qualcos'altro questo qualcos'altro non è un file vedete non è un file ma a sua volta è un comando ls-l l-l conoscete no ls è quel comando che ci permette di visualizzare il contenuto di un directory ok ora che cosa succede dal punto di vista del cat se andiamo a vedere il codice particolare a vedere qua dentro il cat prende l'input come una stringa e non fa altro che sparare sullo standard output che cosa beh se se se la stringa identifica un file sparo il contenuto del file in tutti gli altri casi sparo che cosa la stringa stessa ok quindi nel caso del no.txt il cat che cosa fa espande perché va a prendere il contenuto del file del no.txt e lo spara sullo standard output poi c'è una concatenazione e quindi fa la stessa cosa con quello che sta a seguire ls-l l-a è una stringa non è un file ma è una stringa quindi il cat che cosa fa spara sullo standard output la stringa ls-la ma se voi sparate sullo standard output la stringa ls-la cosa state facendo state dando un comando e quindi sullo standard output voi vi ritrovate l'effetto dell'esecuzione di quel comando ok per cui il risultato di questo input passato al comando cat sarà hello world punto esclamativo puntini puntini e poi a capo l'intero contenuto della directory locale perché l'effetto di sparare ls-la sullo standard output coincide con l'esecuzione di quel comando ok ora immaginate immaginate di avere nel vostro sistema delle applicazioni analoghe a cat che che che vi permettono di lanciare comandi i cui riferimenti sono passati come input se voi riuscite a entrare in un sistema che ha una funzionalità di quel genere lì voi poi su quel sistema potete eseguire tutto quello che volete per quanto si si si perché a questo punto il comando ls-la non lo sta eseguendo l'utente che esegue il cat è il sistema che lo sta è cat che lo sta eseguendo quindi è il sistema che lo sta eseguendo e non ha i limiti che avete voi quindi è un modo per fare escalation dei privilegi in molti casi l'escalation funziona in questi modi qua non sono io a eseguire un comando perché non ho il diritto di farlo però lo faccio eseguire al sistema chiedo al sistema di eseguirlo e lui lo fa perché perché ci sono situazioni come queste comandi che posso lanciare che fanno quello che io vorrei fare ma non posso e l'injection di comandi è uno dei modi più frequenti e utilizzati di fare escalation una volta che siamo all'interno di un di un sistema questo è un esempio di injection di comandi fatta localmente perché io ho bisogno di essere già sul sistema per eseguire cat e chiede alla cat di eseguire qualcos'altro ok e l'injection di comandi funziona anche da remoto in certi casi se io ho accesso delle applicazioni che consentono di caricare codice non locale qui vedete un altro esempio anche qui astraiamo un po' come abbiamo fatto prima nel caso della blind SQL injection immaginate di avere una pagina come questa ok la stessa pagina vulnerabile di prima ha un sacco di vulnerabilità questa pagina non conosciamo il codice del file contact.php però e non sappiamo neanche il codice della della home di myhomebanking.com però ipotizziamo e spesso succede effettivamente questo che nel sorgente associato a questo url vengano incluse le funzionalità di questa pagina ok ora che succede se non c'è un controllo stringente su questo parametro esattamente come abbiamo visto prima che succede se io posso andare ad alterare questo parametro senza che al lato server non ci si accorga di quello che sta succedendo perché perché non faccio nessun controllo sul fatto ad esempio che contact.php sia una pagina locale safe e non alterato fornita da altri per cui eseguire tutto fare tutto quello che c'è in quella pagina è sicuro perché è una pagina locale e non c'è nulla di strano però se io improvvisamente sostituisco contact.php dell'url con non più una pagina locale ma con una pagina remota che contiene il codice scritto da me ora se non pesi myonbanking.com fa dei controlli sull'input che cosa fa assumerà che tutto quello che sta dentro questa pagina qui è legittimo e può essere eseguito quando eseguo il contenuto della pagina è un caso stupido banale perché stiamo parlando di una pagina che carica senza controlli tutto quello che gli dice di caricare di fare un'altra pagina passata come parametro ok però vi dà l'idea di cosa vuol dire fare injection di remoto anche da injection di comandi anche da remoto perché a questo punto sta dicendo a questa pagina qua di caricare e fare tutto quello che questa gli dice ok anche qui di nuovo il problema di fondo è esattamente lo stesso che abbiamo visto nel caso dell'injection di dati ovvero ci vuole un controllo accurato degli input quindi tutti quanti i parametri rispetto ad esempi di questo genere funziona non bastano tutti i casi però sicuramente è una condizione fondamentale ok molti moltissimi forse la maggior parte dei vettori d'attacco di cui vi accennerò fanno escalation in modi analoghi a questo le situazioni sono anche facilmente identificabili sono tutte documentate questo tipo di azioni le cose sono un po' più complicate quando invece sono di fronte a attacchi di tipo zero day quindi attacchi che sfruttano vulnerabilità che non sono ancora note ci sono ma non sono ancora note quindi il primo problema per l'attaccante consiste nell'identificare vulnerabilità non ancora note con l'obiettivo quindi di eseguire poi degli attacchi che non siano rilevabili come si fa a trovare vulnerabilità non ancora note e quindi montare attacchi di tipo zero day è piuttosto complesso di solito i modi per cercare vulnerabilità in un sistema sono due fondamentalmente il primo consiste nel ricreare in un ambiente protetto in un ambiente chiuso il sistema che vogliamo colpire questo si fa quando ad esempio noi del sistema non conosciamo nulla se non il codice eseguibile ok e se non conosciamo il codice eseguibile non possiamo fare l'analisi del codice cosa facciamo testiamo il sistema è quello che si fa quando si vuole trovare un baco nel nuovo windows ok lo si prende lo si installa su una macchina e si comincia su quella macchina a provare tutto quello che in passato ha funzionato in tutte le sue varianti e si vede se il sistema reagisce in maniera inaspettata ok si va per tentativa l'altra possibilità invece consiste là dove questo è ammesso fare analisi del codice se il codice è open source vi mettete lì spunciate il codice e andate a vedere se ci sono errori di programmazione o cattivi stili di programmazione realizzati situazioni che a occhio in passato hanno rappresentato delle potenziali anomalie e quindi si fa una analisi statica sul codice senza la necessità di doverlo eseguire ok quindi da una parte approcci dinamici basati sul testing dall'altra approcci statici basati sull'analisi del codice questi sono i due modi per andare a cercare vulnerabilità nuove che però spesso volentieri sfruttano errori di fondo che sono sempre gli stessi e forse quello più comune in assoluto è legato all'overflow delle aree di memoria particolare il caso del buffer overflow ok buffer overflow è una di situazioni che tipicamente possono essere sfruttate per fare injection di comandi o per fare escalation in maniera simile a quella che abbiamo visto nella slide precedente in cosa consiste il buffer overflow quando è che si ha buffer overflow si ha quando un programma cerca di accedere o di memorizzare dati in un'area di memoria non allocata ok quando succede questo si provoca un crash del sistema segmentation fault perché un tentativo di scrittura in un'area non allocata chiaramente dà luogo ad un errore non recuperabile che viene gestito dal sistema il controllo quando si verifica un errore di questo genere il controllo passa al sistema ok ed è in questo passaggio al sistema che c'è il rischio che il sistema venga indotto a eseguire oltre a le azioni di recovery anche a altre azioni associata ad esempio a codice malevolo e questo è possibile e ve lo mostro attraverso un esempio che rimette in evidenza quanto il sistema sia vulnerabile in situazioni di questo genere è un esempio banale che si basa che ho costruito basandomi su una delle prime funzioni della libreria dello standard di input out del C deprecata ormai da anni proprio perché è una funzione che soffre del problema del buffer overflow e che poteva essere usata per injection di comandi questa funzione è la gets che ha una funzione che serviva serve per leggere una stringa dallo standard di input ok ho scritto tre righe di codice estremamente estremamente banali quindi ho il vettore di otto caratteri ok e ho l'invocazione della gets che prende legge dallo standard di input la stringa che io vado a inserire e la salva dentro il vettore che ho appena creato che ho appena allocato ok dopodiché stampo il contenuto del vettore che ho usato per salvare la stringa basta leggo una stringa la restituisco dello standard output la gets sta qua dentro c'è ancora tutt'ora però se andate a compilare questo dipende dalla versione del gcc che utilizzate però tenete quantomeno un warning che vi dice guarda che stai usando una funzione deprecata ok lo dice proprio la funzione gets è pericolosa e non dovrebbe essere usata perché è pericolosa e non dovrebbe essere usata perché soffre del problema del buffer overflow molto semplicemente la gets non verifica che la stringa che va a prelevare dallo standard input quella che voi digitate della tastiera non sia più lunga rispetto all'area di memoria dove deve andare a scriverla cioè nel nostro caso il vettore buff se il comando gets fosse sicuro fosse save farebbe un controllo per cui faccio un esempio banale se buff è lungo 8 come in questo caso dentro buff vado a scrivere i primi 8 caratteri che leggo dallo standard di input e li mi fermo dopodiché se ce ne sono negli altri io mando un messaggio che dice hai superato il limite di memoria non posso salvare ulteriori dati ok invece la gets questo controllo non lo fa cerca di scrivere dentro buff tutto quello che legge dallo standard di input ok è chiaro che se nello standard input io butto qualcosa di più lungo rispetto alle dimensioni di buff che cosa succede succede che la gets cerca di scrivere a un certo punto oltre i limiti fisici dello spazio di memoria allocato per buff e quindi ho un buffer overflow cerca di scrivere in un'area di memoria non allocata quindi segmentation form ok fin qui nulla di male no vabbè sei stato disattento a inserire l'input poco male ho una terminazione anomala del programma ok e infatti vedete che si verifica l'errore che provoca la terminazione no questo è è lo standard output dell'esecuzione quindi ho lanciato l'eseguibile dopo averlo compilato questo è lo standard di input quello che ho digitato da tastiera e per evidenziarlo il rosso rispetto al resto cosa c'è di strano di strano c'è che prima della terminazione anomala prima del segmentation fault cosa compare nello standard output compare la stringa che io ho inserito il che è strano perché è strano perché la printf è successiva alla guess se la guess deve provocare un segmentation fault un errore perché viene eseguita la printf perché questo è il risultato della printf questo mette in evidenza anomalie tipiche di ciò che può succedere quando il sistema assume il controllo del flusso di esecuzione per in questo caso interromperlo perché è successo qualcosa di anomalo ok questo esempio mette in evidenza il fatto che il mio input anche se provoca un errore viene lo stesso preso in considerazione ok ok viene elaborato anche se io questa cosa non me la aspetterei allora immaginate se l'input che provoca il buffer overflow sia un input che contiene un injection di comandi come nel caso degli esempi che abbiamo visto prima no comandi che io non potrei eseguire non sono autorizzato a eseguire ma che il sistema può ok quando compare questo risultato è il sistema che ha già assunto il controllo e che quindi con privilegi di sistema che cosa fa spara il risultato e provoca la terminazione del programma capite bene che usando questa vulnerabilità voi potete pilotare l'input in maniera tale da provocare situazioni in cui il sistema inadvertitamente eseguo del codice scelto da voi come nel caso del common injection del slide precedente chiaro che ci vuole qualcosa un po' più sofisticato però questo esempio nella sua semplicità vi mette in evidenza che tipo di vulnerabilità emergono nel momento in cui abbiamo un buffer overflow perché lì ripeto nel momento in cui il sistema assume il controllo del flusso di esecuzione può essere indotto a fare cose che non dovrebbero come l'esecuzione di un malware e io inietto sotto forma di comando ok questa è l'idea generale che sta dietro il modo in cui chi sviluppa exploit basato sul buffer overflow imposta nel vettore d'attacco quindi i principi di base sono appunto buffer overflow e il command injection anche qui chiaramente per evitare questo tipo di situazioni bisogna evitare che si verifichi il buffer overflow e quindi anche qui controlli quindi ad esempio la F-GETS non ha questo tipo di problema la GETS ce l'ha qui avete un elenco di esempi di funzioni che interagiscono con lo standard di input output quelle di sinistra dovreste evitare di usarne perché sono vulnerabili da questo punto di vista ok quelle di destra invece sono safe va bene ci vediamo la prossima settimana? Grazie a tutti.