Ok, perfetto. Allora riprendiamo dove siamo rimasti la volta scorsa e adesso appena riparte l'applicazione dovremmo vedere lo stato in cui siamo terminato ieri. Abbiamo visto un paio di cose molto di basso livello, primitive per la composizione della UI in Flutter. Abbiamo visto che l'approccio che si sposa è quello dell'interfaccia funzionale per cui ci sono dei metodi, delle funzioni, degli effetti che vanno a comporre un albero di widget che poi noi presentiamo a schermo. Abbiamo visto che fondamentalmente il primo metodo che lancia tutto l'albero e lo rende visibile a schermo è questo RunApp che è il punto d'ingresso dell'applicazione Flutter al quale passiamo un widget e questo widget poi ha la capacità di costruire se stesso e quindi costruire tutto l'albero di widget sotto stack. Perché quindi c'è sempre un widget radice che da solo si fa molto poco e poi quando questo viene costruito, quando viene buildato, va a creare una gerarchia più o meno sofisticata di sotto widget che poi rappresenta la nostra interfaccia utente sullo schermo. Qui appunto per iniziare abbiamo fatto questo material che vi ho detto di ignorare per ora, poi il resto dell'applicazione è un insieme di colonne, righe, testi e widget fatti, widget che derivano da status widget. Altra cosa fondamentale che abbiamo visto è che quando andiamo a implementare un status widget, quindi un widget che non tiene traccia dello stato, quindi un widget che è immutabile, quindi un widget che non dipende da nessuna informazione mutabile, questo ha un solo metodo che è questo build, quindi è il metodo fondamentale che lancia l'applicazione e genera i widget sotto stack. Ok, qui è partito, per cui a questo punto vi faccio vedere brevemente che cosa avviene nella riga di comando. Qui la riga di comando è molto simile a quella che abbiamo visto lavorando con il web, quindi avete il log di output e il log di output di Android, quando ho lavorato con Android, è ovviamente più verboso, cioè parla un po' di più, perché vi dà informazioni anche contestuali di Flutter e del log del dispositivo, per cui è un pochino più rumoroso, diciamo così, per virgolette, però non cambia radicalmente. Quello che cambia radicalmente è che lavorando su Android, qui avete due comandi fondamentali, cioè avete più comandi in realtà con cui lavorare, ma i reload sono due, sul web è soltanto uno, cioè il hot restart, mentre su Android ne avete due che è hot reload e hot restart. Adesso tra un secondo vediamo qual è la differenza, però diciamo così, alla fine se avete hot restart già siete in una condizione abbastanza positiva. Ok, a destra vediamo l'interfaccia, che è con grande fatica. Qui notate che l'interfaccia è interattiva, per cui questo non è soltanto una copia, ma è anche interattiva, per cui è molto comodo per, se dovete debaggare, testare, lavorare su un dispositivo vero, è sicuramente conveniente rispetto a usare un emulatore, e con ScreenCopy comunque potete interagire anche con il mouse, se volete. Ok, la nostra interfaccia è composta in questa maniera, e tra l'altro vediamo sotto, che ho scritto, cioè in varie occasioni, in vari punti della cosa, che ho scritto, abbiamo messo i nostri debug print per vedere che cosa viene costruito e quando. Ripetiamo un secondo, giusto per vederlo in azione, perché durante la costruzione dell'interfaccia, quindi quando RunApp viene lanciato, la prima cosa che fa chiaramente è prendere il primo widget, e poi costruire i suoi sotto widget, per cui troviamo i vari building qui nel log. Qui troviamo, abbiamo quattro istanze di riga colorata, che era quel widget senza alcun senso, questo qui, che non fa altro che creare una riga con sinistra e destra e poi un colore fornito da fuori, e qui per la domanda che mi faceva prima, sul fatto che se possiamo passare delle informazioni da fuori al widget e poi costruirlo in maniera diversa in base ai parametri che forniamo, questo è quello che facciamo qui con il colore già, però nulla ci toglie, cioè qui stiamo fornendo un colore da fuori e poi quel colore viene usato dentro, in questo caso per colorare quel blocchetto colorato, quindi ha un effetto abbastanza diretto, però... Forse invece ha messo un, cosa ne so, un buleano... Possiamo passare a questo, possiamo passare a quello che vogliamo, possiamo metterci un buleano, sì, per esempio, anzi possiamo anche farlo, adesso che sappia scrivere, e che so, ci mettiamo expanded, e magari possiamo fare che... andiamo opzionale, per cui... anzi, dovrebbe essere così, così... dargli un pulse qui... Ok, adesso questo expanded qui, non so cosa possa servire, però potremmo mettere che se è espanso, l'altezza è 40 invece che 20, per dire, però non posso venire in mente cose più intelligenti, se expanded vale 60, altrimenti vale 60. Ok, quindi possiamo... in questi casi, siamo dati a vedere le prozioni di operatore condizionale, non so, ma... Sì, sì, questo, considerate che dentro build, questa è la cosa... ma... cioè, Mario, questo è il paradigma fondamentale di Flutter, per me, di creare interfaccia dente con del codice, quindi voi state lavorando con del codice che è codice Dart, proprio, e quindi qui, intanto lo facciamo tra un secondo, andremo a costruire una lista dinamica di widget in un ciclo for, quindi qui, in realtà, questo è il codice generico, possiamo fare dei for, possiamo fare dei while, possiamo fare delle richieste di rete, possiamo fare delle cose del genere, chiaramente, tutto quello che richiede del tempo, qui, non è una buona idea a farlo, la build deve essere immediata, quasi, perché deve costruire interfaccia dente, quindi non può richiedere del tempo, quindi qui, seppure sia tecnicamente fattibile, potremmo fare delle richieste remote, accedere ai file, eccetera, eccetera, non è, ovviamente una buona idea, poi Flutter si lamenta immediatamente, se la build non è immediata, però, sulla carta, è codice generico, quindi potete metterci assolutamente quello che, quello che volete. Per cui adesso qui ho messo questo expanded qui, per cui giusto per vederlo in atto, a questo punto possiamo, espandere il blu, e passare qui, expand che appunto è opzionale, nominale ed opzionale, e espanderlo. Così questa è anche una buona scusa, per provare la rebuild, cioè la hot reload, adesso faccio hot reload con la R minuscola, guardate che il cambio di comando è abbastanza, così, sui dettagli, la R minuscola è il hot reload, e la R maiuscola, quindi con lo shift attivo, è il hot restart. Che cosa cambia? Hot reload ricarica, cioè ricostruisce, i widget sullo schermo, andando a rebuildarli, in sostanza, e quindi in questo caso mi aspetto, che quello riesca a cambiare, perché sta ricostruendo tutta la gerarchia, e questo è il ripropulsare. Hot restart riavvia, in sostanza l'applicazione, seppure mantenendo parzialmente, alcuni elementi, però la riavvia da zero, in sostanza, e quindi tutto quello che è lo stato, e i widget già esistenti, vengono persi, per questo se faccio hot reload, molto bene, e ecco, in questo caso probabilmente è da vedere, se no, ci salva da questo, ok, quindi in questo caso ho cambiato il modo con cui veniva costruito, il widget, questo qui, ok, per cui non ricostruendo widget, cioè facendo hot reload, piuttosto che hot restart, questi widget che già esistevano, che non sono stati ricostruiti, ma sono rebuildati, non avevano expanded dentro, possiamo dire, dentro la classe, ok, quindi hot reload, ha fatto la ricostruzione, il rebuild, quindi ha chiamato questo metodo qui, su widget già esistenti, e quindi i rebuild già esistenti non avevano ancora il booleano, ok, con hot restart è ripartito da zero, e quindi a questo punto tutti i widget hanno il loro expander, e quindi sono riusciti a rebuildarsi, quindi attenzione, nel modificare, cioè, hot reload è molto efficiente, molto comodo, perché è molto più veloce, chiaramente, che hot restart, non vi richiede di ripartire dall'inizio della vostra interfaccia utente, però se fate modifiche profonde, chiaramente non è possibile sfruttarlo, quindi in genere, se volete essere sicuri che tutto è in ordine, hot restart, ci parte da zero, e quindi siete sicuri che tutto torna, ok, quindi questo era un esempio, cioè, così, rapida della differenza, se ne vediamo un'altra, tra un'estate che ci rende evidente qual è la differenza tra hot restart e hot reload. Altra cosa, qui abbiamo quindi quattro istanze di riga colorata, e infatti vediamo quattro stampe, no, building riga colorata, quello che cambia, nel web avevamo quattro righe, building riga colorata, in Android a volte, quando le righe sono ripetute, compare questa cosa qui, che si mangia, le righe ripetute, quindi qui vi dice, attenzione, ci sono due righe identiche, cioè, questa cosa qui, questa stampa qui, vale due ripetizioni, di quello che è precedente, in sostanza, cioè, questa cosa qui vale due volte building riga colorata, perché il log si accorge del fatto che sono ripetizioni, e quindi ve le comprime in qualche modo, questo, adesso qui è abbastanza inutile, perché chiaramente corrisponde a quattro volte building riga colorata, però se avete un log molto pieno, dove ci sono cento eventi uguali, è comodo, perché ve li collassa in due righe, in sostanza, ok, quindi la prima riga, la prima istanza, e poi le ripetizioni identiche. Ah, ok, e poi abbiamo building riga colore casuale, che è questa cosa qui. Ricordate che ieri abbiamo fatto questo tentativo, di creare un widget, che è senza stato, ovviamente, però quando viene costruito, quando viene creato, per la prima volta, si genera un colore casuale, questo l'abbiamo visto, no, rapidamente ieri, specificamente andiamo a prendere, l'array dei colori primari, e poi peschiamo un valore casuale di questi. Questa cosa qui, fa sì che il widget stesso, non possa essere const, non può essere const, perché i suoi componenti, cioè i valori che stiamo utilizzando, nel costruttore stesso, non sono note a tempo di compilazione, quindi non può essere const, per definizione, perché alcune cose, vengono fornite a runtime, come per esempio questa random, no, e questo, tutto sommato ci sta. Ora, a che serve questa cosa qui? Non molto, però serve a farci vedere, che questo, cioè quando viene eseguito, questo costruttore qui, quindi questo rig a colore casuale, è il costruttore che quando viene creato il widget, viene lanciato, e genera un colore casuale, per cui, è un buon esempio per, una buona scusa per usare hot reload, quando faccio hot reload, quindi quando ribildo l'applicazione, senza ricostruire, la generarchia dei widget, quindi R minuscolo, cosa accade? Non molto, anzi, nulla, perché il widget, questo qui con colore casuale, non viene ricostruito, cioè è sempre lo stesso widget, che è rimasto in memoria, è dentro la generarchia, viene solo ribildato, e si ripresenta al schermo in questa maniera. Il colore, che ha scelto casualmente, rimane identico, posso ricostruire quante volte voglio, e rimane arancione. Se faccio hot restart, invece, quindi, meno usecolo R, tutta l'interfaccia viene ricostruita dalla radice, per cui, anche riga colorata casuale, come si chiama, viene ricostruito, e quindi avrà un colore casuale diverso. Se è di nuovo arancione, è più sfortuna che ha. Hot restart è più lento, ovviamente. Ok, adesso un verdino, e così via. Quindi ogni volta che faccio hot restart, l'interfaccia viene ricostruita, e il colore scelto casualmente, diventa, cioè viene variato. Ok, e fin qui, nulla di praticamente sofisticato. Ora, cerchiamo di rientrodurre lo stato, ossia, allora, finora qui, questa interfaccia qui, cioè questa applicazione qui, non fa nulla, adesso che è uno schermo statico, che non regisce gli input, non ha nessuna attività, l'utente non può farci nulla, perché l'interfaccia è sempre la stessa. Cioè l'interfaccia viene costruita staticamente sulla base di questi widget qui. Questo, fin qui ci può star bene, cioè fin qui abbiamo un'esperienza utente, un'esperienza utente, un'esperienza, diciamo così, sì, un'esperienza utente, in qualche modo, che è paragonabile a quella di un documento statico, come per esempio un documento HTML sul web, un documento HTML statico con soltanto del testo, dell'immagine, e così via, è fisso, non può essere modificato dall'utente in alcun modo, perché quando lo vediamo su un browser, quello è effettivamente stateless, quindi non ha stato interno, non può essere modificato, se clicchiamo sugli oggetti non accade nulla, perché è giusto che sia così. Quindi per fare quello ci basta il mondo stateless dei widget, perché ci può bastare così. Appena l'utente deve in qualche modo interagire con il mondo dell'applicazione, deve introdurre dello stato, cioè l'applicazione deve memorizzare da qualche parte nella sua memoria un oggetto, una variabile che può essere modificata e poi con cui reagire all'interazione dell'utente. Ora rimplementeremo rapidamente quello che è il template di base di Platter, per cui andremo a creare un pulsante da qualche parte che una volta cliccato incrementa un contatore e quel contatore lo mettiamo a schermo, lo stampiamo fuori, ok? Per cui andiamo a rendere qualcosa, la nostra applicazione state full, quindi con stato. Allora, per farlo, per fare un po' di pulizia, riannido i componenti, per cui qui prendiamo tutto quello che è dentro la home di Material App, ok? E lo rendiamo un widget homepage, lo chiamiamo. Quindi tutto questo blocco qui, da Material in poi, lo prendiamo, lo tagliamo, cosa si fa molto spesso, quindi quando bisogna organizzare l'interfaccia dell'utente, magari all'inizio si fa una prova, si crea un'interfaccia abbastanza complessa, direttamente tutta in un blocco per vedere che cosa ne viene fuori. Quando un widget, un sottocomponente ci sta bene, ci piace, adesso ovviamente non è proprio esteticamente soddisfacente, però diciamo che ci va bene, lo prendiamo, lo tagliamo e lo rendiamo un widget da se stante, ok? Per cui l'ho tagliato e qui creiamo una classe homepage che di nuovo farà extends the test widget, ok? Qui, come al solito faccio fare il lavoro sporco a Visual Studio Code e qui per riprodurre le cose fatte prima faccio return e incollo la cosa fatta prima e poi metto il punto di tutto qui, qui di nuovo faccio creare il costruttore const al mio amico Visual Studio Code e tutto fatto, adesso l'unica cosa che manca è aggiungere qui homepage, ok? L'ho spostato, l'ho reso un widget a se stante e fermo lì, ok? Se ricostruisco mi aspetto che non cambia assolutamente nulla se non il colore casuale. Ok, a questo punto dobbiamo scegliere il punto dove mettere il nostro, cioè intanto dobbiamo mettere il punto dove vogliamo mostrare questo contatore, quindi immaginiamo di avere un contatore, no? Counter che parte da zero e quindi conta il numero di click che abbiamo fatto e dobbiamo stamparlo in qualche modo. Allora lo stampiamo, io direi che lo mettiamo sotto al colore casuale per esempio, perché no? Per cui sarebbe a dire qui sotto. Quindi qui dentro, magari ricicchiamo questo text qui e ci scrivo hai cliccato zero volte. Ok, per ora chiaramente questo è un testo statico quindi tant'è che possiamo rendere il conto senza problemi e questo sarà sempre zero quindi insomma è poco interattivo per ora. Allora, l'idea è questa. Qui dentro vogliamo accedere a una variabile che viverà da qualche parte. Ora, se mettiamo una variabile qui dentro, questo, clic, counter magari è più... abbiamo una variabile counter che vale zero quando viene inizializzata e qui possiamo giustamente metterla nell'output. Questo gravete non è più cons quindi l'altra giustamente si lamenta. Ok, questo qui funziona ovviamente per cui possiamo farlo. Quindi adesso comparirà ha cliccato zero volte immagino appena ricostruisce e fin qui va bene è ancora statico. Ok, adesso a questo punto bisogna modificare in qualche modo questo counter qui. Ora, questo counter qui chiaramente non può essere modificato perché ogni volta che il metro build viene invocato questo counter qui viene reinzializzato a zero dentro lo scope della funzione quindi questo oggetto qui non è modificabile. Potremmo modificarlo a runtime qui dentro mettendoci una random mettendoci un for o qualcosa del genere però questo avviene ogni volta che facciamo build per cui non è quello che vogliamo fare. Per cui dobbiamo metterlo in qualche modo al di fuori del metro. Lo possiamo mettere qui dentro. ovviamente quindi qui possiamo fare int counter uguale zero va bene a questo punto a questo punto questa home page qui non può essere più const perché contiene dello stato variabile cioè non è più finale questo potrebbe rimanere const soltanto se questo fosse final. Se questo fosse final cioè una volta costruito rimane così com'è potremmo farlo però non è questo il caso anzi facciamo un'altra cosa intelligente per sì può essere utile facciamo così chiamiamolo counter display e compiliamo la vita un altro po' andando a creare un widget stateless questo per reiterare questa cosa della costruzione quindi qui possiamo metterci un contatore che è final int counter ok e lo costruisco con direttamente così interna e questa cosa qui la passo qui sotto quindi a questo punto qui ci metto il mio counter display che tra l'altro è c'è sì perfetto che tra l'altro è const è const fin a questo punto potrebbe essere const allora cosa voglio dimostrare con questo allora ho spostato il text fuori e creato un widget che non fa altro che mostrare del testo quindi un widget estremamente inutile però si può fare quindi è soltanto un widget di contorno che annida un testo questo sulla carta per noi è const questo può essere const nel senso che il valore che prende qui intero è fisso è noto può essere noto a tempo di compilazione per cui all'atto pratico questo oggetto qui può essere contatore finale const e va bene così non può essere const fuori perché questo counter qui purtroppo è variabile quindi è stato variabile questo contatore può essere incrementato da qualche parte quindi ovviamente questo qui non può essere const perché a tempo di compilazione chissà quanto vale counter cioè noi sappiamo che vale zero però non è quello il punto sulla carta potrebbe essere potrebbe variare per cui questo ci dà errore e tradisce il fatto che appunto lo stato cioè quindi il fatto che lo stato sia mutevole è come tante cose nella programmazione è una cosa virale che si passa che contamina tra virgolette il nostro codice è un po' come la sim una volta che qualcosa diventa asincrono asincrono a cascata tutto diventa diventa asincrono stessa cosa vale per lo stato una volta che c'è dello stato in giro che può essere modificato che è mutevole quindi una volta c'è una variabile che qualcuno può modificare a cascata tutto lo stato tutte le tutte le nostre nostri widget diventano mutevoli ok? quindi questa variabile qui il fatto che può essere modificata rende non const non const cioè non è possibile rendere const questo mio oggetto qui perché c'è lo stato che arriva dal dal livello superiore nell'albero e viene passato giù ok? quindi a questo punto il nostro counter display qui è abbastanza inutile perché insomma non dà nessun vantaggio non essendo const quindi esprimente un widget in più che fa da lavoro però lo lasciamo così perché perché ci sta ok? per cui questo counter qui è quello che andiamo a cioè vorremmo modificare lo rendiamo non final perché chiaramente deve essere modificabile il che rende non const nostra home page quindi vedete che a cascata il fatto che c'è una variabile modificabile compromette un po' la nostra architettura ora a questo punto questo funziona toco con screen e qui ci dà un errore ovviamente nel senso che la classe status widget è marcata come immutabile e noi l'abbiamo resa tutt'altro che immutabile per cui non so non ricordo se questo è un errore o un warning lo vediamo subito ok quindi ci dice che guarda qualcosa qui non mi torna però faccio fare lo stesso va bene così quindi abbiamo questo puntatore qui come si fa a modificare questo puntatore allora ci si aspetterebbe che allora che ci sarà un modo in Flutter per reagire al click dell'utente ovviamente esiste e basta usare un oggetto interattivo e per oggetto interattivo intendo un widget che reagisce ai click ce ne sono un miliardo e il più semplice ovviamente è il pulsante classico che in ah questo magari possiamo anche vederlo se l'ho aperto a che parte perché i pulsanti sono diversi e dipendono dalla ecco lì dall'inter dalla dalla piattaforma su cui siamo quindi su material design su Android ne abbiamo vari quindi i pulsanti che ci sono sono sostanzialmente cinque e hanno nomi diversi perché cambia l'aspetto grafico in sostanza quindi c'è il pulsante elevato quello filled quello tonale quello outlined e poi cos'altro e quello testuale base quello testuale è quello più invisibile nel senso che si prevede del testo tipo un collegamento testuale che però diventa vivo quando ci si passa ok quindi qui tanto poi la documentazione adesso non l'abbiamo ancora vista però la documentazione di Flutter è fatta molto bene per cui si è data un'occhiata alle gallerie di widget in Flutter poi trovate non soltanto la guida ma anche degli esempi pratici di quegli oggetti che potete utilizzare quindi questo questo vale per i pulsanti material sempre ok quindi questi si valgono per insomma i widget che prendono ispirazione ad Android se vi trovate su nei widget copertino chiaramente avete dei pulsanti chiaramente diversi che riprendono lo stile grafico di di iOS ok diciamo che ci piace quello elevated per dire sono tutti equivalenti ok quindi il comportamento è lo stesso per tutti cambia solo lo stile grafico ok elevated button ok ora qui lo costruiamo e vedrete che ci sono due proprietà proprietà due parametri richiesti uno il più banale è child child è un widget che è il widget cioè l'oggetto che viene mostrato dentro il pulsante quindi qui nell'esempio non questo qui abbiamo visto dei pulsanti con dentro del testo quando andiamo a crearli si fa esattamente come ve lo aspettate ossia con un text come child ok quindi mettere un testo dentro un pulsante prende il pulsante testuale prego tornando a un codice scritto si il banco material utilizza un child singolo un colpo che è un widget quindi noi potremmo mettere un colpo tutto dentro la nostra parte come child si si sulla carta si poi bisogna vedere quanto si rompono alcuni componenti non sono troppo contenti di ricevere widget casuali dentro per come sono implementati però in teoria il visit button prende un widget qualsiasi quindi qui possiamo metterci una riga possiamo metterci un'immagine possiamo metterci un'icona ci si può mettere ragionevolmente tutto poi bisogna testare se poi funziona chiaramente però sulla carta è un widget generico l'uso più comune comunque è metterci un text quindi qui mettiamo clicca qui ok lo metto const perché chiaramente il testo è const ovviamente e on pressed che cos'è on pressed è una funzione ora quella sentassi noi l'abbiamo vista in realtà facendo dart però la leggiamo un attimo insieme così capiamo che cosa avviene allora required vi indica che è un parametro richiesto per costruire l'oggetto questa qui è la signature quindi questa è la firma dell'oggetto cioè il tipo dell'oggetto che stiamo passando a on pressed on pressed è il parametro quindi questo richiede un oggetto che oggetto è è un oggetto che è una funzione le funzioni in dart sono oggetti di primo ordine per cui si possono passare come se fossero delle variabili in sostanza quindi i puntatori a funzione sono equivalenti a qualsiasi altro oggetto di qualsiasi altro tipo e hanno un tipo esplicito quindi la funzione che dobbiamo passare a questo oggetto qui cioè come on pressed è una funzione che non prende parametri perché la lista qui è vuota e ritorna void quindi di tipo prende void e ritorna void come si fa questa cosa qui? allora come si passa la funzione? si può fare in vari modi il modo più chiaro è creare una funzione qui quindi questa è una funzione che prende void e ritorna void e si può passare così direttamente quindi questa è una funzione diciamo così di primo così nel file proprio direttamente potrebbe essere anche un metodo statico della classe volendo oppure più comunemente si usa direttamente la notazione funzionale e si crea un cosiddetto metodo anonimo una funzione anonima dentro il codice stesso ora questo rende tutto molto comodo e esprimibile in poche righe ma lo rende poi molto annidato e a questo punto molto poco insomma molto poco gestibile per cui insomma vedete voi cosa vi conviene però in genere si usa questa notazione qui ok che esprime un metodo una funzione senza nome che viene dichiarata direttamente qui dentro la sintassi è un po' arcana questo significa è un metodo anonimo che prende void e ritorna void di nuovo ok nel senso che non c'è non c'è non ritorna nulla se ritornasse un intero farebbe così ma questo non è infatti questo è un errore di tipo perché non possiamo ritornare a nulla quindi questo è un metodo che fa qualcosa cosa fa? allora l'idea è che vogliamo incrementare il nostro contatto ok adesso ho salvato l'arri rimpacchettato in qualche modo dart in maniera poco soddisfacente ma va bene così quindi adesso abbiamo un un cosiddetto event handler quindi un gestore dell'evento il pulsante sotto cliccato che modifica il contatore e ci si aspetterebbe che tutto venga ricostruito quindi la nostra home page qui nonostante Flutter ci sia avvertendo del fatto che stiamo facendo delle cose completamente sbagliate però si può ancora fare proviamo a vedere cosa accade non molto in teoria però dovremo quantomeno vedere il pulsante quindi già qualcosa ok perfetto quindi abbiamo la nostra stampa qui io clicco qui vedete che il pulsante è interattivo quindi fa il suo effetto di click molto accattivante il ah tra l'altro count possiamo stampare qui stampiamolo da backprint questo potrebbe essere utile vediamo quanto vale il contatore così qualcuno ce lo dice sennò è un po' e no perché lo vediamo subito però no dovrebbe dovrebbe incrementare ma ok quanto incrementa effettivamente non vale sempre uno perché viene messo a zero quando viene costruita home page quando home page viene costruito cioè quando home page viene istanziato che avviene qui viene messo a zero poi quel widget rimane esiste nell'albero dei widget finché non viene ricostruito e non viene ricostruito mai perché se venisse ricostruito ah potremmo vedere lo sapremmo se qualcuno stampasse da backprint qui quindi qui facciamo print this per cui qui quando compare building home page sappiamo che qualcuno ha chiamato build che comunque non necessariamente significa che qualcuno ha costruito home page quindi ci sono due cose diverse nonostante build sia un nome un po' come nomenclatura confonda un po' da una parte c'è la costruzione dell'oggetto cioè la costruzione dell'istanza della classe home page che è una cosa che vale per dart e da una parte c'è la build quindi la costruzione per usare il termine uguale la costruzione dell'albero di widget che è quello che riguarda flutter sono due cose diverse da una parte c'è la classe che viene istanziata e che inizia counter a zero dall'altra parte c'è build che costruisce l'albero di widget di quell'oggetto lì però non lo reistanzia quindi se noi dentro il button dopo the back print invoca su build sicuramente dovremmo modificarci se qui ah sì esatto esatto sulla carta poi non si può fare per vari motivi però sì quindi allora questo io sto cliccando qui questo link quadratore vale home page non è mai ricostruita perché non ha modifiche quindi il quadratore rimane non viene rimesso a zero in sostanza perché un page è sempre la stessa istanza è solo che l'interfaccia dente non si aggiorna che cosa bisogna fare per convincere l'interfaccia dente a costruirsi come ha detto lei giustamente se noi riuscissimo a fare qui this build saremmo molto felici però questa cosa intanto non si può fare a livello di costrutto perché non abbiamo il build context adesso poi vi dico che cos'è quindi non abbiamo nulla da passare qui dentro e anche se volessimo farlo questo va contro tutti i dettami di platter e se lo facessimo si arrabbierebbe moltissimo perché richiamato da platter stesso è un po' come il anzi se volete sempre dei paralleli con win32 è un po' come la vmpaint il messaggio di di pittura della nostra finestra non possiamo mandarci da soli quello in realtà non l'avevo testato su windows però io posso mandarmi un un messaggio vmpaint perché è un messaggio come tutti gli altri però se windows non mi ha dato il permesso di dipingere non c'è modo che io dipinga quindi stessa cosa vale per platter su platter io posso fare quello che voglio nella mia classe ma finché platter non mi ridipinge non c'è modo che io mi modifichi il suo schermo perché perché l'interfaccia è funzionale quindi vengo costruito non sono io che mi ricostruisco da solo non sono io che mi ridipingo da solo per cui bisogna dire in qualche modo a platter guarda qualcosa è cambiato qui dentro mi fa il favore di dipingermi quindi ci sospetterebbe di avere qualcosa che somiglia all'invalidate no se dobbiamo fare sapere dei paralleli di win32 cioè dire a flatter guarda questo widget qui non è più giusto così mi devi aggiornare non si fa così anche se si fa una cosa abbastanza simile tra virgolette seppure più intricata a livello concettuale ossia come si fa allora visto che flatter è cioè insiste molto sul fatto che tutti i widget sono stateless quindi anche i widget con stato anche i widget che in qualche modo hanno uno stato interno in realtà non ce l'hanno cioè sono dei widget immutabili una cosa inossidabile di flatter che però hanno un sottocomponente parallelo una specie di oggetto fratello gemello che contiene lo stato tipo un pacchetto che sta da un'altra parte a livello proprio di struttura logica dell'applicazione che contiene che pacchetta che incapsula lo stato ok quindi è come se avessimo un oggetto perché lo stato è il male del mondo cioè perché le interfacce utenti si rompono perché qualcuno non gestisce bene lo stato perché in flatter è la stessa cosa lo stato è quello che rompe l'interfaccia utente quindi dobbiamo gestire in qualche modo perché l'utente deve purtroppo modificare questo stato benedetto con cui lui sta lavorando però è quello che rende complicato l'interfaccio utente se non ci fosse stato viveremmo in un mondo perfetto di pagine html statiche ma non è questo il caso per cui per contenere lo stato e metterlo da parte in modo che nessuno lo possa vedere si creano dei widget che sono stateful che però sono comunque immutabili che hanno un oggetto parale sporco brutto che nessuno vuole vedere che è lo stato dell'oggetto si separa correttivamente questi due oggetti per cui per arrivarci finalmente ci siamo messi un po' ma ci si arriva facciamo questa cosa ossia tramutiamo home page in un oggetto stateful widget quindi l'arrivo è questo per farlo ripulisco un attimo il codice perché tutte queste cose che abbiamo provato a fare non sono valide veramente per cui togliamo il counter torniamo al nostro magico mondo di widget perfettamente statico il counter vale zero il button qui non fa nulla quando viene cliccato ok quindi siamo di nuovo in un mondo ideale di staticità ok tutto è noto a priori questo può essere const non mi sape a scrivere ok convertiamo questo come si fa? allora per farla breve si può usare sempre il nostro l'assistenza di questo studio code per cui con la lampadina vi compare il suggerimento di convertire l'oggetto in uno stateful widget quindi lo facciamo e poi vediamo che cosa avviene clicco avvengono delle cose e siamo da cavapiedi quindi questo qui lo possiamo di nuovo eseguire vedete che non è cambiato nulla perché la conversione in stateful widget in sé non cambia nulla quindi non è cambiato ancora nulla siamo ancora in una condizione in cui c'è il pulsante clicchiamo non accade nulla però ci si arriverà ok siamo ancora qui però my homepage cioè homepage è stateful che cosa significa? che allora la classe homepage è questa qui quindi prima era stateless widget questo qui e la build era qui dentro gli stateless widget sono dei widget comodi perché sono immutabili che non contenendo dello stato non possono essere cambiati cioè una volta che sono stati costruiti con i loro parametri non cambiano mai come voglio dire è che il nostro counter display è un widget che sulla carta può mostrare vari interi quindi in base a come lo costruiamo potrà mostrare hai cliccato 0 volte hai cliccato 10 volte hai cliccato 1000 volte quindi può mostrare vari testi in base a come viene costruito però una volta che è stato costruito con l'intero 1000 non c'è modo di schiodarlo giusto quel 1000 non è modificabile intanto perché è final è final giusto perché così esprimiamo in maniera in maniera così nel linguaggio stesso il fatto che non si modifica però anche se anche se non fosse final anche se questo non fosse const comunque non potremmo modificare counter cioè non c'è nessun uno strumento che ci permette di modificare questo contatore qui giusto? cioè se il final non final non cambia nulla cioè non può essere una volta costruito quindi una volta che qui ho fatto counter di state 0 quello 0 rimane per sempre in quel widget lì ok stessa cosa quindi lo state test widget è comodo perché la build è direttamente qui dentro perché ha tutte le informazioni necessarie per costruirsi perché il counter è qui dentro è fisso non cambierà mai quindi quando costruisco interfaccia non faccio quando siamo stateful cambiano un po' le cose perché abbiamo bisogno di due oggetti separati quindi già da una parte c'è lo stateful widget che cosa fa? che non ha più la build perché non ha la build? perché non ha lo stato nel senso che quando creiamo uno stateful widget in realtà andiamo a creare una piccola gerarchia di due widget gemelli in cui uno è stateful widget l'altro è state del widget in questione quindi abbiamo un oggetto che è home page che estende se è home page e poi abbiamo un oggetto che per convenzione se il studio code lo rinomina con underscore nome del widget fratello diciamo così state quindi è lo stato di home page e l'underscore serve perché lo stato in genere è privato lo stato chiaramente viene incapsulato dal widget quindi non deve essere mostrato al di fuori da questo file questo estende state generico del widget stesso a cui fa riferimento è un po' intricato però capite che quindi lo stato è strettamente legato a home page non può essere lo stato di nessun altro widget perché è lo stato espressamente di quel widget a questo punto la build non è più del widget stesso il widget non ha idea di come costruirsi il widget dipende dello stato interno che lui non conosce quindi il widget qui è solo il come si potrebbe chiamare è il placeholder è il come è il placeholder in italiano è il segnaposto grazie mille il segnaposto all'interno dell'altro dei widget che dice ok qui ci va un widget che ha uno stato interno però che aspetto abbia io non ne ho idea perché dipende dallo stato cioè in base allo stato interno del widget può cambiare radicalmente aspetto per cui dentro la classe state qui possiamo metterci dello stato finalmente qui dentro siamo liberi di metterci quello che vogliamo perché state non è immutabile lo state ovviamente è stato mutabile per definizione e quindi possiamo metterci degli oggetti come il nostro famoso counter ok che è questa variabile che può essere incrementata e modificata by homepage state è quello che finalmente riesce a fare la build per cui dentro la build qui possiamo fare riferimento alle variabili di cui abbiamo accesso quindi qui passo counter questo non è più const ovviamente ok le altre cose sono tutte const sulla carta quindi possiamo anche decorare in questa maniera se vogliamo essere proprio precise e ok a questo punto di nuovo non cambia nulla perché counter non viene modificato però giusto per apprezzarlo siamo ancora ancora ok a questo punto possiamo modificare questo oggetto questo contatore qui si ma non così facilmente cioè adesso ci aspetteremmo che si può fare counter più più questo si può fare ma non ha effetto di nuovo tanto per diluderci di nuovo con Flutter quindi di nuovo adesso ho messo la modifica del contatore nel click questo più più si può fare questo modificare questo contatore qui ma di nuovo non accade nulla perché? perché bisogna avvertire Flutter del fatto che l'ho stato modificato tutto qui ok bisogna fare l'invalidate di Flutter come si fa a fare l'invalidate? prima non si poteva fare perché eravamo dentro uno state less widget quindi non c'era modo per dire a Flutter guarda ricostruiscimi dentro state si può fare e il metro per farlo si chiama set state e per come è stato costruito purtroppo rende illegibile il nostro codice per cui set state è una funzione su state quindi è della classe state che prende in input un'altra funzione anonima che prende void e ritorna void quindi dentro set state ci va un'altra funzione che non fa nulla se non modificare lo stato non mi spiego perché è fatto in questa maniera però insomma è così quindi una volta dovremo modificare lo stato perché è un platform di access state e poi si trova per il nostro modificare lo stato è un po' particolare però adesso vi dico perché cioè perché è così però c'è un motivo tra virgolette ok però adesso giusto per districare questa sintassi un po' è legibile quindi c'è on pressed che è l'event handler quindi il click del pulsante richiede una funzione come parametro la funzione è questa ok che può fare varie cose chiaramente nel momento in cui deve modificare lo stato quindi deve andare a modificare le variabili che hanno un effetto sulla grafica lo deve fare non su non direttamente dentro la variabile della funzione stessa ma dentro un blocco set state che è la funzione che segnala a flat guarda sto iniziando a settare lo stato non toccare nulla qui dentro questa funzione qui invoca un'altra funzione che è questa funzione anonima qui dentro che può modificare lo stato perché è fatta in questa maniera qui perché questo set state qui cioè questa funzione qua che viene passata a set state viene eseguita viene viene lanciata viene invocata da flat per stesso quindi stiamo passando una funzione di modificare lo stato a flat per dicendogli guarda devo modificare lo stato puoi interrompere l'attività di rendere torsione un secondo così posso farlo ok perché quello che avviene è che flat eseguirà questa funzione qui nel momento in cui non sta renderizzando lo schermo cioè si interrompe come se fosse un singhiozzo si interrompe esegue questo codice qui questo modifica lo stato e poi riprende ad aggiornare lo stato aggiornare l'interfaccia tecnica ok quindi serve per quello ed è come se voi cioè se volete mapparlo correttamente è proprio se facesse come se facesse l'invalidate e lo repaint su win32 cioè perché quando dipingete qualcosa nel win32 cosa fate mandate invalidate alla finestra la finestra si invalida poi quando si ridipinge lo fa con lo stato aggiornato quando arriva il messaggio paint quindi in un certo senso è tutto questo meccanismo qui in tre righe ok adesso che sia più o meno leggibile il win32 è una materia aperta al dibattito però il fatto è che bisogna fare quello ok per cui andiamo a vedere se tutto questo funziona perché dopo tutto questo pane girico di cose sarebbe bello che qualcosa funzionasse quindi adesso clicchiamo e mi aspetto che quel contatore incrementi e finalmente magia con estrema fatica abbiamo fatto una cosa che è molto primitiva e vediamo una serie di cose qui nel debug adesso vediamo in dettaglio perché avviene ultima cosa cioè prima di vedere in dettaglio quello che avviene un'altra cosa sulla auto reload auto restart e così via se adesso io cambio questo colore qui e lo rendo arancione ho cambiato qualcosa di puntuale nell'interfaccio utente per cui posso tranquillamente fare hot reload che è la versione base r minuscola hot reload ricostruisce le interfacce e questa qui è diventata arancione questo non ha cambiato però vedete che qui lo stato è rimasto integro quindi questo mantiene 13 perché perché Flutter non ha ricostruito tutto l'albero dell'albero dei widget e quindi il nostro oggetto state dove questo qui home page state non è stato ricostruito quindi non è ripartito da zero questa è l'idea per cui ancora mostra 13 se adesso faccio hot restart hot restart riparte dalla radice e ricostruisce tutto quanto da zero cioè ricostruisce col costruttore intendo e poi fa anche la build quindi fa construct e build hot restart fa esattamente questo e adesso il cliccato sarà varia a zero una volta che il costruttore ha inizializzato lo costruito per una volta generale soprattutto il costruttore si era a zero sempre lo stato poi quando diciamo invece su tanto ripeto dell'interfaccia grafica lo stato diventa invariato esatto sì esatto cioè fin tanto che questo oggetto qui non viene ricostruito lo stato chiaramente viene mantenuto e quindi possiamo fare build build intendo la costruzione dei widget un miliardo di volte questo counter qui rimane col valore attuale ok appena ricostruiamo ricostruiamo col costruttore intendo home page a quel punto viene ricadato lo stato e si si riazzerra il contatore ok questa è l'idea dato la stessa cosa vale anche per questo colore casuale quindi quando faccio hot restart appunto riparte tutto e ricostruisce il colore casuale tra l'altro ah ecco altra cosa volevo dirvi quando cioè no altra cosa volevo dirvi quello che vi accennavo prima adesso diamo un'occhiata a questo debug molto prolisso perché quando clicchiamo qui in realtà si aggiorano tante cose che ci non non necessariamente ci aspettiamo che che vengano ricostruite un po' di lag perché quando clicchiamo se parare un po' quando clicchiamo su clicca qui cosa viene avviene che il counter ora è 12 questo va benissimo viene rebuildato home page state eccetera che è il nome di questo oggetto qui questo ok quindi viene viene rebuildato l'oggetto che contiene lo stato ma questo necessariamente ovviamente avendo modificato lo stato interno deve essere rebuildato per forza nel senso che è stato modificato è invalidato rifaccio build dell'oggetto ok e poi viene rebuildato anche la riga colore casuale cosa che non è completamente intuitivo perché viene rebuildata perché riga colore casuale non è stata modificata direttamente però è figlia di un oggetto che è stato ricostruito quindi è figlia di my home page state e quindi per forza viene ricostruita ogni volta che la madre il widget padre viene costruito quindi a cascata modificare questo puntatore qui ha un effetto in realtà abbastanza profondo nel senso che tutta l'interfaccia viene ricostruita perché tutta l'interfaccia è dentro my home page è dietro my home page state piuttosto le altre non vengono ricostruite ma soltanto perché sono const questa cosa è data in mente il const viene usato in flutter in vari modi in genere per bloccare la ricostruzione dell'interfaccia quindi è proprio un blocco una specie di ferma porta diciamo così che vi permette di non fare non fare non fare la ricostruzione a cascata perché qua appena si incontra un oggetto const flutter si accorge del fatto che quel widget è uguale a quello precedente quindi quando c'è una ricostruzione in realtà poi ho delle slide che lo rendono un pochino più evidente però quando c'è una ricostruzione quello che avviene è che l'albero precedente di widget non viene buttato via immediatamente viene mantenuto e poi si crea un altro parallelo di widget che viene ricostruito in maniera interattiva appena c'è un widget che rimane identico perché è la stessa istanza perché è identico quello precedente quella ricostruzione si interrompe quindi ricicla i pezzi di albero già esistenti appena il widget non è cambiato ok quindi la ricostruzione di flutter è molto ottimizzata sulla base in sostanza della identità dei vari oggetti che contiene per cui appena c'è un oggetto che non è stato modificato in alcun modo dentro l'albero precedente si prende si sposta e si ricicla ok nell'albero nuovo per cui in questo caso qui my homepage state lo dirò homepage state viene modificato ma non cioè ma scusate alcuni suoi componenti non vengono modificati e non vengono modificati perché non possono essere modificati questa ricca colorata qui sono tutti oggetti identici a prima perché c'è un const ok quindi const significa che c'è una sola istanza di quell'oggetto per come è fatto Dart in base al colore che contiene quindi ricolorata red, green, blue e orange ci sono quattro istanze ricolorate in memoria per i quattro colori e non vengono mai rigenerate se togliamo const a un di questi questo per esempio vedrete che le cose cambiano radicalmente perché a questo punto ogni volta che ricostruiamo l'interfaccia viene ricostruito anche l'oggetto non più const che è quello blu prego in questo caso siccome stiamo soltanto modificando la struttura del build non potremmo fare sempre l'oggetto per velocità e sì il hot load è più veloce ma funziona bene se facciamo modifiche estetiche quando facciamo modifiche strutturali il hot load poi non si comporta cioè non mostrerebbe quello che voglio mostrare ossia che quell'oggetto lì viene ricostruito perché perché rebuild soltanto i singoli i singoli oggetti cioè fa li aggiorna graficamente ma non li ricostruisce proprio per cui si potrà fare ma in quel caso si sarebbe comportato come prima ancora a questo punto clicco qui e dovremmo vedere che si aggiornano tre oggetti quindi home page state ricca colorata che è quella blu questa volta viene ricostruita e poi ricca colore casuale che viene ricostruita sempre perché non è const ok a questo punto abbiamo un oggetto che si ricostruisce anche se non c'è bisogno anche se non è variato quindi il const serve esattamente a quello serve per bloccare l'aggiornamento dell'interfaccia e adesso insomma questo è un buon esempio di rica colorata e serve un po' quello poi si lo sfrutteremo in tante cioè in più occasioni sempre con l'intento di impedire a Flutter di aggiornare tutto quanto è a cascata perché chiaramente il const non è obbligatorio per cui Flutter vi suggerisce di metterlo o meglio l'estensione vi suggerisce di metterlo dove capita però non è obbligatorio utilizzarlo in genere visto che il modello applicativo è proprio quello della no? quello funzionale di cui parlavamo per cui l'interfaccia la possiamo interpretare in questa maniera qui in assenza di const in realtà noi non ci interessa più di tanto se lo stato cambia io apro F che è l'insieme dei mail dei mail di build e mi aspetto l'interfaccia utente che genero sia coerente con quello che viene mostrato ed è quello che accade quando il contatore viene modificato si rebuilda tutto l'interfaccia utente viene generata ed è coerente con lo stato interno che è il numero che impostiamo sul contatore se F è inefficiente non è un problema mio nel senso che cambia soltanto la performance di attivazione di costruzione però l'interfaccia utente si comporta sempre la stessa maniera per cui di base se voi fate l'applicazione nella maniera più inefficiente possibile non usate nessun cons non fate nessun aggiornamento non fate nessuna attenzione a come riservo stato però Flutter funziona quindi non bisogna le cose che faremo da adesso in poi sono tutte delle considerazioni per ottimizzare questo aspetto di Flutter quindi per ridurre per quanto possibile le attività di ricostruzione per fare in modo che soltanto gli oggetti che vengono veramente modificati vengano ricostruiti però di base se non facciamo nessuna attenzione non si rompe nulla semplicemente la nostra interfaccia viene costruita interamente ogni volta che qualcosa cambia ok immaginate che la vostra applicazione contenga più stato di quello che continua adesso quindi adesso chiaramente è l'esempio più primitivo possibile però immaginate di avere qualcosa di più sofisticato di un intero immaginate di avere non so un esempio che ne so ripetate Gmail mail in flattro per dire quindi avete una homepage state che contiene la lista delle mail ogni mail contiene destinatario emittente il testo le immagini e così via quindi sono oggetti molto così importanti di dati e sulla carta voi se non fate attenzione non fate nessuna attenzione particolare a come viene costruita l'interfaccia voi potete partire sempre ogni volta da zero e ricostruire l'interfaccia a partire dai dati del vostro site state quindi di base può andar bene anche questo se avete una singola homepage è stateful quindi contiene lo stato qui c'è tutti i dati di cui vi occupate e poi la build ricostruisce tutta l'interfaccia questo si può fare è chiaramente molto lento perché appena qualcuno cambia qualcosa di molto piccolo tutta l'interfaccia viene costruita di conseguenza anche se qualcuno cambia aggiunge una stellina su un'email per marcarla in qualche modo tutte le mail vengono ricostruite e tutta l'interfaccia viene ricostruita quindi chiaramente non è questo che vogliamo fare vogliamo ottimizzare fare in modo che soltanto alcuni elementi dell'interfaccia si aggiornino però funziona anche questo questo approccio qui brutale in cui non facciamo attenzione è simile a quello che usavamo nelle Win32 quando facevamo invalidate di tutta la finestra diciamo invalida tutta la finestra ridipingi tutto e stava bene così perché le nostre interfacce erano molto molto primitive quindi cambiava abbastanza poco però se nelle Win32 bisognerebbe ottimizzare le zone da rebuildare sulla base di quello che avviene a maggior ragione possiamo provare a farlo qui in Flutter che ci dà alcuni strumenti per farlo in maniera puntuale giusto per dimostrarvi questo anche facciamo un altro esempio con un colore ecco per esempio una buona idea potrebbe essere quella di spostare il colore non dovete replicarlo ma giusto per fare un esempio facciamo qui un colore ok questo colore qui lo passo a questo oggetto qui questa rega colorata non è più costante perché dipende da un elemento esterno va bene e a questo punto quando qui aggiorno il contatore aggiorno anche il colore sempre con questo metodo dei colori casuali che rubo da qui quindi quando clicco sul pulsante non soltanto riprimento il contatore ma cambio il colore ok qui chiaramente dentro setState posso fare posso modificare tutto lo stato del mio oggetto stato quindi qui sto modificando sia color che counter color lo propago su riga colorata questo lo rimetto const perché è sempre blu qui metto come debug ok ricostruisco adesso vedremo che quando clicchiamo qui forse non è un esempio particolarmente cambio l'esempio per un secondo ma non è quello che quindi qui adesso ho incremento qui e cambia il colore qui sopra giusto? e va bene quindi qui ci sta che tutto venga aggiornato ora se voglio rendere cliccabile questo qui no scusate questa riga colorata qui corrisponde a questa riga colorata qua giusto? quindi tutto questa riga qui è questo si può trasformare anche questo in un pulsante se vogliamo non mettendo dentro un elvise button per forza ma mettendo dentro un widget che riconosce i click ed è in il platter si chiama gesture detector quindi un riconoscitore di gesti quindi lo wrappo lo incarto dentro un gesture detector ok che ha unico figlio unica colorata e vedete che quando andiamo a vedere i parametri di gesture detector ha una serie di di funzioni che possono essere invocate in base a quello che l'utente fa quindi c'è soprattutto i gesti classici dell'interfaccia touch quindi c'è il force press c'è il drag quindi lo trascinamento il long press eccetera quello più banale è on tap on tap è il click semplice l'altro on tap il gergo è quello del touch quindi chiaramente il platter nasce per l'ambiente mobile quindi on tap però è equivalente al click in realtà per cui se lavorate su windows e macquist chiaramente l'on tap sarebbe il on click è simile simile ma ha una semantica un po' diversa perché l'on press dovrebbe essere no non c'è il long press dice o quale nel senso noi su testo il testo lo abbiamo on tap invece su il path lo abbiamo ah ok quello lì facciamo gli altri è uguale è uguale sì adesso i dettagli bisogna vedere come è fatto il button però si può immaginare che dentro button ci sia un gesture detector che reagisce all'on tap si può andare a vedere non è il caso ma vediamo un po' se c'è no quindi lo fai in altro modo però o forse lo fai in un altro file che non vediamo però in sostanza è la stessa cosa sì il nome cambia un po' però la a livello di codice non cambia molto perché è sempre una funzione void per cui di nuovo ci troviamo in questa condizione qui quindi quando clicchiamo sul colore o sulla riga lì vogliamo che cambi il colore per cui prendo questo bellissimo codice qui lo copio qui non incremento il contatore e qui non cambio il colore a questo punto abbiamo due oggetti interattivi il pulsante che incrementa il contatore e la riga che parte come arancione che cambia colore cambia colore tra l'altro su tutto il blocco quindi attenzione a dove mettete i gesture detector perché questo qui ingloba il suo child è riga colorata nella sua interezza proprio tutta la riga colorata è cliccabile e quindi ovunque voi clicchiate qui rientra tutto nel vostro gesture detector quindi quando clicco qui viene ricostruito viene ricostruito il testo applicato un tot volte anche il colore casuale chiaramente ma viene ricostruito anche riga colorata riga colorata questo qui che corrisponde a questo oggetto qui viene ricostruito perché non è const non può essere const essendo reattivo cioè reagisce ai click e soprattutto dipende dallo stato che non è const quindi non può essere const questo blocco qui non viene modificato dal click sul pulsante ma viene comunque ricostruito ok? cosa è chiaro se clicco qui avviene la stessa cosa quindi clicco qui cambia il colore però cambia il colore anche casuale qui sotto perché tutta la homepage viene ricostruita e in realtà viene rebuildato anche il nostro text display qui che mostra il testo adesso non si vede perché non lo stampo magari mettiamo quindi il nostro counter display viene ricostruito building this e magari ci mettiamo anche il valore del contatto ok? ok quindi questa è l'inefficienza di cui parlavo prima nel senso che adesso lo stato è a monte cioè da my homepage homepage state scusate homepage state contiene tutto lo stato sia il colore che il testo e quindi chiaramente ogni volta che viene modificato ricostruisce tutto se stesso ok? quindi tutti gli elementi che ho composto quindi qui cliccando sul colore cambia sul colore ma in realtà in rebuildato il colore casuale per forza e anche ha cliccato zero volte poi chiaramente a livello grafico non cambia nulla perché ovviamente non se ne accorge del rebuild però non è quello che vorremmo prego da later si flutter quando in questo caso due due parametri dello stato cioè uno circolatore del colore si se cambia sul colore flutter rebuild sempre o rebuild si rebuild tutto perché non ho modo di capire che cosa è cambiato nel senso che set state è un metodo generico avverte flat che c'è una modifica di stato poi dentro qui allora set state avviene cioè a effetto sia che lo stato cambi che non cambi proprio anche se qui commentassimo adesso commento il colore la modifica di colore scusate commento qui quindi set state adesso non sta facendo non farà nulla se clicchiamo sul colore arancione il colore arancione rimarrà arancione quindi non c'è modo di cambiarlo però non toglie vedete che sto comunque ricostruendo perché set state dice semplicemente guarda non è più valido qualcosa è cambiato probabilmente quindi adesso il colore non cambia però comunque viene rebuildato quindi questo è il problema in sostanza il problema che non ha certo punto può essere cioè l'importante è che l'interfaccia sia l'interfaccia sia coerente e il fatto che sia coerente è garantito dal fatto che lo stato è uno quindi lo stato è tutto qui e noi stiamo costruendo tutta l'interfaccia sempre in modo tale che sia coerente quello che volevo quello della coerenza è importante parlando di un commento in chat un attimo bisognerebbe fare un faithful widget per ogni singolo elemento che si vuole aggiornare singolarmente esatto quindi idealmente per ridurre gli aggiornamenti di stato lavorando soltanto con gli faithful widget bisognerebbe prendere lo stato e metterlo nel punto più basso possibile della nostra gerarchia cioè più verso le foglie andiamo meno torna l'albero dei widget chiaramente quindi più più in basso possiamo mettere lo stato meglio sarà questo non sempre è possibile adesso magari per fare un esempio anche di questo che è un buon esempio possiamo farlo per cui per esempio il contatore anzi è un buon esempio vediamo ok facciamo facciamo un esempio con il colore facciamo due esempi un altro è tutto ancora più chiaro aspetta però prima per rimanere sulla coerenza dico sempre della coerenza interfaccia che è importante perché Flutter fa varie cose molto bene e una delle cose che fa bene è assicurarvi assicurarsi cioè garantire a livello proprio inscalfibile che la vostra interfaccia sia sempre coerente col suo stato interno perché se noi abbiamo lo stato interno che ha dentro uno faithful widget quando facciamo build voi sapete al 100% che cosa verrà costruito alla fine della vostra build e verrà sempre costruito in maniera coerente per cui a meno che non vi impegnate veramente particolarmente non c'è modo di dimenticarsi di aggiornare qualcosa ok perché una cosa che avviene spesso lavorando in maniera imperativa è che magari c'è un pulsante che aggiorna una varabile interna un contatore un qualcosa del genere se voi non dite imperativamente alle le vostre finestre in giro di aggiornarsi e rappresentare lo stato aggiornato non c'è nessuno che lo fa per conto vostro quindi se magari vi dimenticate di aggiornare un pulsante di renderlo di risattivarlo di spostare degli elementi grafici e così via l'interfaccia utente non è più coerente con se stessa e le cose si rompono e l'utente rimane frustrato perché in alcuni casi le cose non si comporse in maniera prevista infatti questo non può avvenire perché l'interfaccia viene sempre ricostruita da zero ogni volta cambia qualcosa per cui apposito di coerenza se io metto qui un'altra espressione del contatore qui metto il contatore non che sia praticamente utile però in questo caso è un dato per buono o qualcosa di simile comunque un dato che dipende dal contatore facciamo un contatore per cui non che sia non che sia utile però per dirvi che può essere anche un qualcosa che dipende dal contatore ma non è necessariamente espressione diretta del contatore adesso ci sarà un test in più che parte da zero e poi sarà sempre il doppio del contatore ok il contatore è zero clicco qui poi diventerà due quattro così via questi due valori quindi cliccato cinque volte e contatore dieci sono sempre coerenti per definizione cioè non c'è modo per renderli incoerenti in win32 sarebbe molto facile rendere incoerenti se vi dimenticate in alcune condizioni di non settare il testo di uno delle legal quindi è molto facile magari vi dimenticate commentato un pezzo del codice non so chi si occupa di quel componente non vi parlate bene e ci si perde per strada quindi qualcosa non si aggiorna in Flutter è impossibile perché tutti i componenti che sono aggiornati in automatico a ogni volta che lo stato viene aggiornato quindi questo qui vi garantisce la coerenza al 100% in ogni singolo istante però di contro appunto come si diceva dipendiamo da uno stato che a cascata può aggiornare più di quello che è dovuto ovviamente quindi è sulla carta Flutter è meno efficiente per natura di quello che avremmo fatto con le win32 adesso per per esprimere cioè per fare quello che diceva il vostro collega in chat giustamente per ridurre questo problema no basterebbe spostare verso il basso lo stato quindi adesso prenderemo lasciamo il contatore di dove è il contatore rimarrà parte di fail state però per ridurre gli aggiornamenti prendiamo questo oggetto qui no questo del del colore e lo spostiamo più in basso quindi lo prendiamo da dove è lo spostiamo più in basso nella gerarchia e vedrete che in questo modo riusciamo a ridurre gli aggiornamenti perché a quel punto soltanto il colore si aggiungerà ok per cui a questo punto questo blocco qui questo segue un colore regato allo stato questa bella cosa qui che ho scritto la prendiamo la prendiamo via non c'è più e lo rendiamo un widget lo sposto giù quindi tutto qui questo è il canto di speso lo tocco vabbè magari lo mettiamo qui o anzi lo chiamiamo color switcher parto da state switcher anche se sappiamo benissimo che sarà uno stateful widget però per arrivarci passo passo qui cosa facciamo il ritorno del blocco di prima questo blocco qui non funziona perché erano due oggetti giusto quindi questi due oggetti non li possiamo non li possiamo mettere possiamo metterli in un oggetto in un singolo widget quindi mettiamo dentro una colonna di nuovo così questo punto ci possiamo incollare e qui non funziona ancora perché non c'è il colore chiaramente per cui da qualche parte bisogna metterlo quindi questo oggetto qui diventa stateful convertiamo ok non cambia molto adesso l'unica cosa che bisogna fare è spostare il colore da uno stato all'altro vedete quindi ho color switcher che è l'oggetto widget color switcher state che incapsula lo stato dell'oggetto ok lo prendiamo questo qui non serve più niente infatti ci lo dice anche dart ci dice questo qui che ci sta a fare perché non lo usi giusto lo tolgo e lo metto nello stato del color switcher effettivamente senza modificare alcunché più o meno abbiamo spostato l'oggetto sotto color switcher notate che la cosa particolare è che color switcher è stateful è vero ha dello stato interno però in sé lui cioè color switcher stesso è immutabile quindi viene costruito una singola volta non ha parametri è const quindi è un blocco che non viene mai aggiornato però ha internamente dello stato quindi è immutabile per modo di dire è un widget immutabile che contiene stato quindi è mutabile però come oggetto nell'albero qui Flutter sa che non può essere modificato perché lo stato sugestisce lui internamente ok per cui non dipende dallo stato esterno ok cioè non dipende dal contatore per esempio adesso abbiamo due oggetti nello stato quindi c'è poco da fare c'è il contatore e il colore color switcher dipende soltanto dal colore ok per cui agli occhi di chi lo usa da fuori è immutabile non c'è nulla con cui costruirlo non c'è nulla da passargli quindi in sostanza è immutabile e possiamo metterlo come oggetto immutabile quindi qui ci mettiamo const color switcher giusto? quindi si è un widget o comunque possiamo mettere sopra const sì esatto perché il widget in sé è costante perché non è costante la constità è una è una parola chiave di Dart quindi è const a livello di codice Dart perché questo oggetto qui questa classe qui è const perché non ha variabili non ha variabili quindi non ha stato interno ha stato interno a livello di Flutter quindi Flutter sa che c'è dello stato perché c'è color switcher state che è associato a color switcher ma il widget stesso color switcher non può essere modificato quindi quando vado a ricostruire il nostro albero è sempre quella l'istanza non cambia in alcun moto questo è un moto cioè dal punto di vista di Flutter questo oggetto qui non cambia mai a meno che non cambia il suo stato interno a meno che qualcuno non cambi qui questo color qua quindi a questo punto se salvo e ristarto tutto che cosa avverrà? avverrà auspicabilmente almeno che se clicco su clicca qui si aggiorna tutto eccetto il nostro ah tra l'altro forse potevo anche metterci un bug print tanto per adesso è sempre bene metterci lo mettiamocelo quindi building this ci mettiamo anche il colore che verrà stampato in maniera un po' illegibile ma ok ristarto ok non è proprio leggibilissimo però ecco quindi è stato creato con il coloretto al dettaglio adesso se clicco qui attenzione la cosa fondamentale cambia lo stato soltanto di color switcher perché color switcher viene modificato lo stato di quello e si rebuild soltanto quell'oggetto lì quindi clicco qui cioè solo quello lì è rica colorata perché rica colorata è l'oggetto che è dentro color switcher chiaramente quindi viene ribilitato per forza ok quindi cambia il colore e stiamo modificando soltanto questo oggetto qui quindi a livello concettuale soltanto questa zona qui viene rebuildata quindi flutter in questo caso è super efficiente perché rebuilda soltanto quell'elemento di interfaccia dentro ok in realtà rebuilda sinistra e destra forse anche non so se l'ho messi const o meno ok sono const quindi anche quelli dovrebbe poterli non rebuildare all'atto pratico ok quindi questo qui è quello che volevamo ora mentre se clicchiamo su clicca qui visto che questo oggetto qui è const non dovrebbe aggiornarsi quindi mi aspetto che building color switcher state per il mio per il mio colore non compaia infatti è questo ok adesso sto aggiornando l'interfaccia tente tutta eccetto questi blocchi qui questi qui non sto aggiornando perché sono costanti quindi i primi tre RGB qui sono tutti const quindi non possono essere ribelledati mai questo qui non viene rebuildato perché lo central widget è const e quindi non ha bisogno di essere ribelledato questo casuale viene ribelledato ma questo serve è uno spieghetto cioè come si può dire è il canarino che ci avverte il fatto che qualcuno ha ribelledato home page e quindi tutti i suoi widget sottostanti il pulsante viene ribelledato per forza e questo col test viene ribelledato ma questo è giusto perché chiaramente il test è stato modificato ma il contatore è stato modificato ok vi torno in qualche modo questo questo è fondamentale per capire tutto il resto di classi per cui diciamo che questo è abbastanza fondante come concetto ok ok ora chiaramente vediamo un attimo torniamo alle slide e poi facciamo una breve pausa e poi riprendiamo da qui per andare a vedere come possiamo non complicare ma come possiamo ottimizzare ulteriormente il passaggio dello stato perché chiaramente Flutter alla fine noi vedremo un po' come si costruisce l'interfaccio utente con le righe con le colonne gli elementi e così via però la difficoltà maggiore di Flutter non è tanto nel creare un interfaccio utente che sia apprezzabile o utilizzabile in qualche modo con gli elementi che abbiamo anche se appunto lo vedremo però la difficoltà maggiore è proprio gestire lo stato perché è diciamo così lo scoglio fondamentale di Flutter è estremamente questo per cui l'idea è questa abbiamo questo questo approccio per cui lo stato è da qualche parte nella nostra interfaccia utente c'è lo stato e il metro build lo prende lo manipola e poi scuta fuori una serie di widget che rappresentano quell'oggetto in qualche modo lo stato questo l'avevo visto la slide l'avevo vista brevemente ieri senza andare in realtà l'avevamo saltata direttamente intendo un attimo nel dettaglio ci sono due tipi di stato nella nostra applicazione possono esserci lo stato effimero cosiddetto o locale e lo stato invece che è generale la differenza qual è? che finché lavoriamo con stato effimero o locale noi possiamo rappresentarlo tranquillamente dentro un widget che vive da qualche parte nella nostra nella nostra gerarchia di widget che se si trova abbastanza in basso nella gerarchia fa sì che lo stato non il cambio di stato non ricostruisca l'intera interfaccia cioè è uno stato che vale per un sottoramo una sottoparte del nostro obbligo di widget e riguarda soltanto quella è l'esempio del colore qui dove lo stato è di questo widget qui e basta e il resto dell'applicazione lo ignora completamente quindi il fatto che qui sia arancione adesso e qui adesso sia verde non riguarda in alcun modo il resto dell'interfaccia quindi è letteralmente lo stato che però è sempre lo stato del widget stesso sì sì sì o di alcuni pochi sotto widget quindi questa cosa in realtà questo widget qui che sta cambiando colore è a sua volta composto da una riga due testi e poi un color non mi ricordo come si chiama color display quindi è composto da tre widget in realtà di cui soltanto uno dipende dal colore però ecco è un piccolo sotto elemento di widget che racchiude dello stato questo va benissimo finché che insomma il fatto che qui sia arancione in questo momento non è importante per un altro pezzo dell'applicazione perché in quel caso se questa cosa è rilevante in qualche modo allora si parla non più di stato effimero o locale ma di applicazione di stato è stato dell'applicazione non so che significhi che significhi potesse avere cioè stato dell'applicazione ossia stato generale che vale per tutta l'applicazione che riguarda più elementi delle interfacce utenti quindi più widget più sottocomponenti e così via possono dipendere da un unico blocco di stato che ne so preferenza dell'utente la lista delle mail in arrivo per Gmail la lista delle cose da fare per la vostra applicazione delle cose da fare altri esempi appunto login info quindi informazioni di potenziali di login per la vostra applicazione che si collega ai network di vario tipo e così via quindi in alcuni casi chiaramente lo stato è così pervasivo così importante che riguarda tutta l'applicazione quindi in quel caso chiaramente la cosa diventa un po' più sofisticata perché a quel punto sulla carta se quello cambia tutta l'interfaccia può essere modificata di conseguenza quindi ha degli effetti a cascata abbastanza importanti ok il futuro abbiamo visto i widget che di base sono stateless quindi il widget più primitivo che si possa immaginare è stateless quindi non ha stato non può essere modificato non dipende da stato esterno variabile quindi una volta che è definito a quell'aspetto lì è buono una volta costruiti con un dato valore nel costruttore non rimangono non vengono mai modificati e sono i nostri widget preferiti quelli non fanno danni e non causano grattacapi lo stato viene passato in costruzione quindi quello che si dice in gioco che lo stato viene passato dentro quindi quando costruiamo il widget forniamo subito le informazioni al widget e di conseguenza il widget da lì in poi viverà con quello stato lì perché è finale immutabile e non può essere modificato è l'esempio in codice di che ne so di tutti i vari testi che appunto per questo motivo sono const perché gli forniamo il testo da mostrare e poi quel text lì non cambierà mai non può cambiare neanche volendo oppure il container qui il container non è const per una serie modifi in realtà però non è const perché l'altezza dipende da del codice da un'espressione che può variare a runtime quindi questo expended può essere true o false in base a quello che noi passiamo e quindi l'altezza sarà o 60 o 20 però una volta che è stato costruito il container nonostante non sia const il container rimane comunque immutabile non può essere modificato quindi non è che il container cambia altezza in maniera dinamica il container lì è alto 60 o 20 e quindi rimane alto 60 o 20 non può cambiare questo si propaga cioè questa costruzione passando il dato da fuori sulla carta si può propagare fino all'elemento più cioè dalla radice all'elemento più in basso della vostra perché se volete potete avere ne so dello stato che vive qui dentro no che ne so qui dentro qui dentro homepage per esempio sulla carta potremmo tranquillamente fare in modo che è un po' complicato da fare però se volessimo potremmo qui passare qui un ciao mondo ho una stringa qui dentro questa la passiamo qua saluto non fatelo però così e questo saluto qui sulla carta cons chiaramente questo stringa saluto qui sulla carta può essere propagato in basso verso l'albero quindi potremmo fare in modo tale che questo saluto qui che viene da qua attenzione questo dato può essere cons potremmo mostrarlo dentro una stringa qualsiasi in questa stringa qui ciao mondo potremmo tranquillamente mostrarla ok lo potremmo fare qui dentro lo stato possiamo andare a leggere un saluto e questo possiamo farlo dentro state di un oggetto possiamo leggere lo stato del widget fratello parallelo che esiste con riferendoci al widget questo widget qui è un riferimento a homepage vi dicevo quando viene creato un widget stateful widget in realtà esiste nella gerarchia dei widget ma esistono in due cioè c'è lui e lo stato insieme quindi si conoscono e si possono parlare tant'è che lo stato può andare a leggere i dati di homepage quindi homepage sono sempre associati e quindi questo saluto qui viene passato dentro da fuori e viene mostrato a schermo ok quindi questo è un modo per fornire delle informazioni dalla radice praticamente e poi mostrarle a schermo sotto in una delle tante foglie della nostra applicazione ok non è cambiato nulla chiaramente però questo ciao mondo qui viene in realtà viene dal costruttore dell'applicazione quindi viene da qua ok quindi a cascata chiaramente questo può valere a tanti livelli però in genere a un certo punto passate lo stato dell'informazione questo a cascata può essere propagato verso il basso e cambiare l'aspetto della vostra interfaccia appena vi serve di tener traccia di stato che può essere cambiato a runtime a differenza di quel ciao mondo lì che è definito una volta che rimane statico per tutta l'esecuzione quindi questo non può mai cambiare chiaramente è una costante se bisogna cambiare qualcosa chiaramente introdusiamo dello stato locale per cui gli stateful widget lasciano quello ossia abbiamo dei widget speciali che possono contenere in sé lo stato che li riguarda ok quindi lo impacchettano incapsulano e poi a cascata lo espongono lo possono esporre ai widget stateful o stateful che siano di cui sono composti per cui l'idea è questa che se lo stato cambia cambia il sottoalbero di base questo abbiamo visto con l'esempio del colore e del contatore quando cambia uno stateful widget cambia tutto il sottoalbero per cui qui nell'esempio per fare un parallelo abbiamo lavorato prima col contatore e poi con il contatore no scusate il colore che riguardava solo quella piccola area questo qui che varia questo qui sarebbe questo elemento qui per esempio per fare un parallelo quindi cambio il colore e cambio questi pochi widget sottostanti quando cambio il contatore questo contatore qui lo stato è più in alto nella gerarchia perché è dentro home page non è più dentro il blocchetto del colore ma è dentro tutta la home page quindi ricostruisce tutta la home page quindi clicco qui e soggiorna un po' tutta l'interfaccia è come se parlassimo di questo widget che chiaramente una volta che viene ribidato ricostruisce tutto il blocco ok quindi più in alto è lo stato più è grave più impatta la sua ricostruzione come dicevo prima l'idea nostra è di spingere più verso il basso possibile lo stato in modo da evitare queste costruzioni così impattanti ok ok ok questo perché allora vediamo più in dettaglio come si costruiscono le interfacce poi facciamo una pausa per il caffè e poi andiamo avanti con la costruzione quando costruiamo un'interfaccia quando quando Flutter costruisce l'interfaccia cosa fa? va a costruirla blocco per blocco quindi passa e rassegna il nostro alberello dei widget e ad ognuno gli dà il contesto nel quale viene costruito questo contesto quindi questo questo questo spazio in cui viene costruito il widget è quello che si chiama in codice proprio si chiama build context quindi questo oggetto qui è il contesto all'interno del quale il widget viene costruito quindi è contiene tutti i widget nel livello superiore che sono stati costruiti fino a quel widget per farvi un esempio qui nella grafica quando viene costruito my app che è diciamo così il punto di partenza la radice vive in un contesto ancora vuoto quindi nel primo nel primo reame poi viene costruito e a quel punto esiste poi in cascata viene costruito il primo sotto widget che viene incontrato qui nell'esempio qui è material app questo material app qui vive in un contesto in cui esiste soltanto my app e poi a cascata questo contesto si riempie di widget resistenti ok quindi a un certo punto arriviamo qui al primo center questo qui siamo nel primo center che vive in un contesto molto più ampio che ha riferimento che ha nozione del cioè vive in questo contesto blu in realtà cioè ha visione del proprio spazio verdino in cui sta per essere costruito però vede anche quello blu quello rosso quello grigio quello giallo e quindi a cascata quando viene costruito dalla radice alla foglia no? perché va dall'alto al basso la costruzione necessariamente per cui ogni widget quando viene costruito ha un riferimento al contesto del widget padre e quindi può trovare se vuole i widget anzi gli avi gli avi della sua costruzione quindi in qualche modo che ne so la foglia text se ne ha bisogno può andare a leggere qualcosa che riguarda material app o my app o my homepage e così via ok? perché quel widget lì quel text lì è stato costruito in quel contesto lì per cui volendo può andare a cercare nella gerarchia questo come si fa? poi vedremo appena dopo la pausa come si fa però qui dentro già vi do un'anticipazione dentro context ci sono una serie di metodi di supporto di sostegno d'aiuto che vi permettono di andare a scartabellare nei widget che costruite quindi qui vedete che find root ancestor eccetera find ancestor state of time depend on elementi e così via quindi potete andare a scartabellare a cercare widget già costruiti perché sono stati costruiti prima cioè più in alto nell'albero della costruzione ok? questa è un po' l'idea per cui la dipendenza in questo caso è questa quindi questa icona qui può dipendere da materiale perché sa che quando è stata costruita da qualche parte nella gerarchia degli avi trova un oggetto di quel tipo lì questa è la costruzione inversa rispetto a questa qui vedete che normalmente quando costruiamo i nostri widget lo facciamo a cascata cioè partiamo dalla root poi la root passa i dati giù e questi poi sono visibili ai widget più in basso però nulla nulla vieta che i widget sottostanti possono in primo modo fare riferimento a cascata su oggetti sovrastanti ok? questa comunicazione appunto è biunivola quindi è bidirezionale in qualche modo quindi andiamo a vedere più in dettaglio come funziona quando dobbiamo far comunicare due oggetti che si vedono no? quando passiamo giù forniamo dei parametri in costruzione quando vogliamo notificare il nostro genitore di qualcosa che è avvenuto possiamo farlo con degli eventi per esempio questo l'avevo appena fatto lavorando con il pulsante il pulsante funziona esattamente così il pulsante viene generato con un costruttore che prende l'ingresso il widget il test e così via rivediamo un secondo per competenza il pulsante era da qualche parte l'ho perso questo qui il pulsante è Elevated Button gli passiamo quello che deve rappresentare la schermo quindi il testo e ci aspettiamo che lui ci invochi cioè ci chiami questa funzione quando viene premuto quindi gli passiamo l'oggetto con cui invocarci con cui segnalarci le cose quindi di base la comunicazione tra due oggetti legati è questa ok quindi io gli passo qualcosa e gli fornisco una funzione con cui lui può chiamarmi se ne ha bisogno questo è di base la comunicazione con due widget che sono su due livelli con una parentela di padre e figlio insomma questo chiaramente si può espandere su più livelli quindi chiaramente questo posso farlo a partire da MyApple quindi posso mettere un event handler dentro MyApp una funzione e passarla giù fino in fondo e fare in modo che l'ultimo pulsante in fondo sulla foglia chiami un event handler che in realtà è dentro MyApp ok sulla carta potrei farlo quindi qui potrei volessi farlo dentro anche qui possiamo anche questo possiamo farlo volendo function void function quindi questa è una funzione a vuoto chiamami ok così quindi questa è una funzione che sto passando a home page è dentro mail qui direttamente quindi lo devo dichiarare qua dentro questa è la funzione scriverà ok ok questo lo renderà non più const solo questo cambia ma a parte questo non cambia molto questa funzione qui questa funzione chiamami posso tranquillamente passarla o meglio invocarla qui dentro solo che widget chiamami ok è vagamente chiaro quello che ho fatto quindi ho passato una funzione alla radice proprio cioè questo è nel name proprio ho creato una funzione anonima che non ho fatto per fare una stampa la passo a home page poi home page la passa a sua volta questa funzione qui la passa a sua volta al pulsante che che chiama il contatore cioè la invoca dentro la funzione oppure potremmo se uno se volessimo non aggiornare lo stato e quindi non avere non avere il cambio di contatore potremmo direttamente passarla così ok quindi passare direttamente la funzione al pulsante il pulsante a quel punto quando viene cliccato non invoca invoca direttamente questa funzione anche questa cosa la possiamo propagare in ingegno esatto in questo caso a questo punto perdiamo la funzione di aggiornamento del contatore chiaramente perché non c'è nessuno con l'aggiorna per cui non è quello che vogliamo però è giusto per dimostrarvi che appunto le funzioni sono elementi che possiamo passare come se fossero degli oggetti e possiamo farlo in una gerarchia come vogliamo quindi in qualche modo un oggetto molto in alto può passare una funzione un oggetto molto in basso e quindi può reagire quindi adesso a questo punto non è utile perché non si aggiornava il contatore quindi ho rotto l'applicazione però sulla carta posso notificare qualcosa molto in alto quindi se se lo faccio in questa maniera magari il mio elemento radice è una stateful widget e puoi reagire a dei pulsanti che sono molto in basso nella gerarchia volendo basta passarsi la funzione ora qui sono andato indietro perché veramente l'aggiornamento del contatore mi piaceva lo lasciamo così questo comunque richiama il main ma aggiorna anche il contatore ok poi non ci contiamo che ci siamo perché poi andiamo in un regno ancora più complesso qui si verrà del caffè ok quindi a second punto lo sono notificando il main del fatto che ho messato questa cosa qui va benissimo quindi il fatto che si possono passare dei dati al costruttore e ricevere delle chiamate tramite eventi va benissimo si può fare a tanti livelli però è una intanto è un legame forte tra i due widget quindi i widget devono prevedere di avere dei parametri in ingresso e devono prevedere di avere degli eventi che che segnano la comunicazione per cui è una cosa che possiamo fare proconci dal fatto che stiamo legando ovviamente ci mettiamo una vita perché bisogna passarsi dietro mille parametri per farla funzionare la nostra comunicazione per cui non è ideale dopo il caffè andiamo a vedere come si fa a comunicare tra widget senza legarli così in maniera indissolubile con dei meccanismi che ci dà a disposizione Flutter stesso però ora pausa riattacchiamo alle 11.10 facciamo un quarto d'ora circa di pausa grazie a tutti grazie a tutti