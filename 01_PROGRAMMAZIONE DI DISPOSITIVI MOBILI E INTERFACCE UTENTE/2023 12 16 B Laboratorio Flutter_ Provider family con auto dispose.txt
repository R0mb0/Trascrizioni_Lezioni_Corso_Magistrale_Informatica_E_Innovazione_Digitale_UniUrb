Allora, quindi diciamo prima, abbiamo questa galleria e vogliamo renderla più efficiente, ok? Quindi rendere i caricamenti delle immagini più efficienti, proviamo a farlo. Allora, dobbiamo farlo se trovo... Dove farlo, si intende? Allora, intanto, qui abbiamo fatto... Dipendiamo al momento da questo gallery provider che ci legge JSON e quant'altro. Adesso creeremo un altro provider che si chiamerà... Gallery Picture Provider, per esempio, ok? Sempre un provider. L'idea di questo provider qui è che ci dà accesso all'immagine, cioè al pacchetto di dati non scaricati delle nostre immagini. Quindi, chiaramente, essendo le immagini tutte diverse, come se Vinci avrebbe fatto una scelta colorata e una diversa, tutti gli urlo di queste immagini sono diverse, chiaramente. Adesso, magari, per esempio, possiamo capire un browser che vi darà un'occhiata a questo, ma... Ok, sia utilissimo. Ok, quindi qui noi andiamo, in sostanza, andiamo a caricare... Questi elementi qui e andiamo a caricare queste immagini, questi placeholder qua, in particolare il thumbnail URL che ci dà queste immagini uguali grandi, 150-150. Quindi questo è l'URL che identifica in maniera univoca i singoli elementi della nostra lista. Ok, per cui il nostro feature provider può, esattamente come questo oggetto qui, era un provider che ci dava una finestrella su un singolo elemento to-do item della nostra lista di to-do item, quindi grazie a questo costruttore family, noi possiamo specificare l'istanza single provider passando una stringa. Faremo la stessa cosa, cioè vogliamo che questo gallery price provider sia, in realtà, una famiglia di provider che ci danno accesso a cosa? A una serie di oggetti. Adesso qui vediamo, tra un secondo, che tipo di oggetto vogliamo, però per ora ci metto un intero, tanto per... E l'oggetto che torniamo adesso è un intero, poi diventerà un po' più utile, e l'elemento discriminante è sempre una stringa, perché sarà il percorso, quindi l'url, all'immagine, quindi esattamente questa cosa qui. Vogliamo che per ogni immagine ci sia un provider assistente. Ok? Ricordate che quando facciamo una family... I provider, la cosa importante a ricordare è che i provider sono nel nostro provider scope, quindi vivono lì dentro. Di ogni provider c'è un'istanza, è soltanto un'istanza. Se abbiamo un family provider, di quella famiglia di provider, per ogni parametro possibile c'è un'istanza. Ok? Quindi basta che cambia una lettera in questa stringa qui, e avremo un'altra istanza del provider. Però questo ci sta bene, perché chiaramente se l'url è lo stesso, ci sta benissimo che il provider sia lo stesso. Quindi anche per una forma di caching, se abbiamo già in memoria, abbiamo già scaricato l'immagine dal dettaglio, e va benissimo avere già in memoria il provider che corrisponde a questo url qui. Ok? Quindi questo qui ci sta benissimo, e a questo punto nel costruttore qui avremo due parametri, ref e arg. Arg è il parametro stringa. Nel nostro caso il parametro stringa lo possiamo ribattezzare in url direttamente, perché sappiamo che sarà l'url della nostra immagine. Ok? Cioè il nome del parametro non è importante. Ok. Se non mi sono sbagliato, con le valenze... Sì? Prima di esserci. Ok, quindi questo è il nostro feature provider. Benissimo. A questo punto internamente, come ho detto qui, adesso ho messo intero per soddisfare dato un attimo, ma tra un attimo cambiamo tutto. Questo è un feature provider, quindi anche il metodo per generare, per ottenere i dati chiaramente può, non deve, ma può essere asincrono. E internamente cominciamo a lavorare per ottenere l'immagine. Quindi facciamo il debug. stampiamo l'url al quale stiamo accedendo. Poi cosa facciamo? Andiamo a fare, come sopra, andiamo a fare la richiesta remota, quindi facciamo la stessa cosa qui. Andiamo a response. Ok, quindi qui l'url non è più statico, ma sarà il nostro parametro url. Ok, quindi sto creando un oggetto url, lo posso facciare al charget dell'http. Otterrò una response, che sono i dati che otteniamo dalla richiesta remota. Giusto? E a questo punto, dentro response, abbiamo una serie di possibilità di accesso ai dati. Per esempio, Wint 8 list. Andiamo a vedere come possiamo costruire la nostra interfaccia sull'altro lato. Torniamo nella nostra gallery... Ok, perché qui usavamo image.network, se lo ritrovo. Ok, questo era quello che usavamo. Qui dentro, vedete che qui possiamo anche creare, possiamo creare le immagini con vari modi. L'asset, abbiamo visto, che sono le immagini che sono compilate dentro il nostro pacchetto DAF. Quindi, questo non è, questo è il caso, chiaramente, perché non possiamo scaricare tutte le immagini, in questo caso non funziona. File serve per caricare le immagini da file system, quindi qui dentro image.file passeremmo un percorso al file, cioè in realtà un'istanza di file addirittura. Quindi questo è un percorso al file effettivo. Questo vale soltanto per le immagini che abbiamo in qualche modo scaricato dentro il file system. Poi questo lo facciamo per un istante. Vedremo come si fa, ma non è di nuovo questo il caso. L'ultimo scenario è quello del memory, al quale possiamo passare dei byte in maniera grezza. E i byte, come al solito, in DART, sono una lista di Wint, quindi Wint a 8 bit senza segno. Ed è quello che vogliamo fare perché effettivamente di là, dentro il provider, abbiamo il modo di fare response.bodybytes, che effettivamente è Wint 8 list. Quindi esattamente questo stesso dato che ci interessa. Ritorniamo a questo. Quindi quello è i dati grezzi della nostra immagine. Quindi anche questo chiaramente cambierà e diventerà un Wint 8 list. Ok. Importare il file. Ora chiaramente questa cosa qui va bene fino a tutto punto, ma se la richiesta fallisce in qualche modo, qui bisogna fallire ugualmente. Quindi anche qui faccio il response. Non è 200, allora esplodiamo in qualche modo. Ok. In caso in cui la richiesta remota fallisca. Ok. E questo è il nostro calendar di Pension Provider, molto primitivo. In realtà, a dire la verità, questo provider qui va bene per qualsiasi immagine. Nel senso che li abbiamo specializzato molto poco. Adesso gli stiamo passando l'URL completo. E quindi in realtà, diciamo così, potrebbe... Questo provider qui può caricare qualsiasi immagine remota in questo formato qui. Più sensato sarebbe magari se creassimo un thumbnail picture provider di passargli non l'URL completo come parametro, ma magari soltanto la parte finale, questo 92C952, che è l'elemento identificativo. In realtà poi è il colore in esodecimale dell'elemento. E poi costruire l'URL... Anche qua, queste sono scelte che potete fare voi nel nostro posto. In ogni caso, a questo punto abbiamo il nostro provider e andiamo a utilizzarlo. Quindi qui dentro, nella nostra foto gallery, cosa andiamo a fare? Andiamo a creare degli elementi. Per pulizia potremmo farlo... Vediamo un po' come fare. Però la cosa più facile in realtà è farlo qui dentro. Quindi qui dentro andiamo a fare... Forse varrebbe la pena fare un widget a sé stante per il caricamento dell'immagine, però adesso non è tanto importante. Quindi qui creiamo un thumbnail magari. Thumbnail, facciamo ref. Ah, cremate, non ref, ma facciamo ref soltanto se abbiamo un'istanza di ref. Quindi questo status widget diventerà un consumer widget, ovviamente, perché ci serve... ...dugit ref qui. Ok, se no non c'è modo di fare sconto di... Menula ref watch, che cosa? Lo specifico... Gallery, eccetera, eccetera. Nel parametro del costatore ci mettiamo... Il costatore del metodo di funzione ci mettiamo l'URL del thumbnail. A questo punto otteniamo un oggetto che è un async value dei dati grezzo dell'immagine. Ok? Quindi qui stiamo caricando effettivamente l'immagine tal dei tali e a questo punto qui dentro, qui in questo contesto qua, cosa possiamo fare? Ci mettiamo il nostro thumbnail. E ricordate che quando abbiamo un async value, il pattern di proviso prevede che possiamo fare when. Ok? E poi abbiamo tre callback che fanno cose diverse in base a quello che sta avvenendo. Quindi nel caso in cui abbiamo i dati, qui ci arriva direttamente il pacchetto di dati. Quindi metto bytes e ritorno images... No, image.memory e passo i bytes. Ok? Quindi sto costruendo l'immagine usando i bytes che mi sono arrivati dallo scaricamento. Perché li ho ottenuti. Se c'è un errore di qualche tipo, allora... Cosa facciamo? Facciamo... Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Cosa facciamo? Facciamo? Facciamo? Facciamo? Facciamo? Facciamo? ColorThread e come Child ci mettiamo... X. Ok? Non è bello ma funzionale. Se stiamo caricando, qui abbiamo una funzione che ritorna assolutamente un widget senza niente e ci mettiamo il Circular Progress Indicator, che come al solito è quel pallino che ruota. Ok. Salvo tutto. Adesso non mi faccio errore di parentesi. Ok. Ok. Quindi qui abbiamo la nostra attesa all'interno di un spazio che sarà sempre quadrato. Quindi questo Asked Traction qui ci garantisce che il container è alto 110 e abbiamo quindi 110% di spazio in cui fare le nostre cose. Ok. Ripetiamo tutto. Vediamo che succede. come succede. L'idea è che abbiamo fatto a mano quello che faceva adesso per noi image.network. su specifestyle e la questa è la ovunе del fi Valeux History ÉsDate. Ok. Noi dobbiamo connettare l'interno del mercatrice. dietro il miraggio di google~! Ok, qui carichiamo la lista e a questo punto, vabbè, migliorabile perché qui il circular, come sindicato non l'ho messo, vedete che era un po' grande, conviene metterlo dentro un center, così diventa piccolino e centrato. Ok, e abbiamo la nostra interfaccia, e in realtà vediamo qui che abbiamo creato, cioè il provider family, tal dettaglio, che crea la lista di immagini, è stato creato 8-9 volte, quindi già ha precaricato i prossimi elementi, la tecnologia che si scorre qui. Vi vedo e nel frattempo vediamo che, visto che il studio comincia a pre-buildare gli elementi sottostanti, ok, cominciano a vedersi. Se ricarico, faccio un altro reload per apprezzare un attimo quel center che ho messo attorno al loader. Ok, adesso è più carino, quindi il caricamento adesso è... così, più grazioso rispetto a quello che faceva image.network, che non ci dà nessun feedback, anche lì si può fare qualcosa chiaramente per gestirlo, ma in questa maniera creiamo dei future provider che ci permette di gestire praticamente in maniera ordinare. Notate che, allora, una cosa bella e brutta al tempo stesso, è che appunto per ogni url, quindi per ogni istanza unica di stringa identica, viene creato un future provider per gestire quella specifica immagine. Quindi per ogni provider poi avremo in memoria il provider e anche il ritorno di quel provider. Quindi questa win-8 list, che è in realtà il pacchetto di dati crezzi di quell'immagine lì, la stiamo tenendo in memoria. Quindi il nostro provider scope principale si sta riempendo di byte che rappresentano queste immagini qui. Questo è un vantaggio perché, se torno su, quei provider lì sono già costruiti. Vedete che il caricamento adesso non viene più fatto perché sono tutti quanti prefatti. Se torno giù, vedete che è fluido e appena ritorno nella parte non caricata di carica, però man mano che carico tutti i elementi, questi rimangono in cache, in memoria, a di valore di RAM, e il caricamento non avviene più. Il rischio di questo approccio qui è che chiaramente a questo punto la nostra memoria si riempie di byte, ovviamente, e non ce la fa più a gestire la lista. La lista qui è praticamente lunga, per cui se dovesse arrivare più in fondo mi riempirei di provider e questi qui non vengono mai scalzati nella memoria. Ok? Per questo, pensateci bene quando fate un family provider, sappiate che nel caso più comune, cioè nel caso se non fate nulla, tutte le istanze di family provider rimangono in memoria e rimangono cacheate. Quindi, appunto, tornando su, poi è un vantaggio perché è molto fluido, è molto rapido. Però, magari non è quello che volete. Per evitare questo problema qui, cioè questo potenziale problema, c'è un meccanismo in RiverPod che vi permette di fare il dispose dei provider. Cioè i provider vengono sempre allocati in maniera dinamica, esistono sempre nel vostro provider scope, ma possono essere anche deallocati alla bisogna in maniera dinamica. Per fare questa cosa qui possiamo aggiungere nella costruzione qui un'altra chiamata che è l'autodispose. Ok? L'autodispose è... Tra l'altro fate caso anche a questo che è un po' una personalità di RiverPod che a tempo di... Certo, tutti i provider cambiano tipo in base a come li costruiamo. Quindi, prima il nostro provider qui era un family... Era un family... È un future provider family. Ok? Quindi una famiglia di future provider. E qui va bene. In assenza di family, chiaramente era un future provider, semplicemente. Con family diventa una famiglia di future provider. Se aggiungo autodispose, e lo posso fare sia prima che dopo, in realtà, non cambia la sostanza, questo diventa un autodispose future provider family builder. Ok? Quindi è un future provider, una famiglia di future provider che si autodispongono. Ok? Altra cosa, se tolgo la family, quindi se metto autodispose su un provider che non è una famiglia, tipo questo, questo diventa un autodispose future provider. Ok? Quindi ci sono vari tipi che mappano tutti i vari possibili, tutti i vari possibili incroci tra provider, future provider, family provider, autodispose provider, e possiamo intrecciarli come vogliamo. Sono tutti oggetti diversi che provalgano in maniera, come so dire, ortogonale. Quindi possiamo decorarli come vogliamo. Adesso qui. A che serve autodispose? Autodispose serve a fare una cosa abbastanza semplice sulla carta, ossia ci permette di, cioè permette a RiverPod di scartare dei provider che non sono più ascoltati. Cioè appena svanisce l'ultimo widget che fa watch o listen di un provider marcato come autodispose, allora RiverPod lo scarta e lo butta via. Ok? Questo è utile in questo scenario in particolare perché, guardate qua, possiamo ricaricare tutto così siamo sicuri che il provider sia vuoto. Appena ricarica vedrete che man mano che scorriamo e man mano che la list view toglie, cioè scarta i widget che svaniscono dalla vista, RiverPod si libererà degli elementi, degli elementi, cioè dei provider che non servono più. Ho scaricato la lista, sto scaricando gli elementi, ok, qui vediamo che mi sta caricando. Fate caso a questo 2e, di e0 che possiamo immaginare sia il 93, non è detto che lo sia perché l'ordine di caricamento non è detto in seconda, però non importa, è uno dei primi che mi hanno caricato, quindi questo 2e, di e0 è stato caricato, vanno giù, per cui sto caricando i prossimi elementi. Nel frattempo la list view avrà fatto, avrà fatto dispose dell'elemento primo, quindi questo che possiamo immaginare fosse 2e, di e0, vanno ancora un po' per essere sicuro. Quando tornano giù, su, vedete che questi qui vengono ricaricati, quindi inaspettatamente vengono ricaricati e vedete che tornando in cima è stato ricaricato 2e, e0, anche se era già, cioè era già stato caricato, quindi in teoria era già in cache tra i nostri provider. Con auto-dispose la vita del provider è legata alla vita dei widget e appunto finché c'è un widget in ascolto su un provider, chiaramente il provider rimane in vita, appena svanisce anche l'ultimo viene rimosso, ok? Quindi se fate refwatch sullo stesso elemento della family al tempo stesso, questo viene mantenuto in vita, se svanisce anche l'ultimo widget in ascolto, appunto il provider viene rimosso nello stesso momento, ok? Di nuovo, questo va valorato bene se è quello che volete o quello che non volete, in questo scenario mi viene da pensare che è quello che vogliamo, in qualche modo stiamo caricando elementi mano a mano e ci sta bene così e se torniamo su, vengono ricaricate, quindi in memoria non rimangono mai se non in maniera breve. Nel caso degli elementi come questi in realtà l'effetto non è proprio gradevolissimo, la virgoletta, se vogliamo, perché magari in alcuni casi voi vorreste che che che ha una vita un pelo più lunga di quella che no? Di quella che di quella che ha, per esempio, no? Quindi per esempio cioè è un po' scomodo il fatto che appena ritorno su vengono ricaricati. se volete potete rendere il punto più sofisticato il vostro provider andando a a rendere più sofisticato il processo di autodispose pilotandolo un po'. Allora, e questo vi faccio giusto un esempio perché allora quando usiamo un autoresposable provider quello che possiamo fare per complicarci la vita è che con questo ref vedete che questo ref qui oltre ad essere un riferimento a tutti gli altri provider che avete quindi con ref potete fare ref.watch e così via ovviamente di altri provider ma non solo perché con ref avete anche un riferimento al vostro provider in realtà e quindi potete fare una serie di cose sofisticate che sono on cancel on dispose on resume sì sono queste tre quindi on cancel on dispose on resume che sono le tre operazioni che Riverpod invoca sul vostro provider in base al proprio stato in sostanza se volete che l'autorespose uno scenario realistico qui l'autorespose cioè l'autorespose parte ed è sempre attivo cioè appena il provider sparisce dalla vista viene distrutto però vogliamo che se l'immagine è stata scaricata magari la abbiamo già memoria e vogliamo bloccare questo autoresposto dall'avvenire quindi facciamo ref e facciamo keep alive keep alive questo qui è una chiamata a un metodo che blocca quella istanza di provider provider e impedisce l'autorespose ok in questa maniera noi siamo l'autorespose è attivo soltanto quando quando la risposta non è ancora stata ottenuta non so se riusciamo a simulare questa cosa in maniera efficace vediamo magari dobbiamo far disporre un elemento di ipod mentre sta ancora scaricando quindi devo fare un po' di essere molto veloci l'interfaccia evidentemente scaricando ok adesso il 1964 era incaricamento non ha finito di caricarsi è svanito e adesso quando ricompara non è fatto il tempo e 753 era giusto 753 ecco se avete visto la quindi sono sceso rapidamente 753 a partire il caricamento non aveva finito però di fare il caricamento sono tornato su e evidentemente l'http è stato interrotto prima di cioè il provider legato a 753 è stato cancellato prima che potesse essere bloccato al secondo caricamento ho riavviato il processo di caricamento quindi siamo ritornati qui una volta ottenuta l'immagine con keep alive stiamo impedendo all'auto risposta di disporre gli elementi quindi adesso se lo nascondo e torno giù 753 rimane vivo ok quindi noi in questo caso con keep alive diciamo guarda adesso non vi parlo esatto esatto quindi vedete che il 1404 adesso sta sempre ripartendo lo scaricamento da zero vedete che non è mai adesso l'ha caricato e poi se torno giù compare avete visto dall'ultimo secondo ha finito di scaricarlo era comparso e quindi a questo punto col keep alive rimane rimane in memoria possiamo rendere ancora più complicata la cosa se vogliamo ma giusto perché ci piace complicarci la vita perché con keep alive noi possiamo in realtà questo keep alive qui ci dà un keep alive link lo mettere qui ok perché in alcuni casi ci può essere magari vogliamo mettere un vogliamo fare in modo che l'autodesposto sia comunque attivo ma magari a tempo ma magari vogliamo mettere in memoria per che ne so per dot minuti gli elementi e non di più e lo possiamo fare con un timer quindi possiamo fare tipo timer questo è un elemento di dart che ci permette di fare delle operazioni asincroni e passare sul tempo e a questo punto usiamo i tre metodi on dispose on cancel on resume che ci dà che ci dà riverpod con dispose quindi on dispose vogliamo che vogliamo cancellare il nostro timer on cancel questo viene invocato quando praticamente quando l'ultimo l'ultimo list è stato rimosso quindi praticamente quando sta per avviarsi l'autodesposto in sostanza quindi il link su quel particolare provider è stato rimosso a questo punto voglio creare un timer un timer adesso qui lo mettiamo a non so a secondi 5 5 secondi così e vogliamo che allo scadere del timer qui c'è un metro che viene eseguito vogliamo fare link punto close ok questo è tutto in modo complesso in person parentesi forse ok e questo è cons e on resume invece viene chiamato quando quando ci si riaggancia all'istiner perché è ricomparso qualcuno o qualcosa che sta ascoltando il ok è tutto estremamente sofisticato ma arriviamo un altro replay quindi abbiamo creato cioè quando l'immagine viene scaricata facciamo keep alive quindi ci assicuriamo che non venga cancellata in automatico però ci teniamo in memoria un link a questo elemento che tiene vivo il nostro oggetto a questo punto una volta che abbiamo il link attiviamo un timer e in base a quello che accade al nostro oggetto vogliamo che magari iniziamo un po' meglio vogliamo che accadano delle cose in particolare quando l'ultimo elemento ascolta il nostro provider attiviamo il timer di 5 secondi e poi cancelliamo il keep alive ok quindi significa che dopo che l'ultimo elemento ha fatto watch del nostro feature provider aspettiamo 5 secondi e a quel punto togliamo il keep alive e a quel punto sappiamo che verrà fatto l'autorisposta quindi stiamo ritornando l'autorisposta 5 secondi in sostanza e in più questo timer cancel significa che se per qualche motivo il nostro oggetto viene disposto prima dei 5 secondi togliamo il timer perché tanto l'incloser non serve a niente e on resume significa che prima che cioè se il timer è in corsa e qualcuno si mette di nuovo in ascolto sui nostri oggetti allora vogliamo annullare il timer e mantenere in memoria cioè rimettere in keep alive il nostro oggetto ok cioè stiamo gestando manualmente il fatto che se dopo 5 secondi non c'è più nessuno in ascolto lasciamo scadere il timer e togliamo il keep alive se qualcuno si rimette in ascolto lo teniamo l'idea vediamo se funziona veramente a questo punto abbiamo una cache temporanea di 5 secondi in sostanza degli oggetti questo magari nel vostro scenario può aver senso o meno però è un modo per gestire manualmente la vita dei nostri programmi ok adesso facciamo un esempio pensando con il 4900 se adesso andassi su il 4900 sarà scaduto sto aspettando aspetto questi 5 secondi fatidici se torno su mi aspetto che il 4900 venga ricaricato ecco perché sono scaduti 5 secondi se torno giù non è più visibile torno su in tempo è ancora visibile anche perché l'ho fatto entro 5 secondi riproviamolo vado giù mettiamo 5 secondi sarà scaduto quindi saranno scaduti ok vengono ricaricate vado giù di parecchio torno su c'è ancora quindi questo è il modo manuale che abbiamo trovato per giustire questa cosa è del codice un po' opaco magari mi rendo conto però è un modo che ci dà riverpod per gestire manualmente queste cose qui nel caso delle immagini adesso questo vedremo questo ha senso fino a un certo punto può aver più senso in realtà per il vostro gallery provider quindi questa cosa qui magari la spostiamo di qua perché più l'immagine sappiamo che non cambiano mai l'immagine qui sappiamo che è statica quindi non cambierà radicalmente da un secondo all'altro quindi avere una cache 5 secondi ha senso fino a un certo punto per cui useremo una cache invece statica sul file system che faremo adesso che finalmente lavoreremo col file system ha più senso invece per le API quindi per le chiamate delle API che magari possono cambiare col tempo per cui un buon caso di uso in realtà è questa gallery provider in questo caso qui la galleria sappiamo che non cambia mai che è sempre la stessa API quindi i risultati sono sempre gli stessi cambia soltanto il fatto che siamo manualmente e arbitrariamente cambiando l'ordine degli elementi però immaginiamo di avere un API invece che è a tempo quindi immaginate di fare un'applicazione che vi scarica il tempo metodologico della città tal dettaglio potete immaginare di avere un family future provider con autoresposed dove la stringa è il nome del paese quindi qui avrete future family provider che ritorna il medio tal dettaglio e come parametro string avete Urbino Roma Milano e così via questa scarica le informazioni volete che se l'utente naviga in giro per l'applicazione le informazioni per la stessa città non avendole scaricate ogni singola volta perché non volete riempire le chiamate l'API anche perché questo ha un costo ovviamente e quindi mettete l'autoresposed a tempo della chiamata perché magari il metro cambia di ora in ora ci può stare e quindi fate esattamente questo quindi questo procedimento qui lo possiamo riciclare tranquillamente di qua e lo facciamo qui e il keep alive magari più di 5 secondi lo facciamo di qualche minuto nel nostro caso quindi se un minuto dopo un minuto vogliamo vogliamo che il future provider tal tali venga fatto scadere e quindi venga ricaricato questo poi non vorrà per le immagini e chiaramente il future provider che cosa significa? che il future provider quando viene riascoltato lo scenario è questo qui ok quindi qui carico la galleria adesso chiaramente questa pagina qui è in ascolto su questa galleria qui quindi non si aggiorna in automatico a meno che non clicco qui qui sto facendo refresh forzato della nostra galleria ok quindi qui lo ricarica da forza se vado via e torno sulla galleria non è passato un minuto quindi la galleria è stata ricaricata immediatamente perché era già in cache se adesso lascio qui l'applicazione aperta senza che nessuno ascolti la galleria aspettiamo un minuto la galleria verrà ricaricata e questo è un comportamento abbastanza classico dell'applicazione in cui c'è un time out delle informazioni e chiaramente poi nella vostra sensibilità mettere la duration del timer in maniera più o meno coerente con quello che è l'aggiornamento dei posti dati adesso lo lasciamo scadere così vediamo che l'effetto è quello nel frattempo lavoriamo con il file system perché l'idea è questa allora qui noi stiamo usando RiverPod come cache praticamente quindi siamo con questo ma che siamo dell'autoresposed del Keepalive sappiamo che in memoria in RAM questo provider qui rimarrà e non verrà riscaricato però in alcuni casi è opportuno avere una cache locale più persistente dei dati è il caso delle immagini quindi questa galleria qui in realtà sappiamo che appunto come dicevo prima le immagini non cambiano di minuto in minuto per cui tanto vale scaricarle e memorizzarle non in memoria dove la RAM soprattutto su dispositivi mobili è molto limitata quindi è sempre il caso di tenerla ad occhio quindi non teniamo una cache di immagini in RAM ma teniamo una cache di immagini in memoria è in memoria statica quindi in memoria del disco quindi facciamo questo e facciamo una cache locale di data allora facciamolo subito e per farlo ci saranno una serie di oggetti in più ossia dobbiamo cominciare ad accedere ai percorsi quindi ci saranno dei pacchetti in più di data in particolare ci servirà un pacchetto che si chiama path path è un pacchetto sempre di defaulted art che ci permette di fare operazioni sui percorsi quindi unire numeri directory file e così via ok quindi lo prendiamo e lo mettiamo nel nostro app spec sempre path e poi ci saranno anche path provider che è un altro pacchetto molto classico che ci dà l'accesso a dei dei percorsi standard dell'ambiente che ci troviamo e quindi questo supporto Android iOS con tutte le piattaforme praticamente in cui c'è un file system degno di nota che si può accedere non supporta il web quindi attenzione quando andiamo a includere questo file provider qui la nostra applicazione non funzionerà cioè si accede ai metodi sul web quindi attenzione in questo caso sì sì chiaramente path dovrebbe essere compatibile con il web perché non fa accesso al file system ma gestisce semplicemente le stringhe e le mette insieme quindi non fa nulla di parte di sofisticato file provider invece appena accede al file system può darvi eccezione sul web o altre piattaforme in cui path provider non è implementato quindi il nostro primo esempio di di applicazione ok abbiamo un altro volume di dipendenza e quindi risolverlo allora flutter test flutter test non l'abbiamo usato quindi direi che possiamo sostanzialmente cassarlo un attimo troviamoci oppure possiamo passare a path 1.8 credo è stato un problema grave nel frattempo mentre qui aspettiamo se qui riapro la gallery mi aspetto che venga ricaricato ecco perché nel frattempo è scelto il minuto di time out del provider il provider è stato scartato e adesso che la pagina viene ricaricata il provider viene ripresso in memoria e chiaramente deve ripartire da zero ok allora vediamo un attimo path lo includiamo nella nostra anzi no lo facciamo nel provider quindi qui tutte le operazioni che le faremo le faremo qui nei provider quindi in realtà chiuderemo qui i nostri oggetti path in genere si include come per l'http visto che ha una serie di metodi globali in genere sporcano un po' l'ensuice quindi tanto si include spesso come sotto il nome path o qualcosa del genere e stessa cosa avviene per il nostro path provider facciamo questo e lo facciamo path prov ok a questo punto qui dentro quindi nel gallery picture provider andiamo a fare un po' di operazioni sui file la prima cosa che facciamo è scaricare l'immagine questo si può sempre fare però visto che la nostra idea è questa di scarichiamo l'immagine solo se effettivamente non l'abbiamo mai scaricata prima ossia se in locale non abbiamo una copia di quell'immagine quindi la nostra idea è questa di avere una directory in locale nella nostra applicazione dove teniamo questi file e i cache scaricati queste immagini scaricate se diamo un'occhiata a path prov facciamo punto vedete che qui ci sono una serie di metodi che ci danno accesso a una serie di directory standard diamo un'occhiata breve qui perché il significato di questi metodi cambia di piattaforma in piattaforma in cui ci troviamo chiaramente per cui allora la piattaforma fondamentalmente diciamo così la la cosa più comune in generale che si fa nelle nostre applicazioni è può accedere alla cosiddetta directory privata della nostra applicazione quindi la directory che è unica per la nostra applicazione e nella quale noi possiamo scrivere in completa libertà la cosiddetta application document directory che è una directory appunto che altre applicazioni e il sistema su cui ci troviamo non in generale non possono scriverci non direttamente e in cui possiamo fare un po' quello che ci pare e ci piace su android questa directory qui vive dentro il percorso della nostra applicazione viene dentro il pacchetto della nostra applicazione magari questo può aver senso leggerli e stamparli quindi magari per vedere in pratica che cos'è lo facciamo direttamente sono tutte chiamate asincrone quindi vedete che sono due future directory quindi per poter leggere dobbiamo fare await e facciamo stampiamolo quindi app doc dir await questo è appunto il percorso privato della nostra applicazione poi abbiamo app temp dir che sarà fatprov.get temporary directory ok ok questo è un percorso alla directory dei file temporanei della cache in sostanza ok anche qui cambia da dispositivo a dispositivo su android e anche su iOS ogni applicazione installata ha una sua cartella privata in cui mettere i file temporanei che vengono buttati via tutti quanti quando l'applicazione si installata quindi è una specie di cartella slash temp diciamo così in cui mettere i nostri file temporanei che vengono cancellati ma non servono più e poi ah c'è anche application cache in realtà che sicuramente vediamo se combacia ok questa è la cache near infine ci sono altre directory tipo la external storage directory questa ha senso in in particolare su android in cui c'è questo concetto di storage esterno che è identificato come una specie di memoria SD virtuale in realtà che viene messa nel dispositivo dove in genere sono tutti i file condivisi del sistema e dove in genere si va a scrivere o a leggere se vogliamo accedere alle immagini della fotocamera e così via quindi questo external storage qui è la directory in cui il sistema in cui tutte le applicazioni possono scrivere in maniera più o meno libera posto che abbiano il permesso di farlo questo adesso non lo vedremo qui perché non c'è il tempo però se volete scrivere o leggere questa directory qui su android vi serve un permesso speciale di accesso all'external storage ok perché altrimenti non potete leggere e scrivere la cosa di directory però dovremmo poter ottenere almeno il percorso vediamo se questo è vero un secondo external storage come? probabilmente un secondo external storage sì external storage è praticamente il percorso di questa cartella virtuale che è uno spazio condiviso tra tutte le applicazioni del sistema posso dire che non funziona perché l'ho provato usare cioè l'ho risolto in una maniera un po' arcana ovvero parlo del percorso fissato che è storage emulet in più ah sì il percorso è fisso vediamo un secondo come si comporta vediamo subito pranto ria allora se non funzioni aspetto che sia perché non ho i permessi per leggerlo però andiamo a leggere i nostri percorsi che ci sono poi in realtà sappiamo già dove andare a scrivere così così e così ok in questo senso ovviamente vorrà chiamato per ogni singolo ah chiaramente quindi vorrei avviare al frattempo scusate perché ho cambiato i pacchetti quindi naturalmente le cose non funzionano quindi aspettiamo per i bindi altrimenti poi abbiamo ne pass provider ne pass nel nostro pacchetto ok ok ok bene bis5 su sorpreeven di e quindi più Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. alto per essere un invoco chiaramente questo deve essere un invoco a livello di sistema e quindi in genere ci metterete qualcosa di più significativo nel nostro caso se dovete pubblicare l'applicazione della pubblica e poi qui c'è un la cartella in cui mettete tutti i fatti ok la tempo di directory è la stessa cosa quindi vive nello stesso ramo no però invece di essere dentro app flutter è dentro cache e la cache è la sua directory che può essere cancellata liberamente dal sistema senza che vi dica alcun che quindi la cache è sempre a rischio di cancellazione questo avviene soprattutto se magari finisce un po lo spazio il sistema vi suggerisce di svuotare la cache del sistema questo significa che per ogni applicazione installata la cartella cache viene svuotata questo peraltro si vede anche qui vedo un po dal sistema che è installato ma se riuscissimo ad aprire un'applicazione questa qui se apriamo app info qui data usage ah ok vabbè storage qui vedete che questo è la cartella che contiene occupa 93 mega quindi la cartella data user zero com punto fast mail immagino appunto non so client non so come si chiama il package name di questa applicazione ma quello che è tutto quanto occupa 93 mega app size è il pacchetto quindi la pick up user data è la cartella applications documents quindi la cartella dei documenti dell'applicazione quindi sono in questo caso è grande perché questo contiene veramente delle mail scaricate che sono importanti e la cache sono delle delle informazioni che sono scartabili quindi è questa cartella cache in generale quando chiedete di quando cancellate dei dati in android android vi chiede se volete cancellare tutti i dati questo va stato con parsimonia perché chiaramente cancella tutta la applicazione tutta la documenti e quindi ovviamente c'è della perdita di informazioni se le informazioni non sono sincronizzate con un server o qualcosa del genere oppure solo la cache la cache questa cartella qui e come detto la garanzia è che se svuoto la cache non rompo nulla in teoria per cui se clicco qui la cache si svuota ok adesso quando rilancio applicazione applicazione non trova nulla dentro cache e va a riscaricare le cache questo avrà anche nel nostro caso la cache è una cartella a parte questo è una persona con tutte le altre per cui va gestita in maniera autonoma della nostra applicazione quindi siamo noi a doverci curare il fatto che la cache non viene non venga riempita troppo di informazioni no inutili e quindi gestire in qualche modo lo spazio che andiamo coperto sul file system quindi vedete che get temporary directory e get application cache sono la stessa cartella in realtà ok quindi non cambia nulla e l'external storage invece punta a quello che dicevamo prima quindi è il nostro storage monedit eccetera eccetera e in particolare ci punta a una directory nostra diciamo così che però vive dentro questo storage condiviso ok quindi storage monedit zero è il diciamo così la scheda sd emulata che android ci dà disposizione dove mettere i file condivisi al questo interno di questa cartella qui ovviamente abbiamo accesso tutti i file perché non c'è non c'è controllo accessi a me se abbiamo l'accesso a tutta la cartella condivisa però sono delle sottocartelle per ogni per ogni applicazione installata se così vogliamo se vogliamo in qualche modo andare a fare file specifici e quant'altro al momento noi accesso a questa carta qui non ce l'abbiamo ok per cui se accediamo a quella a quella quel percorso e la nostra applicazione esplode potenzialmente se volessimo accedere a quel percorso dovremmo andare a modificare il manifesto nuovo andando a raggiungere ai nostri vari permessi e e fare troppo d'azione ricordo bene troppo d'azione possiamo aggiungere i permessi e specificare che utilizziamo a questo livello e ma vorrebbe essere come dentro java dentro java perché ce ne sono tipo 3 4 le manifesto su google e vabbè questo comunque adesso ci guardiamo non è rilevantissimo comunque nel manifesto a un livello che adesso non ricordo sembra che fosse andare a livello di application ma forse sbaglio eh possiamo specificare quali permessi vogliamo e qui andiamo a specificare esattamente se vogliamo eh scrivo leggere questo extra storage che al momento appunto non ci interessa quindi lo togliamo però il caso volessimo eh in questo modo quando inseriamo l'applicazione eh Android ci avverte del fatto che l'applicazione potrebbe potenzialmente scrivere leggere questo extra storage e poi sono rispondente la nostra dare o rifiutare questo permesso ok torniamo al nostro provider eh che tutto questo quadragirico per far cosa per avere accesso alla nostra application cache electric e quella che ci interessa quindi questo app cache dir è il è l'applicazione è la cartella in cui andremo a scrivere eh cosa andiamo a scrivere? Questa cosa qui sappiamo che vale eh no vale eh no vale vale questo ok sappiamo che vale questo noi vogliamo l'idea questa potrebbe essere questa vogliamo fare una cache che sia cache che ne so eh thumbnails ok poi ci mettiamo il nome del del del del eh eh eh univoco il nome univoco del file quindi questa cosa qui sotto nove due c novanta c'è il nome del colore in sostanza nove c quello che è eh punto png che sono dei png e risaliamo in questo provato qui quindi noi vogliamo scrivere qui dentro ok ok come lo facciamo allora questo valore qui in realtà lo tiriamo fuori dall'url ok perché l'url è nell'altro è nel formato eh copiiamo questo valore qui a noi arriverà un dato sappiamo che url avrà una valore di questo valore qui ok quindi dobbiamo tirare fuori tirare via questo elemento qui no dal dall'url quindi facciamo eh un'operazione ma si usa abbastanza così con l'accetta tiriamo fuori la la slash position url eh che la stringa last eh index of chiaramente questa cosa si può fare in vari modi eh più eleganti di questo ma adesso non è che ci interessa qui tanto tiriamo fuori dov'è l'ultima slash quindi questa sarebbe a dire ok eh a questo punto tagliamo eh il codice dell'immagine con url substring eh partendo questa ci dà la posizione partendo dopo l'ultima slash quindi la slash position più url ok questo ci darà un image code che è una stringa che è solo ops solo questa ok ok per cui il percorso eh eh facciamo così cache file path sarà cosa sarà eh la combinazione tra eh eh eh eh eh eh eh eh altri elementi e come si combinano questi questi elementi percorso usando il pacchetto eh path quindi usiamo path per combinare queste stringhe e darci un percorso che sia sensato eh path ha un metro che si chiama join che serve proprio questo con join possiamo mettere insieme una serie di stringhe e alla fine avremo un file path completo quindi partiamo con app cache dir questo chiaramente è un'istanza di directory quindi non va bene ci serve la il percorso eh quindi direccio qui serve path c'è anche absolute path non mi ricordo no beh questo ci serve una directory stessa quindi ok path va bene poi seconda posizione vogliamo thumbnails che mettiamo la stessa sotto directory thumbnails ok e poi come punti a posizione ci mettiamo eh questa cosa qui col png info quindi ci mettiamo eh quindi quindi quindi allora questi tutti questi debatt coerenti qui li togliamo magari che non servono niente ci sforcano solo il debug ah in realtà poi tutti questi non servono nulla perché ci ne interessa solo una quindi per al primo lo facciamo così quindi questo è il percorso ok lo stampiamo per dirigenza eh vediamo se tutto funziona quindi ricarichiamo e vediamo se vediamo se abbiamo fatto le cose più bene bene ok quindi adesso abbiamo eh accessi a varie immagini e la il cache file che ci aspettiamo di avere ma se non troviamo ancora ma lo avremo eh eh sono sono qui quindi avremo una cache nel file tal dettaglio questo forno ok eh benissimo a questo punto ok adesso facciamo un cambio radicale ora visto che lavoriamo con dei file locali sul file system a questo punto il nostro gallery page provider non ritornerà più i dati grezzi del file perché cioè questo provider qui deve poter ritornare o la richiesta di rete o il file di cache no? cioè ha due opzioni quindi piuttosto che ritornare i dati grezzi così come se non ritorna direttamente un file in ogni caso alla fine dei conti ci dovrà trovare il file di cache ok quindi qui file è l'oggetto che ci interessa questo va importato ad art.io quindi cambia il taglio ovviamente qui il body bytes qui non funziona più ok perché adesso a questo punto abbiamo il file di cache perfetto adesso andiamo a verificare se questo file esiste o meno per cui andiamo a creare un cache file che è un'istanza di file a cui passiamo il cache file file è un oggetto esattamente come directory qui questo qui torna a directory che è un oggetto astratto che non è capto da directory che poi possiamo usare in vari modi file è la stessa cosa per il file cosa può fare file? file come come come istanza ha varie cose meno utili tra cui exist questo metodo asincrono o sincrono se vogliamo però visto che siamo dentro un future provider che possiamo avvenzare l'asincrono che ci permette di verificare se il file esiste o meno if await exists ah se esiste cosa facciamo se esiste abbiamo già scaricato il file precedentemente lo possiamo ritornare direttamente e ci mettiamo qui cache fit e ritorno cache file perché sta già in istanza di file ed è valido evidentemente se non esiste bisogna in qualche modo andare a procacciarcelo e bisogna fare questa richiesta di accesso questo accesso remoto ai dati li scarichiamo ok quindi una volta scaricati se tutto va a buon fine andiamo a prendere i dati della richiesta http andiamo a dumparli dentro un file anche qui ci sono vari modi con cui possiamo farlo e ah mettiamo intanto cache miss ok e a questo punto dentro response dobbiamo andare a scrivere dentro cache file anche qui possiamo farlo in vari modi però un modo comodo è usare lo stream se lo abbiamo dovrebbe essere response.bodi proprio eh body e body e body ci sono già i dati grezzi in realtà se ricordo bene ah perché lo stream non ce lo dava io non serve in altri modi perché allora sì per fare questa cosa avanzata bisogna fare delle piccole operazioni quindi invece di fare direttamente http.get perché http è l'interfaccia semplificata per fare direttamente la richiesta eh facciamo la richiesta request ricreiamo l'istanza request che è get di cosa? di dell'uri quindi sperma uguale ok ehm a questo punto response sarà ehm no sarà request send ricordo bene ok questo è uguale e a questo punto il response dovrebbe avere lo stream esatto questa è una response è una stream response che non è una risposta botta risposta che ti dà subito tutti i dati come stringa o come a ready byte questa è una risposta che possiamo streamare cioè appena inizia a ritornare i dati possiamo subito ridiriggere questa cosa qui abbiamo accesso ai dati come stream e qui possiamo fare ehm lo stream è uno stream di byte quindi possiamo farci un po' quello che vogliamo c'è un qui ci sono vari metri con cui possiamo fare delle operazioni possiamo leggere possiamo spandere possiamo fare for each su ogni byte cioè che cosa che è più o meno inutile in questo caso ci interessa pipe pipe è come la pipe della command line quindi prendi i dati e li ridirige in una conduttura quindi è un canale effettivamente e lo consumiamo col file quindi qui facciamo eh cache file open right questo di aprire il file in modalità di apertura in modalità di scrittura scusate eh qui abbiamo varie operazioni le cose che non ci interessa perché è binario quindi la codifica non importa e la modalità sarà write questo è di default quindi tanto come? non dovrebbe essere attendere quindi dovrebbe essere essere uno stream ma tutte le cose mano mano divengono date e no perché il file esiste cioè se scariciamo due volte lo stesso file non vediamo appendere la stessa immagine al stesso file più volte è proprio che in questo momento stiamo creando il soggetto esatto quindi con un overbet lo sovrascriviamo se per puro caso ci viene rischio perché se facendo appendere scriveremo in coda l'immagine che aveva scaricato quindi avremo un'immagine che man mano cresce quindi l'append in questo caso non ci è non c'è l'aiuto però in pipe sì pipe è sempre a sync quindi qui anche qui posso fare await e a questo punto sappiamo che il file è stato scritto e possiamo ritornare il file quindi in realtà cache file per ritornare cache file possiamo farlo fuori così ok quindi il file comunque aspetta che il stream sia completato esatto esatto cioè perché abbiamo fatto la wait chiaramente sì perché visto che siamo dentro il official provider possiamo fare le varie await e fare tutto quanto in maniera progressiva ok a questo punto l'autorespose qui è attivo nel senso che tutti i provider qui vengono dispostati appena escono dallo schermo giustamente ok quindi ci fidiamo a questo punto del fatto che c'è una cache locale dei file se tutto questo funziona il rischio di esplosione a questo punto è altissimo per esempio perché non funziona ah beh ovviamente adesso qui il provider ho cambiato tipo ritorno a un file non ho ancora cambiato la memory qui la nostra image.memory si aspettava un ready byte adesso invece gli arriva un file e sappiamo che c'è un costruttore giusto per fare questa cosa che è image file e ci ritorna cosa bytes però bytes in realtà quindi questo si chiama file in realtà ok ritorno quindi a questo punto costruisco l'immagine sulla base di un file sul file system locale e questo file system su questo file ho appena scritto in questo stato perché l'ho appena scaricato oppure esiste da prima e anche se riavvio l'applicazione il file c'è già e andiamo in galleria perfetto perfetto qui perché non c'è il percorso ha ragione anche lui allora vedete qui comunque l'errore viene gestito in maniera perfetta perché ci dà un error che va bene viene gestito in maniera corretta e non ci permette di aprirlo perché non esiste credo il percorso cioè non esiste la cartella thumbnail spedio quindi va creato senza va creato prima e bisogna farlo allora per esempio ma il ilv east whether is i a a l e constantly а introdiszi esatto allora bisogna accertarsi che la cadetra di contenente esista quindi per fare questa cosa qui bisogna fare e qui facciamo create recursive true questo servirà soltanto se fossero i dati più volte ok quindi se non c'è la cartella la creiamo dovrebbe essere questo questo è perché sto creando questa cache thumbnails che poi è sotto il vario file, non può scrivere qui in un'essente directory contenente se avessimo chiuso direttamente dentro la cache il problema non ci sarebbe stato no, perfetto a questo punto sebbene vedete qui i provider stanno scomparendo tant'è che appena torno su vengono ricreati lo vedo qui nel log perché c'è provider access in tal datale e c'è cache hit ogni volta ogni volta che vediamo il file chain, il file system c'è cache hit poi se scendo scendo abbastanza c'è cache miss quindi i vari oggetti qui vengono scaricati e a questo punto stiamo riempendo di immagini più o meno inutili il nostro file system e a questo punto la nostra immagine cioè abbiamo una cache locale di immagini che valgono rimangono anche se i provider vengono cancellati anche se torno indietro anche se faccio scadere la gallery anche se ricarico alla gallery e così via quindi qui è cambiato l'ordine per cui alcune immagini nel memore alcune no siamo un po' sfortunati ce n'era una vedete in base all'ordine in cui è stato ricostruito possiamo incontrare delle immagini già in cache occasionalmente ecco ecco e così via e a un certo punto avremo 5.000 immagini in cache locale memorizzate sul nostro file system che rimangono lì a questo punto chiaramente la responsabilità di gestire smistare ripulire un po' la cache è nostra ok perché sono dei file sul file system e 105.000 elementi le foto sulla carta a questo punto ne abbiamo troppi e va fatto un sistema con cui magari andiamo a vedere le immagini più vecchie e le bugliamo praticamente prego tipo teoricamente quando andiamo a chiudere effettivamente la più testa di computer e viene terminata la funzione run up del main e poi usciamo il problema possiamo fare che ogni volta che chiudiamo l'app bugliamo tutto la cache forse si potrebbe teoria se non che per come è fatto non tanto il flat ma per come è fatto il ciclo di vita delle applicazioni mobili in realtà fare le cose in terminazione non è un'idea particolarmente cioè facile non è mai facile perché essere terminati spesso è una cosa di cui non si viene avvertito in ambiente mobile ok perché mentre su Windows e così via noi sappiamo che siamo per essere terminati perché la finestra viene chiusa e poi facciamo tutto il tear down dell'applicazione e terminiamo in maniera più sensata qui bisogna sempre essere allerta perché potrebbero essere terminati in un momento all'altro perché Android decide che possiamo buttarci fuori quindi si può fare ma c'è il rischio che non venga mai fatto e quindi in genere quello che viene a fare è o fare un servizio in background quello che fa per noi questo però non l'abbiamo visto a lezione perché non è una cosa che Flutter permette di fare di suo perché Flutter è solo interfaccio utente sincrona quindi attiva se abbiamo servizi in background che devono fare delle cose bisogna andare a parlare con Android proprio Android ci permette di fare servizi in background che ripuliscono l'applicazione o più facilmente mettiamo all'avvio addirittura qualcosa in background che pian piano vada a scartabellare nei file e ripulisca quando è opportuno quindi è più nell'avvio che possiamo fare delle operazioni di risinistamento dei file piuttosto che alla terminazione ok a questo era come fare le cache locale abbiamo visto come si si lavora con i file più o meno chiaramente file a questo punto cioè stiamo usando le primitive non tanto di Flutter ma di Dart quindi qui stiamo lavorando con Dart IO la libreria che stiamo utilizzando questo qui per cui questi sono file a tutti gli effetti e non c'è nessuna differenza con lavorare con Dart da riga di comando o altri programmi di altro tipo quindi qui avete comprati la libertà di scrivere leggere gestire file come volete nel rispetto chiaramente delle directory e dei premissi che avete su Android in questo caso su Windows ma questo avete più libertà perché lì avete l'accesso al file system più o meno senza limitazioni su web tutta questa cosa che qui non c'è per niente ok perché il file system su web non esiste c'è un potete emularlo con cioè emularlo potete accedere a una cosa che si chiama local storage che è diciamo così un database locale della vostra applicazione ok con e potete lavorare emularzare le dati in questo modo qui ed è simile a quello che potete fare con i file tutto sommato e qui in realtà la piattaforma local storage vi permette di farlo su multi-cataforma per cui è un buon modo per avere local storage che vale per tutte le piattaforme in realtà quindi vi emula il comportamento del local storage web anche su piattaforme che non sono web quindi può essere una buona idea se avete esigenze molto semplici di gestione dei file può essere questo il modo in cui lo gestite ok e chiaramente i file sono in json perché su web chiaramente sono tutti in json diciamo così il minimo comune denominatore è ovviamente una mappa di file simile file codificate in json e ecco questo è quanto quindi in base alla piattaforma su cui vi trovate chiaramente cambiano un po' le cose l'ultima cosa che vediamo in 3 nanosecondi perché mancano 20 minuti e siamo arrivati a un livello di cottura elevato direi sono le shell per la presence che sono un altro strumento che non vi mette a disposizione Flutter in sé ma vi mette a disposizione in genere cioè sono nati in un contesto di applicazioni mobili cioè su android e su ios c'è questo concetto di preferenza dell'utente in sostanza che vanno memorizzate tra un avvio e l'altro dell'applicazione e quindi vanno mantenute dal sistema sono una forma di memorizzazione che è diversa dai file quindi i file diciamo così è il sistema più primitivo se vogliamo dirlo in questa maniera di accesso alla persistenza perché stiamo lavorando con dei oggetti sul file system locale quindi lavoriamo un po' ci fidiamo del fatto che alla fine i nostri sistemi sono tutti unix compatibili quindi abbiamo un file system possiamo leggere e scrivere e possiamo fare un po' quello che vogliamo però le scelte sono un sistema semplificato di persistenza che ci permette di memorizzare delle preferenze personali dell'utente in maniera semistrutturata che non sono nel file system quindi è uno storage alternativo che è gestito sempre da Android o da iOS che ci permette di memorizzare dei dati semplici qui vedete vediamo già nell'esempio degli integri dei booleani dei double delle stringhe una lista di stringhe cose di questo genere in genere si usa questo sistema di memorizzazione per delle cose molto piccole quindi per memorizzare per esempio non so uno scenario realistico in questo caso magari potrebbe essere l'ultimo username con cui l'utente ha fatto login per dire ci ricordiamo com'era il suo nome e noi lo facciamo ripetere e quindi acceleriamo un pochino la forma di login oppure visto che qui abbiamo un contatore di interi che aumenta di volta in volta e parte sempre da uno magari abbiamo un modo di memorizzare questo come intero come cell preference e quindi quando riavviamo l'applicazione ripartiamo in questo caso da sette e non da uno cose di questo genere non è il caso di memorizzare cose importanti nelle cell preferences perché non c'è garanzia che vengono memorizzate anche questo è importante ricordarlo cioè sono preferenze dell'utente e in quanto preferenze possono essere dimenticate senza grande formalismo dalla parte della piattaforma ci sono anche dei limiti sulla quantità di dati che possiamo metterci dipende dalla piattaforma della piattaforma su android in genere sono un paio di k di byte in totale non per campo per cui bisogna stare attenti a non sabordare non metterci cose effettivamente grandi ok qui andiamo in dettaglio molto poco perché il tempo è pochissimo però se vogliamo utilizzare questo sistema che è una cosa che si può fare ovviamente intanto terminare l'applicazione come al solito aggiungere il nostro amabilissimo pacchetto mettiamo qui tra i pacchetti servono a tempo di esecuzione scarichi il pacchetto ora visto che non complicarci la vita in genere è una buona cosa se abbiamo ossigenza di usare questo plugin qui e magari adesso vogliamo metterci l'ultimo username dell'utente potrebbe per senso metterlo dentro un provider ovviamente come tutte le altre cose essendo tutte le search references fortemente asincrone vedete che c'è await dell'istanza proprio e poi await dei singoli valori sarebbe chiaramente un future provider ovviamente per farla breve e non perdere tempo invece di fare un provider possiamo fare al volo una cosa che non abbiamo fatto finora usare una primitiva di flutter per gestire queste cose asincrone direttamente entro faccio utente usando un future builder in questo caso facciamo riseguire e ripartettizzare tutto qui dentro andiamo a operare solo su login quindi andiamo a fare una cosa molto molto semplice dentro login a pay qui in sostanza vogliamo che all'avvio la complicazione diciamo così che è data dal fatto che abbiamo due modalità due portre e quindi ancora allora intanto facciamo cioè ah in realtà facciamo una cosa ancora più semplice possiamo farlo esattamente qui dentro perché tanto abbiamo i nostri conto che tengono traccia dello stato ovviamente, per cui tanto vale fare ovviamente qui nello stato nella nostra applicazione possiamo fare un un future data che è un metodo asincrono che andrà a caricare a installare i dati con quello che ci serve noi invochiamo qui attenzione che qui non stiamo aspettando qui non possiamo aspettare qui è un metodo asincrono stiamo lanciando e basta qui nel metodo asincrono andiamo ad ottenere un'istanza delle share per le avvenze direttamente questo è un uso un po' brutale di questo oggetto ma tanto vale è solo riposizionatoĩ this again good Ora compilando, quindi... Lo copio intanto così poi... Per un oggetto andiamo a leggere una stringa, quindi facciamo getString e facciamo press getString. Ogni preferenza, quindi ogni opzione che mettiamo in questa mappa di opzioni, avrà una chiave, una chiave stringa, che identifica in maniera univoca, e quindi qui ci mettiamo qualcosa tipo last username. Queste sono preferenze chiaramente a livello di applicazione, quindi sono uniche per la nostra applicazione, non c'è il rischio che... Vengono sovrascritte, facciamo wait di questo, e a questo punto possiamo aggiornare, sovrascrivere il conto username e impostare il testo. Ecco il rischio che stiamo sovrascrivendo quello che l'utente ha già scritto. Allora, ok, ovviamente il controllo potrebbe essere nullo, ma sappiamo che non lo sarà, però facciamo finta che lo sia. Facciamo così, non ho importato questa libreria, appena Dart se ne accorge, qui ancora sta compilando, va in estrema lantentezza. Ok, chiaramente, questo sto facendo delle cose rapide, perché abbiamo 12 minuti di tempo per si do, però non c'è grande rischio di fare queste cose qui, perché appunto queste cellar preferences sono legate solo a questa piccola schermata, quindi tanto vale a fare così. A fare le cose bene, chiaramente avremo un future provider che si realizza caricando queste preferenze e caricando la preferenza dalla sua username, poi potremo fare watch di quel provider e aggiornare eventualmente la semprefaccia in base a quello. Sarebbe la cosa più pulita da fare, ovviamente. Quando andiamo a fare login, quindi quando andiamo a fare... Ah, qui tratta di una cosa un pochino poco carina, nel senso che qui il login lo facciamo in due punti diversi e c'è una ripetizione del codice. Allora, facciamo... Raduniamo questo codice qui. Una volta solo, quindi tutta questa bella cosa qui lo prendiamo e lo mettiamo via. senza invocazione, effettivamente così. Così e poi ci diamo le cose qui dentro. No? No, ho visto. Posso provarci dietro ovviamente. se no, non possiamo valere. Ok, quindi questo diventa una domanda di attenzione, ovviamente. Vediamo? Oh, non è ancora partito, non è ancora partito, ma sarà lo datore. Ah beh, perché non era pronto, vabbè. Ehm... sicuramente può essere nullo. Ok, lasciamolo. Ah, questo non è la vostra. Allora, bravo. Ok, il string è immediato. Va bene, ricompiliamo un attimo. e quindi l'idea è che, appunto, per carico i dati, ricarico, lancio il processo. Appena i dati vengono ritornati da SharePrefers, posso sovrascrivere il controller e impostarli. Questo non sarà immediato, appunto, compare lì dentro. Quando un attento clicca, e... in realtà, tutta questa roba qui non ci interessa a un certo punto, perché possiamo semplicemente andare a fare di nuovo, anche questo sarà un metodo asincrono che non viene aspettato da nessuno. E qui nella... che ricarico a SharePrefers in asincrono e poi vado a impostare setString e qui avrò... userò la stessa chiave, chiaramente. Ok. Ups. E useremo questa testa qui. E qui magari va a fare così. anche questo dovrebbe essere un future, quindi aspettiamo anche questo. Qui si attringua una stringa non nullabile, va benissimo, quindi qui se... se questo è nullo lo mettiamo a stringa vuota. quindi quando clicchiamo sul pulsante login scateniamo un metodo che in realtà è asincrono, le operazioni che facciamo subito sono queste qui che vanno a fare login. Poi in background, tra virgolette, il metodo continuerà e in asincrono andrà a scrivere le cose sui SharePrefers e il pulsante non aspetterà che la scrittura viene fatta, però questo è un processo bene. Lo facciamo direttamente da qui dentro. Ok? Quindi il rischio è che lo vedete clicchi più volte il pulsante login però sicuramente poi andremo a sovrascrivere le SharePrefers con l'ultimo valore che era del controller username che non è un grande rischio. Ok, lo stiamo facendo forse. quando facciamo login e logout sapete che la login page viene creata e distrutta in base allo stato del nostro provider di login per cui sappiamo che tutto quel processo viene generato. Ah, perché si lo sto creando. Ah, perché lo sto invocando. Ups, errore mio. Allora, tutte queste cose chiamate qui ovviamente non possono essere chiamate fatte con altre costruzioni devono essere frappate dentro una funzione. Ha senso. Ok, perché stavo richiamando il metodo della costruzione non è quella di idea. Il metodo deve essere chiamato quando il pulsante viene costruito quindi deve essere un metodo anonimo che fa la costruzione che fa, che viene invocato al click del login. Ha senso. Ok, facciamo. Facciamo. Ho perso qualche... Ok. Un virgola. Ok, allora, vediamoci qualcosa. Ok, ok. Faccio login, mi aspetto che nel shell preferences venga messo il dato, se faccio logout viene rigenerato e vedete che viene proprio compilato con le shell preferences perché questo... E tra l'altro c'era un istante in cui era vuoto il canto se avete fatto caso. Faccio di nuovo login, faccio logout, è vuoto e poi subito dopo si carica perché c'è questo comportamento, questa sincronia di caricamento dato dal fatto che sto facendo in Threat Data soltanto dopo aver fatto il need state, quindi il contatto viene creato vuoto e poi ci metto il dato dentro. Per evitare questo caricamento qui chiaramente dovrei... L'interfaccia intera dovrebbe aspettare che questo caricamento viene fatto. Ok, per fare questa attesa appunto la soluzione più pulita è il future provider che permette all'interfaccia di aspettare che il future provider venga inizializzato oppure un'altra cosa si può fare, adesso non lo faccio per mancanza di tempo per non complicare c'è un builder poi quindi un widget che attende cose che è il future builder che può essere stato proprio a tale a questo scopo quindi è un builder c'è un builder come tutti i builder di Flutter che hanno un metodo di costruzione con dei dati gli passiamo dei dati che arriveranno in futuro e poi il builder semplicemente viene invocato quando i dati arrivano ok, quindi è un metodo un po' come il future provider che vi da con il when che permette di creare interfacce quando il dato c'è quando siete in attesa quando il dato non è arrivato e il future builder ha la sua sua patta non ci state quindi avete qui il builder ha un parametro che vedete che vi arriva il dato futuro e poi avete vari metodi con cui potete sullo snapshot potete andare a vedere se il dato è arrivato o meno snapshot qui qui ci sarà has data has error e così via in base a questo potete distinguere lo stato dell'applicazione e costruire esattamente quello che vi interessa questo è un altro modo per rendere dipendente cioè rendere l'interfaccia dipendente da uno stato che ancora non esiste però attenzione allora il future provider è uno strumento così un tappabuchi che va benissimo però state creando un oggetto future nella vostra interfaccia utente e poi quando quello diventa vero il faccio si aggiorna e quant'altro quindi può funzionare ma il metodo più garantito di funzionare in maniera corretta rimane il future provider che perché lì avete un'istanza globale del vostro provider che vive tra i provider come questi come questi qui e potete attenderli nella vostra interfaccia senza andare a rischiare che il provider o comunque dell'oggetto che viene costruito così in futuro venga istensato più volte o ci siano dei problemi vari di stato quindi in genere vi conviene sempre di quando c'è qualcosa dei dati a gestire per quanto semplici che si siano di spostarli di altri provider ammesso chiaramente che voi stiate utilizzando i provider cosa che non dovete fare non è obbligatorio però vi suggerisco di fare ok vorrei di interrompere qui manca soltanto a questo punto appunto SQLite vi carico un esempio commentato magari vi mando un piccolo video in chiusura per rispondere un'idea di come funziona se volete utilizzarlo avendo già accesso alle shared preferences e ai file in ogni caso entrambi questi metodi sono esperimenti sufficienti per soddisfare il punto di persistenza dei dati nello sviluppo del progetto se vi interessa sviluppare quel punto SQLite chiaramente è lo strumento più compiuto e più complesso quindi per rendere il corso più o meno completo ci aggiungiamo anche questo però non è obbligatorio dover fare appugna anche col database locale se non volete farlo ok detto questo questa era l'ultima sessione direi ho concluso per cui io rimango a disposizione chiaramente se vi serve qualsiasi informazione dubbio eccetera eccetera mi potete scrivere sia via mail sia sul forum di Blended e di vengo in soccorso se ci sono dubbi che riguardano le persone magari le risposte le possiamo mettere anche sempre sul forum o ve le condivido in qualche modo anche se avete problemi con il progetto se è stata contattatemi e a parte questo se non ci sono dubbi non specifico sulla lezione di oggi direi che chiudiamo e ci si aggiorna per le sessioni di esame più avanti e nel frattempo vi auguro delle buone feste immagino ok allora niente buona giornata ancora grazie