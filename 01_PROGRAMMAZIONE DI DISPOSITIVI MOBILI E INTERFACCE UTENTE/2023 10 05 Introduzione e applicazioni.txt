Benissimo, ok, iniziamo finalmente a questo punto. Benvenuti al corso di programmazione di dispositivi mobili di interfaccia utente. Come stavo già accennando a chi è presente, prima appunto è un corso che si concentra sulla programmazione in generale di interfaccia utente, quindi non è necessariamente concentrato sui dispositivi mobili, e quindi parleremo in realtà di tutta la storia dell'interfaccia utente, da dove vengono, qual è l'idea di fondo, quali sono le metafore che si adottano, come funzionano in generale, cioè da quando sono state inventate, hanno stati stili, paradigmi di programmazione, e cercheremo di andare a snocciolarli un po' insieme, vedere da dove nasce tutto e dove siamo arrivati in qualche modo, e quindi facendo questo vedrete anche vari modi con cui si possono programmare alla stessa maniera, alla fine dei conti, dell'interfaccia utente. Come vi accennavo prima, appunto, ne vedremo tre, in particolare il laboratorio, perché c'è una parte abbastanza consistente di programmazione pratica, che come vi dicevo prima, chi è da remoto potete chiaramente eseguirle anche da remoto, ma in particolare il laboratorio, che poi nella seconda parte del corso diventerà l'attività principale che facciamo, se riuscite a partecipare in presenza, spesso è utile perché chiaramente è molto facile risolvere intoppi, problemi vari, che si trovano sempre in genere, lavorando su cose che non si, cioè cose che si scoprono, che si devono andare a esplorare, per cui se riuscite ad esserci in presenza ve lo consiglio. E quindi, dicevo, vedremo almeno tre modi diversi per fare la stessa cosa, quindi fare interfacce utente in generale. E poi chiaramente, come già nel titolo dell'insegnamento, ci concentreremo in qualche modo anche su dispositivi mobili, che in tutto sommato sono i dispositivi con cui più comunemente interagiamo nei giorni, no, quotidianamente, quindi in qualche modo ci torna utile. Questo perché alla fine del corso lavoreremo prevalentemente con Flutter, che è questa tecnologia appunto che ci permette in maniera abbastanza agevole di fare interfacce utente per piattaforme mobili come Android e iOS, e non solo. Quindi questo è prima del concetto, quindi vedremo vari temi, perché appunto cerchiamo di partire da lontano per arrivare a un punto comune di approccio, di approdo, non di approccio. Per cui intanto vediamo cos'è la differenza tra un programma generico e un applicativo grafico, fondamentalmente. Vedremo quali sono i vari paradigmi di programmazione e quali sono i cicli di vita più comuni di un'applicazione. Questo sembra molto banale, ma poi vedrete che non lo è. Quali sono gli approcci design e i pattern di design più comuni per le applicazioni che hanno un'interfaccia utente di qualche tipo. Faremo una lezione abbastanza rapida su esperienza utente, tipografia, cose di questo genere, che non è chiaramente il focus del corso, però per darvi giusto un sprazzo, un'idea di quello di cui si parla, poi chiaramente se dovessimo parlare di design, delle applicazioni, ci si potrebbe perdere un altro corso da 9 CFU tranquillamente, però appunto non lo faremo. e poi appunto lavoreremo per la programmazione mobile di applicazioni, cioè applicazioni mobili piuttosto, in uno scenario multiplattaforma. Però prima di arrivarci ce n'è di temi da affrontare. Intanto, prima di iniziare, vi chiedo, secondo voi ha già esperienze di programmazione mobile o di interfaccia utente? Sì? Sì? E con cosa? Flutter. Flutter, perfetto. Si è già esperto. Android Studio, perfetto. Quindi con Android classico, Kotlin... Flutter. Già, ok. Flutter. Perfetto. Ah beh, anche Angular, perfetto. Angular e derivati poi li citeremo, quantomeno. Quindi qualcuno di voi già conosce Flutter, quindi probabilmente vedrete cose già viste, nel senso che noi partiremo da zero proprio, partiremo proprio dal linguaggio. Intanto, per iniziare, che di Dart, che è un linguaggio un po' atipico, nel senso che non è un linguaggio che si studia di norma, a meno che non si voglia fare Flutter, per cui è un linguaggio che nasce un po' per quello, e ha tutte le sue stranezze del caso, per cui lì ci... cioè, perderemo un po' di tempo lì per farvi arrivare a un punto di... di comune, di programmazione utile con Dart. E poi, a quel punto, partiremo con Flutter, proprio le basi. Per cui chi già conosce Flutter, ovviamente, è, da quel punto di vista, si annoierà o rivedrà cose già viste. Però, come detto, poi parliamo anche di altri laboratori che, da questo punto di vista, spero che completino la vostra visione di quello che è l'interfaccia utente, o il mondo della programmazione dell'interfaccia utente. Come funziona l'esame e il materiale? Allora, il materiale è questo, quindi le slide che vedete sono il materiale che vi propongo, la sua, così, umiltà, per cui ve le carico di volta in volta, cioè, ogni volta che chiudiamo una sezione, diciamo così, vi carico il PDF su Blended, se volete riscorrere le lezioni. Troverete chiaramente anche i video registrati. Non vi consiglio nessun libro specifico, perché non ce n'è, tra virgolette, nel senso che se poi volete approfondire sui vari progetti, i vari laboratori che facciamo, credete, vi posso suggerire della letteratura specifica per quel contesto, però, diciamo così, che non serve. Anche per Flutter posso dare dei puntatori, se volete approfondire, scoprire con più dettagli e quant'altro, però anche qui non necessariamente è fondamentale. Anzi, in generale, di Flutter in particolare, la documentazione che trovate online è più che sufficiente per farsi un'idea di quello che bisogna fare. Per quanto riguarda l'esame, proprio concretamente, cosa bisogna fare per superarlo e per verbalizzarlo, c'è un progetto finale da consegnare, un progetto individuale, per cui, salvo idee veramente astruse, incredibili che vengono in mente, che richiedono più persone, magari, che possiamo discuterne, in genere, è fatto per essere consegnato, cioè sviluppato e consegnato poi da soli. Le specifiche le adatto ogni anno, per cui adesso le rivaluto un pochino e poi ve le pubblico su Blender di quando sarà ora, tra qualche lezione, così intanto potete dare un'occhiata di quello che sarà la specifica. In generale, però, è una specifica molto vaga, in realtà, nel senso che se c'è qualsiasi progetto che possa essere, in qualche modo, presentato come applicazione mobile per Android o per iOS, va benissimo. E quindi, se avete un progetto personale che vi piace, se avete un interesse specifico, se avete un altro esame che dovete fare in concomitanza con questo, magari combinate gli interessi, va tutto bene. Insomma, quindi, negli anni, cioè nei pochi anni che c'è stato questo corso, sono state consegnate cose molto eterogenee, dalla mappa interattiva delle fontanelle dell'acqua al Pokédex, coi Pokémon, quindi qualsiasi cosa possa diventare un'apprecazione mobile, va benissimo, quindi non fatevi frenare nelle vostre idee. Chiaramente, ecco, siate, cioè, questo è un problema che è sorto svariate volte, visto che è così vago, poi a volte si fa prendere un po' dell'ambizione e quindi si arriva a fine corso senza avere un progetto che sia presentabile, per cui è vero, fate magari, inventatevi cose astruse che vi piacciono, però non fatevi prendere la mano troppo, poi si rischia di andare un po' per la tangente e poi il progetto rimane un po' poco sviscerato in quello che conta per l'esame, per cui, insomma, ecco, va bene sdirazzare, ma cercate di essere concreti dal punto di vista dell'implementazione, poi. Perché, ecco, per concludere questo, l'esame poi viene valutato in maniera molto, come si può dire, un tabellare, non so, ci sono dei punti da consegnare, quindi ci sarà la gestione dei file, la comunicazione remota in HTTP, tutte queste cose qui che vedremo a lezione, per cui quelle vi danno punteggio, poi alla fine si fa la somma e quello è il ritardo finale. Quindi è una cosa molto meccanica vedere quanto avrete alla fine, però ecco, da questo punto di vista è bene ottimizzare, diciamo così, il vostro impegno per fare in modo che abbiate tutti i punti, o almeno la maggior parte dei punti, coperti, ok? Sennò poi, appunto, c'è chi poi col Pokédex si lascia prendere dalla mano dai Pokémon, dai colori e quant'altro, e poi ci mancano alcune altre parti fondamentali. Tutto qui. E poi, per consegnarlo, appunto, si consegna la repository, quindi il suggerimento è sempre di svilupparlo su Git o su qualche altro sistema di tracciamento del software, su GitHub se volete, per cui lo sviluppate all'aperto, tra virgolette, e me lo consegnate in quella maniera, c'è un, e poi c'è da fare una demo di quello che c'è, e una piccola discussione di quello che, di come avete fatto le cose. Tutto qui. Molto lineare. Ci sono domande o dubbi su questo? Poi, appunto, una volta che vedrete la specifica, diventerà più chiaro come viene valutato, ma, insomma, non è niente di particolarmente originale. Ok. Se qui ci siamo, direi che possiamo andare avanti rapidamente, visto che la perdita di tempo per problemi di audio, andiamo subito al so, in qualche modo. Per cui, la prima cosa di cui vi parlo è di applicazioni. Quindi, il primo punto, il primo tema che tocchiamo è la distinzione tra quelli che sono programmi standard, quindi quelli che, adesso, molti di voi già programmano per piattaforme mobili, per cui già avete un'idea di quello che si intende per applicazione. Però, se venite dal triennale, per esempio, in cui si sviluppano applicazioni da riga di comando o in C, magari, o in linguaggi di questo genere, quello che in genere come progetto si fa sono dei programmi standard che hanno magari input e output, però vanno a elaborare in maniera automatica delle informazioni, nella maggior parte dei casi. Per arrivare alle moderne applicazioni, c'è un piccolo salto, diciamo così, concettuale da fare. Per cui, giusto per dare le definizioni iniziali, allora, partiamo dai programmi proprio. Il programma, per quanto riguarda, per quanto concerne il sistema operativo, in generale, è semplicemente un file binario che è, in qualche modo, identificato come eseguibile, quindi, è un file che contiene degli uni e degli zeri completamente opaco che contiene nulla che sia noto da fuori, da chi lo va a usare. noi sappiamo, noi, il sistema operativo sa, per conto nostro, che il programma, il file, è un eseguibile e quindi può essere eseguito, ok? Banalmente. E anche qui, molto banalmente, questa cosa cambia dal sistema operativo aditivo al sistema operativo, per cui, quello che avviene su Windows è che i nostri eseguibili vengono identificati dall'estensione, quindi hanno un punto exe, finiscono con un punto exe, e non solo, in realtà, però, generalmente, è un punto exe, mentre su Linux derivati, in realtà, qualsiasi file può essere eseguibile se è marcato come tale nel file system, quindi ha il bit dell'esecuzione marcato e quindi può essere lanciato. E lanciato, cosa significa? Significa che il sistema operativo mette in memoria il file binario, lo carica in memoria, e poi, in una maniera che a noi sembra automatica, ma automatica non è, effettua il caricamento del binario e a un certo punto l'esecuzione, cioè un thread dell'esecuzione va dal sistema operativo, dal kernel, salta dentro il programma, in sostanza. Da quel punto in poi, il programma va in esecuzione e quindi c'è un thread, quindi un filo di esecuzione che esegue e a quel punto l'esecuzione effettivamente non è più controllabile dal sistema operativo, quindi il programma può fare effettivamente quello che vuole e da fuori noi si comporta come al solito come una specie di scasola nera, la classica black box che fa delle cose e poi speriamo che non esploda e speriamo che non faccia dei danni anche, questo è sempre il grande mistero, non si sa mai dove vanno a finire perché non c'è nessun modo per analizzare in maniera statica, in maniera completa, che cosa fanno eseguibile per natura stessa della computabilità. Ok, qui, ah, qui è giusto un esempio molto banale per chi viene qui, faccio sempre dei esempi molto banali perché prendo come riferimento il corso di programmazione base della triennale di informatica per cui se avete fatto almeno il corso di programmazione di base quindi che si fa in C il progetto si fa ancora in C credo, no? Sì, ok, perfetto, meno male che il C è sempre fondamentale per tutti nella sua rudimentalità e il C è una programmazione di alto livello tra virgolette e quello che avete fatto facendo il progetto d'esame è scrivere un file C e poi lo buttate in pasto a gcc o a un compilatore equivalente questo sputa fuori un eseguibile che può avere un nome e un'assenza di estensione qualsiasi lavorando qui su Unix e a quel punto l'eseguibile è specialmente individuato cioè marcato da questa X qui, quindi queste tre X che vedete qui significa che qualsiasi utente può mandare in esecuzione il programma e questa cosa si fa con il classico punto slash main in questo caso, ok? Quindi questo qui significa lanciare il main questo è l'eseguibile vedete anche l'eseguibile è molto più grande del file sorgente di questo parleremo tra un secondo l'eseguibile sono 8k di spazio occupato il main sono 74 caratteri quindi potete immaginare che fa molto molto poco tant'è che scrive Hello World come vuole la prassi però in questa forma qui il nostro main eseguibile non sappiamo cosa fa se non l'abbiamo scritto noi e quindi quando lo lanciamo stiamo così incrociando le dita e vediamo cosa accade ok? Quindi qui poi main fa delle cose stampa su console su riga di comando e poi termina e a noi torna al controllo ok? Quindi anche a livello di se avete mai lavorato cioè maggiormente sì ma se avete lavorato in maniera assidua su riga di comando magari in ambiente Unix o Linux e così via quando si lancia un eseguibile da riga di comando avviene esattamente quello che dicevo prima cioè si lascia il controllo a un eseguibile e poi si aspetta che questo termini chiaramente abbiamo degli strumenti con cui possiamo uccidere l'eseguibile se fa cosa che non doveva fare o se si blocca quindi ci sono dei strumenti per fermarlo però in genere accade che noi diamo controllo perché la nostra interfaccia con la riga di comando viene interrotta tra virgolette cioè viene presa in ostaggio dall'eseguibile fin tanto che questo non termina ok? che questo è un'esecuzione la nostra interazione col sistema è interrotta cioè qui noi parlavamo con la riga di comando qui lo facciamo di nuovo in questo frangente qui stiamo parlando con l'eseguibile se parliamo con qualcuno e l'eseguibile può tranquillamente ignorarci ovviamente ok appunto parlando di input e output dicevo prima quando noi deleghiamo quando noi eseguiamo un programma noi deleghiamo il controllo all'eseguibile adesso sto chiaramente sto semplificando con l'accetta quello che avviene in un sistema moderno chiaramente perché in un sistema moderno ha tutti gli strumenti in genere che servono per controllare un eseguibile in esecuzione e terminarlo gestirlo fare in modo che non faccia danni e così via quindi però semplificando molto quando l'esecuzione un programma in esecuzione non c'è molto che noi possiamo fare a meno che il programma non sia attento a captare i nostri input e i nostri output quindi è il programma che in maniera attiva deve essere in qualche modo fatto in modo con la giusta attenzione per captare i nostri input e per eventualmente generare degli output che a noi sono utili un programma super mega standard e quali modi ha per comunicare con il mondo esterno ne ha diversi in realtà molti di quali conoscete ovviamente già però vi rivediamo insieme giusto per completezza perché il primo il più banale è proprio l'argomento di lancio quindi quello che è detta la riga la la riga di comando con cui viene lanciato l'eseguibile quindi immaginiamo di essere diciamo uno scenario di prima siamo nella riga di comando abbiamo il nostro eseguibile in sul file system lo lanciamo in questa maniera qui questo che cosa che cosa avviene dietro le scene qui noi stiamo fornendo questa stringa qui alla alla alla scene al terminale no poi appunto il terminale può essere può assiare il terminale qui il terminale probabilmente la bash o quello che è insomma quello dettaglio parliamo col terminale del nostro stesso operativo gli forniamo questa stringa qui il terminale interpreta questa stringa qui capendo che si sta per lanciare il main lo manda in esecuzione gli fornisce questa stringa qui come parametro quindi quando noi lanciamo l'eseguibile non soltanto lo mettiamo in memoria e lo eseguiamo ma gli passiamo la stringa con cui è stato lanciato che nel nostro caso appunto è main e poi tutto quello che segue questa è la riga di comando cioè il comando di lancio di main in questo caso ok quindi quando viene lanciato l'eseguibile quello che avviene in primo luogo è che chi ha lanciato l'eseguibile gli passa questa riga di argomenti che come dicevo prima inizia classicamente col nome del programma l'altro nome del programma è il nome del file del programma in realtà quindi questo è il nome con cui quel programma quello eseguibile si chiama sul file system quindi prima era main prima abbiamo visto main.exe qui si chiama program insomma può chiamarsi in mille modi diversi ma non cambia la sostanza quindi il primo argomento è sempre il nome del programma lanciato e poi una sequenza di argomenti che può essere più o meno lunga sulla carta potrebbero essere infiniti ma cioè infiniti infiniti no però arbitrariamente lunga e per così per standard per come si dice per dalle guida standard insomma i vari argomenti con cui viene lanciato il programma sono separati dallo spazio ok quindi possiamo fornire una serie di argomenti tutti separati dallo spazio e poi questi il nostro programma può leggerli in qualsiasi momento ok questa questa informazione qui che viene da fuori ci viene fornita nel programma è sempre a disposizione dal programma perché è in una zona della memoria del programma ed è sempre leggibile ok quindi in qualsiasi momento potete andare a rileggere la riga di comando con cui il vostro programma è stato lanciato questo non sempre traspare tra l'altro poi vedremo come come il il main cioè scusate come in C questa cosa viene declinata ok però adesso immaginate ragioniamo in maniera astratta non stiamo programmando in C anche se ad esempio di prima era in C stiamo programmando in qualsiasi linguaggio possibile quindi siamo in questo programma qui che è scritto in un linguaggio di fantasia noi sappiamo che da qualche parte nella memoria del nostro programma quando ci hanno lanciati qualcuno ci ha copiato dentro questa riga di comando ok quindi noi sappiamo che possiamo leggerla in qualsiasi momento ed è sempre alla nostra disposizione e possiamo far cambiare il nostro comportamento in base a questo ok quindi in base agli argomenti passati in base all'ordine delle cose in base alle varie opzioni che noi prevediamo quindi che noi gestiamo in qualche modo il programma potrà fare un'operazione o piuttosto un'altra ok come può reagire a questa cosa il nostro programma cioè qual è il modo con cui può rispondere il modo più banale per farlo è il cosiddetto exit code l'exit code è un intero che esattamente come questa riga di comando è un intero che sta nella memoria del programma quindi immaginate che il nostro programma dicevo prima quando viene lanciato viene caricato in un blocco di memoria del seno operativo questo è vero questo blocco di memoria contiene almeno due spazietti due blocchini vuoti uno è per questo argomento qui l'altro è per l'exit code ok come almeno poi ci sono altre informazioni però almeno queste due informazioni ci sono quindi input e output qui quando il programma termina di eseguire il programma può non deve ma può scriverci un intero tutto suo quindi con un valore arbitrario che anche qui è lasciato a chi programma il programma definire qual è l'exit code che valore ha e perché viene usato in un dato modo quindi a quel punto l'utilizzatore l'utente noi che lanciamo il programma sappiamo che un valore 0 indica questo valore 1 indica quest'altro valore 100 indica un'altra cosa ancora e così via quindi potremmo immaginare di avere una tabella dei valori di output del nostro eseguibile e sapere quindi che cosa ci risponde in questa maniera in genere anche qui per convenzione ma non è non è scritto nella nella roccia però come se lo fosse lo 0 in un in ambito unix significa che il programma è seguito in maniera corretta terminato senza dare senza esplodere senza dare problemi in sostanza quindi 0 è il successo tra virgolette e un numero positivo in genere potrebbe indicare un errore non deve perché anche qui chiaramente sta al programma definire un insieme di valori che possono essere interpretati in un modo o nell'altro però lo 0 in genere viene preso come tutto a posto o terminato in maniera corretta ok perché è importante che questi sono due degli spazi questi sono due blocchi di memoria che sono nel programma perché il sistema operativo quando va a lanciare il programma crea il nostro blocco di memoria con il programma ci scrive questo e poi quando il programma termina il sistema operativo va a leggere questo ok perché sa esattamente dove sono questi due spazi nella memoria e li va a leggere poi li fornisce a chi ha lanciato il programma quindi nel nostro scenario di prima in questo scenario qui questo punto slash main è input che noi forniamo al terminale il terminale lancia main e passa questo come input al nostro eseguibile il nostro eseguibile a questo punto esegue come deve fare giustamente e a quel punto il terminale attende è bloccato non può fare non può fare nulla in sostanza finché il nostro programma non termina di eseguire a questo punto qui il nostro terminale potrebbe andare a leggere il valore di ritorno di main ok adesso non lo fa sicuramente poi lo ignora perché non gli interessa però sulla carta potrebbe andare a leggere quel valore e comportarsi di conseguenza qui è la shell quindi è il terminale che lancia main ok però chiaramente qualsiasi altro programma può lanciare un altro programma quindi a cascata un vostro programma può lanciare un altro programma e comportarsi come se fosse il terminale quindi fornire delle informazioni da riga di comando e aspettare che l'applicazione l'altro programma scusi termini e poi leggere il famoso interro di ritorno quindi il famoso exit code che ci dà un un valore di ritorno ok questi sono gli strumenti più primitivi che abbiamo ok quindi qui qui sì e tutto sommato sono primitivi ma buona parte della di quello che fa un sistemista Unix il mondo dei server Unix si basa su questo quindi in realtà è un mondo molto primitivo ma in generale funziona abbastanza bene nel senso che noi possiamo lanciare dei programmi con dei argomenti variabili e in base a questo valore qui possiamo fare delle operazioni diverse e comportarci in conseguenza ma non basta questo perché questi strumenti qui sono statici cioè questo viene scritto una volta quando il programma viene lanciato e non è più alterabile ok quindi quando il programma viene lanciato questo blocco qui viene scritto dal sistema operativo viene messo in questo blocchetto no fisso che c'è per ogni processo e poi quando il programma ha terminato di eseguire lui il programma può scrivere qui dentro e poi a quel punto anche questo si cristallizza e questo exit code viene letto da fuori dal sistema operativo dal terminale da chi ha lanciato il programma in generale ma non è più modificabile ok quindi input sola che può essere scritto una volta sola output che può essere scritto una volta sola questa è la limitazione importante di questo approccio quindi questo sistema qui funziona benissimo ma non va bene per tutti quei programmi che sono interattivi quindi che devono comportarsi a runtime diversamente in base a quello che sta accadendo ok chiaramente poi parlando di interfaccia utente interfaccia utente per definizione è un programma che deve raggire in qualche modo all'input dell'utente altrimenti un'interfaccia utente molto noiosa e quindi ci si verrà uno strumento un pochino più dinamico e sul fronte dinamico c'è un altro strumento un'altra primitiva diciamo così dei programmi nati su Unix derivati che sono i canali cosiddetti i canali sono dei dei file a tutti gli effetti perché in Unix tutto è un file tutto sommato però a parte questa divagazione sono dei canali sono dei file astratti infiniti sulla carta dai quali si può leggere e sui quali si può scrivere quindi ogni programma per di default ha sempre un canale di input che si chiama standard input di base e due canali di output di cui il primo si chiama standard output e l'altro si chiama standard error ok quindi questo vale per tutti i separativi Unix e tutti i suoi derivati compreso anche windows non perché è un derivato di Unix ma perché ha ripreso questo concetto e quindi di base avete sempre questi tre canali uno di input e due di output come si usano in genere lo standard input è collegato di norma all'input dell'utente quindi è il canale attraverso il quale l'utente fornisce l'input al programma a runtime quindi dinamicamente lo standard output è il canale attraverso il quale il programma fornisce output cioè il risultato quindi il risultato atteso all'utente sempre in maniera dinamica lo standard error invece è il canale attraverso il quale il programma può fornire eventuali errori che possono esserci durante l'esecuzione ok sono distinti per non sporcare l'output con gli errori ok quindi la buona norma stampare gli errori qui e stampare gli output qua proprio perché sono due cose distinte e possiamo gestire l'una separatamente dall'altra ok quindi questo è proprio per convenzione anche questa anche qui l'avete sicuramente già utilizzata appunto programmando in C o derivate perché anche in C classicamente i primi programmi che si fanno si va a scrivere hello world sul standard output ed è quello che si fa con la classica printf no oppure si legge da riga di comando si va a leggere un valore scritto dall'utente e questo si fa con la classica scanf e derivati e in quel caso si legge lo standard input quindi si leggono questi due canali di base sempre rifacendoci un attimo al mondo della shell quindi cosa avviene quando da qui viene lanciato il nostro main avviene questo ossia il terminale suggerisce cioè chiede al sistema operativo di lanciare il main ok quindi cosa avviene di nuovo viene caricato main in memoria viene copiata la riga di comando dentro main viene mandato in esecuzione main quindi a quel punto il terminale perde il controllo ma prima che questo accada main l'eseguibile in memoria viene collegato alla alla riga di comando ok per cui quando c'è questo passaggio di consegno quando main viene lanciato durante l'esecuzione di main o program in questo caso questo standard di input qui viene allacciato al terminale ok quindi l'input di program in questo caso o di main in quel caso diventa la riga di comando e l'output e lo standard error ugualmente vengono collegati alla riga di comando per cui in questo caso quando program è in esecuzione quando lui parla su questi tre canali in realtà sta parlando con il terminale ok perché è stato lanciato da qui questo perché il terminale quindi in questo caso il terminale bash che è quello più comune diciamo così fa questa operazione qui cioè lancia main e poi si collega cioè collega i canali di input e di output del processo lanciato alla riga di comando stesso e questo è il motivo per cui main può scrivere qui se questo non avvenisse main scriverebbe sullo standard output il suo canale di output di default ma se questo è collegato a nulla stampa nel vuoto cosmico ok i byte che scrive vengono persi il fatto che il terminale si allacci a standard input e standard error di main permette a main di scrivere qui ok questa è l'idea quindi viene lanciato viene collegato e a quel punto qualsiasi cooperazione di lettura scrittura su questi canali che faccia main avviene sulla riga di comando chiaramente possiamo collegarci anche ad altre cose chiaramente quindi questi canali di default esistono sempre quindi questi non possono essere non possiamo essere lanciati senza che questi canali esistano però sono collegate qualcosa che viene letto e scritto soltanto se veniamo lanciati da riga di comando ovviamente per cui nel mondo Linux in genere questo avviene per cui poi da riga di comando possiamo leggere l'input dell'utente e possiamo scrivere sulla riga di comando in Windows non avviene cioè in Windows tutti i programmi hanno sempre questi tre canali questi esistono ugualmente ovviamente però non sono collegati in nessuna parte quindi non c'è nessuno che legga quei canali e quindi se noi facciamo printf sul programma Windows nessuno leggerà mai con la printf viene scritta ci dà ok come risultato ma i byte scritti vengono scartati immediatamente perché non c'è nessuno che possa leggerli ok? come urlare nel vuoto e leggere d'altro canto ci è permesso ma non c'è nessuno che scrive ovviamente perché non c'è nessuna riga di comando non c'è nessuna tastiera collegata allo standard input quindi anche questo canale qui è esistente ma non arriva mai niente per cui se il nostro programma Windows fa una scanf per esempio rimane bloccato in attesa di un input che non arriverà mai perché non c'è nessuno che possa fornire dei byte in ingresso ok? purtroppo poi questo ciò non toglie che anche da anche in Windows se noi lanciamo un programma da terminale ovviamente lì il programma è collegato a questi canali qui perché c'è un terminale in ascolto però di default questi canali qui diciamo così sono un concetto che è nato chiaramente in ambiente Unix con riga di comando e lì è rimasto quindi vale in quello scenario lì tutti i programmi moderni infatti anche questo poi lo vedremo andando avanti tutti questi concetti fondamentali sono stati inventati ormai decenni fa quasi troppi anni fa e sono parte di un mondo completamente diverso però sono rimasti per cui anche un programma moderno come un programma per Android per dire ha questi canali ce li ha ovviamente ci può anche scrivere ma ovviamente vengono buttati nel nulla cosmico anche lì quindi questi qui resistono e tuttora ovviamente sono utilizzabili per quanto sono poco utili gli scenari moderni che noi ci immaginiamo ok ora tutti questi per un attimo qui tutte queste letture qui i canali sono lievemente più dinamici ma sono ancora abbastanza passivi nel senso che questi come ho detto qui sono tutti questo è un input statico questo non cambierà mai questo è un output che si può impostare una singola volta quando si fa quando si termina il programma giusto non so se ho delle slide con del codice fate vedere prima che faccio promesse che non posso mantenere no non ce l'ho però se immaginate il classico main scritto in C dove c'è int main poi tra parentesi c'è l'array di string che sono queste qui in input e appunto per convenzione il main in C prevede che si possa ritornare un intero l'intero di ritorno è questo qui quindi l'intero che si ritorna dal main fornirà l'exit code al nostro esecutore quindi già strutturalmente diciamo così in C è prevista che ci sia questo questo meccanismo qui classico poi abbiamo appunto i canali che però sono dinamici cioè sono dinamici perché possono essere insomma dipendono dal comportamento al runtime dell'applicazione ma vengono invocati sempre dal nostro programma cioè il nostro programma che deve essere consapevole e deve leggere l'input dell'utente quando gli serve e deve scrivere quando è opportuno quindi sono comunque operazioni scatenate dal programma stesso come si fa a segnalare delle cose che non fanno parte dell'esecuzione del programma in sé ci sono i cosiddetti segnali i segnali sono delle operazioni che permettono a chi ha lanciato l'applicazione questo in generale in genere sempre uno scenario di prima è la riga di comando quindi la nostra la nostra beniamata shell ma potrebbe essere il sistema operativo o un altro programma che ci ha lanciati tutti questi attori queste entità possono mandarci dei segnali i segnali sono degli interrupt delle notifiche diciamo così che interrompono l'esecuzione del programma quindi sono cioè bloccano in qualche modo l'esecuzione del programma perché servono anche per dare degli input un pochino più drastici rispetto all'input standard ok quindi è un modo che ha il sistema operativo per fornirci dei comandi che devono essere gestiti in maniera immediata come funzionano? allora praticamente per semplificarla prima vi avevo detto che ci sono c'è il blocco di informazioni per l'input per la riga di comando c'è il blocco di informazioni per l'output ci sono i tre canali fondamentali anche questi chiaramente potete immaginarveli come dei blocchi di memoria nel vostro programma perché ci saranno dei buffer di tour dei buffer di lettura nel vostro programma dove questi canali prendono forma in qualche modo quindi in memoria il vostro programma ha questi cinque blocchi di memoria e poi ha anche una batteria di segnale si chiama quindi ha una immaginate è un grosso array se pensiamo in C è un grosso una grossa serie di interi dovrebbe essere o di bytes non mi ricordo comunque informazioni numeriche molto semplici c'è questa batteria e questi possono essere scritti da fuori ok? quindi è come se qualcuno da fuori andasse a prendere il vostro processo e può impostare questi segnali li può switchare metterci un 1 o rimetterli a 0 come se fossero dei semafori qualche modo quando vengono switchati il vostro programma può se lo prevede può prevedere di andare a reagire a questi segnali ok? cioè per farvela per spiegarla meglio quando ho lanciato il programma il programma prevede che gestirà i suoi segnali dice ok io so che da fuori potranno mandarmi dei segnali per cui voglio gestirli voglio prevedere essere reattivo in questo senso e fornisco al sistema operativo una funzione che serve soltanto per gestire i segnali da fuori ok? quindi registro una funzione del mio programma qui dentro mettiamo che reagisce ai segnali quando da fuori poi il sistema operativo dice ok mando il segnale x al programma allora imposta questo flag questo questo semaforo ha un valore e fa eseguire la funzioncina di gestione del segnale del programma ok? quindi il programma si interrompe immediatamente fa eseguire questa funzione questa funzione può andare a leggere la batteria di segnali e vedere cosa è successo ok? e vedere ok non so faccio un esempio il separativo sta terminando devo chiudere le operazioni e smettere di eseguire quindi il nostro programma può fare queste operazioni qui appena eseguito torna ad eseguire come prima ok? quindi è un effettivamente è un interrupt che viene condizionato da fuori dal segnale che ci fornisce questo segnale come si usa come si usa nel 99% dei casi per terminare l'esecuzione del programma da fuori quindi quando voi lanciate un un eseguibile in questa forma qui e questo ci mette una vita a eseguire oppure avete lanciato un comando per errore quando fate ctrl c avviene esattamente questo ctrl c fa lancia il segnale sig term questo qui quindi sarebbe il segnale di terminazione sig signal termination o termination signal imposta il il flag di terminazione nel nell'array di segnali dell'applicazione il programma nella maggior parte dei casi non lo gestisce quindi va avanti ignaro di cosa sta per cadere se non lo gestisce non può reagire non può intercettarlo e viene terminato subito dopo ok? quindi quello che avviene è che se nessuno gestisce quella bandierina quel flag impostato allora il suo programma dice vabbè allora evidentemente non ti interessava e termina l'applicazione è il programma scusate no l'applicazione il programma ok? quindi è semplicemente un bit fate finta che sia un bit una batteria di bit si possono impostare alcuni sono molto importanti ripositi term che dicono termina per favore se non lo gestisci ti terminano fuori quindi alla fine dei conti il programma deve terminare in ogni caso poi ci sono vari segnali più o meno importanti si termina il più comune che è il ctrl c se questo non funziona poi c'è il sig kill che è quello che è più grave ancora che manda il servizio per dire che che basta così insomma se anche sig term viene ignorato sig term può essere ignorato se quindi immaginate che la nostra questo può capitare anche se avete esperienza in unix quando fate ctrl c ma la programma non termina perché non vuole quello che avviene in genere è che il programma in esecuzione gestisce i suoi interrupt interrupt scusate per cui gestisce i segnali e lo sta semplicemente ignorando quindi sta mangiando il segnale di interruzione quindi lo sta leggendo lo imposta a zero di nuovo e dice ok io continuo ad eseguire perché perché sì quindi questo questo si può fare perché da fuori sembra che sia stato gestito correttamente il segnale ok come sempre il comportamento del programma è completamente imprevedibile da fuori quindi da fuori c'è solo questo meccanismo molto banale io da fuori ti posso mettere questo bit a 1 e sperare che tu termini però ecco è una speranza che che è di nuovo è una carineria no? nei confronti del segnale operativo terminare veramente l'esecuzione ma non si è obbligati a farlo ovviamente ok questi sono i diciamo così i canali di input output più di basso livello e più comuni che si possono utilizzare se lavorate in un ambito da riga di comando no? se lavorate in C e derivati questi li avrete conosciuti ah scusate mi ero perso l'ultima freccetta quindi le variabili d'ambiente questo è un altro elemento molto molto importante per chi lavora fa un sistemista e quant'altro le variabili d'ambiente sono delle variabili che vengono impostate da fuori sempre durante il lancio dell'applicazione quindi funzionano esattamente come la riga di comando quindi funzionano in questa maniera qui c'è un blocco di variabili che possono essere impostate da fuori vengono scritte quando il programma viene lanciato e rimangono tali non possono essere modificati quindi sono soltanto in scrittura scusate sono ROM cioè possono possono essere solo lette dal vostro programma e sono scritte durante la fase di lancio in genere come funzionano il vostro sistema operativo il vostro ambiente d'esecuzione ha una serie di variabili di ambiente che sono quelle del sistema e potete chiaramente aggiungerne modificarle e alterarle come volete in genere quando lanciate i programmi i programmi si portano dietro una copia delle variabili di ambiente quindi quando vengono lanciati prendono le variabili di ambiente del vostro sistema le copiano e poi se le portano dietro per questo motivo appunto una volta che il programma è in esecuzione non potranno essere modificati quindi se modificate le variabili di ambiente del vostro sistema a posteriori dopo un lancio il programma non se ne accorgerà ok giusto per fare un esempio questo probabilmente non vi dico nulla di nuovo ma ve lo dico lo stesso questo vale per ben male a tutti i sistemi che si ispirano a Unix tra cui compreso Windows anche e quindi questa è l'interfaccina con cui si può fare queste si possono impostare queste variabili di ambiente la trovate qui cercando variabili di ambiente e queste sono tutte le variabili di questo sistema qua ok quindi ci sono tutte delle coppie chiave e variabile quindi alcune cose sono completamente inutili ma alcune cose sono il sistema tipo il numero di processori questo è un 4 il tipo di sistema operativo il path lo conosce sicuramente perché sono i percorsi dove il sistema ma anche gli altri programmi possono andare a cercare degli eseguibili l'architettura quali sono quali sono gli eseguibili quindi vi dicevo prima che gli eseguibili su Windows sono ex non è vero sono tutti questi qui e potete cambiarli per cui sono com, ex, bat cmd vbs eccetera sono tutti degli eseguibili sulla carta e per cui se avete se volete aggiungere un eseguibile basta aggiungere qui l'estensione che volete lanciare cioè che volete che sia lanciabile e così via queste informazioni qui se voi in un programma qualsiasi scritto in qualsiasi linguaggio che volete se andate a leggere le variabili di ambiente riuscirete a leggere esattamente questi valori qui ok andate a leggere la variabili di ambiente non so processor level e troverete il valore 6 e come vi dicevo prima se il programma in esecuzione modificare questo valore qui non cambia il valore che sta leggendo il processo in esecuzione viene fatta una copia integrale dei valori quando viene lanciato ok benissimo altri sistemi che abbiamo per comunicare con i programmi sono le system call questo poi le vedremo più in dettaglio ma tutte le chiamate a funzione quindi tutte le chiamate di sistema che permettono al processo di parlare con il sistema operativo quindi con il kernel in qualche modo rientrano in quella che si chiama le chiamate di sistema e permettono al programma di dire qualcosa al sistema giusto? quindi possiamo aprire dei file possiamo chiudere dei file possiamo mandare delle informazioni possiamo spegnere il sistema possiamo fare una serie di operazioni anche abbastanza importanti e ci permettono di comunicare in vari modi tra l'altro altra cosa qui le system call poi vedremo possono essere di varia natura alcune di queste ci permettono di creare dell'interfaccia utente anche chiaramente perché quando poi vedremo come si programma l'interfaccia utente su Windows vedremo che tutte le operazioni con cui andiamo a creare delle finestre dei pulsanti reagire ai click che arrivano e così via funzionano con dei meccanismi abbastanza arcaici e strani ma ovviamente sono dei system call quindi noi chiamiamo il sistema che è Win32 e gli diciamo guarda voglio una finestra qui voglio un pulsante qui voglio fare questa cosa qui e poi di conseguenza compare l'interfaccia utente che fa quello che noi vorremmo quindi questo punto per quanto generico è anche molto passo in realtà quindi racchiude molte cose altre cose fondamentali di comunicazione sono la comunicazione inter processo questo l'avrete visto al corso di sistema operativo ovviamente o di reti sono mille modi per farlo tutti un po' diversi ma alla fine dei conti sono dei sistemi che permettono di trasferire dei byte da un processo all'altro di base quindi a questo punto non comuniciamo più verticalmente con il sistema questa comunicazione finora era tutta verticale verticale nel senso che parlavamo con chi ci ha lanciati giusto? quindi la shell o il sistema operativo e quindi in qualche modo era verticale con la comunicazione inter processo parliamo in maniera orizzontale quindi parliamo tra processi che sono pari per virgolette quindi sono stati lanciati magari dalla stessa shell dalla stessa sistema operativo però non si potrebbero comunicare di norma se non con questi strumenti qui ce ne sono vari cambiano da sistema a sistema per cui ve li butto lì giusto così per nozionismo uno strumento abbastanza comune sono le named pipes quindi le le pipes sono dei tubi in sostanza dei tubi per vista del sistema operativo a cui possiamo dare un nome dei tubi proprio perché sono dei come si può dire degli oggetti astratti in cui entrano in formazione da una parte e escono in formazione dall'altra quindi è una specie di file astratto senza dimensioni in cui qualcuno può scrivere e l'altro può leggere e viceversa quindi appunto sono dei tubi in quel senso possono avere un nome nel senso che possiamo creare un tubo di nome pippo e sapere che quello poi esiste possiamo scriverci e se c'è un altro processo da qualche altra parte che apre accede al tubo pippo può leggere al tubo e quindi noi possiamo passarci delle informazioni che possono avere la forma e insomma la codifica che preferiamo la stessa cosa vale per le socket le socket sono un'astrazione che avrete visto al corso di resi presunvolmente un'astrazione che ci permette esattamente come le pipe esattamente come i file astratti di scrivere dentro un oggetto opaco incomprensibile come la socket e sperare che attraverso una serie di passaggi estremamente tortuosi questi byte arrivino dall'altra parte dell'universo perché c'è un'altra socket aperta su un altro processo remoto su un server in Patagonia che sta leggendo i nostri byte quindi lo stesso concetto però potenzialmente su un fronte più esteso potenzialmente dico perché chiaramente si può usare una socket anche in locale quindi posso aprire una socket locale sul mio sistema scriverci come se fosse una comunicazione remota e può essere letta da un processo che è sulla stessa macchina ok quindi semplicemente complicando l'astrazione siamo partiti dai file che è la nostra astrazione preferita che è un blocco di dati da cui leggere abbiamo visto i canali che sono la stessa cosa ma sono infiniti hanno una lunghezza non specifica e sono astratti le named pipes sono dei canali con un nome quindi sono come se fossero dei standard in e standard out però sono al di fuori da questi tre da questa triade classica le socket sono la stessa cosa però in maniera ancora più astratta ok quindi sono delle pipe dei canali di comunicazione che possono volendo essere proprio dislocate nel globo poi su questi strumenti quindi sulle pipes sulle socket possiamo crearci le nostre astrazioni ancora più complesse ovviamente insomma per complicarsi o semplificarsi la vita gli informatici sono degli esperti per cui insomma ci sono vari strumenti più o meno sofisticati che si basano sui stessi principi ma che vi danno degli strumenti più complessi quindi Dbus è il bus di comunicazione classico su ambiente Linux in particolare COM è un sistema di comunicazione per oggetti astratto che è per Windows e che in particolare dovete combatterci se mai avete la pessima idea di lavorare con la DirectX quindi se volete fare grafica tridimensionale Windows parlate con questa roba orribile qui Corba è un sistema multipiattaforma per fare la stessa cosa di COM WCF è un sistema di comunicazione astratta sempre alla fine sopra le socket che però permette di passare degli oggetti complessi e così via quindi sono tutti strumenti che adesso non vedremo in dettaglio perché non serve non serve a molto però sappiate che sulla base di questi strumenti qui esistono delle sovrastrutture possibili che potete adottare per rendere un pochino più efficienti o complesse le vostre comunicazioni alla fine conti comunque sempre di un tubo si tratta in cui buttare dei byte e leggere dei byte quindi alla fine ci si può complicare la vita quanto volete però alla fine il meccanismo fondamentale è sempre quello e anche qui appunto comunicazione remota vi dicevo prima le socket possono lavorare tra processi sulla stessa macchina tranquillamente ma possono vi aprono l'orizzonte del mondo perché potete parlare anche con server remoti poi su per le socket chiaramente anche esattamente come di bus, com, corb e così via possiamo crearci dei protocolli più complessi tutti i protocolli di comunicazione più sofisticati di di quelli previsti dalle socket quindi TCP UDP che avrete sentito nominare o avete già utilizzato tutti i protocolli più complessi possono essere implementati al di sopra delle famose socket di tutta questa roba qui alla fine ci interessano i system call che vedremo perché parleremo con il kernel per darci accesso alla grafica e poi ci interesserà l'HTTP che è il protocollo principe del web che è il protocollo di trasferimento di ipertesti che useremo per comunicare con dei servizi esterni perché in genere è il protocollo in assoluto più utilizzato anche dalle applicazioni mobili per scaricare informazioni aggiornarsi e così via ok a questo punto abbiamo visto cos'è un programma devo annoiarvi un altro po' parlando di processi queste sono tutte cose che avete già visto in abbondanza però giusto per per così per mettere in metterci in pari quindi il processo è un'istanza di un programma in esecuzione per come lo vede il sistema operativo ok quindi il sistema operativo è il nostro amico che gestisce in qualche modo la macchina quindi si prende la briga di astrarre tutto quello che è la ferraglia che fa funzionare il computer e ci offre una serie di interfacce di funzioni che permettono al nostro processo al nostro programma scusate di andare in esecuzione e vivere come processo dentro il sistema operativo ok quindi la distinzione fondamentale è il programma è il binario eseguibile ed è eseguibile sulla macchina ok quindi la cosa importante è che il programma sulla carta può essere eseguito qui dentro direttamente è il processore che a un certo punto salta tra virgolette nel nostro codice e va ad eseguire i nostri le nostre istruzioni e va a fare le cose che abbiamo detto di fare però tutto questo meccanismo funziona perché c'è il sistema operativo che mette in memoria il nostro programma in qualche modo e lo fa funzionare in un ambiente molto più sofisticato che è però di base quando parliamo di esecuzione siamo qui dentro per andare in esecuzione però c'è tutta una sovrastruttura che è permessa da questo livello qui quando andate a fare quando avete cioè quando andate a eseguire il comando ps su qualsiasi sistema Unix avete questa bellissima brodaglia di caratteri che vi dà un'idea di quali sono i processi in esecuzione quindi la visione per quanto riguarda il sistema operativo dei processi in memoria e in esecuzione è data da questa da questo schema tabulare che ci dà un'indicazione di quello che sta avvenendo ok quello che è interessante vedere qui giusto per ricollegarci le cose che ho detto precedentemente vorrei far confusione uno di questi qui non mi ricordo assolutamente quale è la dimensione del questo è l'identificativo la dimensione dovrebbe essere uno di questi due sto commettendo chiaramente degli errori sicuramente uno di questi due è la dimensione in memoria del nostro processo ok quindi il processo vi dicevo prima quando viene lanciato viene copiato in memoria e ha una serie di dati accessori che gli permettono di comunicare i canali la riga di comando il vero ambiente e così via tutte queste informazioni qui sono dentro il suo spazio privato lo spazio privato di un processo comprendono una serie di informazioni tra cui anche il codice dell'eseguibile ma non soltanto e poi chiaramente quando il programma viene in esecuzione poi potrà allocare altra memoria quindi questo numero potrà gonfiarsi se il programma deve allocare memoria però di base c'è almeno il codice e almeno queste variabili di sostegno in qualche modo che sono il modo con cui il programma comunica con il sistema quindi uno di questi numeri qui è questa cosa qui mi scuso perché non mi ricordo qual è delle due colonne non è rilevante ovviamente l'altra cosa importante è questa cosa qui questa è la riga di comando di cui si parlava prima quindi qui il vostro sistema operativo quindi in realtà il programma ps che è uno strumento di base del sistema operativo linux in questo caso vi dà access vi dà l'elenco dei processi e vi scrive qui la riga di comando è questa informazione statica che è la legge dal processo stesso ok questo qui è il comando con cui quel quel processo è stato lanciato quindi questo è il demon di MySQL questo è MongoDB questo è Node e così via quindi vedete che cos'è in base a come è stato lanciato poi in sé il processo è completamente opaco voi avete solo nozione di come è stato lanciato da questo qui ok però poi dentro come è fatto o se è veramente quel file lì in realtà non lo potete sapere ok quello è il comando con cui è stato lanciato potrebbe essere qualsiasi cosa ok ora questo è la stessa cosa ma in un ambiente più grafico questo è il classico il task manager o quello che si chiama giusti di attività in Windows 10 credo e questo già si differenzia parecchio dal modello prima non tanto soltanto per la grafica un po' più umana ma perché parla proprio di applicazioni questa è una differenza fondamentale che in qualche modo anticipa quello che adesso faremo nel definire applicazioni e distinguere dai programmi perché quando aprite giusti di attività in Windows quello che vedete è la lista delle applicazioni e non la lista dei processi la lista dei processi è ben nascosta sotto c'è un modo per leggerla ma non mi ricordo assolutamente mi sa che sotto dettagli vero Sanzi perché non ci cliccherebbe mai nessuno volontariamente per cui solo se sa cosa deve andare a fare l'utente medio chiaramente usa meno dettagli e vede solo la lista delle applicazioni attive ok? di base perché le applicazioni sono diciamo così l'idea l'astrazione che l'utente diciamo così standard di un sistema operativo ha di quello che avviene a schermo ok? ed è quello che ci mostra bene o male Windows per cui sotto a questa questo elenco di applicazioni in esecuzione si possono nascondere uno almeno uno e ho più processi ok? quindi è un'astrazione che potrebbe nascondere in realtà più processi in memoria quindi per arrivare alla nostra definizione fondamentale un'applicazione è un programma che è sviluppato per un utente finale quindi quello che si chiama end user in gergo quindi l'utente finale è un utente non tecnico in genere è un utente che deve fare una qualche attività con il sistema operativo quindi deve scrivere un foglio di testo deve mandare un'email deve navigare sul web e così via e ha quell'attività in mente e non si cura dell'aspetto tecnico di svolgere quell'attività e l'applicazione è lo strumento con cui fa quell'attività in sostanza in genere sul sistema grafico come Windows Mac OS e così via in genere ha un'ultrafaccia utente nel senso più generale del termine peraltro perché ha un'intrafaccia utente cioè una finestra si intende almeno una finestra con cui interagire ma al minimo ha un'iconcina da qualche parte con cui l'utente può interagire perché i processi per loro natura non li vediamo mai quindi possono essere in esecuzione possono essere dei servizi di sistema possono essere dei processi completamente invisibili finché l'utente non vede la lista dei processi attivi l'applicazione deve essere in qualche modo palpabile e presente per quanto riguarda l'utente che deve poterla controllare in qualche modo e un'applicazione come dicevo prima può essere composta da uno più eseguibili in realtà in esecuzione o in esecuzione concorrente o uno dopo l'altro o in altri modi in concerto in qualche modo perché appunto un'applicazione può essere più sofisticata di un singolo processo un processo magari un'applicazione complessa può lanciare vari sottoprocessi può rimpallare l'attività da un processo all'altro può avere un processo padre che poi smercia le attività da fare a vari sottoprocessi e così via però questo dettaglio di come questo concerto di responsabilità avviene in realtà non ci interessa l'importante è che l'utente sappia che è in esecuzione dell'applicazione tal dettaglio per farvi un esempio abbastanza concreto vediamo se riesco a farlo proprio live immagino sì l'esempio più concreto di questo è un browser qualsiasi quindi in questo caso Firefox che dovrei avere già aperto esatto perché i browser sono tra i programmi le applicazioni più complicate che potete immaginarvi per la stessa natura per cui qui vedete che appunto c'è Firefox in esecuzione sono varie stanze di Firefox però se apriamo i nostri famosi dettagli qui vedrete che questi sono effettivamente i processi in esecuzione quindi esattamente questo è come il PS di prima in Linux qui vedete che ci sono vari processi qui ci sono un bel numero di Firefox in esecuzione qui vedete che sono almeno una decina alcuni occupano parecchio alcuni occupano di meno quindi non sappiamo esattamente cosa stanno facendo i vari processi però possiamo immaginare che facciano cose ben diverse in genere magari uno si occupa dell'aggiornamento dell'applicazione ogni settimana va a verificare se c'è un aggiornamento questo molto grande si può immaginare che sia il processo principale che gestisce le schede e tutti i browser moderni in genere per stabilità poi delegano le singole pagine che mostrano a sottoprocessi quindi se una pagina si comporta pagina web si comporta in maniera poco carina e occupa non so quanta memoria semmai è quel processo lì che può essere terminato in maniera improvvisa senza andare a diciamo così minare la stabilità del processo principale che immaginiamo essere questo gli altri sono processi di servizio che saranno attivi soltanto se navigo su una pagina se apre una pagina nuova se interagiscono in qualche modo ma sono abbastanza statici in questo momento stessa cosa vale in realtà anche per zoom possiamo immaginare zoom vedete che molto vuoto anche zoom esiste in varie salze d'altro qui vedete come qui windows cerca di questa diciamo così per windows il sistema operativo esistono solo questi ok quindi la visione che ha il sistema operativo è questa come linux come tutti i altri sistemi quindi questo è quello che vede il sistema di quello che è in esecuzione poi con delle euristiche più o meno magiche cerca di capire come metterle insieme in modo che cambia senso per l'utente finale quindi infatti questi due zoom siano parte della stessa applicazione in realtà è una carineria del sistema operativo appena ce la fa quindi ci mostra questi due processi eh inglobati come se fosse la stessa cosa ma in realtà non lo sono ok sono due processi distinti che fanno cose probabilmente diverse quindi uno di questi posso immaginare sia la finestra di zoom che mi dà l'elenco delle delle cose in calendario e l'altro sarà la sessione che stiamo registrando e l'altro ancora sarà il processo grafico che ci dà questo pannellino qui posso immaginare però non lo possiamo sapere per certo stessa cosa vale per powerpoint e così via quindi qui vedete la vera natura delle cose e poi chiaramente ogni processo ha le sue le sue cose che nasconde c'è anche un altro modo se ricordo bene per vedere i dettagli se non ricordo male si può fare no non si può fare c'era un modo misterioso questo qui è giusto questo ci dà il processo di riferimento per quel processo in particolare che ci permette di risalire in qualche modo ai processi in esecuzione ok quindi questa è la distinzione fondamentale è un'estinzione arbitraria ovviamente come dicevo prima però è una distinzione che per l'utente finale ha abbastanza senso l'esempio più anche qui più quello adesso l'abbiamo fatto live con Firefox quindi non aggiunge molto l'esempio più classico è se avete mai usato macOS è il blocco noto di macOS che è un text edit che è come blocco noto di Windows è un programma molto banale che fa una cosa e basta quindi permette di modificare dei file di testo però è possibile avere un'esecuzione tanti senza saperlo in realtà perché per ogni scheda in realtà ce n'è un'esecuzione un altro cioè sono tutti processi paralleli che sono in esecuzione per ogni singolo file aperto e e quindi macOS quindi se no vi nasconde la complessità sottostante camuffandovela graficamente in quello che è per voi una singola applicazione in esecuzione ok quindi questa è un po' è un po' l'idea tal'altro giusto per completare il discorso macOS è particolarmente sofisticato da questo punto di vista perché fa questa cosa ancora più in maniera profonda rispetto a Windows perché lì in particolare avete che le singole applicazioni sono tutte aggregate nel classico dock sotto nel dock di macOS dove avete le varie iconcine attive quindi anche lì l'iconcine è sempre soltanto una ma può nascondere n processi uguali o diversi e n finestre anche quindi è un mondo ancor più complesso se volete di quello che vi dà Windows però l'idea di fondo è sempre la stessa quindi un'applicazione è quello che vedete a schermo che vi permette di fare delle cose e che internamente poi vengono svolte da uno o più processi a voi in maniera completamente da spare ok direi che questo l'ho snocciolato in grande dettaglio forse anche eccessivo per cui direi di andare avanti e passiamo invece alle piattaforme di applicazioni quindi abbiamo visto già visto già accennato macOS Windows e questi sistemi qui che per loro natura espongono queste applicazioni adesso li vediamo più in dettaglio questi questi mondi intanto sempre per dare delle definizioni è utile definire dei dei sottocomponenti in qualche modo di un'applicazione quindi quando il nostro programma va in esecuzione su una qualsiasi macchina vi dicevo prima appunto è vero che il nostro programma per come è scritto nel nostro linguaggio poi una volta compilato va in esecuzione qui sulla macchina hardware quindi sulla ferraglia vera e propria ma non lo può fare se non c'è un sistema operativo di mezzo che gli permette di farlo e poi in realtà nella maggior parte dei casi quindi anche qui nel 99,9 periodo dei casi ci sono degli oggetti delle entità aggiuntive che sono fondamentali perché il nostro programma possa eseguire veramente e questi sono i framework e runtime adesso vediamo che cosa si intende per queste due definizioni ah intanto partiamo proprio dalla base quindi il sistema operativo è il quella componente che è al di fuori del nostro programma come vedete qui anche dallo schemino non è parte di quello che possiamo controllare noi e quindi viene vive al di fuori del nostro programma per definizione quindi è il sistema che ci carica in memoria poi ci lancia quindi per definizione non potrebbe essere altrimenti è un oggetto a noi esterno noi intendo il nostro software e anche di queste ne esistono 2000 varianti ovviamente per cui qui non mi dico nulla di nuovo si parte dal primitivo MS-DOS a tutti gli Unix a Windows Mac OS e così via nulla di nuovo alcuni tra l'altro sono sovrapposizioni per cui in realtà anche Android se volete fa parte della famiglia di Linux e così via però non andiamo a mischiarci in cose in dettagli inutili passiamo al runtime il runtime è una suite un sistema un software che noi scegliamo perché vogliamo che il nostro programma esegua dentro il runtime ok runtime tradisce in qualche modo questa idea nel senso che runtime è quello oggetto che ci permette di eseguire quindi di mandare in run il nostro programma se scegliamo un runtime il nostro programma fa uso delle primitive di questo runtime per funzionare ok lo dico in maniera così astratta perché i runtime sono tanti in realtà perché in maniera poco anti-intuitiva anche il linguaggio C in realtà vi dà un runtime di base noi siamo abbastanza per sentire o dire magari siamo abituati a pensare a Java e .NET e Python magari anche e altri linguaggi di questo genere come linguaggi che hanno un runtime necessario per farli girare in realtà anche C C++ ma qualsiasi altro linguaggio Go Dart pure insomma per parlare di linguaggi che conosciamo prevedono un runtime il runtime è quella serie di strumenti di oggetti di convenzioni così via che permettono al nostro programma scritto in quel linguaggio di funzionare ok chiaramente banalmente il runtime C ci serve se scriviamo un programma in C e il runtime C++ servirà se scriviamo in C++ e così via quindi non dico nulla di nuovo alcuni runtime sono multilinguaggio quindi classicamente il runtime Java nonostante il nome è nato per far girare applicazioni scritte in Java ma poi permette di scrivere anche gli altri linguaggi tipo Scala credo ma altri che sono non cotto di girare su Java sai no perché quello era il runtime art no GVM anche ok perfetto e quindi può accogliere vari programmi scritti in vari linguaggi come anche .NET che è multilinguaggio per dire per vocazioni quindi c'è C Sharp che è il linguaggio principe però c'è F Sharp c'è Visual Basic c'è vari altri meno popolari oppure Python che notoriamente è un linguaggio interpretato non sempre però parte come linguaggio interpretato per cui il runtime è particolarmente importante perché non soltanto deve far girare il programma ma deve anche interpretarlo quindi il runtime in Python è ancora più invadente come oggetto però comunque sì il runtime c'è quindi il runtime C notoriamente è molto piccolo il runtime Python è molto grande il runtime .NET è sterminato anche il runtime Java è bello grande però in base a quello che noi utilizziamo il runtime è più o meno ha delle funzioni più o meno sofisticate perché devono far funzionare tutto quello che è l'infrastruttura del programma quindi di nuovo per fare degli esempi il runtime C ci dà quel poco che serve per far funzionare un programma in C quindi ci dà il main ci dà come parlare con il seno operativo alcune operazioni con le string ci dà pochissime cose però insomma ci è popolare per la programmazione di basso livello non giustamente perché è molto scarno da quel punto di vista C++ è un ingaggio molto più impegnativo invece è molto più complesso ha le classi quindi tutto insieme di gestione delle classi al runtime è tutto nel runtime C++ gestione tutta la standard library C++ che è enorme si è confrontata con C che ha tante altre cose che sono tutte nel runtime e così via e come dicevo prima appunto Java, .NET e Python hanno librerie standard ancora più importanti per cui ovviamente hanno molte più cose che potete utilizzare di default perché sapete che c'è il runtime sotto quindi le liste in Java le liste in .NET e qualsiasi altra cosa di questo genere adesso vedremo qualche esempio in pratica per quanto riguarda invece i framework quindi il framework abbiamo visto il separativo runtime è proprio l'impalcatura di base che permette l'esecuzione senza la quale non possiamo eseguire il framework è invece una serie di strumenti software che possiamo utilizzare in maniera completamente opzionale quindi siamo noi i programmatori del nostro programma di riferimento che scegliamo di utilizzare un framework di sviluppo perché ci piace ok però è completamente opzionale per farvi un esempio anche qui se avete mai fatto la scelta molto sbagliata di fare applicazioni grafiche in C++ potreste aver fatto la scelta troppo sbagliata di usare le Qt le librerie di grafiche che erano nate in ambiente Nokia addirittura se vi ricordo bene però sono abbastanza vecchiotte esistono ancora per cui molti programmi moderni comunque vengono ancora scritte con le Qt e sono un framework di sviluppo grafico per C++ quindi praticamente si appoggiano a C++ quindi a tutto il runtime C++ perché vi espongono delle classi in C++ che permettono di creare delle finestre il tra giro con le finestre i pulsanti e così via se avete sviluppato applicazioni grafiche vecchio stile con Java potreste aver utilizzato avete aver utilizzato le Swing che sono le librerie quelle più classiche diciamo così per Java per fare interfacce grafiche grafica grafiche sì e per .NET c'è il corrispettivo che si chiama Windows Forms che è una un framework che si appoggia a Windows e le librerie Win32 che adesso vi accenno soltanto ma praticamente sono le librerie di supporto per fare la interfaccia grafiche su Windows quindi Windows Forms in qualche modo è il contraltare a Swing su .NET se volete in Linux derivati c'è c'è una GTK molto popolare GTK sono una serie di librerie grafiche che permettono di fare interfacce grafiche appoggiandosi su un server X11 e in particolare se usate l'interfaccia genome è tutto fatto in GTK e così via e poi qui queste sono per le web app quindi non è che ci interessa particolarmente però in genere tutte le sovrastrutture software che potete usare oppure no che sono a scelta vostra rientrano a pieno titolo in quelli che sono i framework per farvi giusti gli esempi noi i tre laboratori che faremo sono Win32 con C quindi lavoreremo in C in questo caso la nostra applicazione userà il runtime C e non userà nessun framework perché non c'è nessun framework di supporto e parleremo direttamente con il serverativo per fare le nostre finestre quindi questo è il laboratorio numero uno che faremo che sarà quello più basso livello con martello e scalpello poi useremo .NET con Windows Forms in quel caso avremo un'applicazione scritta in C Sharp framework sarà Windows Forms il runtime sarà .NET e il sistema partito sarà Windows però in realtà è compatibile anche con macOS e altri ultimamente per cui si può fare anche dell'altro poi con Flutter che sarà il punto da prod d'arrivo avremo un'applicazione che si appoggerà a Flutter come framework quindi Flutter sarà la componente opzionale che ci permette di fare interfacce grafiche il runtime è il runtime DART che è il runtime che permette all'eseguibile cioè al programma scritto in DART di girare qui sopra e il sistema operativo sarà o Android o iOS o in realtà anche Windows o Mac OS quello che preferite però questo cambia poco cambia voglio dire e la cosa bella di questo approccio stratificato in qualche modo è che se i framework sono multipiattaforma e i runtime lo sono altrettanto allora la nostra applicazione è effettivamente portabile quindi possiamo portarla in maniera abbastanza indolore questo tra molti virgolette da un mondo all'altro perché sappiamo che questi oggetti qui sono portabili quindi scrivere un'applicazione in Go per dire che gira dappertutto noi sappiamo che il runtime esiste per Windows per Mac OS per Linux e così via quindi sappiamo che possiamo compilarlo per tutti questi sistemi senza doverli riscrivere questa è l'idea stessa cosa vale per Cici all'epoca era appunto era di un modo popolare proprio perché il suo micro runtime permetteva di scrivere applicazioni senza legarsi al seno operativo di base ok quindi potremmo scrivere applicazioni per tutti i sistemi parlando in C ora per rendere più chiaro il ruolo del runtime ah scusate ultima cosa su questo elemento ci sono approcci diversi con cui possiamo far girare runtime per complicare un po' la vita allora quando il runtime è compilato staticamente dentro il nostro programma generalmente avviene quello che vedete nello scenario a sinistra quindi la nostra applicazione è quella che viene messa in memoria la nostra applicazione contiene il runtime perché il runtime viene scaraventato dentro con con foga a tempo di compilazione e il framework se c'è ugualmente viene inglobato dentro la nostra applicazione la nostra applicazione è questo blocco verde che contiene il runtime e contiene il framework questo avviene eh ne in dotnet moderno avviene questo avviene in flutter scusate in dart scusate quindi quando programmiamo in flutter avviene esattamente questo il nostro il nostro la vostra applicazione di progetto sarà un'applicazione come questa grandina verde che contiene flutter il framework e contiene il runtime dart quindi il runtime dart viene inglobato a tempo di compilazione ve lo portate dietro tant'è che gli eseguibili flutter sono molto grandi perché contengono tutta questa roba qui in sostanza sono eseguibili abbastanza massicci perché c'è tutto tutto questo insieme di software che vi portate dietro l'altro approccio è quello di avere il runtime condiviso cioè avete il runtime che è sulla macchina e poi il runtime che carica dentro la vostra applicazione che contiene il framework ok quindi questo è l'altro approccio questo è l'approccio classico che viene utilizzato da .NET vecchia maniera e Java in particolare quindi Java se avete mai visto Java classicamente si installa Java sulla la standard edition o quello che volete sulla macchina e poi quando lanciate un applicativo Java in realtà lanciate Java che carica il pacchetto come si chiamano i pacchetti Java? jar jar grazie sì i jar i jar quindi il compilato di Java viene caricato dal runtime Java e poi viene mandato in esecuzione però è il runtime che è il saluto della macchina e carica l'applicativo ok poi il runtime gira sul sistema operativo però il runtime questo in realtà è l'approccio più efficiente perché il runtime poi se avete mille applicazioni Java è tutto condiviso quindi il runtime esegue una volta cioè concettualmente è iniziato una volta sola ed esegue tante applicazioni nell'altro esempio chiaramente avete tutte applicazioni molto grandi perché si portano dietro tutto il runtime quindi insomma vantaggi svantaggi la comunità di questo è che qui il vostro applicativo è statico quindi è staticamente compilato si dice quindi la compilazione butta tutto in un singolo eseguibile e quindi questo potete prenderlo e copiarlo incollarlo proprio così com'è su varie macchine diverse l'importante è che questo non cambi quindi finché il soprativo è lo stesso un binario fatto in questa maniera voi potete prendere e copiare e eseguire alla stessa identica maniera in questo caso no in questo caso dovete installare prima il runtime e poi fare in modo che il lanci l'applicativo quindi questo è il classico problema probabilmente della scomunità di Java classico e questo è il modello che più modernamente si utilizza in genere anche anche Python ultimamente adotta questo approccio qui in cui avete un binario enorme che comprende tutto però ha la comodità di avere tutto quanto pacchettizzato dentro ok questa è la la differenza quando lavoriamo con runtime molto piccoli ovviamente l'approccio è sempre questo di base quindi quando lo abbiamo in C in particolare C non ha questo approccio qui ok ha questo approccio qui per cui il runtime C sarà sempre dentro la vostra applicazione perché è così tanto vale però abbiamo visto prima no la differenza quella ce la faccio saltare sull'altra slide chissà forse ho molte slide dove era qui no qui quindi quando eravamo qui avevo visto che il sorgente di main.c è ridicolo in dimensione quando viene compilato diventano 8k perché perché la maggior parte del codice cioè il codice che segue Hello World ovviamente sono tre istruzioni in croce quindi copio la stringa Hello World da qualche parte poi eseguo printf e ho fatto quindi sono quattro istruzioni non dovrebbero occupare molto il resto è tutto runtime ovviamente quindi questi 8k sono prevalentemente runtime e poi più qualche accessorio del del punto exe però ecco quindi diciamo così che qui in questo caso il runtime C occupa 8k quindi il grosso dell'applicazione chiaramente è lì chiaramente man mano che l'applicazione cresce quindi il vostro main diventa più sofisticato poi il costo iniziale del runtime ci diventa minore e la vostra applicazione prenderà lo spazio maggiore e giusto per concludere invece C++ comunemente almeno così usava l'approccio inverso quindi si installava runtime C++ e poi che viene condiviso tra tutte le applicazioni e poi e poi l'applicazione si appoggia a quella però ecco dipende sempre da come viene compilato l'applicativo com'è il sistema com'è fatto e così via però ecco ci sono vantaggi svantaggi per entrambi i mondi però ultimamente negli ultimi anni si sceglie sempre più questa via qui perché lo spazio sul disco è sempre presente in abbondanza quindi non c'entra niente e possiamo praticamente scaricare eseguibili da 300 mega quando scarichiamo che non so Spotify o cose del genere ma ben uguale e poi l'importante è che sia tutto quanto in un pacchetto unico senza dover dipendere da mille sottocomponenti ok sono già le 4 per cui mi interrompo qui perché a questo punto poi ci addentriamo in quelle che sono le interfacce di comunicazione tra tutti questi strati qui quindi abbiamo visto la stratificazione classica tutti questi strati si parlano in qualche modo ovviamente e questo determina quello che chiaramente la nostra applicazione potrà fare poi da da domani vedremo in dettaglio di cosa si tratta se sono domande volentieri vi rispondo se no vi rimando a domani vediamo in dettaglio se sta funzionando ok grazie a tutti