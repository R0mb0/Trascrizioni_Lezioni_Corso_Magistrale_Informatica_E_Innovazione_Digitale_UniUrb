esperienza magari con Dart. Sì. Torci il porto, secondo me. Bene. Ok. Mentre avete esperienza con magari C Sharp, invece. Anche dare modo che c'è un esperto di Dart. Ok. E vedete che Dart, diciamo così, si ispira in qualche modo a vari linguaggi, che cerca di radunare un paio di ispirazioni qua e là, per certi versi somiglia abbastanza a C Sharp, per molti versi. Quindi molti elementi, a mio giudizio, però forse è distorta dalla mia conoscenza di C Sharp, molti richiami sono proprio a quel linguaggio lì, però molti altri elementi invece sono propri di Dart e lo rendono un linguaggio un po' tutto a sé stante, con tante differenze fondamentali, ci sono tante altre linguaggi. Per cui cercheremo di vedere per differenza quei tre linguaggi, magari per sottolineare a cosa fare attenzione e quali sono eventuali problemi in cui ci si può imbattere. La prima cosa da fare, chiaramente, è installare il AdSolcente, quindi la mette in sviluppo. Ve l'ho mandato sul forum ieri, ma l'ho fatto un po' tardi, perché non so se avete fatto un tempo a fare alcun che. In ogni caso ve lo faccio vedere rapidamente come funziona. Allora, chiaramente Dart potreste installare il compilatore in maniera indipendente, quindi volendo potete scaricarlo a parte, però nel nostro scenario, visto che lo useremo per fare, per lavorare con Flutter, la cosa più sensata da fare è installare direttamente Flutter, e poi che si porta dietro chiaramente il compilatore per Dart, cioè di Dart. Per cui, dalla pagina del Get Started di Flutter, trovate i vari link alle varie piattaforme. Nel mio caso, chiaramente, scelgo Windows, in questo caso, e la procedura di installazione è molto semplice, molto primitiva, e somiglia molto a quella che avevo già fatto con TinyCC, quindi in realtà dovete scaricare un grosso zippone, magari possiamo anche rifarlo, un grosso zippone che va scaricato dove volete, e una volta che l'avete ottenuto, va decompresso dove preferite. Qui vi suggerisce user profile, che è il vostro profilo utente, o qualche altra cartella. La cosa importante è che venga decompresso, non dentro programmi, applicazioni e così via, deve essere una directory, o meglio, è meglio se è una directory in cui potete scrivere senza diritti da super utenti, in sostanza, quindi deve essere una cartella scrivibile dal vostro utente standard, diciamo così. La rete è lenta, per cui è molto incoraggiante per chi ci segue da remoto. Vabbè, non aspettiamo oltre, direi, visto che ci stiamo mettendo una settimana, però una volta ottenuto il pacchetto si apre, anzi, posso farvi vedere quanto meno il pacchetto no pezzallato, perché una volta preparato tutto, dovresti avere Dart eseguibile, che nel mio caso si trova esattamente dentro la cartella user profile, quindi si trova proprio qui. Anzi, non è vero, è di sotto. Local app da Talones per quantità. Però, come detto, voi potete mettere veramente se volete, qui io tengo i vari programmi di varia natura. Questo è lo zip aperto, diciamo così. Una volta aperto qui dentro, dentro bin trovate i vari eseguibili, chiaramente come da prassi. Qui trovate sia Dart che Flutter, sono due file .bat, che poi fanno i loro vari magheggi. Una volta aggiunta questa cartella qui al percorso, quindi all'ambiente, alle varie ambienti, scusate, quindi con questa procedura, adesso ve la mostro giusto al volo, bisogna sempre modificare la varia ambiente path, qui fare in modo che l'utente abbia il percorso a Flutter, cioè, dove? Non so dove è finito. Flutter bin, ecco qui. Questo qui, una volta l'ho aggiunto, riaprende il terminale e dovresti avere Dart. Quindi, se fate Dart, meno o meno version, dovrebbe accompagnarvi la versione di Dart. Altra cosa che potete già fare, a questo punto c'è anche Flutter, quindi vengono insieme, quindi c'è anche l'eseguimento di Flutter. Flutter, ugualmente, potete richiamare la versione, dovrebbe essere l'ultima, che è la 3.1.13, no, la 13.9, scusate, la 13. E altra cosa che si può già fare, questo magari lo vediamo meglio domani, però Flutter, chiaramente, vi dà accesso a tutta quella che è la compilazione, l'esecuzione, il debugging, eccetera, dei vari progetti fatti con Flutter, ma se volete vedere che tutto sia configurato meglio e corretta, potete chiamare Flutter Doctor, si chiama il comando, che ci mette un po', raccoglie un po' di informazioni e vi dà un'idea di quello che avviene sul vostro sistema, se tutto è disponibile e configurato in maniera corretta. In questo caso, io qui ho Flutter, che mi dà la spunta verde, per cui c'è sia Dart che Flutter, quindi va bene, Windows va bene, non ho la tool chain Android, non ho la tool chain Visual Studio, non ho altro studio e così via. Quindi, in realtà, nel vostro scenario, se non avete installato altri pacchetti, altri componenti, dovreste trovare qualcosa di più o meno simile a questa, come scenario. La tool chain Android ci servirà, se vogliamo sviluppare applicazioni per Android, adesso, su questa macchina qui, non lo farò, perché la mia macchina è così lenta che compilare una macchina, un pacchetto per Android, ci potrebbe via un'ora della lezione, per cui faremo a meno, però nel vostro caso, dovete sviluppare per Android, ovviamente, poi domani vedremo come configurare la tool chain Android, che in sostanza, equivale a installare Android Studio, in sostanza, una volta installato Android Studio, avete tutta la SDK per Android, a questo punto, questa parte qui dovrebbe risultare con la spunta verde, mentre se volete fare applicazioni per Windows, quindi con Flutter, chiaramente, va installato tutto il pacchetto di questo studio, con tutti i componenti, per sviluppare applicazioni, che è un altro, pacchettone da vari giga, che ugualmente non installeremo, però sappiate quindi che potete attivare vari, diciamo così, vari output di Flutter, alla bisogna. Se lavorate con un Mac, su Mac OS, chiaramente avrete la possibilità di fare anche applicazioni per iOS, e per Mac OS, che chiaramente in questo caso, noi non abbiamo. Ok, detto questo, dovrebbe già essere venuto in questo scenario, adesso metto di scaricare il pacchetto, perché vedo che non è per oggi, quindi mettiamo, ok, e creiamo, come al solito, una bella cartella, no, non è qui, è qui, creiamo una cartella dove mettere i nostri progetti, ok, e a questo punto la apriamo dentro il terminale, quindi siamo nella cartella Dart, in questo caso, e qui dentro andremo a creare i nostri primi, i nostri primi programmi fatti con Dart. Allora, se ricordate quello che abbiamo fatto con TCC, avevamo creato un file .c, no, con il main, e poi abbiamo lanciato TCC, no, fornendo il main .c, e poi eventualmente il main .ex, cioè l'output che desideriamo, e questo era 4, per cui, in C, quando si lavora con il linguaggio C, chiaramente non c'è, nessun concetto di alto livello, per quanto riguarda, il concetto di applicazione, pacchetto, libreria, su tutti i concetti di alto livello, che sono, che hanno, che esistono per, così, per linguaggio un po' più avanzato del C, per il C tutto questo non c'è, ma Dart, essendo un linguaggio moderno, invece ha questi concetti di alto livello, per cui, quando si crea un programma, anche banalissimo, anche un classico Hello World in Dart, quello che potremmo fare, è creare un pacchetto Dart, un pacchetto Dart è un assemblato, in qualche modo un pacchetto, che è composto da un manifest, che descrive che cosa fa quel pacchetto, può contenere un name, quindi può essere uneseguibile, ma può anche non essere uneseguibile, può essere una libreria di solo codice, quel pacchetto, una volta compilato, diventa un, così, del codice compilato per Dart, descritto dal manifest del nostro pacchetto, adesso lo facciamo a più senso, quello che sto dicendo, è simile a quello che avviene per Node.js, se avete esperienza con Node.js, lì in quel caso, tutto funziona a pacchetti, e ad ogni pacchetto Node.js, corrisponde un file di configurazione, di cui adesso non mi sorviene il nome, però c'è un file standard, che descrive il pacchetto. In Dart, questo file, questo manifest, che descrive il pacchetto, si chiama pubspec, dove pub è la piattaforma di diffusione dei pacchetti. Adesso, prima di iniziare, vi faccio vedere come si creano i pacchetti, perché per creare questi progetti Dart, questi pacchetti Dart, useremo sempre la toolchain stessa, quindi il Dart, eseguibile, non è soltanto un compilatore, ma in realtà fa tante cose potenzialmente utili. Lo vediamo qui, permette di analizzare il codice, permette di compilare il codice, permette di creare progetti, permette di eseguire, ovviamente, programmi, permette di testare programmi, permette di pubblicare, quindi parlare con tutto quello che è l'ambiente pub di Dart, che è, diciamo così, il sistema che permette di pacchettizzare, e di distribuire, e eventualmente anche di pubblicare, i vari pacchetti scritti in Dart. Anzi, per darvi anche un'idea di questa cosa qui, si chiama pub, perché il sito corrispettivo è pub.dev, hanno scelto un dominio eccezionale, che è questo aggregatore di pacchetti, è un po' il corrispettivo di npm.js per Node.js, se avete esperienza di Node.js, o Nougat per .NET, insomma, ogni, o pip per Python, insomma, avrete esperienza con vari linguaggi, sono i vari gestori di pacchetti, quindi, per Dart e Flutter, c'è questo pub.dev, che racchiude tutti i pacchetti, che possiamo utilizzare in Flutter, o in Dart, e molti di questi, poi, chiaramente sono molto utili, e li useremo poi, lavorando in Flutter. E, appunto, volendo, possiamo creare un nostro pacchetto, e pubblicarlo, su pub.dev, se questo ci è utile in qualche modo. Ok, creiamo un pacchetto, il comando Dart Create, è seguito dal nome del progetto, cioè, del template, come al solito. Dart Create, quindi, prende il nome, cioè, il nome della directory, in cui creare il pacchetto, e poi prende, opzionalmente, un template, quindi una, come si vuole dire, un modello di riferimento, da utilizzare. Questo perché, il pacchetto che andremo a creare, può avere varie forme, in base a quello che ci serve, di base, ve ne descrivo due, gli altri non sono veramente utili, di base c'è, il pacchetto console, quindi, creerà un progetto Dart, da console, quindi, che funziona su una riga di comando, quindi, classica, quello che potrebbe essere il corrispettivo, di un programma in C, oppure, un package, che invece è un pacchetto Dart, che non ha main, quindi non ha un punto di ingresso, perché è un pacchetto, di libreria, che può essere incluso, da altri, da altri pacchetti, in questo momento, useremo, specialmente, il template console, perché andremo a fare, il classico, hello world, senza, senza particolari ambizioni, veramente, Dart create, se vogliamo, possiamo fare, meno t console, ma è, di default è quello, e poi usiamo, cioè, specifichiamo, la, la, la directory, per crearlo, in questo momento, lo chiamerò, hello world, questo farà un paio di, cose, aspettiamo che, i termini, e avrà creato, nella directory, qui avrà creato, la cartella, la directory, con un nome, che equivale, al nome, guardato, perché? molto lenta, evidentemente, sì, è, flutter doctor, si chiama, quindi, il comando è, cioè, si può fare, flutter version, per vedere se, almeno, riscrivibile, esiste, e poi, flutter doctor, avviene, avvia i vari controlli, non va? Forse il percorso, non è giusto, oppure, probabilmente, non ha riavviato il terminale, quando, perché una volta, cambiando le varie ambienti, bisogna ricordarsi, che quelle non si propagano, quindi, bisogna riavviare il terminale, o l'applicazione, che sta usando, ah, per riavviare il terminale, tra l'altro, un'altra cosa si può fare, invece di chiudere, e riaprire, si può rilanciare, la riga di comando, o della riga di comando, un'altra cosa si può fare, quindi, questa è la riga di comando, già aperta, se adesso modificasse, la prima dell'ambiente, potrei fare cmd, questo rilancia, un'altra sessione del terminale, dentro il terminale, non ha molto senso, però, questa, il finale qui, vede le prime ambienti nuove, infatti, se faccio exit, termino il terminale interno, e torno a quello stesso, avvado annidato due terminali, e, ok, via, finalmente ce l'ha fatta, ok, abbiamo creato il nostro, Hello World, vedete che, fa varie cose, adesso vi descrivo anche, che cosa ha fatto, in dettaglio, così, ha più senso, però, intanto apprezziamo, che dentro Hello World, c'è, non solo un file, ma tutta una, una, cosa vuol dire, una cornucopia, una collezione di file, che ci potranno, cioè, che molti dei quali ignoreremo, ma che sono, fondamentali, per far funzionare, il pacchetto Dart, prima di vedere questo, magari aspetto, che siete tutti quanti allineati, cioè, se vi funziona Dart, funziona, ma, Dart Create, e poi, Dart Create, e poi, quindi, di base Dart Create, Hello World, progetto 1, o quello come volete chiamarlo, insomma, ah, un altro limite, questo nome qui, deve essere tutto minuscolo, senza spazi, e, solo lettere, e, solo caratteri, e numeri, ok, perché, perché sarà anche il nome, del nostro pacchetto. Si è chiuso, il titolo, il titolo, il titolo, il titolo, il titolo, il titolo, ah, beh, incoraggiate, se è stato, è un'altra. Si è chiusa, la rica rica rica rica rica, all'avvio, facendo Dart Create, si interrompe la rica rica rica rica rica rica rica? Quello va, però, si, mi sembra un problema, abbastanza bloccante, Sì, sì. Sì, sì. Sì, sì. Sì, sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Ok, quindi effettivamente se Git non è insalato, Dart fa una terminazione molto brutta. Ok, a questo punto, allora diamo un'occhiata a questi file creati e lo facciamo aprendolo con Visual Studio Code. Anche qui per lavorare con Dart e con Flutter useremo sempre Visual Studio Code che va benissimo. Sì. Chiaramente potete usare qualsiasi altro editor come al solito e potete usare anche editor del genere più destinati a Dart e Flutter, se volete. Tra cui Android Studio sicuramente è quello più utile se appunto intendete lavorare poi per applicazioni per Android. Visual Studio Code che di base non supporta in particolare Dart, può essere però esteso con delle estensioni se volete, per cui potete metterci l'estensione per Dart e l'estensione per Flutter, se volete, che trovate nel marketplace. Dovrei averle da qualche parte. Ecco, questo è attivato Dart e Flutter, poi questo vi dà, se non altro, il highlighting della sintassi di Dart e poi vi dà un po' di aiuti in più che sono sempre comodi. Ok. Ci siamo? È andato? Perfetto. Ok, allora a questo punto vediamo l'architettura del pacchetto pub per Dart. Il file fondamentale che descrive il pacchetto e questa specie di manifest è questo pubspec YAML. YAML è questo linguaggio non particolarmente bello che spesso si usa per dichiarazioni, descrizioni di progetti e quant'altro. Se avete esperienza di Docker, Docker è tutto fatto in YAML in genere, però ecco, è abbastanza leggibile ed si basa su questa indentazione, perché bisogna fare molta attenzione a come sono identate le varie cose, perché è fondamentale avere una coerenza di indentazione nel gestire il file, quindi attenzione agli spazi e alle tabulazioni. di base, appunto, di scrivere il vostro pacchetto, per cui quando lo create, crea nome, descrizione e versioni di depot che hanno questo aspetto qui. Potete personalizzarle come volete, facendo attenzione al fatto che il nome del progetto è quello che lo descrive al pubblico, all'esterno. Quindi questo nome qui è molto relevante, non potete metterci come volete, ma va scelto con cura, perché è il nome con cui il vostro pacchetto è visibile agli altri pacchetti. Quindi se un giorno decidete di suddividere in più pacchetti la vostra applicazione, chiaramente si parleranno per nome, in questo senso. Il nome, come dicevo prima, ha delle limitazioni per cui non può iniziare con un numero, deve essere tutto a lettere e numeri, non può avere spazi e così via. E se pubblicherete qualcosa su PubDev, sul sito di distribuzione dei pacchetti per Dart, è anche il nome con cui poi il pacchetto è risultato visibile a tutti quanti. Quindi in particolare qui questo PathProvider è un pacchetto che come nome ha PathUnderscoreProvider. Vedete che sono tutti quanti anche in minuscolo, il che tradisce il fatto che non si possono usare delle maiuscole, altra limitazione. E questo è quanto. Il numero di versione anche qui, questo è rilevante soltanto se poi pubblicate il pacchetto su PubDev, dove chiaramente il versionamento del vostro pacchetto è rilevante. PubSpec include una serie di altre informazioni, per esempio l'SDK, quindi la versione di Dart che avete utilizzato per creare il pacchetto. Questo è il 315 se avete l'ultima versione. E poi la cosa importante sono le dipendenze, perché chiaramente ogni pacchetto può, se serve, dipendere da altri pacchetti di cui fa uso. Qui ce n'è uno commentato, il Path. Il Path vi dà accesso ai percorsi rilevanti della vostra piattaforma, quindi il percorso ai file temporanei, il percorso ai file dell'utente e così via. Lì lo useremo poi lavorando da un'integrazione per Android. Allo momento non ci serve, quindi lo lasciamo commentato. Questo è il sistema con cui possiamo includere altri pacchetti e eventualmente anche pacchetti che vengono da qui. Quindi se ci serve per esempio il pacchetto, non so, block per dire, lo includeremo aggiungendolo qui nell'enco delle dipendenze. E poi quando compiliamo l'applicazione, quando diciamo a Dart di compilare il nostro pacchetto, Dart si tira giù tutte le dipendenze e i pacchetti che servono e poi ci crea l'eseguibile. Quindi è tutto abbastanza semplificato la versione dei pacchetti e in genere funziona tutto abbastanza bene senza grandi intoppi. Sì, prego. Ma, sono fatto un ruolo. Noi abbiamo detto che sul spec, il più grande del link è il nome che chiamano il pacchetto. E che sarà accessibile quando la atmosfera è iniziata a interaggere il pacchetto. Nel caso di poter avere un'applicazione possiamo far sì che siano diversi come un'applicazione su Dart, però, tra l'altro, non c'è un'applicazione su spec, dove noi vediamo l'applicazione come pacchetto. Giusto? Esatto. Quando noi esprimamente provo a pubblicare l'applicazione, giusto la vacazione, cioè, coincide con questo? No, no, è giusto, questo è giustissimo. Allora, perché ancora Flutter non l'abbiamo ancora visto, lo vediamo domani. Perché Flutter, quando creiamo un'applicazione Flutter, quello che andremo a fare è esattamente equivalente a questo. Questa è un'applicazione Dart per riga di comando. Un'applicazione Flutter è uguale, ovviamente con più cose all'interno, però alla fine dei conti è sempre un'applicazione, è un pacchetto Dart in realtà. Questo nome qui è il nome del pacchetto Dart e non ha nessun legame con il nome della vostra applicazione Android, iOS, eccetera. Quindi se poi volete pubblicare come applicazione compilata sugli store Google Play, App Store, quello che è, il nome che dite l'applicazione in quella forma lì compilata non c'entra nulla con questo nome. Quindi posso essere... Quello lì è compilato. Esatto, quel nome lì è il nome della vostra applicazione per quanto riguarda il mondo Android, eccetera, che è un pacchetto compilato che però non si porta dietro. Cioè, una volta che è compilato, chiaramente il fatto che sia un progetto Dart non si vede più. Quindi, a meno che non si vada poi a vedere come è stato compilato. Quindi probabilmente è stato per ricompilare il binario. E non solo in realtà perché il nome dell'applicazione, una volta che diventa un'applicazione iOS, Android, Windows, eccetera, a quel punto è un'applicazione pacchettizzata che avrà un suo manifesto che dipende dalla piattaforma di destinazione. Quindi ci sarà il manifesto Android che descrive l'applicazione ad Android, ci sarà il manifesto per Windows che descriverà la posizione Windows, eccetera. Quindi questo manifesto qui è solo il manifesto per il mondo Dart. E a quel punto, una volta che è un'applicazione compilata, non ci interessa più. Quindi questo è a vostro uso e consumo per dare direttive di come devo compilare questo pacchetto. Poi vedrete domani quando faremo un pacchetto Flutter, quello che cambierà è che chiaramente nel nostro ambiente e alle dipendenze aggiungeremo Flutter. Ok? Perché dovremo portarci dietro Flutter in modo tale da poter creare un'applicazione script and art che però includa Flutter, in sostanza. Però questo nome qui... Tant'altro finché non pubblicate il pacchetto su PubDev, in realtà questo nome qui non è molto rilevante. Quindi il vostro nome interno può essere veramente anche Pippo e non è importante. Tra l'altro, appunto, Hello World è un nome così banale che ovviamente è un nome già occupato qui su PubDev, nel senso che se voi cercate Hello World, chiaramente l'abbiamo trovato un pacchetto di Hello World, se non ricordo, è già... adesso non lo dà, però c'è un pacchetto che già esiste. Quindi i nomi... cioè se volete pubblicare su PubDev, chiaramente dovete scegliere un nome che sia comprensibile, univoco e in qualche modo rilevante a quello che fa il vostro pacchetto. Ok, a questo punto vediamo come è strutturato il pacchetto. Ci sono due cartelle... tre cartelle fondamentali che ci sono sempre. BIN, LIB e TEST. TEST, in un momento lo lasciamo da parte, non penso che sarà modo di vederlo, però TEST include i test, quindi la batteria di test che potete utilizzare per fare dei test automatizzati sul vostro codice. Io ve lo dico, per saperlo, poi in realtà probabilmente non c'è tempo per darci, quindi a vostro... così potete andare a spulciare voi se avete interesse a vedere come funziona. LIB contiene tutto il codice accessorio al vostro pacchetto, per cui tutto il codice non direttamente eseguibile sarà dentro LIB, mentre il codice direttamente eseguibile, quindi in sostanza il vostro punto d'ingresso, cioè il codice che contiene la vostra funzione main, è dentro la cartella BIN. per, come si dice, per coerenza, per definizione in qualche modo dei vostri, i pacchetti che create con Dart, in genere dentro BIN hanno un file Dart che ha lo stesso nome del pacchetto stesso, quindi sarà hello world.dart, che contiene il main, che è il punto d'ingresso della vostra applicazione. Quando fate... quando lanciate la vostra applicazione, viene lanciato il main che si trova dentro hello world.dart, di default. Ok, adesso, ignorando tutte le belle cose che ha già creato Dart per noi, adesso taglio anche questo così poi lo vediamo meglio, lo taglio un attimo, vediamo se tutto funziona, andando ad eseguire il nostro codice. Quindi di base, adesso lasciando da parte le cose che ci ha creato Dart stesso, il nostro main è una funzione molto banale che ritorna void, ritorna anche int, se volete, quindi per essere coerenti con C, può ritorna anche int, se volete. No, è che è il codice. Ecco, è il codice, è molto lento, ok. che prende in input una lista di string, questo già, poi vedremo in dettaglio, sono le variabili, però list string già si intuisce cosa significa, che sono i vari argomenti suddivisi per lo spazio. Print è la vostra classica print. Questa cosa qui la possiamo lanciare direttamente dalla cartella, quindi possiamo fare, entrare dentro HelloWorld e fare da run, e questo in teoria dovrebbe compilare l'applicazione e lanciarla subito dopo. Vediamo se è vero. Ok, sta compilando. Ce l'ha fatta, la lancia. Ok, quindi questo è qua. Per lanciare l'applicazione si fa così. Questo non ha creato nessun eseguibile, nel senso che l'ha creata e poi l'ha subito scartato, perché l'ha soltanto fatto perché volevamo lanciarla. Se vogliamo compilare un eseguibile, effettivamente, lo possiamo chiaramente fare e c'è il comando compile che ci permette di creare un eseguibile. Quindi con tcc compilavamo, troviamo l'eseguibile, poi lanciamo l'eseguibile. Con dart run riusciamo a fare compilazione e esecuzione in un singolo passo, quindi senza portarci dentro l'eseguibile. Se vogliamo l'eseguibile perché vogliamo finire il nostro lavoro e darla a qualcuno, dart compile è il vostro amico e può produrre una serie di output diversi. Adesso magari vi do un'idea rapida di quello che può fare, perché di base il comando va dato con dart compile, tipo di output e poi eventuali argomenti. Dovremo impostare se... Esatto. Allora, sono tutti equivalenti, comunque producono un eseguibile del vostro codice. Quindi produciranno un eseguibile che fa questa cosa qui molto banale. Su Windows passare exe come sottocomando produce un eseguibile che è un punto exe, come quello che produceva tcc a partire dal vostro file c, ed è un self-contained exeguibile, cioè un eseguibile che è a sé stante, che possiamo prendere e copiare su un altro file, di più che con Windows, con l'X86 eccetera, ed eseguirà senza alcuna dipendenza. Per cui è la cosa bella di Dart, che in genere produce eseguibili completamente a sé stanti, che possono portarci, però sono portabili finché non cambia l'architettura hardware specifiche di l'A. Prego. Ma assolutamente anche del codice o questo, per esempio, in particolare, si porta tutto quanto è ineseguibile? Si porta tutto quanto è ineseguibile, per cui esatto. Quella cosa bella è che una volta che abbiamo il nostro exe, sarà un exe... Ok. Cosa che manca? Ah, l'entry point, ok. Io la posso trovare solo, dovrebbe farcela? No? Allora... Anzi. Allora... No, perderemo convento di i quali... letto, lo farà? Ok, ci ho messo un po', e quindi gli ho dato come parametro l'entry point, quindi gli ho dovuto dire qual è il file in particolare che contiene l'entry point, chi contiene il main, perché chiaramente potenzialmente qui dentro BIN potrà avere più file Dart che tutti potrebbero sulla carta avere un file, una funzione main da richiamare. Quindi mi diceva appunto che se noi includessimo tanto codice qui dentro Dart, altri pacchetti dentro PubSpec, quindi qui magari posso includere Path e altri mille pacchetti su PubDev, posso includere anche delle risorse, quindi potrei includere delle immagini, dei font e così via, tutti vengono combinati estaticamente dentro il file X. Quindi il nostro file X è un cosiddetto X, si dice in gergo FAT, nel senso che contiene tutto quello che serve per essere seguito, per cui se adesso riesco in qualche modo a fare DIR di BIN, vedete che un eseguibile è molto grande in realtà, quindi se ricordate gli eseguibili di TCC erano all'ordine dei kilobyte, qui abbiamo un eseguibile che è bello grande, è un eseguibile di 4 megabyte, giusto? Circa. 4 megabyte, 4 megabyte, è rotti e quindi è grandino. Questo perché? Perché Dart si porta dietro tutto il suo runtime, il runtime di Dart non è piccolissimo e questo può crescere ulteriormente se noi includiamo qualcosa di ulteriore. Vedrete che un eseguibile, quando faremo la stessa cosa per Flutter, faremo la stessa cosa, quindi faremo, compileremo un pacchetto Flutter, cioè Dart, scusate, compilato con Flutter al suo interno e vedrete che le dimensioni dell'eseguibile saranno abbastanza grandi perché chiaramente Flutter non è proprio più. È un interno runtime, tutto un framework di interfaccia grafica ha il suo peso, per cui genere Flutter si porta dietro una serie di megabyte di libri aggiuntive. Quello che volevo dirvi, appunto questo è un eseguibile per Windows, tant'è che posso lanciarlo ovviamente. Forse... forse... ah no, ovviamente ho sbagliato, barra. Ok, quindi questo è il segreto Word e va bene, questo se lo prendiamo e lo copiamo su un altro PC funziona alla stessa maniera. La cosa per cui è nato Dart, in realtà Dart era stato ideato non tanto per fare Flutter o altri, ma per transcompilare del codice che potesse girare dentro il browser. Quindi l'idea con cui era nato era far girare delle applicazioni scritte in altri linguaggi, o scritto in Dart in particolare, e far girare dentro il browser web, tant'è che uno degli output potenziali del compile è proprio JavaScript. Se vedete, qui vedete che uno degli output è JS, per cui la transcompilazione in JS è quella che di solito... cioè è una cosa per cui Dart è nato, per virgolette. Ah, no, vado a dargli... dentro il conto ovviamente. E quindi possiamo anche vedere che possiamo compilare per JavaScript. Questo darà... ci... ci... genererà un file JavaScript mettendolo da qualche parte. Non lo avevo messo. Ah, qui dentro. Out.js. Questa cosa qui che è abbastanza grande, questo file JS è abbastanza importante di dimensioni, contiene tutto il runtime Dart, quindi... per questo è così grande, non è perché il nostro codice sia particolarmente rilevante, ma che contiene tutto il runtime Dart, scritto in JavaScript chiaramente, e poi da qualche parte il nostro codice, che di solito è in fondo ed è molto piccolo. Ok, questo è il nostro menu. Quindi per fare queste quattro righe abbiamo circa svariati megabyte di JavaScript. Però la cosa bella è che abbiamo scritto in Dart, e quindi un linguaggio dignitoso, e abbiamo compilato il linguaggio invece legno come JavaScript, che però gira al vantaggio che gira sui browser. Quindi questo qui potete inserirlo in qualsiasi browser web e inviterà. Allora, chiaramente possiamo creare applicazioni un pochino più complesse di questo, e possiamo programmare con il linguaggio statico, tipizzato, eccetera, e avere Output che è compatibile con qualsiasi browser. Questo avviene in particolare ovviamente quando andremo a fare un'applicazione web fatta con Flutter. Quindi anche Flutter può girare nel web proprio perché Dart nasce per transcompilare per il web. Se questo ci interessa fino a un certo punto, torniamo al magico mondo di Flutter, perché vediamo dei Flutter di Dart, scusate. Cominciamo a vedere un paio di funzioni, funzioni di specifiche del linguaggio. Allora, il linguaggio è un linguaggio, appunto vi dicevo, statico e fortemente tipizzato, quindi tutti i tipi sono noti a tempo di compilazione. È un linguaggio che è molto attento anche ai valori che sono null e non nulli, cioè supporta la verifica dei valori nulli e quant'altro, e poi vedremo che cosa significa. Stringa e ha un supporto di primo ordine alle stringhe, quindi vedete che questa stringa qui è un oggetto di tipo stringa, quindi le stringhe a differenza di C e C++ hanno solo un tipo che esiste concettualmente dentro il linguaggio. Ovviamente è vantaggioso per la salute nostra, per ricordate. E gli altri tipi fondamentali sono, abbiamo un attimo così al volo, ci sono gli interi ovviamente, ci sono i double, quindi esattamente come in C, questi si somigliano abbastanza. Qui attenzione, vi sta dando errore perché la variabile non è utilizzata, quindi anche su questo punto di vista Dart è estremamente noioso, perché fa di tutto per impedirvi di fare degli errori, e quindi se la variabile non è utilizzata, non soltanto è un warning, ma è proprio un errore addirittura in alcuni casi di compilazione. Quindi in realtà se proviamo qui probabilmente dovrebbe darci errore, se ricordo bene. Faccio Dart run, se lo ritrovo. Vedo darci errore perché nessuno ha utilizzato quelle variabili, ah no, non è vero, ok. Questo è solo un warning in questo caso, però si può impostare a errore se volete. Qui può bloccarvi sul nascere qualsiasi variabile inutilizzata che lasciate in G. Quindi int double, dicevo, ci sono i booleani chiaramente, quindi qui true, questa è la differenza di C, che dovevamo usare l'intero anche per il booleano. In questo caso abbiamo il booleano proprio. E come vi dicevo, la stringa, quindi string s, ciao, questa è ugualmente una stringa, le string si possono specificare sia con le virgolette, sia con gli apici. È equivalente. Ok, nella maggior parte dei casi in realtà, e mi sembra che come tipi di base proprio, mi sa che sono questi, mi sa che non ce n'è altri. Frutti non c'è. O c'è? Non c'è. No, non c'è. Char dovrebbe esserci in teoria. No, Char non c'è neanche il Char, perché si usa, giusto questa è la limitazione strana lì. Non c'è anche il Byte. No, c'è una cosa strana che... Allora, buon riferimento al Char, che è il nostro ben amato carattere in C. In C, giustamente non c'è, perché il Char di C in realtà è una brutta bestia che viene dalla preistoria della programmazione, perché il Char in realtà è un Byte, quindi è un Byte camuffato che a noi ci risulta essere un Char. Usarlo come carattere poi causa tutti quei problemi, del fatto che noi lavoriamo in genere con caratteri che hanno più di un Byte, quindi lavorare con i Char vecchi o vecchio stile di C causa più problemi che altro. Quindi quando si lavora con singoli caratteri o si usano le stringhe, le stringhe di un singolo carattere, oppure si possono usare gli Uint. Questi qui in genere non si usano molto, però ci sono, sono i tipi fondamentali di Dart che rappresentano gli interi 8 bit, interi 16 bit, 32 bit, 64 bit. Quindi se avete bisogno di un oggetto che rappresenta un carattere largo, in genere si usa una stringhe per comunità, oppure se proprio volete lavorare con i Byte, si lavora con gli Uint. Quindi questi qui sono pacchetti da 1 byte, 2 byte, lo dirò 4 byte, e 8 byte alla bisogna. Però è abbastanza raro che si utilizzino questi dati qui. Quindi in genere si usa o l'intero o direttamente le stringhe. Lo Uint 8 si usa solo se lavorate proprio con i Byte a basso livello. Quindi in genere non si fa quasi mai, a meno che non dobbiate, non so, o caricare un'immagine da file, o caricare dei dati in HTTP. Quello si fa lavorando con questi Uint 8, che quindi sono in qualche modo il nostro Byte progettuale. La piccoletta. Qui c'è una versione di Uint 8, cioè 2, non un sign. Dovrebbe esistere. Sì, esatto. Cioè l'int 8, l'int 16, e così via. Quindi quelli lì esistono. Però in genere quelli io non l'ho mai visti utilizzare, perché in genere non necessariamente serve. Lo Uint 8 si usa perché è il corrispettivo del Byte, però ecco si usa abbastanza raramente, a meno che non si va a fare cose di bassissimo livello, che però lavorando con delle applicazioni in Flutter poi non capita quasi mai. Il tipo spesso non si specifica necessariamente in maniera così esplicita, perché nonostante il linguaggio sia fortemente tipizzato, cioè ogni variabile ha un tipo esplicito e noto a tempo di copilazione, nella maggior parte dei casi si usa la cosiddetta Type Inference, cioè l'inferenza del tipo, ossia il var. Il var ci dice questa è una variabile qualsiasi e il compilatore Dart a tempo di compilazione determina che tipo di variabile è. Quindi in base a quello che gli appioppiamo chiaramente capirà che cos'è V. Questo cosa sarà un intero, se diventa un punto diventerà un double, se è una stringa anche qui diventa una stringa. Quindi in base al tipo che ci mettete, var si auto adatta in base a quello che è passato. Chiaramente il tipo deve essere noto a tempo di compilazione, quindi in questo caso stiamo assegnando un valore costante, quindi il compilatore sa già che quella è una stringa. Stessa cosa vale se usassimo una funzione, se noi andiamo a creare una funzione qualsiasi ha un'occasione per descrivere come funzionano le funzioni. Le funzioni del codice funzionano in miglior modo simile al C e al C Sharp, quindi hanno il tipo di ritorno in prima posizione, il nome della funzione subito dopo e poi eventuali argomenti nella lista tra le parenti. quindi la sintassi è molto simile a quella del C o di C Sharp e anche Java e così via. Questa funzione qui saluta, per esempio, adesso non la faccio, facciamo in modo che ritorni una stringa che fa ciao e poi il nome del parametro che abbiamo passato. Quando dobbiamo andare a mettere insieme, combinare più stringhe, che è una cosa che in C è sempre una mezza tragedia, in C Sharp o in C Sharp in genere si possono usare gli operatori di somma, in questo modo qua. Questo non è... Cioè si può fare, ma non è consigliato, infatti vi dà un warning, perché Dart supporta e consiglia di utilizzare la cosiddetta interpolazione delle stringhe. Sarebbe a dire che nelle stringhe ne possiamo direttamente mettere un dollaro e poi il nome della variabile. È un po' come PHP, esatto. È un verso condivisibile. La differenza di PHP e Dart che Dart lo fa in maniera statica e molto più sicura di PHP. quindi la sintassi è rubata da PHP, ma non perché... cioè, PHP è rubata da PHP, perché il dollaro identifica tutte le variabili di PHP. In questo caso, questa cosa del dollaro vale soltanto dentro le stringhe. Quindi se usiamo un dollaro dentro la stringa, questo fa riferimento a una variabile visibile da qui e la tira dentro a tempo di esecuzione. Quindi questo nome che viene aggiunto qua. Non sarebbe meglio che si può direttamente. Allora, giustissimo. Allora, questo l'avrei fatto, sì esatto, questa è una mononorma. Si possono stare direttamente così per essere sicuri che Dart capisca dove inizia il numero della variabile, dove finisce, dove ricomincia la stringa. Questo è una cosa non sempre facilissima. Qui adesso c'è il punto esclamativo, che è di nuovo stringa costante, quindi è di nuovo una stringa che viene inclusa. Quando ci sono potenziali conflitti, quindi nomea, per esempio, vedete che qui magari la mia idea era di fare, di aggiungere un a in fondo al nome, ma se non ha molto senso, però ti metti che voglio aggiungere un a in fondo al nome della persona. In questo caso Dart si confonde e pensa che nomea sia il nome della variabile. In questi casi in cui c'è potenziale confusione si possono usare le graffe per identificare dove inizia, dove finisce il nome della variabile. Quindi in genere, poi nel mio genere, io suggerisco di usare sempre le graffe, così è più chiaro, in genere è più evidente dove inizia e dove finisce la variabile. Quindi in questo caso è più chiaro. E in più questo vi permette anche di chiamare delle funzioni sulle variabili. Perché in questo caso diventa esplicito il fatto che qui dentro ci mettiamo nome, però nome è una stringa, quindi in realtà possiamo chiamare delle funzioni sulla stringa. Quindi per esempio possiamo fare, non so, to uppercase per esempio, e urlare il nome della persona. Quindi possiamo metterci funzioni di qualsiasi tipo, possiamo fare operazioni matematiche, adesso in questo caso no, perché lo faremo sulla stringa, quindi Dart poi si arrabbia. Però ecco, qui dentro è effettivamente del codice. Notatevi, diciamo appunto, è più elegante di PHP in questo caso, perché questo è soltanto il cosiddetto zucchero sintattico, perché in realtà poi a te, una volta compilato, questo diventa una combinazione efficiente di tre stringhe, quindi metti insieme ciao, il nome e la parte finale, ah, esparmativo, li metti insieme in maniera che sia efficiente e sicuro anche da pubblico selettino. Quindi non è, è soltanto comodo da utilizzare, ma non è, non può esplodere a tempo di runtime, questo vuol dire. Perché in PHP invece capita spesso che uno fa delle cose che si immagina che funzionano, poi quando le segue esplodono, perché è un linguaggio puramente dinamico, quindi le cose possono cambiare in tavola. Questo è un linguaggio perfettamente, cioè, contolimente statico, per cui se il compilatore lo accetta, vuoi dire che funziona. Quasi sempre. Ok, quindi questa cosa possiamo, possiamo chiamarla anche dal nostro coder, quindi qui voglio salutare me stesso, in maniera così autoreferenziale, quindi faccio print salute. Non so scrivere il mio nome, a parte questa. Ok, e quindi questa cosa qui ritorna una stringa. Ah, perché volevo dirvi questo? Perché chiaramente qui, barra B, è noto, è una stringa perché quello che segue è una costante, quindi per il compilatore è molto facile, però questo vale anche per le stringhe, quindi se chiamo la funzione saluta, la funzione chiaramente ritorna una stringa, e quindi a tempo di combinazione, B è già nota come stringa. Ok? Sì, questo è un riassegnamento di S, che era stata già specificata qui, quindi questa è una stringa S, a cui riassegniamo un'altra stringa. quindi vale ciao, poi vale ciao 2. E non è un'idea di questione, senza, o va. No, esatto, esatto, questo, esatto, non si può fare, quindi se dichiariamo, che ne so, un altro nome, L. Ciao 3, questo è un errore, perché, perché, perché L non lo sono dichiarato. Perché non è dichiarato. Dato, come C, che, con C e Java, che ne chiede, ne ho scelto, se vuoi, tutto il libro, adesso. Che cosa, scusate, non ho capito? Dato, che, con C e Java, ho uscito, e, punti virgola, non è JavaScript, non come JavaScript, che fa, che è molto tollerante, saluto, punti virgola, no, punti virgola è obbligatorio, e serve, ed è giusto, che si sa. E vedete, quindi, qui, la stringa è stata generata con, ciao, Lawrence A, ok? E, e quindi, ecco, questo è stato creato, tramite l'interpolazione, delle stringhe, di cui, prima. Questo è un errore, quindi adesso lo commento. Un'altra cosa che non si può fare, allora, chiaramente, vi dicevo prima, è statico, e fortemente tipizzato, per cui, una volta che una variabile ha un tipo, non può essere, cambiato il tipo, ovviamente, per cui, se abbiamo la stringa, questa non può diventare, improvvisamente, un intero, perché non lo viene, perché non si può fare. Questo chiaramente, in PHP si può fare, in Python si può fare, in JavaScript si può fare, qualsiasi cosa, quindi, questo avvarrebbe in altri linguaggi, in Dart no, perché dovremmo, dovremmo cambiare tipo, e quindi non si può fare. Ok, allora, fondamentalmente, questo è quanto. Un'altra cosa che posso rivedere, sulle funzioni, le funzioni, quindi, in genere, si esplicitano, si dichiarano, si dichiarano, e si definiscono, in questa maniera, non c'è il concetto di dichiarazione, e definizione, come in C, degli anni 70, giustamente, si possono fare anche, funzioni, espresse, in maniera funzionale, per usare, una definizione un po' ricorsiva, nel senso che, immaginiamo di fare, un metodo, che fa la somma, quindi, quindi, facciamo un int, somma, a, e, int, b, ok, questo, come al solito, no, ritorna a, più b, per il punto, a, più b, questo, è un metodo, perfettamente, legittimo, in, darsi può esprimere, anche in maniera, più, sintatticamente, più, stringata, la stessa, funzione, in questa maniera, quindi, insomma, a, e b, che è, precettina, a, più b, senza ritorno, senza niente, adesso qui l'errore è perché, l'ho già dichiarato, quindi, devo semplicemente, commentare questo, eh, questa dichiarazione qui, è equivalente a quella sopra, ok, è solo più, stringata, e quindi, già mi permette di fare, di dichiarare funzioni, su una singola riga, se sono molto semplici, quindi, se fanno poche operazioni, e le potete esprimere in maniera così, funzionale, potete usare la freccina, e, questo in genere, è abbastanza, eh, comodo. Tipo, in questo caso, in tanto, questa scrittura, diciamo, di avere una, funzione, che esibili, c'è una serie, in là, perché, determinati parametri, può, eh, invocare, a sua volta, una funzione, cioè, di senso, ma quella uguale, maggiore, quindi, invocare, salutare, la, la, sì, sì, sì, già, sono compito bene, anche in questa forma qui, qui dentro, possiamo metterci quello che vogliamo, questa è un'espressione, che può essere, abitualmente complessa, quindi bisogna chiamare, eh, boh, saluta, adesso scrivo cosa a caso, perché saluta, ritorno alla stringa, quindi, ci metto, cioè, può essere anche una cosa, che non ha alcun senso, come questa, ho perso una parentesi, sì, vero, ho perso qualcosa, in giro, e, prima di, sono un paolo, a presto, no, quella, si può, quella dove è stata, ah, sì, va bene, giustamente, ok, ok, meglio, e, quindi, questa cosa che non ha alcun senso, logico, però, possiamo fare delle operazioni, molte, complesse, quanto ci pare, ok, quindi, allora, dicevo prima, è staticamente noto, ah, facciamo un altro attenzio giusto, per vedere come si infutano le funzioni, perché, la cosa che distingue, cioè, che rende Dart, un pochino ossico, da, da, da, da capire, per chi viene da, Java, Syshark, e così via, è che, l'unità di compilazione, cioè, l'unità di codice minima, in Dart, non è, il pacchetto, non è il namespace, che in Dart non esiste, se avete, se conoscete Java, e Syshark, conoscete il concetto di namespace, che il namespace è lo spazio in cui, in classi, variabili globali, e altri, altri dati, sono, noti, no, e si conoscono la vicenda, in Dart, il namespace non esiste, quindi, il namespace è, il file stesso, quindi, tutti, le nostre funzioni, che devono utilizzare dentro il mail, in questo caso, devono essere note, dentro il file, quindi, in questo caso, saluta, lo trova, perché è nel file stesso, Somma lo trova, perché è nel file stesso, se io vado a fare riferimento, a una, una funzione, che non è nel file, in cui mi trovo, devo, devo includere il file, proprio di una sua interenza, serenamente, ok, non posso includere, il namespace, in cui i file si trovano, perché manca questo concetto, di Fama, fa come il C, e fa come il C, nel senso che, il C funziona, in questa maniera, ah se il C è, da tanto, lo primitivo, perché il C, quando includete in C, no, sapete, abbiamo fatto con, le cliente di T2, abbiamo fatto, no, per esempio, Windows.h, per dire, questo cosa fa, questo dice al tuo processore, guarda, prendi il file, Windows.h, e butto tutto quanto dentro il file, e poi compila, alla fine dei conti, poi magari fate le cose, un pochino più intelligenti di queste, ma alla fine dei conti, è un copio e incolla del file, e quindi alla fine dei conti, quando compilate in C, avete un unico file, C enorme potenzialmente, che viene compilato, e tutto quanto in un singolo file, Dart non arriva a questi livelli di, di, di, di prehistoricità, però, quando, lavorate con più file, dovete includere, i singoli file, quindi dovete fare una cosa che è simile al C, effettivamente, per esempio, qui, quando abbiamo fatto Dart Create, era stato fatto una, una, un piccolo, un piccolo esempio di questo, perché veniva incluso, il file hello world.dart, che attenzione, non è hello world, del bin, è un hello world, che è dentro la cartella, deep, hanno il stesso nome, però sono due file, ovviamente diversi, questo hello world, qui, include, una funzione misteriosa, calculate, che fa 6 per 7, non vi vedete perché, e, e quindi si può utilizzare, come se fosse una libreria, per utilizzarla, questo calculate, chiaramente, possiamo richiamarla, qui dentro, quindi qui, io ho detto, io re, visto che ormai, ho fatto una cosa molto complicata, facciamo anche calculate, ok, questo, ah, tra l'altro, qui, un'altra cosa che a me, cioè che è utile in Flutter, ma in dart, è estremamente fastidiosa, è che quando salvate il file, in Visual Studio Code, per farvi un favore, dart, riformatta il file, quindi adesso, non so se avete visto, ma salvandolo, è saltato giù, perché passa dart format, su tutto il file, e quindi vi riformatta tutto quanto, in base a quello che lui ritiene essere giusto, in questo caso, era troppo lunga la riga, per cui ve l'abbassata, perché può essere anche giusto, però, non affezionatevi alla formatazione, dei vostri file, perché appena fate contro S, Dart passa sopra, senza alcuna pietà, e quindi, dovete fidarvi di quello che fa Dart, questo poi vedrete, in Flutter, ha un suo senso, perché in Flutter, spesso si hanno, si hanno il codice, estremamente annidato, e quindi, l'autoformattazione, vi aiuta molto, una domanda qui, si può essere esattivato, si può obbligare Dart a non farlo, però visto che poi in Flutter, ci torna comodo, adesso non lo faremo, però ecco, al vostro beneficio, ve lo ricordo, sappiate che c'è un comando magico, per dirgli, ti prego non farlo, dovrebbe essere in realtà, cioè, da quanto, immagino, è il pacchetto, l'estensione di Dart, che lo fa, per conto vostro, per cui, se non lo avete, immagino che non avviene nulla, ok, quindi questo concreto qui, non esiste da nessuna parte, è una undefined function, come si importa? Allora, qui in realtà, control punto, quindi la, l'iconcina della, della, come si chiamate, la, la lampadina, grazie, la lampadina vi aiuta, perché già, cioè, già sa dove si trova la libreria, per cui, vi, vi propone di importarla, per cui quello che avviene, se clicchiamo qui, viene aggiunta una riga, che importa, il file che ci riguarda, ora, diamo un'occhiata a come è superato, questo import, perché è un po' diverso, dall'include di C, in particolare, inizia con package, due punti, e poi il nome del pacchetto, ok, questo fa riferimento, vi dicevo prima, no, che i pacchetti sono noti, tramite il loro nome, questo Hello World qui, è il nome del pacchetto, quindi è il nome, che è dentro il pacchetto, questo qui, quindi questo dice, al compilatore Dart, di andare a cercare, nel pacchetto Hello World, che, il caso vuole, è lo stesso pacchetto, in cui già siamo, però non deve essere, necessariamente quello, non deve essere un pacchetto, qualsiasi, e poi segue, il percorso, ops, guarda, un bacchetto, segue il percorso, al file Dart, dentro quel pacchetto, dentro la cartella Lib, ok, quindi Lib, è la cartella, la tecnicia, che include i file, che voi volete esporre, come libreria, ad altri pacchetti, potenzialmente, quindi, se qualcuno va, viene a utilizzare, il vostro pacchetto, Hello World, come se fosse un pacchetto di libreria, avrà accesso, a tutti i file, che sono dentro Lib, in sostanza, ok, quindi, Hello World, per esempio, è un buon candidato, e quindi, se uno vuole, può importarsi, questa funzione calculate, molto, molto, rilevante, e quindi, è quello che avviene, anche qui, quindi noi stiamo importando, noi stessi, un pacchetto, e siamo importando, il file in Word, che ci permette, di utilizzare a calculate, attenzione, che importando, un file, noi in realtà, ci importiamo, tutto il file, quindi, se qui ci sono, delle variabili, cioè, sono altre funzioni, importano, importano, importano, anche quella, se ci sono le variabili globali, importano anche quelle, quindi, per cui, tutte queste belle cose, che ci stiamo portando, resta a questo punto, dovrebbero comparire, quindi, non c'è, la, quindi, no, chiaramente, quindi, c'è la stringa ciaone, cioè, c'è il calcoletto, e così via, li troviamo, nel, come si può dire, il namespace di Dart, è, flat, cioè, piatto, in sostanza, per cui, è tutto quanto, lo stesso guazzabuglio, a partire dal file, quindi, questo, a volte, causa dei pulimini, perché, chiaro, se uno chiama la variabile, a, insomma, non è una buona idea, al genere, una cosa che si può fare, però, quando si importa, e questo, ve lo suggeriva già, di default, il, il Dart create, si può importare, as, un oggetto, as, questo è un, un surrogato, del namespace, per cui, se volete, se lo esprimete, esprimete in questa maniera, a questo punto, calculate, non si trova più, nel namespace, piatto, vostro, nostro file, ma è dentro un oggetto, hv, e a quel punto, avete, un surrogato, del namespace, in qualche modo, ok, però, questo, un pochino, come quando, si può fare, su, esatto, somiglia molto, si può fare, molto, al require, di JS, in cui, lì funzionano moduli, no, in cui, si richiede il modulo, poi diventa un oggetto, già, l'altro, che è un modulo, che contiene, le vari, sottocomponenti, è molto simile, però, attenzione, in JavaScript, quando si fa require, si importa un modulo, che è proprio un modulo, come oggetto, quindi un oggetto, a tutti gli effetti, questo in realtà, è soltanto, di nuovo, è solo zucchero sintattico, nel senso che, questo oggetto qui, non è niente, hw, o come lo chiamate, è soltanto un modo, per il compilatore, per capire, che cosa intendete, poi in realtà, una volta che, non lo avete importato, è sempre, è sempre pieno, quindi in realtà, a vostro giudizio, può essere, o più elegante questo, o una porcheria, questa, insomma, la vostra preferenza, però questo è molto, molto semplice, solo per far capire, nel compilatore, cosa intendete. Quindi, noi, praticamente, su Fib, due file, con la stessa funzione, esatto, importiamo, come, passapure, guacca, esatto, e, quindi, dopo, non ci saranno, un'altra, esatto, esatto, anzi, questo si può anche provare a fare, non è utilissimo, però, fare questa cosa qui, con un altro calculate, è un'altra, di un altro, il buyer, e, ah, se è presente, sarà, 4, 2, così, per questo, è stata fatta, in questa maniera, ok, a questo punto, se chiudiamo l'altra funzione, adatto, qui, il, il, il, il, vi aiuta, nel senso, vi dà anche una lista, dei pacchetti potenziali, e così via, e tutti i file che contengano, quindi, qui vedete, i pacchetti, e l'automportamento, vi dà anche i file, che potete importare, potenzialmente, ok, sì, sì, in chat, c'è uno spoiler, ok, quindi, se adesso è importante, error 2, già vi dà errore, perché ci sono due, ah no, questo perché non l'avevo utilizzato, va bene, quindi, possiamo fare così, e dovrebbe dare errore, sul calculate, esatto, e a questo punto, è ambigua, su due librerie, quindi, non sa, non sa quale, importare, vi suggerisce, molto poco in realtà, non mi aiutare, in alcun modo, quindi bisogna importarlo, come due cose diverse, ok, così, però è a vostro, ah, questo invece dovrebbe essere, errore, però, se ricordo bene, se importate qualcosa, di non utilizzato, dovrebbe darvi errore, come? non è il godo, il godo è errore, vero? esatto, il godo è sì, ah no, è l'art, in questa cosa no, qui anche questo si può configurare, non lo ricordo, ma, appunto, le cose, le variate utilizzate, sono dei warning, ma possono essere rese degli errori, e anche gli import, sono degli errori, sono dei warning, che possono evitare degli errori, se vogliamo essere veramente, molto precisi, però in questo caso, ce la, ce la lascia passare, un'altra cosa, che forse avete notato, venendo da C Sharp e Java, è che, ah no, una cosa fondamentale, che avete notato sicuramente, è che non ho dichiarato, le funzioni dentro, una classe, per esempio, se lavorate in Java, in C Sharp, vi avete visto, che non si può lavorare, al di fuori delle classi, quindi tutti i metodi, sono necessariamente, dentro una classe, anche una classe fantoccio, quindi una classe statica, che non serve a nulla, quindi per esempio, il name, non va sempre dichiarato, dentro una classe program, quello che è, in Dart, no, Dart prevede, che le funzioni, sono degli attori, di primo ordine, nel linguaggio, che si possono dichiarare, direttamente, nel linguaggio, nel file Dart, senza, necessariamente, usare delle classi, poi vedremo, che vedremo, che possiamo anche definire, delle classi, ci sarebbe altro, una cosa, che forse avete notato, è che non ho, preposto, un, dichiaratore, di, public, private, protected, e così via, davanti al nome della funzione, quindi se, abituati in C Sharp, vi viene, quasi automatico, scrivere, public, o private, e così via, questo perché, Dart ha deciso, di fare piazza pulita, e quindi, questi specificatori, di, visibilità, delle funzioni, non esistono, quindi non ci sono, quindi, è tutto, pubblico di le funzioni, quindi anche qui, nel, hello Dart, calcoli, calcoli due, sono entrami pubbliche, tant'è che, quando importiamo il file, hello Dart, il punto d'art, sia ciaone, che calcoli, che calcoli due, sono tutte visibili, quindi non possiamo nascondere nulla, a chi, importa il nostro file, ma, chiaramente c'è un modo, per avere delle variabili, non visibili all'esterno, e funziona, in maniera puramente sintattica, cioè, il nome della, della variabile, o, della classe, o, dell'oggetto, che vogliamo nascondere, deve iniziare, con un underscore, tutto qui, prego, ah, sì, questo non ho detto, no, sì, domanda, sì, sì, è un linguaggio, oggetti, è un linguaggio, è un linguaggio semifunzionale, oggetti, statico, contipizzazione, strong, cos'altro ha, cosa ha, è un ciclo, solo a smetro, è un ciclo, se smetro, è una definizione, che può, non può starci, e, un'unità, che, in questo caso, per esempio, c'è un linguaggio, solitamente, per il linguaggio, tutto in capsula, c'è un problema, perché sono costanti, sì, ci sono costanti, sì, sì, ci sono costanti, c'è tutto, adesso, ci arriviamo pian piano, sì, di default, le costanti, no, si usano, il micro scoletto, non mi ricordo, se in Dart, è ben involuto, questa cosa, non mi ricorda, ci non è che, arriveremo, però diciamo, quindi le classi, ci sono, e le useremo tra poco, però, ecco, a differenza di altri linguaggi, che sono, veramente, ancorati alle classi, qui, non necessariamente, bisogna usare le classi, quindi, si possono usare, ma non si devono usare, e, ecco, dicevo, prima dell'underscore, se volete nascondere un qualcosa, si, si prepende, un underscore, quindi, questa cosa, calcate 2, diventa, nascosta, nel file, quindi, è visibile nel file, chiaramente, nel file stesso in cui si trova, non è visibile all'esterno, quindi, nel vostro hello world, punto d'art, qui, normalmente, potremmo utilizzare hv, e chiamare hv, calcate 2, adesso vedete qui, che non è, non c'è più, quindi, calcate 2 è sparito, perché è diventato, privato, al file, al file, al file, ok, quindi, attenzione alla differenza, guarda qui, questo calcate qui, è privato, non a una classe, non a un namespace, è privato al file, al file in cui si trova, quindi, questo qui, non si può usare, neanche da hello world 2.dart, quindi, in qualche modo, è molto limitante, perché dovete ragionare, proprio file per file, in genere, in dart, quindi, quando nascondete qualcosa, lo nascondete non soltanto, a chi utilizza la vostra libreria, ma lo nascondete anche, agli altri file, di cui è composta la vostra, ok, quindi quel calcate qui, è proprio privatissimo, questo significa anche, che quando fate una libreria, in dart, in realtà, in genere, tutto quello che deve essere utilizzabile, da fuori, è pubblico al 100%, quindi non c'è protected, non c'è, non c'è il concetto, di avere, metodi nascosti, al pacchetto, o al namespace, perché, o è pubblico, o è perfettamente privato, al file, in cui mi riferimento, qui vi trovate. Ok, mi sa che anche questo, c'è tutto, volevo vedere, arrivare all'iconst, e quant'altro, che parlavamo, perché, è un'altra cosa molto importante in Dart, tutte queste variabili, che finora abbiamo dichiarato, sono tutte variabili, variabili, quindi sono variabili, che possono essere modificate, e ridefinite, quindi, partenari, partenari, partenari, S, viene, viene, inizializzata a ciao, però poi viene ridefinita, cioè, viene riassegnato a ciao 2, e possono essere quindi modificate. Se questo non lo vogliamo, sono due modi con cui possiamo bloccare la variabile, e renderla, quindi, non variabile, banalmente, c'è il, la, la, la, la, la keyword final, che tornerà da Java, e la keyword const, che invece vi tornerà da C Sharp e C++, ci sono entrambe, perché hanno un comportamento diverso, ok? Quindi const è una costante a tempo di compilazione, è come una, è come una define in C, è come una, è come una costante di C Sharp, cos'altro? è come una costante in C++, perché questi altri sono compilate, e stessa cosa vale per Dart, una, una, una, una variabile tipo const, viene compilata da compilatore, e non può essere modificata in alcun modo, neanche se andate lì, con, con, con vari metodi non ortodossi, non si cambia. Un oggetto invece, il final, è un oggetto che viene assegnato una volta, e non può essere riassegnato, quindi semplicemente è, costante a runtime, non è, non è noto a tempo di compilazione, ma una volta che è stata assegnata la variabile, il runtime vi impedisce di modificare. Ok? Quindi la differenza fondamentale è questa, che il cost, è il compilatore che ci mette la cosa dentro, e poi quella volta che l'ha messa dentro, è cementificato, e non si può cambiare in alcun modo. Final, il compilatore non ha moto di sapere che cosa conterrà la variabile, magari viene definita dall'utente, magari l'utente che digita qualcosa da richiede di comando, e quindi non può saperlo a tempo di compilazione, però vogliamo essere sicuri che una volta che è stata dichiarata, assegnata, scusate, non può essere modificata. Cioè, in un video, come se non è grande Final X, non devi dire, ma quando poi l'assegniamo, non possiamo dire, non è un file. E non soltanto, perché Final X non possiamo, se vogliamo fare un intero finale, così questo non si può fare, perché deve essere, infatti questa non è utilizzata, però, ah no, ok, questo si può fare perché Dart è molto, è molto forte con il linguaggio, però, questo si può fare perché è come se venisse dichiarata e assegnata insieme. Quindi, si può fare, ma solo perché il compilatore è molto fluido. Ora, in genere, quello che si fa è che si dichiara e si assegna insieme, perché sia Final che Const, prevedono che la variabile sia assegnata immediatamente, e non possa essere in unità. Ok, quindi questa X qui, adesso il compilatore mi permette di predichiararla, però è un abbellimento sintattico, come al solito, quindi qui posso metterci anche altre operazioni di qualsiasi natura, però è come se questa variabile venisse assegnata insieme alla dichiarazione, e poi se voglio riassegnarla, questo mi dà errore. Quindi questo qui è proprio, questo è un errore, quindi questo è proprio un errore di compilazione che non può essere accettato. Ancora peggio è per le Const, perché le Const non possono essere modificate né assegnate in altro modo se non con delle costanti. Questa è sempre l'errore di warning, però questo, l'altro qui vedete che non sono neanche dichiarando il tipo, perché Const si comporta come var internamente, quindi sia Final che Const possiamo dichiararli senza usare un ulterior var, perché già sottintende che sia stata una variabile, possiamo fare Final e Var, se può essere veramente... No, non lo so, ero convinto che sia questa var. Ah, ok, interessante, però posso fare la FinalIn sì. Quindi questo si può fare, ma la Var9, che in effetti è come dire, due volte è una variabile di tipo, e soprattutto perché Final è un po' in qualche modo, è in antitesi con var ed in antitesi con const. Quindi a maggior ragione questa cosa qui non si può fare, perché le costanti non possono essere modificate. Tra l'altro la cosa... Vediamo un attimo se... Questo è un errore, chiaramente. E questo pure, quindi adesso li sto commentando, sennò poi non compila. Il compilatore Dart è abbastanza intelligente, quindi in realtà possiamo fare anche delle Final, delle costante, che dipendono da delle funzioni. Quindi per esempio, se faccio Final, somma, che è uno più uno, somma, aveso un errore di naming, Final sum, e somma, 1 e 1, quindi questo varrà due, no, non varrà due, varrà qualcosa, non so esattamente cosa, varrà un intero, e questo sum qui ugualmente non posso poi riassegnare. Questo varrà errore, chiaramente. Però sum non è noto a tempo di combinazione, quindi il combinatore ce l'accetta, e sappiamo che poi evidentemente sum vale sum. Seguiamo la metteressetta tutta torna. Ok, vale, 46, quindi perché ha questo 42, questo evidentemente è 2, 1 più 1 è 2, quindi questo fosse quanto. Ok, e in teoria, se il combinatore è molto forte, possiamo anche fare, C-SUM, e provare a farlo in costante. Vediamo se il combinatore è veramente fortissimo. Sì. Ah, ci sa, ovviamente. Sì, infatti era... ho sperato troppo nella forza di Dart. Allora, perché chiaramente C-SUM deve essere compilato a tempo, cioè deve essere noto a tempo di compilazione, perché è una const effettiva, quindi non sempre il compilatore deve determinare quanto vale la variabile a tempo di compilazione. In questo caso, in realtà, paradossalmente potrebbe saperlo, perché se somma viene eseguito con delle costanti, cioè 1 e 1 sono già note. Siamo magari... Esatto, è molto difficile, chiaramente, perché qui dovrebbe capire che saluta, questa è una costante, quindi potrebbe eseguire saluta a tempo di compilazione, farla perché, verificare che ciao, questo chiaramente sarà sempre false, questo, a tempo di compilazione lo sappiamo, questo torna sempre 2, questo torna sempre 42, quindi sulla carta il compilatore non potrebbe arrivarci, non ci è arrivato in questo caso, purtroppo. Però quindi ci sono dei limiti che è quello che il compilatore riesce a capire a tempo di compilazione, ovviamente. Se facciamo soltanto somma, cioè cose più banali, quindi 1 più 2, questa è l'espressione che chiaramente verrebbe eseguita a tempo di runtime, però il compilatore ci arriva tranquillamente, quello vale 3, e quindi in questo caso ve lo accetta. Però in genere i const sono abbastanza... si usano abbastanza raramente, soltanto per i valori che effettivamente non vengono mai modificati, poi il compilatore un pochino vi viene incontro, però in questa cosa const ci siamo male 3. Ok, in senso, andando molto lunghi, quindi forse non riesco a... semmai concludiamo domani con gli ultimi dettagli di Dart, perché appunto poi ci sono le classi e quant'altro, non voglio... cioè voglio che sia tutto chiaro, perché soprattutto final e const sono delle cose fondamentali per vedere bene, perché vengono usate dappertutto in Flutter e per Drive, perché molte... molte parti di Flutter si basano proprio sul fatto di definire con questa liberalità delle costanti per rendere efficiente la costruzione della vostra interfaccia utente. Quindi è importante capire cosa sono i final, cosa sono i const, perché noi cercheremo poi, più avanti chiaramente nel corso, cercheremo di rendere costanti più parti possibili della nostra interfaccia utente. È una cosa che usiamo questa funzione del linguaggio Dart per rendere l'interfaccia utente efficiente da utilizzare. Comunque, questo è quanto, quindi questa riflessione è molto importante da final e const. Cos'altro? Altri tipi fondamentali di Dart, giusto per darvi una nozione, uno che abbiamo già visto qui è la lista. La lista è in sostanza l'array, quindi è una lista, è un vettore di valori ed è dinamicamente sensibile. In Dart, un'altra cosa che è un po' strana, non c'è il concetto di array come blocco dati, quindi non è possibile di creare un blocco di oggetti in array come è possibile fare in C o anche in C Sharp. Si lavora in genere con con le con le con le liste. Quindi in qualche modo se vogliamo fare una lista di di interi si arriveremo infatti rispondo alla chat anche arriveremo anche ai costruttori e a tutti i modi con cui si possono passare variabili alle funzioni perché anche quello è una cosa abbastanza esotica di Dart quindi ci arriviamo tra pochissimo. Quindi liste le liste usano questi sintassi qui che sono i cosiddetti generics quindi questo mi permette di avere una classe generica una list di qualcosa ok? Quindi qui una lista di E e poi a tempo di compilazione noi ci mettiamo dentro l'oggetto che ci interessa quindi questo diventa una lista di interi e chiaramente può essere una lista di double può essere una lista di string può essere una lista di booleani può essere una lista di classi nostra che abbiamo definito noi quindi qui viene la libertà di metterci quello che vogliamo quindi qui è una lista e possiamo dichiararle direttamente nel codice usando la sintassi molto simile a javascript con le due quadre quindi in questo caso abbiamo un, due, tre vabbè non ho preso i tassi giusti quindi no però uguale uno, tre, quattro e questo è una lista a tutti gli effetti e la lista può essere modificata nel senso che è un oggetto quindi ha una serie di metodi e questi li vediamo qui facendo lavorare l'intelligence quindi possiamo aggiungere elementi aggiungere tutti gli elementi di un'altra lista possiamo ripulire la lista possiamo verificare che ci sia un oggetto o meno possiamo espanderla possiamo unire gli elementi in qualcos'altro insomma avete vari oggetti con cui lavorare e avere accesso a ieri metti adesso qui per esempio 999 che andrà chiaramente in coda possiamo anche lavorarci come un un array quindi in questo caso sto rimpiazzando il secondo elemento della lista in realtà quindi rimpiazzando il tre quindi mi aspetto che la lista dopo questa operazione sarà 124999 quindi lavora un po' come un array e in più funziona in maniera dinamica per cui potete espanderlo ripulirlo e quant'altro questa lista qui ha un'altra cosa importante di Dart che è molto usile in alcuni casi è che intanto se passate sopra se avete supporto a Dart vi dà l'elenco di una definizione in più in più se andate cliccate col test e andate a GoToDefinition vi apre la definizione della classe proprio nel runtime Dart quindi qui vedete che andando alla definizione vi dà proprio l'interfaccia lista di E e potete non leggere il codice così come è stato scritto da chi ha fatto il runtime quindi qui in alcuni casi non è molto utile però in alcuni casi se dovete andare a vedere rapidamente che cosa fa un metodo in realtà saltare dentro il codice spesso è molto utile questo vi dà proprio l'idea di quello che sta che avviene internamente quello che volevo farvi vedere prima è che il list in realtà ah lo perso ah qui esatto implementa un'interfaccia anche questo non ve l'ho detto ma ovviamente è un linguaggio intanto agli oggetti e quindi ha gli oggetti le classi e le interfacce esattamente come java e cshark in realtà molto simile e questo possiamo andare a vederle a loro volta perché la cosa che ci interessa in realtà è che alla fine dei conti la lista implementa estende una classe iterable quindi iterabile che è la classe fondamentale che ci permette di andare a leggere una lista di oggetti questa spesso si utilizza perché è la classe fondamentale con cui si possono andare a spulciare liste di oggetti in varie forme che possono avere quindi è se avete lavorato con csharp questo posso modificarlo questo il corrispettivo sarebbe i enumerable ma non so se avete già usato se avete usato una come si chiama una lista in csharp list credo fake list gli oggetti list implementano i enumerable che è l'interfaccia per le numerazioni di oggetti iterable è la stessa cosa per darti in sostanza per cui per cui per cui per cui possiamo andare a implementare un metodo che va a spulciare le liste usando iterable per esempio e questo ci dimostra anche che è un linguaggio che credo che si sta impantanando in maniera ingloriosa a niente facciamo fate ok allora quindi quello che voglio fare è creare un piccolo metodo che permette di stampare a video le liste quindi facciamo print list che è un iterable di e dicevamo ok e prevedendo qui un parametro che è generico anche la funzione deve essere generica quindi ci mettiamo anche qui il parametro generico quindi questo prevede che di print list esisteranno tante istanze sulla carta quanti sono i tipi che deve gestire quindi qui dentro possiamo lavorare su iterable direttamente iterable è una classe di più basso livello di list quindi espone alcuni metodi ma non tutti della della della lista in particolare non c'è add quindi su un iterabile non può essere modificato questo è soltanto iterato quindi possiamo solo esplorarlo non possiamo andare a modificarlo in sostanza però le altre cose ci sono tutte quindi possiamo andare a vedere quanto è lungo iterabile possiamo andare in primo elemento in ultimo elemento possiamo fare varie cose quindi di base se volessimo fare una cosa in classico serie c faremmo una cosa tipo così int è minore di iterable.length giusto? questa è la classica classica e quindi qui potremmo tranquillamente fare print iterable element element at index i ok e questo veramente vi stampa l'oggetto iesimo dell'iterabile questo è un modo con cui potremmo stampare la lista di oggetti se conoscete C-Shout conoscete anche che c'è il metodo for each che for each che è un elemento sintattico del linguaggio che vi permette di iterare degli i enumerable che è appunto il rispettivo di iterable in dart quindi in dart è la stessa cosa ma non c'è un metodo specifico for each ma si usa direttamente il for quindi se vogliamo possiamo fare direttamente for var i in iterable in modo la byte in modo la byte esatto la vede in questa stessa maniera e quindi qui questo oggetto i è semplicemente l'oggetto iesimo della iterabile e quindi possiamo fare paint iter quindi queste due cose sono perfettamente identiche in realtà non è vero questa cosa qui è meno efficiente di questa quindi questa cosa qui è meno efficiente perché la facciamo a mano questa iterazione e elementat a seconda di come fatto iterabile può essere non completamente efficiente perché deve andare a pescare l'elemento iesimo e lo fa dall'inizio sempre per cui se se è una lista di una lista linkata di elementi questa operazione qui ha una complessità n se noi iteriamo col for direttamente allora il computatore può fare delle utilizzazioni e andare a scorrere la lista senza andare a rifarlo n quindi in genere se sapete lavorare con iterabile questa variante qui paradossalmente è più rapida di questa nonostante qui ci sono impegnati di più questa è più netta poi nel caso dell'array non cambia nulla ovviamente però nel caso di altri oggetti può cambiare ok quindi printlist qui possiamo usarlo possiamo farlo prima di aggiungere elementi quindi lo faccio qui printlist lista e lo faccio subito dopo per apprezzare che la lista è stata modificata domanda in questo caso siccome noi come printlist non è e è un generis maggiore dobbiamo identificarla in questo ma non è un'altra come portare se nel senso dobbiamo sostituire il printlist minore unit ah qui qui dentro ah no allora qui giusto la domanda è giustissima qui non dobbiamo mettere il generico qui perché possiamo metterlo il compiatore non si offende anzi ringrazia ma ce la fa da solo grazie alla time perché lui sa che lista è di tipo int quindi veramente lo fa da solo però si può fare se vogliamo quindi ecco qui vediamo qui è 1 3 4 e poi dopo la modifica è 1 2 4 adesso qui magari potrò aggiungere delle righe in più per renderlo leggibile ma cambia poco ah ok una cosa che possiamo fare è dichiarare anche le eh perso i dettagli qui possiamo dichiarare anche le liste come eh final e costanti no costanti no costanti no perché non è no possiamo farlo possiamo farlo ah sì come vedete bisogna farlo sì e anche io non vorrei perché non è un giotto questa infatti no ok questo non ho dato l'orreo di tempo di compilazione cosa che mi sarei aspettato però infatti voglio arrivare a questo però stranamente mi sarei aspettato che il const cioè doveva darmi errore non l'ho fatto vabbè comunque questo è un mistero che devo risolvere un attimo tra me e me adesso ci penso però la const una lista non può essere cioè non può essere const perché la lista stessa per essere const dovrebbe essere dichiarata come const ma forse forse questo avviene se è così se è così non mi ricordavo dovrei mettere il costitore dovremo non c'è quindi adesso mi sto direndo come sta come faccia a funzionare questa cosa devo vabbè lo dico domani non mi ricordo perché però allora il chiaramente list è una classe quindi è un oggetto questa lista è un istante dell'oggetto che possiamo che è definita nella libreria del runtime e quindi anche gli oggetti in dart possono essere costanti quindi noi possiamo definire degli oggetti che sulla carta possono essere costanti esattamente come lo sono gli interi le string e i double e così via quindi questa cosa è legale e stessa cosa è legale definirla come final quindi questa è una lista che non può essere riassegnata quello che però attenzione si può fare comunque si può comunque modificare la lista quindi possiamo stamparla se non sono problemi si possono aggiungere elementi si possono modificare elementi l'importante che non venga riassegnata quindi una cosa che non si può fare è fare questo quindi questo è legale ok perché stiamo riassegnando la variabile lista perché non possiamo farlo però perché è final quindi questo non è possibile ciò che non toglie però che possiamo modificare l'oggetto liberamente come facendo ads o con i vari altri operatori perché è vero che è final l'oggetto ma l'oggetto in sé può essere modificato prego quindi questo è quello che è cost puntatore a un oggetto esatto con i miei però per scomputare esatto esatto quindi se il corrispettivo in Syshara appunto è un puntatore fisso a un oggetto che però l'oggetto ovviamente può continuare ad essere modificato questa è una cosa in genere molto mal vista quindi la lista è un caso un po' a margine però è così in genere quando un oggetto viene può essere dichiarato come final come const quello che si preferisce fare in Dart ma soprattutto in Flutter è rendere l'oggetto immutabile cioè la classe deve essere prevedere il fatto che una volta che è stata costruita con un certo valore non può essere modificata quindi i metodi ads e così via sono dei metodi che modifiano l'oggetto in genere nell'uso moderno di Flutter e così via questa cosa si cerca di evitare perché Flutter va un po' in direzione ai linguaggi funzionali se avete mai usato Ocam Fsharp e altri Maskell altri Erlang e altri linguaggi meravigliosi ma inutilizzabili per questo motivo no scherzato molto difficile utilizzare perché una volta che annulliamo degli oggetti lì è proprio nel linguaggio è proprio fondamentale il fatto che l'oggetto sia fisso e modificabile in Dart non è obbligatorio farlo però è uno stile che si cerca di adottare quindi adesso purtroppo si è fatto già sono già melodici per cui in realtà vi chiudo le ultime cose direi che concludiamo il nostro escurso su Dart per domattina perché vediamo come si crea una classe vediamo cosa significa creare una classe immutabile cosa fondamentale e poi vediamo una serie di altre cose fondamentali di Dart però prima di chiudere vi faccio vedere altri due tipi fondamentali di Dart che sono la mappa e l'insieme quindi la lista è un tipo fondamentale che è l'array lineare di oggetti la cosa importante della lista è che è una lista lineare per cui ogni oggetto al suo interno ha una posizione quindi è o prima o dopo altri elementi della lista mentre questo non avviene necessariamente nel set il set è un insieme in senso matematico per cui è un insieme di oggetti in cui gli oggetti non si ripetono questa cosa è importante nel set per cui non possiamo avere più di un 1 in questo caso portiamolo insieme perché sono molto originale e in questo caso per definirlo usiamo la sintassi molto simile alle quadre ma usiamo le graffe per distinguerlo 1, 2, 3 ok questo è un insieme di oggetti se diamo un'occhiata vediamo che anche il set è iterabile quindi in realtà quando andiamo a sprucciarlo possiamo comunque stamparlo come se fosse un array lineare di oggetti però sappiate che all'inferno di semantica all'inferno di concettuale l'insieme non necessariamente prevede che gli oggetti abbiano una una collocazione spaziale tra di loro quindi 1, 2, 3 è un insieme una nuvola di oggetti e non si ripetono perché se proviamo a raggiungere non ce la farò perché c'è comunque add se aggiungiamo 1 questo in teoria dovrebbe darci errore a tempo di runtime non a tempo di combinazione ma a tempo di runtime dovrebbe darci un errore non l'ha fatto veramente molto bene può essere che non lo aggiungerà no non dovrebbe però tutte le conoscere ah no si c'è un booleano quindi direi che sì andiamo un po' a saperlo si direi che a questo punto è chiaramente così vedete che sto usando l'interpolazione con un metodo che torna un booleano quindi è un po' particolare un po' brutto ma si può fare mi manca una virgola eh no si può le virgolette quindi mi aspetto che sia false perché non aggiunge l'uno false infatti e tra l'altro se faccio print list a questo posso usarlo perché l'insieme sebbene si comporta in maniera diverso dalla lista è comunque uniterabile quindi posso comunque passarlo a print list e mi aspetto che ritorni un due ok quindi questo è l'insieme l'insieme si usa molto normalmente quindi si usa c'è perché a livello matematico ci sta però si usa molto più frequentemente la mappa la mappa è in sostanza un dizionario di valori una mappa più univoca di valori potete come volete comunque è una una specie di array con un indice che che può essere anche complesso cosa significa questo significa che quando faccio dicare una mappa devo dichiarare due tipi uno è la chiave l'altro è il valore quindi le mappe contengono un tipo che fa la chiave e un tipo che fa la valore sono tutti sì è un insieme di tuple se vogliamo dove la tuple ha questa semantica che il primo valore è la chiave se vogliamo però sì l'insieme di tuple è una buona una buona idea una mappa mentale in genere classicamente potrebbe essere string e int quindi abbiamo un insieme di interi che indicizzano delle stringhe e questo si esprime con la sintassi del dizionario sempre con le grafiche quindi qui abbiamo un insieme di valori ogni tupla quindi ha come chiave un intero un due tre mettiamo e come valore una stringa quindi un monostruttura di risonare esatto infatti si usa proprio quello ok questa è una mappa la mappa si può ultimamente modificare quindi la mappa possiamo aggiungere valori o ridefinirli quindi per esempio sempre usando l'indice quindi la chiave quindi un due tre qui sto sovrascrivendo il primo elemento e posso chiaramente aggiungere un quarto elemento così ok si si aggiunge esatto hai aggiunto l'elemento esatto sì le mappe possono ottenere i dati differenti a parte di se stessi ah sì allora no nè allora le mappe appunto possiamo farci quello che vogliamo quindi l'importante è che siano dei tipi cioè dei tipi note insomma in in in dart quindi possiamo fare una mappa di stringa in stringa qui in questo caso possiamo indicizzare con la con la stringa direttamente qui la cosa come bisogna fare attenzione è che la cosa importante è che il tipo che usiamo come chiave deve supportare l'uguaglianza cioè deve essere deve essere implementata in maniera tale da permettere a dart di vedere quale chiave sia uguale alla chiave che passiamo quindi in questo caso l'uguaglianza sarà quella delle stringhe cioè dart qui andrà a vedere in tutta la mappa 2 andrà a vedere qual è la tubla per cui la chiave è equivalente a ciao e per fare questa equivalenza userà l'equivalenza delle stringhe l'equivalenza delle stringhe in dart è l'equivalenza binaria quindi va a verificare che siano perfettamente identiche quindi chiaramente se cambia contatto una lettera un uppercase o qualsiasi altra variante che a noi non traspare sono due stringhe diverse perché usano una verifica binaria di uguaglianza e possiamo usare anche oggetti più complessi in realtà quindi possiamo usare oggetti adesso non abbiamo creato una classe nostra però è nulla di utile in questo caso però possiamo metterci veramente quello che vogliamo anche classi nostre quindi se noi adesso dichiaro una classe giusto vedremo domani meglio una classe esattamente inutile come questa questa classe qui è una classe a tutti gli effetti e la possiamo usare come chiave di mappa non c'è nessun problema chiaramente in questo caso questo non vale più con la stringa attenzione questa cosa qui però non funziona perché la mia classe non esprime l'equivalenza quindi non implementa l'operazione di uguaglianza per cui in questo caso la mappa sarà tutta di valori che non sono mai uguali a nessun altro quindi la mappa in questo caso non funziona perché mia classe non funziona bene come chiave però si può fare non c'è nessun nessun limite in questo come chiaramente mia classe può essere anche la a maggior ragione può essere il valore il valore può essere veramente qualsiasi cosa perché chiaramente non viene mai usato per verificare l'uguaglianza e nessun altro cosa la cosa che chiedeva lei giustamente posso mettere valori cioè tipi diversi no nel valore no nel senso che deve essere per forza un oggetto un'istanza di mia classe però ciò non toglie che posso usare delle classi derivate da mia classe in questo caso in dart c'è lo stesso concetto che c'è anche in java in csharp e così via c'è la classe object con la o maiuscola che è la classe madre di tutte le classi per cui tutti gli oggetti alla fine possono essere un object per cui se vogliamo fare una mappa generica in genere si può fare una cosa di questo genere quindi in genere quando si lavora con dati misti di cui non si conosce l'origine si può fare una mappa di object di cui la natura è ignota o a maggior ragione si può usare si può usare il tipo dynamic che somiglia molto all'object questo lo vediamo domani perché a questo punto è troppo tardi però il dynamic vedete la differenza per chiudere object è una classe ecco la o maiuscola perché è una classe del linguaggio d'art nel linguaggio d'art tutte le classi hanno la maiuscola la iniziana maiuscola perché sono oggetti del linguaggio d'art gli altri tipi che non sono oggetti direttamente almeno hanno la minuscola quindi int double e così via sono tutti tipi primitivi che identifichiamo con la minuscola attenzione però perché chiaramente poi internamente anche int è in realtà un oggetto quindi tra un po' in inganno perché anche questo alla fine dei conti è una classe ma si comporta in maniera un po' un po' inusuale per cui le classi primitive hanno un nome minuscolo le classi a tutti gli effetti hanno un nome maiuscolo tant'è che la stringa che è una classe un po' più sofisticata ha la S maiuscola questa a differenza di C-Shap e poi la stringa invece è sempre il tipo base qui ha la S minuscola e l'object quindi è maiuscolo ed è l'oggetto generico da cui derivano tutti e alla fine dei conti anche gli interi e anche i double e anche le stringhe e anche mia classe deriva da object posso usare dynamic se voglio esprimere in maniera proprio esplicita il fatto che non so di che tipo si stiamo parlando lì dentro quindi in questo caso non è neanche un oggetto è qualsiasi cosa può essere anche null può essere qualsiasi cosa e sto dicendo al linguaggio Dart guarda non ho idea di cosa finirà in questa mappa vedi tu a runtime cerca di districare qualche modo le mani da questo quindi in genere quando abbiamo una mappa generica in cui includere qualsiasi cosa si esprime in questa maniera qui quindi come una mappa di chiave qualsiasi e dynamic dynamic è un tipo un po' particolare a questo punto lo vediamo domani perché appunto è un tipo che nasconde un oggetto che si può comportare in maniera completamente arbitraria a tempo di runtime direi che interviamo adesso che sono le quattro e ci vediamo domattina dalle nuove in poi a vedere altri aspetti misteriosi chiudo e vi saluto a domani grazie a tutti grazie a tutti