Ok, ripartiamo da dove siamo arrivati ieri. Allora siamo più o meno in questa situazione qui. Ieri poi ho approfittato per modificare lievemente il codice, vi passerò la versione attuale, come zip a parte, poi senza le componenti che andremo a sviluppare oggi, che toccano più che altro i file, la gestione della persistenza e così via, e poi vi caricherò lo zip finale, così potete avere tutti gli stati di sviluppo. Ho cambiato solo delle cose grafiche o minimali, questa versione qui per cui nulla di sostanziale, e eravamo rimasti allo stato di... Ieri appunto qui avevo fatto questa interfaccia, come si dice appunto il gergo, master detail, o main detail, in cui c'è una schermata principale, poi si può andare nel dettaglio, in due versioni, in due modalità, diciamo così, sfruttando questo responsive, quindi il design responsivo, per cui in una modalità larga abbiamo questa disposizione, e c'era un ultimo problema che avevo visto ieri, ossia selezionando i vari oggetti, che cosa avviene? Che noi andiamo a cambiare lo stato di un provider, che abbiamo fatto ieri, il nostro select da provider e così via, impostandolo, noi registriamo, cioè ci registriamo ai cambi di stato del provider con il ref.listen, invece di fare ref.watch, perché ref.watch ci aggiorna e ci rebuilda il widget in base allo stagione di stato, mentre nel caso di listen non veniamo rebuildati, quindi con la nostra ref.listen, invece di rebuildare tutta l'interfaccia quando avviene un cambio di stato, semplicemente viene eseguito una callback, quindi viene eseguita una funzione, viene eseguita questa funzione qui in particolare, che ci avverte del fatto che l'utente ha selezionato l'oggetto, nel caso in cui ci troviamo nella modalità in cui bisogna navigare, quindi nella modalità non larga, ossia sarebbe di creazione small, allora navighiamo. Nel caso in cui siamo nella modalità larga, invece non facciamo nulla, perché sappiamo che c'è questo widget qui a destra, questa zona dello schermo, che in automatico avrà fatto ref.watch di questo provider qui, e quindi si è generato i conseguenzi. Quindi abbiamo due modi per navigare, uno in modalità larga, uno in modalità piccola, ristretta, entrambi comunque si basano su questo provider qua. Ora l'unico bug che ci è rimasto è che navigando qui, cioè cliccando su vari oggetti, e... Ah, qui lo risolto. Allora, sì, vediamo perché. Prima... Anzi, vediamolo subito. Sì, nel titolo... Certo, il personaggio che ho lavorato ieri l'ho risolto, per cui andiamo a vederlo. Siamo a dire, come prima, quindi il nostro 2D Editor. Non sto comprendendo la seconda. Il nostro codice era così. Adesso lo ricostruiamo. E poi vediamo perché questa piccola modifica ha risolto il bug di prima. Quindi eravamo in questa condizione qui. la modifica riparta. Ah, qui ho rimpostato un po' la grafica anche di questo, per cui... ...eva meglio con la tastiera. Ok, quindi cliccando sui vari oggetti... Sì. No, scusate. Allora, possiamo fare... Allora, eravamo in questa condizione qui. Scusate. Allora, devo rirompere il codice come era ieri. Allora, qui adesso ho così detto per collegato al primo oggetto. Quando navigo... Ok, adesso abbiamo rotto. Quando navigo ai vari... Sotto... Cioè, altri oggetti, questa pagina qui si aggiorna progettamente, quindi tutta questa sezione qui, che è il nostro To Do Item Editor, viene rebuildato, si aggiorna. Infatti vediamo che l'ID in alto cambia, ma non cambia nello stato degli oggetti qui, quindi i due... Nei widget, vorrei dire. Quindi questi due text field qui non ottengono gli altri valori perché possiamo immaginare che in qualche modo lo stato di questi oggetti venga mantenuto. Ora, perché accade questo? Perché Flutter ha un comportamento un comportamento un po' particolare per quanto riguarda la gestione dello stato che è abbastanza importante da capire, per cui facciamo una piccola tangente di qualche minuto, per vedere in dettaglio. Allora, come funziona questo oggetto? Quindi questa parte di video schermo è occupata interamente da questo To Do Item Editor come avevo visto prima. È uno stateful widget. Adesso, ignoriamo il fatto che sia un consumer di qualche... che sia legato al mondo di programma. Questo è secondario. È uno stateful widget per cui quando Flutter lo presenta a schermo, comunque quando lo mette nella GRID cosa fa? Crea un widget appunto nel nostro famoso algoritmo di widget, al local widget lo mette in questa struttura qui, in questa posizione, e poi, essendo stateful, crea uno stato associato. Quindi crea un blocco di stato che viene creato una volta e poi viene disposto, viene distrutto quando quel widget li sparisce dalla generarchia. Ok? Quindi questa è più o meno l'idea. Ora, già da qui si traspare il problema, sostanzialmente, ossia, se il widget non viene mai distrutto, cioè non viene mai rimosso dalla generarchia dei widget, per motivi di efficienza, Flutter mantiene lo stato parallelo, diciamo così. Immaginate di avere appunto la vostra generazione e in parallelo, cioè così, a fianco, c'è un altro algoritmo identico come struttura che però ingloba soltanto gli stati dei widget. Quindi per ogni posizione dell'algoritmo dei widget che c'è nell'algoritmo dei widget vero e proprio, c'è un altro algoritmo degli stati dei widget che rappresenta la stessa struttura che però impacchetta gli stati e basta. Chiaramente i widget che sono stateless da una parte non avranno lo stato nell'albero copia, nell'albero ombra, diciamo così, con gli stati, tutti i widget invece stateful avranno un piccolo stato a margine nell'altro algoritmo parallelo, diciamo così, che ingloba lo stato. L'idea, cioè per motivi di efficienza chiaramente meno ricostruzioni nel senso dell'albero meglio saranno le prestazioni della vostra applicazione, quindi come già sappiamo rendere gli elementi const o minimizzare le rebuild dell'albero del widget è sempre una buona idea in Flutter, per cui è quello che si cerca di fare. Flutter stesso nel minimizzare queste ricostruzioni cerca di minimizzare le ricostruzioni anche dello stato chiaramente, perché anche lo stato è costoso da ricostruire e da gestire. se l'albero del widget non cambia lo stato non deve essere distrutto, per cui da qui trasparge all'errore, cioè il problema in sostanza, cioè questo TudoItem Editor rimane sempre nella stessa posizione, ossia se torniamo un attimo nella home page e siamo dentro build large, credo, giusto? Esatto, quindi quando la nostra interfaccia è in modalità larga la costruiamo ogni volta in questa maniera qui, anche se l'interfaccia si ricostruisce, cioè se noi modifichiamo in qualche modo l'interfaccia, adesso questo non avviene, però non avviene a meno che facciamo un più uno, l'interfaccia viene ricostruita ogni volta che facciamo più uno, ok? E si aggiunge un elemento e qui gli elementi cambiano, probabilmente che nonostante faccia più uno, in realtà c'è un nuovo elemento in fondo, ma questa parte qui non si è ricostruita, tant'è che gli elementi rimangono col valore sbagliato, no? nel senso che Platter riconosce che questo oggetto qui, questo widget non è stato modificato, non è stato fatto da rebuild e quindi questo to do item editor qui esiste qui, è rimasto tale e quale, ok? Ed è sempre nella stessa posizione. Nonostante venga costruito, non è un elemento cons, notate che qui non è neanche un elemento costante, non potrebbe esserlo perché qui viene costruito con degli id variabili, quindi viene costruito di volta in volta con un id potenzialmente diverso perché dipende dallo stato della selezione chiaramente, però ciò non toglie che è comunque un oggetto di tipo to do item editor nella stessa posizione per cui Platter di default dice beh, allora io ho questo to do item editor qui, va benissimo, è in quella posizione, in questa posizione e nell'albero degli stati ho già lo stato di un to do item editor, allora evidentemente lo stato è lo stesso, ok? Li ricollego, nonostante questo to do item editor sia stato ricostruito nel frattempo, ok? Per cui questo se mettessimo delle scritte di debug, possiamo anche farlo magari, anzi l'ho fatto mentre non c'era ieri sera, quindi ho aggiunto qui vedete in state to do, eccetera, disposed to do e quant'altro, quindi ho messo delle print, the back print nella init state e nella dispose, se andiamo a vedere i log, vedrete che mentre questa riga qui viene ricostruita, ogni volta che io cambio, ogni volta che io switcho oggetto che compare rebuilding to do item editor, eccetera, to do, con il to do, attivo, quindi qui abbiamo lo 049, abbiamo lo DCB e così via, ok? Quindi la build viene fatta, questa build qui, ma non viene fatta all'inistate e dispose perché lo stato esiste già, ok? Lo stato è già lì nell'albero degli stati e è inutile ricostruirlo. Ok? Non so se è vagamente chiaro, ho delle slide in merito per cui magari questo può aiutare per renderlo più evidente. Vediamo se le slide sono d'aiuto in qualche modo. Ok, quindi questa, questo è l'idea, cioè il processo con cui Platter associa lo stato ai vari widget. Quindi immaginate che qui a sinistra abbiamo i widget per come sono nella vostra interfaccia utente, ok? quindi come noi li gridiamo nel nostro albero. Qui mettiamo questo, immaginate che sia la nostra home page, abbiamo vari Stateful widget e questo oggetto rosso mettiamo è il nostro To-Do Editor, no? È il nostro widget che vive nel labo di widget e visto che è Stateful a destra avremo un albero degli elementi cosiddetto, quindi un albero dove sono contenuti gli stati in sostanza, quindi i veri elementi che poi vanno sullo schermo e questi vengono inizializzati una singola volta e poi anche se l'albero di widget cambia, intanto che il tipo di widget è lo stesso, no? Flutter fa il collegamento e dice vabbè evidentemente qui lo stato è rimasto lo stesso, lo riciclo e non lo reinserizzo, questa è un po' l'idea, ok? Questo è l'errore. Come si fa a dire a widget, a Flutter, guarda, grazie per lo sforzo, ma il widget è diverso per quelli che accorgono del fatto che sono dei distinti. Allora, è una cosa che si fa con le cosiddette chiavi e le chiavi le abbiamo già viste in varie occasioni ma non siamo mai andati in dettaglio nel perché servono e perché sono importanti. Tanto le chiavi sono così importanti che quando voi create uno status widget o uno status widget di default, Flutter vi auto vi auto suggerisce di dichiararlo. Se togliamo il costruttore qui, questa parte che non è più legale perché non c'è più questo item qua, ma facciamo finta che questo ci sta bene, vedete che qui ci dà questo warning che ci suggerisce di mettere un costruttore di default con una chiave. Ok? Questo suggerimento qui che ci suggerisce di creare un const constructor che passa, al quale possiamo passare la chiave, questa sintesi qui un po' arcana in realtà è un modo complesso per scrivere questo. È sempre funzionale, quindi, vabbè, possiamo scrivere in vari modi, però è un widget i e sarebbe a dire superi. Ok? A parte il sfumale widget. Quindi quella sintassi di prima, adesso a parte che sto... ... ... qui deve essere nulla. Ah, non è un widget, ovviamente è una chiave. Ok, così è più sinteticamente che corretto, quindi la sintassi di rima è equivalente a questa sulla carta. Quindi sto creando un costruttore al quale posso passare una chiave opzionale, qui in realtà l'opzionalità dovrebbe essere già data dall'altra. no, è vero? Ah, perché sì, si può essere bene così. E quindi posso o no, posso anche non passare, ma posso, se voglio, passare questa chiave. La chiave viene semplicemente passata oltre al costruttore di, in questo caso, di Consumer Stateful Widget, però in realtà se andiamo a vedere i costruttori vari di vari widget, poi questa chiave viene sempre passata oltre, fino ad arrivare a widget. Quindi il Consumer Stateful Widget passa la chiave a Stateful Widget, questa volta la passa a widget, vedete che la super è sempre avanti, response widget, poi qui abbiamo il Diagnoscope Tree, quindi un elemento dell'albero, anche qui la chiave viene passata oltre, quindi in realtà questa chiave famosa è un oggetto abbastanza alla radice del frutturamento di Flap, ovviamente, per cui i vari widget con cui andiamo a operare specificamente la passano oltre, perché ogni elemento dell'albero di widget potenzialmente ha una chiave. A che serve la chiave? Serve per distinguere i singoli widget se la loro posizione non è sufficiente. Cioè, se abbiamo un albero di widget in cui alcuni widget possono trovarsi nella stessa posizione ma avere stati diversi, allora ci serve la chiave per poterli distinguere. Ok? Un elemento, cioè un esempio di questo è proprio lo scenario in cui siamo, ossia questo oggetto qui che è sempre lo stesso widget, è vero che è sempre la stessa posizione per forza, perché è come abbiamo fatto la nostra interfaccia, ha uno stato perché è stateful, va bene. Chiaramente il widget deve poter cambiare perché deve poter cambiare lo stato, internamente perché è un editor quindi in qualche modo ha bisogno di gestire lo stato interno della sua interfaccia e qui va bene, dobbiamo assicurarci che varie istanze di questo widget siano diverse agli occhi di Flutter, cioè sono diversi agli occhi nostri perché li stiamo costruendo con un'altra con un altro to do item id qui, con un'altra stringa, non sono tolto il costruzione chiaramente quindi non è più così, mettiamolo, quindi sto costruendoli con dei valori diversi di questa stringa però agli occhi di Flutter questa stringa Flutter non la vede chiaramente, non gli importa quando Flutter lavora con i widget nel suo albero non ha idea che noi stiamo estendendo la classe con varie campi e così via per cui dobbiamo in qualche modo dare gli elementi pratici a Flutter con cui distinguere i nostri vari ingegni e questo lo facciamo andando a creare una classe appunto per cui quello che facciamo è in questo caso è creare una classe una chiave da noi quindi invece di prenderla da fuori come parametro la togliamo qui e la forniamo direttamente al costruttore e le chiavi ci sono varie tipologie di chiavi che possiamo costruire in Flutter magari vediamo in dettaglio la value qui è una una chiave alla quale possiamo costruire un oggetto qualsiasi che diventerà il valore di quella chiave e a vedere se c'è un modo per costruire ok ho usato una chiave direttamente sì va bene è uguale quindi forse l'uso più semplice è quello della della chiave diciamo usiamo questo direttamente che era quello che ho sentito ieri evidentemente non senso ok per cui siamo costruendo a questo punto l'oggetto fornendo cioè la chiave non viene più da fuori dal nostro costruttore ma viene passata direttamente al costruttore della classe e così arriviamo usiamo key che è la chiave più semplice ossia che ci permette di costruire una chiave usando una stringa che in questo caso l'ho scelto ieri perché in effetti il nostro il nostro il nostro discriminatore è già una stringa che intanto vale usare chi in effetti chi è la classe principale con cui chiamiamo delle chiavi identificative in Flutter prende una stringa come discriminatore e intanto vale usarla in quel modo e come la costruiamo la costruiamo identificando il tipo di widget intanto e poi internamente mettendoci dentro l'idd quindi qui l'idd sarà todo dash e poi il guide dell'oggetto in questo caso noi siamo sicuri visto che il guide è già unico siamo sicuri che tutte le istanze di todo item avranno una chiave diversa se fanno parte del se riguardano un todo item in particolare ok se riguardano lo stesso todo item ovviamente è giusto che condividano lo stato e quindi va bene che l'altra identifica come evidenti a questo punto chiaramente questo valore qui non è costante quindi il costruttore perde la sua constità ok e a questo punto anche nel costruttore qui non può essere const ma non lo rende anche prima chiaramente quindi questo va bene e a questo punto quando andiamo a creare i nostri oggetti se vado a fare a fare controllo R perché devo assicurarmi che l'albero sia magari costruito e a questo punto quando andiamo a selezionare altri oggetti Flutter si accorge della differenza degli oggetti e riesce ad associare le cose a stati diversi quindi adesso apro il primo apro il secondo e questi espliciano correttamente e ognuno ha un proprio stato interno nel senso che qui adesso se io cambio qui vedrete che c'è viene fatta anche l'instate ok quindi lo stato degli vari oggetti viene ricreato perché Flutter si accorge che in quel ramo in quel posto specifico nell'albero dei widget c'è un oggetto diverso e quindi serve uno stato diverso perché hanno chiavi distinte ok e c'è anche la response quindi c'è sia l'instate che la dispose dell'elemento precedente quindi facciamo attenzione qui si è aperto l'instate di 2 e 8 e nel frattempo è stato fatto il dispose dell'oggetto c5e e immagino che sia questo esatto che era quello aperto precedentemente ok quindi in questo caso i nostri stati vengono correttamente creati di rischio ok spero che sia molto notamente chiaro non è banalissimo questo e tra l'altro è un problema in cui si può incappare in varie occasioni adesso faccio magari giusto per completezza faccio un altro esempio abbastanza banale però lo facciamo su un'altra pagina facciamo subito così per completezza facciamo skin page una pagina abbastanza semplice tipo questa copia e incolla è sempre una cosa utile da fare stateless ok ok poi ci mettiamo qui ok allora qui ci mettiamo un riga di due oggetti e i due oggetti saranno due elementi identici quindi qui creiamo un color di cui per abitudine faccio sempre parto da state così mi creo l'interfaccia poi lo converto in stateful ma è uguale ok questo lo convertiamo in stateful e creiamo stato qui facciamo final noi a Grazie. Quindi è un widget stateful che quando viene creato crea un colore e poi lo stampa e ci si colora. Quindi abbiamo due oggetti che saranno di questo stesso tipo. Ok. E l'altra cosa che facciamo... ...dia chiave... ...dia chiave. Allora, questo è un widget che è nel consumer, ok, va benissimo. Anche questo lo rendiamo un attimo stateful, nel senso che vogliamo metterci un pulsante. Nello stato ci mettiamo... ...e quindi mettiamo tutto in una colonna. Ah, questi qui chiaramente li mettiamo in un expended, se non andiamo a dover... ...fanto crescere. Ok. Tutto questo lo mettiamo in una colonna. E questo lo mettiamo in un expended. Ok. E sotto ci mettiamo un... ...button. Ok. E qui ci mettiamo un... ...button. E qui ci mettiamo un... ...button. Ok. E qui ci mettiamo un set state. ... ...ma pagina stateful che non fa altro che... ...avere uno stato interno che indica se è invertito o meno. E in base all'inversione o meno adesso dobbiamo fare qualcosa, ossia... ...dobbiamo cambiare ordine ai due color display. Adesso per rendere evidente l'ordine, forse al color display posso passare... ...un... ...dittiamoci... ...un titolo. ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... Z. ... ... Allora qui... ... ... ... ... ... ... ... ... ... E qui invece la... Ok, tutto un esempio estremamente convoluto per farvi vedere che quando lo stato non dipende da come costruisce gli oggetti, chiaramente Flutter mantiene l'ordine dello stato e non riconosce che i due ci sono stati invertiti, ma perché non ha modo di farlo. Adesso lo vediamo in pratica e sarà più chiaro. Intanto la key page, dobbiamo in qualche modo collegarla al drawer, per cui mettiamoci il pulsante. Ok, non si è perso nulla, cosa molto rubabile, dovrebbe ricostruire. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Ok, quindi abbiamo creato due widget A e B, hanno un stato interno, per cui uno si è generato con l'arancione, l'altro si è generato con questo vertino. Se clicco inverti cosa avviene? Se inverti è messo A, false, no? Per cui quando sto generando l'interfaccia, il widget principale, cosa avviene? Questo è false, per cui creo prima la A e poi la B, in questi color display A e B. Ok, e cambia, in realtà, per quanto riguarda flat, cambia soltanto questo oggetto qui, questa stringa qui, che tra l'altro è l'elemento identificativo che rende gli elementi const. Quindi in realtà, color display A a cui corrisponde A è un'istanza e color display A a cui corrisponde B è un'altra istanza. Quindi sono due widget che vengono allocati una singola volta, non sappiamo come funziona const quando abbiamo un oggetto con costruttore const, ad ogni variante, diciamo così, dei costruttori, corrisponde una singola istanza. Quindi sappiamo che non vengono ricostruiti. Quindi A e B esistono in due istanze soltanto, una vale A, l'altra vale B. Questi sono due widget che, per quanto riguarda flat, sono distinti. Quando invertiamo, li ricostruiamo al contrario, quindi l'ordine inverso nell'ordine dei widget. Quindi l'albero effettivamente ha due color display A e B che vengono generati in un ordine che cambia in base a quando li invertiamo, e lo vediamo qui, cambia la lettera. Però questo non vuol dire che flat in automatico associ lo stato giusto al widget giusto, perché non li distingue. Cioè, potrebbe distinguere in base all'istanza, però non lo fa, perché distingue soltanto in termini di tipo. Quindi vede che sono due color displayer, per lui sono identici, hanno due stati già, arancione e verde. Attenzione perché A e B, quindi farò un distinguo, A e B sono parte dell'istanza del widget. Quindi questa stringa qui sono parte dell'istanza del widget, mentre lo stato non ha nessuna traccia di questo titolo qui. Questo è il parametro che diventa title dentro la classe widget. Questo è il widget che va nell'albero del widget, dove c'è il titolo. Nell'albero degli stati sono distanze di quest'altro tipo, che sono nello stesso ordine, ma uno è arancione e l'altro è verde, e vivono in maniera parallela e non sono strettamente legati con i loro widget, stranamente. Ci verrebbe da pensare che sono legati in maniera insolubile, in realtà non è vero. Lo stato vive in maniera dipendente dal widget e questo è un bene in realtà, perché è un bene in Flutter, perché è importante che lo stato sopravviva al widget quando deve mantenere lo stato. L'idea dello stato è quella di poter sopravvivere proprio al widget, nell'albero dei widget, altrimenti si romperebbero molte altre cose che dipendono dallo stato, che deve esistere a parte. Quindi questo è un bene, ma in questo caso ci comporta dei problemi, nel senso che a questo punto Flutter si confonde e associa lo stato sempre allo stesso widget in base all'ordine in cui compare nel suo widget padre. Ok? La situazione di stati avviene sempre a livello di albero, per cui qui la situazione avviene dentro la riga, in sostanza, che contiene un expanded, che contiene poi degli oggetti. Quindi in base a come si sviluppa l'albero, lo stato sarà sempre o soltanto quello. Ok? Quindi qui vediamo che l'effetto è proprio quello che non ci aspettiamo. Come si risolve? Si risolve identificandoli con una chiave in qualche modo. Quindi qui la cosa più banale da fare è fare quello che abbiamo fatto anche di là. Quindi il widget può portarsi dietro la chiave e fare qualcosa tipo questo. Quindi fare color e poi metterci il titolo, per esempio. Così noi distinguiamo in base al titolo. Questo chiaramente poi fa sì che non possa essere const. Quindi qui torna a non essere const. Questo è non ideale. Adesso poi vediamo come poter fare e risolvere. Ma questo già risolverebbe il problema. Vediamo se è con un hot reload. Hot reload appunto, vedete che già ci dà... Abbiamo cambiato la constità, quindi non funziona. Hot reload appunto sicuramente di sviluppare molto rapidamente, ma hot reload fa il ricaricamento dell'altro dei widget, non dell'altro degli stati. Quindi se qualcosa è cambiato negli altri stati, le cose non funzionano, tanto che bisogna ricominciare. Una volta me ne accorgo prima magari. Ok. A questo punto, visto che Flutter riesce a distinguere i due oggetti, quando invertiamo, non soltanto... cioè, ricreare proprio lo stato. Ok? Quindi si vede proprio evidentemente, con queste scelte cromatiche aberranti, si vede che praticamente lo stato viene distrutto, perché il widget non c'è più, in quella posizione, e viene ricreato. Ok. Abbiamo perso la constità, perché adesso la chiave è generata nello stato, questo non è bellissimo, quindi possiamo fare un'altra cosa, che si fa spesso, o creiamo la chiave direttamente qui, se ci piace far così, questo può aver senso, oppure, facciamo come ci suggerisce di fare Flutter da tempo, cioè, facciamo passare la chiave da fuori, questo ce lo rende const, e qui possiamo passare la chiave da fuori, quindi qui ci mettiamo color b, questa è proprio una costante a questo punto, vabbè, non la chiave chiaramente, bisogna specificare chi uguale a chi, ah, beh, sì, buonissimo, quindi quando abbiamo le graffe due punti, dobbiamo sempre dire il proprio tempo, con le graffe, sì, la graffe, l'idea è proprio quella di avere i parametri nominali, che è una cosa bella, o brutta, secondo me, se vogliamo posizionare, basta usare le quadri, però, visto che la classe base è nominale, ce la farò, e non è così, è così, ok, che se adesso sono diventati const, la chiave la passiamo da fuori, cioè, chi costruisce il widget, passa la chiave, in questa maniera i widget rimangono const, e la chiave viene fornita da fuori, e a questo punto, Flutter capisce come sono organizzate le cose, ok, l'effetto lo stesso, adesso, l'effetto della costruzione è lo stesso, perché gli stati sono in posizioni diverse, quindi non vengono condivisi, però, sono tutti oggetti const, quindi switch in maniera corretta, ok, questo è l'effetto, e, questo è molto, cioè, questo è utile, fino a un certo punto, in questa demo, molto semplice, ma, è ancora più utile nelle liste, fare un ultimo esempio, cioè, un esempio che non faremo, però, per darvi un'idea, qui abbiamo una lista, la nostra to-do list, con i vari oggetti, to-do item, questi oggetti qui, non sono stateful, per nostra fortuna, quindi il problema, non si è mai neanche posto, non tra me, questo è il problema dello stato, chiaramente, ovviamente, c'è soltanto se c'è lo stato, se non c'è, se tutti gli oggetti state, sicuramente, siamo in una botte di ferro, perché quelli non hanno, hanno solo stato che viene da fuori, quindi non c'è problema di, tenere traccia, ma, se questo gli oggetti, è messo sullo stato interno, di qualche tipo, adesso non viene in un scenario, in cui, possa, aver senso, però, magari, non so, qualcosa ci può stare, delle animazioni, dei stati interni, e così via, e, se, l'orde degli item, può cambiare, immaginiamo di avere qui, un altro, un'altra concina, che ci permette di, riordinare la turista, in base a quello che, pensiamo, l'ordine dei nomi, o della creazione, o di priorità, della cosa da fare, e così via, in quel caso, bisogna fare attenzione, perché, la lista stessa, può, essere rimescolata, e, senza che lo stato, venga rimescolato, altrettanto, ok, per cui, se c'è una lista, in cui, l'ordine degli elementi, può cambiare, per qualche strano motivo, e, gli elementi hanno, internamente dello stato, allora bisogna fare, molta attenzione, e dare una chiave, a tutti gli elementi, della lista, per essere sicuri, che, tra l'altro, non si perde per strada, i vari stati, ok, in questo caso, in genere, si fa appunto, fornendo la chiave da fuori, e quindi, nella nostra, to-do list, che, non ricordo dove era, ma, dovrebbe essere, da parte qui, ecco, to-do list qua, ehm, ah, l'ho già fatto in realtà, più o meno, nel senso che qui, cioè, per caso, in realtà, abbiamo fatto per, perché volevamo gestire il dismissible, che, ecco, il dismissible è un buon esempio di questo, il dismissible è quello che ci permette di trascinare via gli elementi, per cancellarli, no? Qui, a flat e serve, visto che, a questo punto, il dismissible, è il widget, che sta tenendo traccia, di questa animazione, cioè, del fatto che stiamo, cancellando gli elementi, deve capire, dove sono i vari, dove sono i suoi componenti, nella, nella, nella lista, e quindi, prevede, che ci sia una chiave, non opzionale, quindi, il dismissible, quando va creato, vedete che richiede una chiave, perché, internamente, deve funzionare, cioè, internamente, questo dismissible, sarà, uno stateful widget, e quindi, prevede, che venga utilizzato con una chiave, e noi qui fornivamo, la, una value key, in realtà, qui, mi hai fatto una cosa un po' strana, qui, stavo a farmi una key, in realtà, perché, è già una stringa, quindi, bastanti, una stringa, quindi, tanto vale, valore, chi, e forniamo, quindi, l'oggetto, questo è l'oggetto, proprio, della, della, della lista, quindi, il distribu builder, ritorna un oggetto, che ha una chiave, ok, quindi, il primo oggetto, nell'albero, della lista, deve essere un oggetto, con la chiave, se vogliamo essere sicuri, che Flutter, riesca a, ricollegare, il widget, con il suo stato interno, ammesso che, abbia stato interno, questo vale, soltanto, in questo caso, perché c'è, dismissible, che ha stato interno, per il resto, in realtà, non ce n'è, perché noi, ci eravamo assicurati, che, tutti, adem viewer, fosse senza stato, questo, stateless, comunque, è un consumer, quindi, tribo di stato, e, fornivamo, tutti i dati, tramite il provider, quindi, in realtà, togliendo, dismissible, questa esigenza, di avere la chiave, non c'è, però diciamo che, in una vista, è sempre buona, buona cosa, prevedere, che ci sia, una chiave, che in genere, dipende dall'oggetto, che abbiamo messo nella vista, ok, quindi questo non fa mai male, ok, direi che questo, l'abbiamo snorciolato, con, dovizia, ultima cosa, magari, giusto per competenza, anche qui, per chiudere, quindi, appunto, come dicevo, ogni widget, ha una chiave, appunto, serve perché, la posizione gerarchica, nell'albero, serve per identificare, i widget, quando questa posizione, non è sufficiente, perché magari, l'ordine può cambiare, allora, c'è un processo, di widget matching, come lo chiama, che, che viene fatto, in automatico, in base alla posizione, che non sempre, è sufficiente, questo è il problema, di cui, prima, lo stato viene creato, e poi, rimane statico, mentre magari, l'ordine, nell'albero di widget, può cambiare, e lo stato, non viene, non riflette, di questo, questo stato, oltre a questo, sono vari tipi, di chiavi, che possiamo utilizzare, per cui, abbiamo visto prima, chi è la chiave, più primitiva, che si può usare, che prevede, che si passi una stringa, se abbiamo degli oggetti, più complessi, possiamo usare, la value key, e value key, di tipo T, ci permette, di passare, qualsiasi oggetto, e poi, spesso usa, l'eguaglianza, tra oggetti, per vedere, se sono uguali, in sostanza, che permette, di usare, qualsiasi oggetto, come chiave, di un elemento, che si è spesso utile, nelle liste, in cui non vogliamo, generare una stringa, ma vogliamo passare, a seguito, l'oggetto, che rappresenta, il widget, nella lista, e qui, usa, il confronto, tramite, l'operatore, di eguaglianza, e poi, ci sono, c'è un'altra, un po' strana, diciamo così, la unique key, quando siamo sicuri, che quel widget, non vorrà mai ripetuto, in giro, per l'interfaccia, possiamo passare, direttamente, una unique key, che internamente, genera un ID, garantito, come unico, in tutta la, tutta l'applicazione, per cui, questo vale per gli oggetti, che non si ripetono mai, in sostanza, quindi sappiamo, che sono stati generati, una volta, hanno uno stato unico, se, per qualche motivo, il, l'added widget, si ricostruisce, anche lo stato, viene ripetuto sempre, ok? Quindi, un'unique key, ci assicura, che quello widget, avrà una chiave unica, appena viene ricostruito, creerà una chiave, di nuovo unica, e diversa dalle altre. E poi c'è un altro caso, un po' particolare, questo magari non lo vediamo, nel codice, perché non vale la pena, però c'è la global key, che ci permette, di allocare una chiave, da qualche parte, in genere, globalmente, nella nostra applicazione, o comunque, globalmente, all'interno di un file, quantomeno, sempre univoco, che ci permette, di far riferimento, ai widget, attraverso, delle gerarchie più complesse, questo in genere, ci è utile, quando dobbiamo far parlare, dei widget, che sono molto distanti, nelle gerarchie, non vogliamo farlo, con una lunga lista, di eventi, che si chiamano, e quant'altro. Questo scenario, diciamo così, è un po' già coperto, dai providers, perché i providers, già ci permettono, di evitare, di fare questi, questi strani accrocchi, con le chiavi, quindi, in genere, non, cioè, se usate RiverPod, o soluzioni simili, questa cosa, non vi dovrebbe capitare, però, giusto per compliutezza, ve lo cito, nel slide, quindi qui, per fare un esempio, in questo codice, qui, stiamo, allocando, una chiave, globale, no, di un tipo, di un tipo, X, la creiamo come variabile, proprio a livello globale, questa, esiste, e sopravvive, no, durante tutta l'esecuzione, perché, è un oggetto, tipo final, e poi possiamo utilizzarla, in più, occasioni, nel nostro codice, e quindi, per esempio, possiamo dare, la chiave, scaffold key, allo scaffold, di un, di un, di un, qualsiasi, widget, cioè, di questo widget in particolare, nella nostra applicazione, e poi, da qualche altra parte, in giro per il codice, possiamo fare riferimento, a scaffold key, come chiave, e, accedere al, al, al, al, al, campo, current state, che ci dà lo stato, del widget, con quella chiave, cioè, esplora l'atto del widget, va a pescare il widget, se esiste ovviamente, e ci tira fuori lo stato, di quel widget, di quell'istante, e a quel punto, possiamo fare, delle operazioni, sul widget scaffold, in questo caso, ok, qui, l'esempio era quello di, un gestore, on press, che andava a fare qualcosa, sullo scaffold stesso, e questo, appunto, può aver senso o meno, se dobbiamo fare, delle manipolazioni, dei widget, però in genere, appunto, questa cosa, è un po', sporca, nel senso che, stiamo legando, i nostri widget, e i loro stati, allo stato globale, dell'applicazione, per cui, in genere, quello che è riuscito a fare, tramite, il provider, è una, una soluzione in genere, più pulita, di questa, però, è una cosa che si può, si può fare, per cui, in questo modo, in questa maniera qui, noi stiamo associando, in sostanza, un'istanza fissa, una variabile, al widget, con la chiave, tal dettaglio, e poi possiamo sempre andare a manipolare quel widget, se vogliamo, però, non, così, sconsigliato come approccio, però, sempre possibile, ok? Ok? Ok, fatto questo, direi che passiamo, cioè, torniamo, in realtà, alla nostra galleria, perché siamo rimasti, qui, per, l'accesso, ai, a, ok, state che chiaramente, non funziona, perché non c'è la rete, allora, un attimo, che mi collego, alla rete sul cellulare, stagate, Grazie. Grazie. Grazie. Grazie. Grazie. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Allora, vediamo se c'è forse il tempo. Forse conviene fare questa cosa prima. Allora, abbiamo visto che mappare gli oggetti dal JSON al JSON è sempre una cosa un po' non facilissima perché è abbastanza noiosa, chiaramente. per cui esiste un modo più facile per farlo, per così dire. E ve lo mostro subito. Qui raccontavo appunto che il problema di la limitazione di Dart è che non c'è la... non c'è la... non c'è la... non c'è la... non c'è la reflection, quindi in qualche modo il codice di Dart, una volta compilato, non ha nozioni di come è stato costruito, giusto, l'origine. Per cui non possiamo avere un metro che va a leggere i campi di un oggetto JSON e poi attribuirli, no, ai campi che hanno lo stesso nome nel nostro codice. perché Dart, quando è una volta compilato, questi campi qui non hanno più nessuna nozione del loro... di come sono stati creati questi nomi variabili che ha segnato noi, no? Per cui questo è un problema, però in Dart si cerca di risolvere questo problema con dei processi di precomplicazione. quindi c'è un modo per agganciarsi al processo di... di... di build di Dart e avere dei piccoli plug-in che vengono eseguiti prima della compilazione per preparare il codice e darci un'esperienza che non è come quella runtime che ci permettono a linguaggi come .NET, Java, Java, Files, e così via, ma, diciamo così, coprono una buona parte di 6 scenari. Per cui quello che adesso dobbiamo fare è utilizzare due pacchetti aggiuntivi. Adesso riesco a aprire qui la pagina. Uno è JSON annotation e l'altro è JSON infreliizable. Sono due pacchetti di Google stesso, io sono ufficiali di tutto il pacchetto Dart. appunto non riguardano, soprattutto Flutter, ma riguardano tutto il build system di Dart. E ci permettono di definire nel codice delle specifiche che poi vengono auto... che autogenerano il codice che poi andrà a creare il nostro oggetto. Quindi, in sostanza, ci permettono di definire, in maniera astratta, come creare i nostri oggetti dal JSON e come serializzare i nostri oggetti in JSON, senza che bisogna andare a farlo a mano, in sostanza. Per cui, cosa da fare adesso è includere questi due oggetti, questi due pacchetti. Li copiamo, li inseriamo... Li mettiamo nel nostro pub spec YAML. E qui, in realtà... .... ... ... Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Il pacchetto non serve portarci dietro nel codice perché è solo un processo di precombinazione. Quindi lo faremo eseguire qui. Potremmo generare dei file dart aggiuntivi che non dobbiamo toccare ma che possiamo sfruttare. E quindi però nel pacchetto finale della nostra pagazione non serve che ci sia. Ok. Finito. Nel frattempo visto che appena i miei pacchetti lavorando su Android bisogna andare a ricompiare tutta l'applicazione per cui qui termino l'applicazione. E intanto per far girare le cose andiamo a fare a eseguire il runner e il comando è dart run build runner B. Molto facile ricordare, d'alt'è che non lo ricordo. Quindi è dart run build runner è il pacchetto build runner che abbiamo appena compilato. Per build è il comando che passiamo a build runner. è illegibile come comando ma è questo qua. Questa cosa qui andrà a fare cosa? Andrà a eseguire build runner sul nostro pacchetto. Andrà a vedere se ci sono delle cose che deve eseguire nella pre build, quindi nella pre compilazione. Le andrà a fare. Questo è un processo che vi chiedo un po' di tempo che deve analizzare il nostro codice. Allo momento ancora non ho fatto nulla, ho messo i pacchetti per cui il nostro build runner non dovrà fare nulla di importante. Tra un secondo annoteremo i nostri oggetti che vengono denominati in JSON e a quel punto ci genererà del codice. Lasciamolo fare intanto. Lo che potremmo fare è dentro il nostro... No. Sì, esatto. Vogliamo che questo oggetto qui venga auto compilato in qualche modo. Auto compilato, auto generato. Quindi come si fa? Lasciamo fare... ...una grande... ...unitezza. Allora, dobbiamo marcare l'oggetto come un sterilizzabile... ...come un sterilizzabile in JSON. Questi valori, diciamo, con let sono degli attributi che possiamo affioppare a classi, metodi e così via. Questo va importato da JSON annotation. Vediamo se lo trova. Ok, qui stiamo facendo i passi avanti, quindi vi vedete che sta pro compilando... precompilando, cioè sta analizzando il bit script, sta precompilando il bit script, quindi adesso sta facendo le varie operazioni che non faranno nulla, però sono preparativi. Ma, ma, ma, per esempio, non sforziamo troppo. Il pacchetto è json annotation e importiamo da json annotation, direi, così. Questo dovrebbe darci accesso a questa. E mentre lo lasciamo fare, qui ancora, se, per me, se avete un pc meno, sono lento del mio, probabilmente c'è molti meno, qui va fatto un, diciamo così, un trade-off tra il costo che ha queste operazioni, che hanno queste operazioni, comunque, per quanto sono lente qui, hanno comunque una certa lentezza. È vero che non vanno fatte ad ogni compilazione, quindi questo va fatto soltanto quando, effettivamente, chiedete a Dart di fare questa precompilazione, e in genere si fa soltanto quando, quando c'è bisogno, ossia quando avete modificato i file che richiedono la serializzazione e la serializzazione. Ok, quindi chi ha analizzato i vari file, vedete che c'è no action e così via, che mi sta aspettando alcuni elementi, ha trovato nulla cosa da fare, cioè, ha trovato delle cose da fare, ma non farà nulla, perché noi non lo stiamo utilizzando. Poi bisogna rifarlo, quindi questa è la prima esecuzione, sempre la più importante, perché deve fare il grafo del nostro codice, che non è banalissimo. Ho immaginato su un progetto più grande, chiaramente il tempo che porta via è ancora maggiore. Ok. Ok, perfetto. Ha fatto tutte le cose, però per cui vedete non ci sono modifiche al nostro codice. Ok, a questo punto possiamo finalmente fare, importare, cioè applicare questi attributi. Questo qui è il primo attributo che marca la classe come serializzabile e inserializzabile. Quindi l'idea è che questa classe qui possa essere convertita e deconvertita da JSON in maniera automatica. E a questo punto possiamo identificare i singoli campi, i singoli campi che costruiscono l'oggetto, con eventuali proprietà JSON key, se vogliamo dare delle specifiche aggianti. Quindi per esempio, un esempio che si può fare qui è che se diamo un'occhiata a come era fatto l'oggetto in JSON, abbiamo visto che id viene da id, argomitd, argomitd, title è title, quindi la mappatura, nome del campo e nome della proprietà in JSON sono identici, se non per imageURL. Qui avevamo usato imageURL, ma nel JSON ci arriva una proprietà URL. Assolutamente. Anche da me, giusto, perfetto. Per cui è il caso di usare JSON key e specificare cosa? Il nome della proprietà. Quindi qui JSON key come attributo a una serie di proprietà che possiamo passare, quindi il nome, il fatto che il valore possa essere nullo o meno, il valore di default, eccetera, eccetera, quindi una serie di, o se vogliamo ignorarlo o meno, se un campo è funzionale, un po' fasullo, questo è un campo che non viene dal JSON, quindi non lo troviamo nel JSON ovviamente, e ossia il JSON. Possiamo ignorarlo. Ok, questo ci stiamo dicendo a, ok, questo è pure deprecato. Sì, perché ignore, vale entrambi i versi, e qui possiamo ignorarlo. Ah, è precato. Include. Ah, eccolo, ok. Include. Ah, include, ok. Quindi possiamo decidere se, se importarlo, segnorarlo in esportazione o in importazione. Quindi questo è un campo aggiuntivo che non ha alcun effetto. qui name è url, come dicevamo, e qui name era thumbnail url. Ok, quindi stiamo sovrascrivendo una lettura di default di nomi, che sarebbe il nome del titolo. Altra cosa che possiamo dire è se un oggetto è richiesto o meno. per esempio, per esempio, l'album ID, noi sappiamo che in realtà del JSON sorgente, tutti i campi sono sempre tutti valorizzanti, però in alcuni casi magari noi vogliamo che un campo sia richiesto, questo magari ha più senso per l'ID che per l'album ID. Quindi vogliamo che l'ID sia sempre impostato e che ci sia un'eccezione se non lo è. E cos'altro? L'album ID magari invece può essere non richiesto se non viene impostato, vogliamo che la loro default sia meno impostata. Ok? Ci sono cose che possono per senso o meno. Ok, a questo punto questo nostro from JSON compilato a mano, cioè fatto a mano, non ha più senso di esistere. Ok? Riseviamo il nostro passo di... Mi sta facendo cose e già qui c'è già un warning di quello che dovremmo andare a fare, ossia... Lo lasciamo fare... Lasciamo a giro un attimo e quello che andrà a fare in sostanza è che prenderà questa nostra classe, qui creerà una classe, cioè un file ombra, diciamo così, un file... Secondario, un parallelo che include il codice che serve per serializzare e di serializzare la nostra classe in automatico. Ah, per questo quindi è stato un dev come si crea la classe esatto, la classe è spesa viene considerata esatto una volta che è generata la possiamo... la viene compilata come tutte le altre cose e a tempo di esecuzione non ci serve. Ok, quindi secondo me c'è il risultato di tempo di sviluppo per dire, creare la tempo. Esatto, esatto. Quindi questa cosa del build run serve bene male a questo. Lo useremo adesso per fare questa cosa qui e poi lo useremo dopo la pausa per lavorare con SQLite in cui faremo la stessa cosa ossia faremo generare il codice per gestire il DB sempre con una build runner con questa incredibile velocità. Ok, l'ha fatta? Allora, qui dovrebbe aver generato... Allora, non l'ha fatto ancora perché manca un pezzo però ci avverte il problema. Allora, qui ci dice attenzione photo item quindi questo qui è marcato come ma deve includere il file ombra che adesso non è stato ancora generato e che altrimenti le cose non funzionano. Quindi si dice attenzione devi aggiungere photo item .g.dart che è questo file ombra appunto per far funzionare le cose. Quindi qui dopo gli import in genere mettiamo una direttiva part e ci mettiamo photo item .g.dart Ok, che è una cosa un po' misteriosa però questo qui in sostanza vuol dire che questo file qui quindi photo item .dart questo file è composto da più parti in livello logico per cui deve importare quest'altro oggetto qui. Rieseghiamo tutto quanto il nostro build runner è soddisfatto e dovrebbe generare il file .g .g sta per generated quindi in qualche modo ed è una convenzione che si usa spesso quindi quando c'è un processo di precompilazione tramite build runner spesso sono generate questi file .g che diventano parte del file officiale cioè del file primario questa cosa a parte diciamo così a parti serve perché appunto dart ragiona a file come unità di compilazione quindi quando compila un singolo file quello è lo scope del variabile e quant'altro per cui ha senso poter definire in realtà un file come composto da più file a livello logico quindi è un file logico può essere composto da più file tisici questo è tipo il c'è il include un dos part del cito è un macro di un pregatore sì praticamente sì è molto simile all'include quello brutale di c che è un copincolo in sostanza penso che sia un po' meno brutale di quello però più meno siamo lì ok stavolta è comparso il nostro file .g.dart devo andare a vedere come è fatto allora qui appunto vi dice attenzione questo codice generato non modificarlo tanto anche se lo modifichi poi verrà scritto alla prossima build run quindi questo qui se va modificato va modificato negli attributi non nelle direttive e qui vediamo quello che succede cioè fa cose simili a quelle che abbiamo fatto noi a mano in realtà quindi crea due metodi uno è photo item from json l'altro è photo item to json che sono metodi di conversione e il primo fa delle verifiche tanto verifica che il json sia valido e che i campi richiesti che noi vogliamo siano presenti nel json ok e poi fa la mappatura e questa la mappatura la fa esattamente come abbiamo fatto noi se ricordate quindi se io torno al photo item diciamo così è simile l'assimilazione è simile qui adesso chiaramente essendo questo un intero nullabile viene messo di default a meno uno come abbiamo specificato negli attributi e così via quindi applica tutte le varie direttive che abbiamo fatto e a questo punto possiamo usarle noi nel nostro codice quindi photo item from json è il metodo è nascosto quindi c'è l'underscore quindi non è pubblico che possiamo utilizzare qui nel nostro costruttore quindi dentro il costruttore che cosa facciamo invece di definire il costruttore a mano facciamo un photo item from json che come prima avrà come parametro string dynamic che è come si esprimono i oggetti in json e tant'è che qui il dato è lo stesso è chiaramente di input e ora attenzione vogliamo inoltrare cioè vogliamo richiamare semplicemente quel quel metodo da qua passandogli il json questo questo è illegale ma se un secondo lo facciamo lo facciamo definendolo come factory ricordate cosa è factory factory serve per definire un costruttore che non costruisce oggetti ma li fa costruire alcun altro e ritorna un oggetto già costruito ok prego in questo caso abbiamo detto che l'underscore ci indica che è visibile solo per il stesso si c'è un motivo per il loro o adesso no quello è per evitare che ci sono collisioni credo se è una cosa da scuola si si si esatto in genere per renderlo incollidabile per evitare collisioni di nome ok quindi questo è un costruttore standard che crea l'oggetto così com'è questo è un costruttore factory quindi che non costruisce l'oggetto in sé ma che ci ritorna semplicemente un oggetto che è già stato costruito da chi è stato costruito da photo item from json che a sua volta non fa altro che richiamare il costruttore di default che è riuscito a che il nostro builder è riuscito a trovare nel codice quindi il build runner ha questa capacità di autoanalisi del codice perché ha accesso al sorgente quindi legge il sorgente vede cosa fa e usa i costruttori i campi e così via in maniera compiuta a runtime dart non lo può fare per cui lo facciamo in questo passo di primo pilastro ok il vantaggio chiaramente è che chiaramente il nostro codice è molto più rapido in tempo di esecuzione perché non deve fare dei controlli a runtime di quali sono i campi e quant'altro che sono abbastanza dispendiosi e lenti sia in .NET che in Java con altri linguaggi però il codice diventa molto meno flessibile chiaramente quindi bisogna sempre questa precompilazione e poi ogni volta modificare qualcosa è sempre un costo importante ok a questo punto visto che c'è anche il 2json tanto vale fare anche quello pubblicare anche quello e possiamo fare un metodo che non fa altro che ritornare e in sostanza non fa altro che riproporre questa funzione qui ma al pubblico ok passiamo oppure data un'istanza di di un metro di distanza che non serve neanche fare nulla siamo test e basta ok abbiamo fatto la stessa realizzazione chiaramente se l'orietto fosse più compresso avremmo fatto prima in questo caso abbiamo messo molti di più però questo è qua ok quindi questa cosa è necessaria per velocizzare tutta la parte di prendori dei datacroci però c'è il suo odore esatto esatto i classici DTO come si chiama oppure i poco i plain old si objects e così via gli oggetti che modellano lo stato cioè il il dato grezzo diciamo così sì usiamo questo metodo qui per non dover fare tolato a mano uno e due chiaramente c'è più garanzia che tutto funzioni perché chiaramente la libreria un po' di lavoro lo fa per quanto nostro quindi non dobbiamo verificare che i campi richiesti sono richiesti che sono default quindi ci sono varie cose che comunque ci aiutano nella generazione del codice e assicurarci che sia tutto quanto corretto è molto più facile debaggare gli attributi espressi in questa maniera che andare a vedere un metodo from json to json scritto a mano che magari appunto in questo scenario era ancora semplice ma immaginate dover lavorare con tanti cioè con API vera con 20.000 metodi possibili con tanti classi json tutta ogni data magari poi appunto è ovviamente molto più sensato lavorare in questa maniera prego altra domanda se noi per assurdo avessimo un oggetto che al suo interno ha tanti altri oggetti serializzabili sì esatto esatto e lì in quel caso ci aiuta perché se un oggetto è già serializzabile e lo insudiamo a cascata poi se non capisce che deve delegare lo fa lui sì sì esatto per cui quello è comodo se adesso non è il nostro scenario e mi sa che l'API che usiamo di default non ha cose sofisticate però appunto se avessimo oggetti con altri oggetti in dati o con liste di oggetti e così via non farebbe tutto quanto di essere serializzable senza che dobbiamo farlo noi quindi quello è un vantaggio notevole adesso l'unica cosa che ci è rimasta da fare a noi nel provider è semplicemente andare a no a leggere cioè a scaricare il json e l'unico diciamo così l'unica parte in cui ci sporchiamo le mani ancora con json è nel castarlo a una mappa di oggetti json cioè sì una lista di mappe di oggetti json in sostanza e a quel punto poi deleghiamo tutto quanto il lavoro a json serializzable però chiaro se il lavoro fosse di più lo farebbe la la libreria per noi ok torniamo a noi rapidamente quindi tutto questo non ha cambiato nulla per cui se adesso io lancio lanciamo l'applicazione che adesso non è fatto questo lavoro ma l'applicazione non è stata lanciata quindi di nuovo aspettiamo un secondo dovrebbe essere identica prima nel senso che non fa nulla di più ovviamente adesso vediamo di caricare queste immagini ovviamente la pagina che carica questo questo provider è la gallery page ma la gallery page ancora non mostra sull'immagine che è un po' deludente per cui ci metteremo finalmente le immagini che è la scusa con cui poi andiamo a fare operazioni di file e quant'altro allora nel frattempo mentre concludiamo tutto dobbiamo complicarci un po' la vita allora qui nel nostro qui siamo qui nel desu builder qui creiamo una lista di n elementi ogni elemento è un testo con l'ind quindi è una cosa molto molto primitiva creiamo un oggetto un pochino più sofisticato quindi facciamo un gallery item viewer o altro genere non so se facciamo lo status widget perché è più bello a questo oggetto qui passiamo direttamente questo cos'è questo è un photo item quindi passiamo un photo item direttamente facciamo le cose in maniera più semplice possibile quindi ho un costruttore che è viewer qui passiamo direttamente l'item farlo più semplice possibile adesso i singoli oggetti saranno composti anche qui facciamo le cose molto facile farò una riga allora l'idea è potrebbe essere a sinistra della riga mettiamo la riga prende tutto lo status intanto mettiamoci questo max e mettiamo le cose a sinistra nel caso in cui qui qui si sta ok qui a sinistra mettiamo l'immagine allora le immagini adesso vediamo tra un secondo ma ci sono vari modi per ricupire dell'immagine qui per compratezza vediamo la gallery e vediamo cosa avviene nulla di utile cioè quello che ci aspettiamo quindi carica la gallery e qui va bene il json a questo punto la json viene serializzata da json quindi non è canale nulla tutto funziona ancora è rassicurante a questo punto mettiamo a sinistra mettiamo l'immagine e allora le immagini in in in in flutter si usa in genere il widget image che ha vari costruttori e visto che noi stiamo lavorando con degli oggetti che internamente hanno degli url possiamo usare il costruttore network che ci permette di esprimere la fonte di un'immagine tramite una stringa che è direttamente una sorgente url quindi possiamo metterci aizan tamil tamil url ah perché non ho portato a padaria grazie ok quindi passiamo l'url direttamente così qui ci sono vari altri campi opzionali che adesso non utilizziamo vedete che ci sono varie cose che possiamo fare ma non ci interessano di tanto ok quindi a sinistra ci sarà l'immagine e poi a destra quindi ci mettiamo un piccolo spazio per separare le cose e poi ci mettiamo una colonna e in cima della colonna mettiamo l'id che sarà item id id cos'è quindi lo castiamo a 0 c'è una stringa scusate e poi sotto ci mettiamo il titolo se non vado errato per il titolo ok e questo è quanto questa cosa sarà molto brutta al momento adesso vediamo cosa viene già questo potrebbe spaginarsi in vari modi che probabilmente accadrà quindi proviamo e vediamo ah beh molto poco visto che non lo sto usando doveva arrivare insomma diciamo così poi l'oggetto in diesimo e poi questo meglio molto brutto adesso funziona ma è orribile soprattutto perché viene tutto spaginato dal fatto che viene caricato quindi la nostra immagine all'inizio c'è il nostro oggetto il nostro widget image visto che viene caricato dalla rete non sa che dimensioni ha e quindi inizio parte 0x0 e poi si gonfia appena ha scaricato l'immagine chiaramente questo non è ideale ma vediamo come fixarlo per cui siamo in overflow quindi insomma varie limitazioni e varie migliorie che si possono applicare però intanto molto banalmente già un funzionamento minimo accettabile cioè dato che visto che la list view precarica gli oggetti man mano che e lo fa mentre sono ancora non visibili in realtà l'esperienza è abbastanza buona appena che vedete che adesso sono arrivato in fondo e non ho ancora caricato però se vado scorro lentamente in realtà l'altro fa in tempo a creare gli oggetti image e a precaricarli prima che li veda ok in questa posizione diamo un paio di botte di martello quella per aggiustare le cose allora qui straborda cioè esce dai margini questa riga qui allora quindi la colonna si può dire altre immagini di essere piccolo sì sì sì possiamo fare questo ovviamente possiamo fare cioè possiamo fare varie cose dato una cosa che si può fare intanto è visto che sappiamo una cosa che sappiamo questo nell'immagine tra l'altro è un problema che vale sia per Flutter ma vale anche per il web cioè nel web le immagini hanno questo problema nel senso le immagini nel web sono a maggior ragione tutte caricate dinamicamente adesso in Flutter no nel senso che nella login page se ricordate cioè non l'abbiamo fatto veramente ma lo siete trovati nel codice quando ve l'ho passato però qui cariciamo già un'immagine ma dagli asset così che qui il costitore di image che avevo usato è asset gli asset sono risorse locali della nostra della nostra applicazione per cui qui c'è una cartella images qui nella radice del quindi a fianco della lib cioè images con dei file e perché vengono compilati dentro l'applicazione bisogna aggiungerli al pubspec YAML quindi qui nella lista delle cose da fare sotto Flutter va aggiunta la lista delle immagini che vanno compilate dentro il pacchetto quindi questa immagine qui viene aggiunta alle immagini dell'applicazione e a quel punto quando le carichiamo dentro login page le possiamo caricare a Tramodas quindi questa questa immagine qui viene caricata immediatamente dalle risorse dell'applicazione quindi questo è un modo per curiosità andiamo sul aspetto come facciamo mentre images slash asterisco prima questa è un'altra domanda non lo so sarebbe sensato se questo sia possibile immaginerei di sì ma da verificare per sumo di sì perché sarebbe penso sia molto comodo però da vedere da verificare sulla documentazione e oltre a questo in realtà è possibile fare varie altre operazioni e avere varie versioni della stessa immagine con varie soluzioni e qui è il caso di andare a vedere questi dettagli però tornando sulla parte dell'immagine remota la difficoltà quando l'immagine remota è che appunto al runtime non sappiamo quanto è grande però possiamo già dare delle piccole direttive qua e là per l'impaginazione quindi aiutare un po' Flutter nel gestirla quindi una cosa che si può fare intanto è visto che sappiamo che questi immagini sono quadrati cioè sappiamo che sono 150 250 intanto possiamo metterle dentro un oggetto che mantiene il rapporto quindi c'è un widget opposto che si chiama aspect ratio ok questo widget ha alcuni campi e l'ho richiesto è aspect ratio proprio che è un double quindi è un rapporto tra larghezza e altezza noi sappiamo che è 1 chiaramente perché è quadrato quindi possiamo scriverlo come frazione se vogliamo essere proprio formali o come 1 e basta così Flutter sa che l'oggetto sarà sempre quadrato ok per cui non spaggiano più di tanto e in più possiamo forzare l'immagine ad avere un'altezza magari un'altezza massima magari quindi specificare height e invece di metterlo a 150 mettiamo la 100 ok giusto per cambiare un po' le cose ricacciamo niente questa volta vediamo un attimo allora ane questo è troppo al dentro della quindi magari diamo una grandezza massima a tutto il blocco questo dovrebbe per senso quindi tutta la riga per aiutare anche un po' al layout possiamo metterlo dentro un container con una dimensione fissa mettiamo magari a 110 adesso container ok questa volta ha già più senso vedete che in automatico l'immagine già sa come disporsa a questo punto perché il container ha altezza 120 a sinistra avrà un oggetto che ha una spectacione fissa quindi sa che l'altezza è costretta a 110 per cui anche la larghezza è a 110 e quindi anche nel prevaricamento già lo spazio per l'immagine è già preimpostato se avete dato un'altra quindi questo qui scorro giù vedete che lo spazio dell'immagine è già fisso perché Platter sa già che è per forza 110 per 110 e questo aiuta un po' la spaginazione poi cos'altro qui spagina il testo che non va a capo quindi vogliamo che avrà qui il titolo in particolare vediamolo a true e poi vogliamo che in realtà vogliamo che tutti i testi siano a sinistra ovviamente per cui la colonna deve avere una main access alignment che dalle 11 ok quindi le mettiamo in cima e poi cross axis vogliamo che gli oggetti siano grandi quanto possibile nella colonna ok vediamo il primo stretch e poi i testi verranno a dire da sinistra di default quindi aspetto adesso abbiamo allora qui facciamo questo entro un expanded così la colonna sa quanto deve essere grande ok così la colonna prende tutto lo spazio residuo a destra perché l'immagine sa che la larga 110 il size box sa quanto è largo 8 a cui puoi expande per tutto il resto la colonna si espande completamente a questo punto sono più o meno accettabili il titolo lo facciamo molto grande ok magari però ecco già diciamo che ci può star bene ok carichiamo e ora vediamo che appunto la network image.network funziona come costruttore e tutto sommato è abbastanza accettabile nella maggior parte dei casi tra 6 minuti cioè adesso facciamo la pausa e prendiamo un caffè poi andiamo di là nell'altra aula e vediamo come gestire in autonomia il caricamento di queste immagini con un provider sempre e poi lo agganciamo a una cache locale quindi cominciamo a lavorare anche in file perché così vediamo anche come ottimizzare questo caricamento del momento funziona ma non è non è ottimale perché comunque l'altra sta caricando così alla bisogna delle varie immagini e alla lunga ovviamente ci sono 5.000 immagini quindi alla lunga potrebbe avere qualche difficoltà a caricarle tanto quando vediamo come fare una cache efficiente di queste di queste immagini interrompo e riprendiamo tra diciamo più o meno le 11 e 10 circa di queste immagini IoT di Wednesday perché finiscono poi diciamo ci siamo c'è File e i ri abbiamo delle esame