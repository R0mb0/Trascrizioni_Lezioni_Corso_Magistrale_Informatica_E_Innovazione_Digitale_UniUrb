ok ripartiamo dove eravamo arrivati la volta scorsa con le nostre prime avventure o sventure che per si voglia con le win 32 forse devo smettere di parlarne in questa maniera sennò poi è poco incentivante per la partecipazione però troppa onestà allora guardate qui abbiamo visto che invece del main il runtime delle win 32 prevede che sia un win name e una volta entrata in win main abbiamo visto che possiamo fare qualsiasi cosa nel senso che qui nel main è un programma tutti gli effetti per cui possiamo fare quello che ci pare ci piace ma in genere ovviamente un'applicazione win 32 dovrà aprire una finestra per comunicare col mondo esterno soprattutto perché di base un'applicazione per win 32 non comunica con i canali standard in genere qui non c'è altro modo per far vedere qualcosa se non farlo graficamente quindi la finestra è la scelta più semplice che si possa fare per fare una finestra qui appunto ricapitolo brevemente bisogna prima creare una classe delle finestre quindi una categoria in cui rientra la finestra che andiamo a creare e poi finalmente una finestra a quel punto la finestra esiste ma non è ancora virtualizzata va mostrata all'utente con show window e a quel punto la finestra esiste concettualmente e comincia a cioè compare sullo schermo meno in teoria e soprattutto comincia a ricevere messaggi quindi la cosa più importante che fa una finestra una volta che è parte del ecosistema diciamo così delle finestre degli elementi grafici dentro windows è che può ricevere dei messaggi di con cui il sistema ci comunica quello che sta avvenendo a schermo e quindi ci comunicherà quello che l'utente sta facendo se clicca con il mouse e digita sulla tastiera se fa qualsiasi altra cosa ci comunicherà se avvengono delle cose degli eventi di sistema quindi ci può comunicare che il sistema sta per spegnersi che l'utente ha cambiato fonti di default sistema che l'utente ha cambiato i colori di default altre cose che sono meglio in mente oppure che la topologia dei monitor visto che parlavamo ieri la topologia dei monitor è cambiata quindi ci può arrivare un messaggio dicendo attenzione lo schermo è cambiato perché l'utente ha collegato qualcosa oppure perché ha modificato le impostazioni degli schermi e così via e poi ci sono anche altri eventi diciamo così di sistema legati alla finestra stessa quindi ci può arrivare un messaggio che ci avverte del fatto che la finestra è stata appena mostrata che la finestra è stata appena minimizzata che è stata spostata e così via tutti i messaggi che adesso tra un secondo vedremo come ricevere ma ci sei per riceverli ci serve un uno strumento una specie di cioè una funzione di effetti che ha questa window procedure la procedura di finestra che sia registrata per gestire questi messaggi quindi questa procedura qui questa funzione qui è quella che andrà a gestire i messaggi al momento non fa molto anzi non fa nulla diciamo così e la controparte è la message pump quindi il il loop infinito e bloccante dentro il nostro main che fa in modo che quella procedura venga chiamata quindi è un concerto tra chi si mette in attesa dei messaggi per elaborarli e poi le funzioni che voi avete registrato per gestire i vari messaggi in assenza di questa di questa procedura qui di questa message pump chiaramente i messaggi non vengono lavorati quindi la vostra applicazione non reagisce ai messaggi questo in gergo tra l'altro si chiama forse avete già sentito nominare questo questi loop bloccanti in attesa di eventi è una tecnica che in genere si chiama anche basic loop cosa avete sentito in insieme operativi no e o busy wait anche è un modo abbastanza primitivo per rimanere attesa di eventi in questo in questo modo il nostro il vostro trend di esecuzione si blocca e quindi rimane busy cioè rimane occupato a elaborare messaggi che magari non sono ancora arrivati quindi in qualche modo è un loop che ci permette di fare delle cose in maniera interattiva nella maniera più semplice possibile ossia sicuramente avere un loop infinito che prima o poi terminerà ok parlando di un infinito e la volta scorsa eravamo rimasti bloccati o meglio c'era cesso cioè abbiamo visto che c'era un piccolo problema perché la nostra applicazione non termina mai cioè l'eseguibile non viene mai terminato perché rimane bloccata in questo busy loop quindi non c'è mai non c'è nessuno che avverta la nostra applicazione del fatto che deve terminare e chiudersi perché perché praticamente cosa avviene i messaggi arrivano alla finestra e la finestra funziona correttamente adesso non ho via del terminale però faccio adesso se rieseguissi il programma vedrei la stessa cosa la volta scorsa quindi che la finestra si apre e può essere spostata può essere manipolata può essere ridimensionata così via quando la chiudo quindi quando clicco sulla x in alto la finestra si chiude ma l'eseguibile rimane in esecuzione giusto se ricordate era quello il problema ma in esatto e adesso non compilo però va bene questo ancora compila a tra l'altro abbiamo fatto anche questa cosa che con l'unico di questo per essere per completezza aggiungo la direttiva unico per essere sicuro che le stringhe sono corrette ok questo problema allora come gestiamo questa questo questa problematica c'è uno collegato perfetto il pattern classico che si utilizza è ricevere i messaggi dalla nostra finestra quindi rimanere in attesa dei messaggi che arriva alla finestra e quando arriva il messaggio di chiusura della finestra cioè quando l'utente clicca sulla x in alto da destra vogliamo gestirlo andando a segnalare al thread sotto quindi qui dentro di dover terminare ok quindi c'è questo bisogna segnalare al al main che la finestra non c'è più è ora che tu chiuda il messaggio pump perché giustamente non c'è più nessun oggetto a schermo che abbia bisogno di un messaggio pump perché in assenza della finestra la nostra applicazione non ha più elementi grafici che debbano comunicare col col resto del sistema per cui come si fa questa cosa allora vi faccio subito vedere in genere come si ricevono messaggi il pattern classico che si utilizza è fare un grosso switch no se la programmazione di base lo switch ci permette di avere vari case no in base ai valori che un una variabile assume la variabile ci interessa è message message è l'intero senza segno che identifica il messaggio in particolare per cui in base al messaggio che arriva faremo delle cose diverse questa è più o meno l'idea vediamo se riesco a aprire anche un browser per farvi vedere alcuni dei messaggi che il messaggio che ci interessa in winter dove ci sono veramente infinita perché anche lì bisogna un po conoscerli però la maggior parte sono abbastanza classici quello che ci interessa è vm destroy che già si capisce a cosa serve è un window message destroy che ci arriva quando la finessa viene distrutta molto manualmente quindi wm destroy è il valore che ci arriva e quindi faremo un case vm destroy questo è un classico break che è previsto da c così via se qui possiamo scriverlo in vari modi diversi in base alla vostra preferenza che possiamo anche mettere le font a messa che sia previsto da c i miei memorie di c sono abbastanza arrugginite ma penso che sia valido ok così quindi possiamo anche scriverlo in questa maniera cioè se non è un messaggio che gestiamo possiamo passare il messaggio alla def window proc che vi ricordo è la window procedure di default che vi dà il sistema quando voi non volete occuparvi di un messaggio quindi fa alcune fa molte poche cose e fa giusto quel minimo che serve per gestire il messaggio nel caso in cui sia un messaggio importante ma in genere di gli scarta tutti ok quindi gestiamo soltanto wm destroy andiamo a fare qualcosa che sia utile per questo questo gioco questo per segnalare insomma la terminazione di là vm destroy chiaramente è una costante di questo intero questo qui è un valore tot che adesso non ci interessa cosa sia ma se andiamo a vedere è il messaggio numero due addirittura quindi è abbastanza fondamentale che potete immaginare che sia abbastanza fondamentale questo in realtà possiamo anche vedere dove è definito così lo troviamo anche dentro windows punto h se avessimo voglia potremmo andare a vedere gli header e vedere tutta la lista dei messaggiati questo forse potrebbe essere utile in generale che dovremmo farlo qui facile trovarlo abbastanza rapidamente perché chiaramente tutti i messaggi sono documentati lì come interi e adesso lasciamo fare intanto proveremo intanto andiamo a gestire questo allora cosa vogliamo fare in questo caso vogliamo che quando la finestra viene distrutta questo blocco qui termini quindi questo while qui torni false quindi vogliamo che get message ritorni false get message ritorna sempre true finché c'è possibilità che un messaggio arrivi ok l'unico caso in cui get message ritorna un valore zero false è quando c'è in coda un messaggio speciale più speciale di vm destroy che vm quit è questo vm quit la differenza è vm destroy è quando la finestra viene distrutta quindi è un evento che vi arriva quando la finestra quando la finestra sarà distrutta dall'utente in genere anche se può essere anche un'altra applicazione che risurge la vostra finestra chiaramente quindi in genere la finestra è stata chiusa vm quit invece è un messaggio più generale a tutta l'applicazione e segnala che l'applicazione e tutte le sue finestre perché chiaramente la professione può avere più finestre può avere più icone può avere più oggetti grafici a schermo tutte le finestre vanno chiuse perché l'applicazione deve terminare quindi vm quit è un altro messaggio fondamentale del sistema quando c'è vm quit in coda nella vostra coda dei messaggi la cosa speciale è che get message ritorna false perché quello è l'ultimo messaggio che la coda dei messaggi in genere e lavora quindi per convenzione che deve essere giro una false e a quel punto la nostra while termina e ritorniamo zero ok questa è un po l'idea come facciamo a mettere vm quit nella nostra coda dei messaggi c'è un apposita che si chiama post quit message e quindi questa funzione qui che adesso possiamo anche trovare serve soltanto a mettere in coda sulla nostra coda dei messaggi un messaggio di vm quit per segnalare a tutta l'applicazione che deve andare che deve uscire niente di di complesso ok quindi è una puntina molto semplice come parametro prende l'exit code che è il famoso da da da unixiana memoria è il codice di determinazione per cui possiamo segnalare noi qui qual è l'intero con cui vogliamo terminare zero per convenzione vuol dire che tutto va bene e e questo è quanto l'exit code quindi questo zero qui ci arriva come doppia v param del messaggio di là adesso quindi per complicare per complicarsi la vita qui vogliamo essere corretti facciamo ok perché quando che messaggi non è false vuol dire che arrivato messaggio vm quit ok quindi messaggio contiene vm quit e per convenzione questo messaggio contiene un campo che si chiamano vv param che è il parametro che contiene l'exit code come ci dice anche la documentazione quindi qui dentro qui mettiamo in coda vm quit come messaggio avrà come parametro w param un valore intero che è questo qui che abbiamo specificato nella funzione nella message pump dove arriva il messaggio questo è una forza perché il messaggio è wm quit e a questo punto questa struttura dati contiene w param impostato con il nostro exit code è un sistema convoluto e complesso e accrocchiato diciamo così diciamo come stanno le cose e però alla fine dei conti l'idea è che questo questo messaggio qui ci permette di uscire dalla da da l'hoop e terminare l'applicazione quindi se non ho commesso errori a questo punto dovremmo riuscire a fare questa cosa intanto dobbiamo aprire quindi win apri win news vediamo un po se rispettare la lista dei dei messaggi per user no qui avevamo già il nostro message box che era sempre qui dentro ecco che quindi i messaggi partono da qui quindi wm null è messaggio zero quindi il messaggio che serve a nulla create è quando viene creata la finestra distruttano viene distrutta move quando viene mossa spostata size quando viene ridimensionata attivate quando potente la l'attiva quindi viene arriva in pieno cioè che primo primo piano e quindi prende il controllo schermo e così alcune si capiscono abbastanza bene alcune set text che sono un colore misterioso magari però in genere si dice questa la web quid che ci interessa e così via l'elenco è abbastanza lunghetto quindi insomma c'è un buon numero e questi sono tutti i messaggi che concettualmente la vostra applicazione potrà voler gestire ovviamente non è necessario essere tutte perché soltanto se ci è rilevante lo faremo vedete qui sono tutti i messaggi della gestione del mouse per esempio e quelle che non ci servono possiamo tranquillamente ignorarle ogni versione di windows in genere poi aggiunge nuovi messaggi se serve per complicare le cose se serve sono tutte cioè c'è una forte retro compatibilità nel senso che è vero che versioni moderne di windows possono aggiungere nuovi messaggi per genere quelli vecchi sono sempre utilizzati comunque comunque i messaggi nello stile classico di windows tant'è che appunto la create risale ai 16 ovviamente e le altre si aggiungono allo schema esistente ok compiliamo vediamo cosa accade il punto ex adesso vedete la finestra qui ecco la finestra immaginare che la finestra sia ricevendo adesso ha ricevuto subito web create chiaramente web activator che sarà attivata web move adesso sta ricevendo ma li stiamo ignorando adesso riceverà dei web size quando cambio la dimensione questo è un web di activate activate di nuovo e adesso però web destroy cliccando sulla finestra e distribuendo la se riesco a chiedere anche test manager perché ci aspetteremmo che la finestra della finestra causi la terminazione del nostro il patico main punto exe quando chiudo qui dovrebbe terminare chiudo quindi a questo punto funziona quindi abbiamo finalmente l'impalcatura minima per fare un'applicazione in winter del mondo voluto molto testo per farlo esattamente 60 righe circa però di base questo è come minimo per avere una finestra funzionale ok se non è chiaro questo questo gioco tra di coda in sostanza ricordatevi sempre che la coda è unica cioè ogni applicazione ha una singola coda degli eventi in genere non è neanche detto ma la maggior parte dei casi è così c'è un unica coda questo che messa qui vi dà l'accesso alla coda degli eventi dei messaggi quindi di tutte le vostre finestre e poi quando l'applicazione termine chiaramente si porta dietro tutte le strutture grafiche che l'applicazione ha generato questo possiamo mostrarlo anche in una seconda in secondo esempio di prova la nostra applicazione che realmente più aggrato una finestra ma nulla toglie che la nostra applicazione possa creare più finestre chiaramente anzi ha molto senso nella maggior parte molte applicazioni fanno proprio quello effetti proviamo a copiare tutto e duplicarlo facciamo due finestre quindi qui sarà semplicemente questo potete anche non farlo solo per vedere quindi farò una seconda finestra con h finestra due e parlo show window h finestra due e cambierò il titolo ciao mondo due ok quindi cosa viene crea una finestra crea una seconda finestra le mostro entrambe e poi entro nella message pump vale per entrambe le finestre ok quindi la coda degli eventi è la stessa le finestre generando gli eventi distinti perché ogni finestra riceve i suoi eventi e mette nella coda e il sempre questo lui che le gestisce ok quindi questa def questa la mia procedura questa funzione qui viene richiamata per entrambe per gestire i messaggi per di entrambe le finestre perché perché entrambe le finestre sono della stessa classe questa è la cosa importante la classe è stata registrata una singola volta la procedura è legata alla classe di finestre e quindi essendo entrambe la stessa classe sono gestita la stessa la stessa maglia vediamo che succede perché il comportamento che forse un po inaspettato è questo allora non le vedete ma che mette sempre sull'altro schermo due finestre sono identiche vedete che cambia assoluto il la caption nel titolo entrambe non fanno notamente nulla gestiscono gli eventi la stessa maniera ma non si nota neanche perché non fanno nulla ancora esattamente stavo arrivando a quello esatto per cui se chiude una finestra chiudo tutta l'applicazione questo è il problema o c'è può essere una cosa voluta chiaramente dovete essere conci voi del fatto che appena una finestra riceve destroy quindi entra qui questo vale per entrambe le finestre appena riceve il destroy invia il messaggio di quit il messaggio qui vale per per la message pump che vale per entrambe le finestre ovviamente a quel punto quando il processo termina il processo si porta dietro tutte le finestre ancora aperte quindi anche se una finestra rimane aperta non vedere creola c'è la festa 2 la sto per terminare la chiudo e sparirà anche la prima finestra perché viene distrutta da windows in automatico perché il processo della finestra è stato terminato quindi quando il processo è terminato oppure va in errore critico comunque in ogni caso smette di elaborare i messaggi quindi non ha più una cosa dei messaggi tutti gli elementi grafici che sono legati al processo ovviamente vengono terminati in automatico quindi avviene questo questo può essere tranquillamente voluto adesso chiuso la finestra numero 2 ma se avessi chiuso la finestra numero 1 sarebbe esattamente uguale questo è ciao mondo 1 come faccio a distinguere le finestre allora ci viene in soccorso questo e ci vende qui quindi quando ci arriva un messaggio riusciamo a capire a che finestra fa riferimento perché il messaggio contiene un riferimento alla finestra per cui se noi volendo e questo poi lo faremo più avanti se vogliamo distinguere la finestra da cui arriva il messaggio possiamo distinguere in base a questo puntatore qui ok quindi adesso qui ci viene scomodo perché questi a questa finestra sono dentro il main però se li mettessimo globali per dire h window 1 e h window 2 no quindi ho due finestre questo questo e 2 e 2 a questo punto appunto non è capito nulla se non che ho i puntatori che si handle ce la globali e a questo punto posso fare molto banalmente h window del messaggio che mi è arrivato è pari a h window 1 allora distruggono la finestra quindi a questo punto la finestra numero 2 non termina la mia applicazione questo è il classico caso in cui c'è no vabbè guarda ok ok ok distruggono la prima la seconda scusate questo non fa nulla questo destra viene ignorato e a questo punto questo mi ci distruggono è uno dei mille modi con cui si può fare questa oppure molto più classicamente adesso avevamo due finestre identiche che avevano la stessa classe è molto più comune invece avere una finestra principale immaginate che non so un'applicazione complessa tipo word per dire che ha una finestra principale che quella del documento che termina tutta applicazione e poi magari può aprire altre finestre secondarie che sono per la ricerca per la sostituzione del testo per altre mille cose quelle finestre sono finestre di utilità di strumenti accessori che però non hanno la stessa classe quindi semplicemente hanno una classe diversa perché sono finestre completamente diverse e quindi quelle finestre avranno una procedura diversa quindi cambierà la funzione che gestisce la finestra quindi di base poi la procedura per la finestra principale farà vmquit e terminerà l'applicazione le procedure per le finestre secondarie invece hanno procedure diverse che non fanno questo quindi non fanno post-quit perché quelle finestre lì sono accessorie ok mi ripetisco un attimo e torno alla selezione di prima per non complicarci la vita per cui torno un attimo alla finestra si si va la pulizia il nostro ok perfetto ok allora adesso andiamo a vedere un paio di messaggi in più che ci possono essere utili allora abbiamo visto webdestroy che è molto utile perché ci arriva poco prima che la finestra sparisca questo avviene tra l'altro ultima cosa questo arriva appena prima che la finestra sparisce quindi questo è l'ultimo messaggio che la finestra elabora in sostanza qui possiamo ancora fare delle cose con la finestra se vogliamo possiamo ancora leggere dove sta possiamo ancora leggere in posizione che dimensioni aveva e così via dopo il messaggio la finestra svanisce e parte la classica animazione di distruzione della finestra l'altro messaggio che abbiamo visto prima è vmcreate che diciamo così va va a ripasso ah qui stavo notando in realtà qui stiamo tornando non sono tornando nulla questo è un errore che il compilatore non nota bellissimo qui non c'è nessuno ritorno quindi chi solo si ritorna non si sa va bene facciamo così che era più legante comunque ok non c'era il ritorno quindi però il tcc non la prendeva come ritornava a zero immagino come per default chissà ok quindi abbiamo vmcreate questo cosa serve? questo è un messaggio che ci arriva prima della creazione della finestra cioè prima che compaia a schermo in genere questo bloccio la vmcreate viene usata per inizializzare eventuali dati e accessori e quant'altro che ci saranno durante tutta la vita della nostra finestra quindi la nostra finestra magari deve non so creare un font o creare dei colori e preparare delle strutture grafiche e così via che poi utilizzerà al suo interno in genere lo fa dentro vmcreate stessa cosa avviene questo poi lo vedremo non lo subito se ne avrò se perché non fermo il tempo però a volte capita che alcune finestre abbiano delle sotto finestre questo capita molto spesso perché per comporre l'interfaccia grafica non è che andiamo a disegnare tutti gli elementi uno a uno in genere si riciclano dalle sotto finestre per far prima quindi classicamente non so i pulsanti facciamo un esempio con come esempio che sia pensato questo è questo è l'interfaccia di ricerca di testo di Notepad Plus Plus forse avete visto è un'interfaccia particolarmente piena di pulsanti e quant'altro questa interfaccia qui è una finestra ovviamente ok? quindi questa è una H window fatta con create window si può immaginare questi pulsanti che vedete qui sono tutte finestre ogni pulsante è una finestra ogni checkbox è una finestra anche questo questa cosa grigetta che vedete attorno a search mode che è un gruppo un group box si chiama Win32 è una finestra sempre la combo box chiaramente è una finestra poi vi vedete in dettaglio questi controlli standard però tutti questi oggetti sono delle finestre sono delle finestre standard sono finestre standard di Win32 perché Windows ci offre una pletora di finestre che possiamo usare senza doverle implementare a mano cosa che è molto noiosa quindi in genere per fare dei pulsanti dei checkbox e così via si ricicliano delle finestre che sono già pronte all'uso ok? quindi vivono delle Win32 hanno già una window procedure che fa tutto in automatico quindi il pulsante non lo gestiamo noi ma lo gestisce la window procedure quindi la funzione implementata da qualcuno che parte dentro Win32 che gestisce il click il pulsante la tastiera e così via quindi tutti questi controlli standard non dobbiamo implementarli a mano andremo semplicemente a creare una finestra di quella classe di classe pulsante di classe controllo di classe checkbox e così via che poi possiamo mettere dentro la nostra finestra ok? quindi andiamo a annidare delle sotto finestre sono tutte delle window gli effetti quindi ricevono i messaggi esattamente come tutte le altre finestre solo che non siamo noi a implementare la procedura che gestisce ok? quindi ci dà meno lavoro da fare perché basta mettere un pulsante dentro la nostra applicazione e quello già funziona in automatico e qualcuno ha implementato la procedura dei messaggi per noi ok? poi noi possiamo parlare con quella finestra e chiedere alla finestra se la spunta è messa se l'utente è cliccata e così via quindi in genere quando abbiamo un'interfaccia complessa in realtà spesso si va a comporre sulla base di finestre che sono già implementate e che implementiamo noi così agendo un po' suddividendo logicamente a pezzi la nostra applicazione ok? raramente abbiamo una singola finestra e poi andiamo a lavorare solo con quella con una singola window procedure però allora non compliciamoci la vita e vediamo come si fa di base quindi qui dentro la VM Create se avessimo delle sottofinestre quindi dei pulsanti delle checkbox o altri oggetti che abbiamo creato noi andremo a creare qui dentro ok? quindi se la nostra finestra è composta da altre finestre qui va a cascata va a creare le sottofinestre di cui è composta ok? ok poi l'altro oggetto veramente classico che si usa molto spesso è VM Paint e questo qui ha senso sentire un po' in dettaglio anche su questo allora anche qui insomma quando il messaggio sarà gestito possiamo o fare break perché poi viene passato il controllo da FWinDoproc oppure riteniamo a zero perché diamo per spuntato che quella funzione ha fatto quindi è abbastanza differente però allora dentro il ciclo di vita di un'applicazione la rieseggo per farvela questa è la nostra applicazione allora quindi ho detto VM Create segnale che è stata creata la finestra VM Destroy segnale che sta per essere distrutta VM Size segnale al cambio di dimensioni ok fin qui è tutto logico ma come si fa a mettere qualcosa a schermo cioè come si fa a mettere qualcosa su questo spazio bianco che è bianco perché se ricordate la classe prevede che sia bianco giusto perché abbiamo specificato che lo sfondo è white brush se mettessimo black brush sarebbe nera provare a fare questa cosa apprezziamo anche il fatto che dovrebbe aprire una singola finestra quindi questa è una finestra col brush nero di sfondo ok non cambia molto c'è anche un grey brush che è il progetto però possiamo creare dei brush a nostro piacimento chiaramente cosa avviene nel ciclo di video della nostra applicazione allora quando la nostra applicazione va sentata a schermo Windows fa una cosa abbastanza furba per l'epoca degli anni 90 ossia ci dà uno spazio su cui disegnare che è lo spazio che è grande quanto la finestra a schermo e attenzione qui entro in gioco tutti i dettagli stabrosi di cui ho parlato ieri per cui la finestra dello schermo non è quella vera adesso facciamo finta che queste cose non ve lo dette quindi abbiamo una dimensione che sono top pixel per top pixel e qui dentro possiamo disegnare in maniera completamente libera questo spazio si chiama client area cioè è l'area del client cioè della nostra finestra quindi qui dentro possiamo fare veramente quello che ci pare piace possiamo disegnare con tutti gli strumenti grafici delle GDI e non solo e non solo dico perché in realtà quando avviate un'applicazione grafica complessa metti un videogioco quello che avviene è che avviate in parallelo le DirectX o OpenGL quello che è quel sottosistema grafico usa la vostra scala grafica per renderizzare delle affascinanti grafiche tridimensionali e poi quando ha fatto il fotogramma le copia dentro la finestra quindi quando vedete una finestra che rappresenta un gioco tridimensionale o una che ne so un editor grafico tridimensionale o cose complesse di questo genere quello che avviene è che quell'immagine viene composta a parte sulla scala grafica e poi viene copiata con un processo che è una copia 1 a 1 che si chiama blitting viene copiata dentro la finestra quindi quello avviene la finestra una volta che ha un'immagine da presentare quindi immaginate che la finestra abbia questo frame questa immagine fissa da presentare Windows prende quell'immagine e la presenta a schermo di continuo quindi l'illusione che la finestra è a schermo e finché noi la spostiamo in questa maniera qui la nascondiamo sotto un'altra finestra e cosa possiamo fare la minimizziamo la apriamo e così via quell'immagine lì non viene mai toccata quindi quell'immagine lì rimane valida una volta che sta disegnata Windows la prende e la presenta a schermo anche se c'è qualcosa che la copre a metà non ci interessa perché la nostra finestra non si ridisegna mai cioè la finestra è stata disegnata una volta e quell'immagine rimane tecnicamente fissa per quanto poi noi ci facciamo delle cose delle operazioni grafiche sopra che gestisce Windows per conto nostro quindi la finestra scompare ricompare eccetera eccetera quell'immagine non viene mai modificata l'immagine viene modificata soltanto quando serve quindi quando Windows dice beh allora a questo punto la finestra deve ridisegnarsi per forza perché qualcosa è cambiato cosa può cambiare fondamentalmente che va a turbare la nostra applicazione la cosa più turbante nel senso di un'applicazione una finestra scusate è il ridimensionamento questa è la cosa l'operazione grafica forse più complessa che si possa fare con una finestra paradossalmente ossia questo questa cosa molto banale cambia completamente le carte in tavola per l'applicazione per la finestra in particolare perché la finestra cambia dimensioni e deve ripresentarsi a schermo perché magari qualcosa è cambiato soprattutto quando la finestra si allarga che peggiora le cose quando la finestra si rimpicciolisce alla fine Windows può dire vabbè io taglio la parte che non c'entra più e faccio finta di nulla quando l'allargo invece vado a presentare uno schermo più grande di quello originale cioè uno schermo una superficie più grande di quello originale in quel caso la finestra deve per forza ridisegnarsi su uno schermo più grande altrimenti Windows non sa cosa mettere nella parte che non c'era prima ok quindi questa procedura qui come funziona funziona su richiesta quindi è on demand nel senso che Windows quando serve quindi quando la finestra ha bisogno di essere ridisegnata ci manda un messaggio WM Paint cioè disegnati per favore perché devi ripresentarti a schermo perché ho delle informazioni grafiche che non sono più aggiornate qui Windows è Windows ma qualsiasi altro sistema operativo è pesantemente ottimizzato per evitare per quanto possibile questi messaggi qui questi sono i messaggi più costosi da mandare a una finestra perché la finestra deve risignare se stessa e a cascata tutte le finestre di cui è composta ok quindi è molto oneroso come processo tant'è che se ci fate caso adesso ovviamente il mio pc è particolarmente scarso però se qualsiasi pc anche moderno in genere la il trascinamento delle finestre è sempre un'operazione estremamente costosa e che non dico che va da scatti però insomma non è proprio elegantissimo quindi il browser stesso quando cambia dimensione deve rimpaginare tutto il documento e ripresentare lo schermo e questo avviene con i messaggi WM Pay il browser fa una fatica tripla chiaramente esatto quindi nel caso del browser è un miracolo che lo faccia nei tempi che ha che fa quindi questo è l'esempio più brutale tanto deve rimpaginare cambiare la modalità grafica c'è una altra complessità in più però qualsiasi applicazione che fa la stessa cosa in realtà fa la stessa fatica quindi anche Visual Studio Code in realtà si cambia poco sempre un browser però per dire l'interfaccia è un pochino più limitata di quella di un browser chiaramente però comunque nell'ingrandirsi si vede proprio l'effetto quindi si vede che Windows alloca una finestra più grande ed è la zona a destra e sotto che rimane nera per un istante e poi quando ce la fa l'applicazione ci disegna sopra quindi questo effetto qui è dovuto al fatto che il WM Paint richiede del tempo quindi in genere il WM Paint quanto ci arriva significa che Windows non sa più cosa mettere a schermo e bisogna sbrigarsi a riempire lo schermo in qualche modo quindi deve essere una funzione se possibile molto rapida ok andiamo a fare la WM Paint a questo punto vediamo cosa possiamo fare allora adesso qui ci sarà del codice molto misterioso che che dobbiamo fare perché sono vari oggetti e oggettilli che bisogna coinvolgere per disegnare a schermo e quindi prendetevi per buone per il momento poi vedremo in dettaglio che cosa serve per non sporcare troppo il codice in genere io faccio questa cosa qui che può essere considerata una cosa orribile o meno a vostro giudizio per non disseminare tutto di variabili in giro per il codice in genere dentro i case faccio un blocco un blocco di codice così che le variabili che dichiaro qui dentro valgono soltanto dentro la WM Paint però potreste tranquillamente fare anche una funzione che è la Paint pulire un po' il codice quindi fate come vi piace più stilisticamente qui dentro ci serve la prima cosa importantissima per disegnare è un device context cioè il contesto nel quale stiamo andando a impugnare il pennello la penna in quanto riguarda che sono gli strumenti con cui si disegna dentro le GDI ed è un oggetto che si chiama HDC quindi Handle to Device Context quindi è una è l'oggetto che in questo modo ha presente qual è lo stato grafico del nostro stato della superficie su cui andiamo a disegnare in sostanza come si ottiene un HDC si ottiene con una funzione che si chiama Begin Paint che ha una serie di parametri che adesso andiamo a vedere i parametri sono la finestra quindi HWindow e poi un altro oggetto che in realtà dobbiamo allocare per forza quindi qui serve un altro struct che va preallocato che si chiama PaintStruct e passiamo per parametro anche qui purtroppo le vintature non sono pre belle per cui è così quindi PaintStruct è la tavolozza immaginate di dover andare a disegnare proprio col pennello PaintStruct è la tavolozza dentro la quale voi memorizzate il pennello attuale il colore attuale queste cose qui HDC è il device context quindi è la tela la tela su cui andate a disegnare e BeginPaint è il processo con cui andate a mettervi davanti al tre piedi avete tavolozza e tela per tutto ok e quindi con BeginPaint voi segnalate voglio andare a lavorare su questa finestra HWindow questa è la mia tavolozza e dammi l'accesso alla tela se posso fare una metafora azzardata questa è l'idea quindi PaintStruct non serve a nulla cioè ce lo portiamo dietro così ed è un oggetto che in realtà poi non ci interessa moltissimo vedere cosa c'è dentro perché sono dettagli appunto del Win32 però ci serve perché questo contiene dei dati accessori che servono a Win32 per capire cosa sta facendo ok visto che c'è un BeginPaint viene abbastanza automatico immaginare che ci sia anche un EndPaint infatti è così quindi quando è finito segnaliamo Win32 guarda ho finito di disegnare e passiamo a EndPaint passiamo alle stesse cose quindi HWindow e di nuovo il puntatore a PS ok quindi la tela la superficie disegnabile diciamo così e la tavolozza che andiamo a utilizzare qui dentro possiamo fare quello possiamo disegnare finalmente ok questo BeginPaint è del Paint Server soprattutto perché andiamo a segnalare a Windows che quando inizia a BeginPaint allora andiamo un attimo indietro quando arriva WMPaint come messaggio quello è l'ultimo messaggio che Windows ci manda quando dice guarda lo schermo è cambiato radicalmente ridisegnati perché non so cosa mettere a schermo e questo è un messaggio potenzialmente asincrono nel senso che come si vede anche nelle finestre quando le ridimensioniamo vedete che in realtà avviene con un po' di ritardo quindi la finestra viene ridimensionata e poi arriva l'immagine questo perché chiaramente lo schermo si muove a 60 frame al secondo quindi ogni frame ha circa pochi millisecondi per essere presentato a schermo quindi Win32 va avanti ignorando il fatto che l'applicazione non ha ancora reagito e quindi presenta la finestra comunque a schermo dato che c'è un effetto grafico orribile sotto si intravede sopra in alto si intravede la barra standard di Windows 10 e poi viene coperta dall'applicazione questa è un'altra bruttura delle Windows 2 quindi sotto c'è una finestra standard e poi viene camuffata dall'applicazione coprandoci sopra il terminale quello bello e moderno quindi anche questa perché appunto quando ridimensioniamo l'utente vuole che la dimensione sia immediata se no poi dice che schifo è una cosa che va a scatti ed è frustrante quindi la finestra va subito dimensionata e poi il procedimento di ripittura chiaramente è asincrono e quindi può avvenire con qualche frame di ritardo e questo è inevitabile a meno che questa webpain sia veramente molto rapida in ogni caso quando ci arriva il messaggio noi segneremo Windows guarda ho ricevuto un messaggio va bene sto per iniziare a pitturare quando facciamo beginpaint Windows frizza cioè blocca il buffer di pittura quindi il buffer su cui andiamo a scrivere non lo tocca più perché sta per essere scritto da noi qui noi possiamo fare quello che vogliamo andando a dipingere quel buffer lì con endpaint segnaliamo il fatto che abbiamo fatto e Windows 32 può di nuovo accedere al buffer senza che ci siano degli effetti strani di accesso parallelo a una cosa che sta per essere scritta quindi in quel caso è una specie di semaforo se vogliamo esprimere in maniera da senso operativo quindi diciamo fermo un attimo scrivo io lascio a quel punto il buffer torna ad essere proprietà di Win32 al di fuori di questi due metodi non possiamo accedere al buffer in alcun modo non possiamo scrivere perché non abbiamo accesso all'HTC se ci portassimo dietro l'HTC fuori da beginpaint e provassimo a scrivere su l'HTC quello non scriverebbe perché a quel punto il buffer non è scrivibile ok tutto questo per farla lunga a questo punto finalmente scriviamo qualcosa a schermo facciamo la cosa più semplice che si possa fare ossia scriviamo del testo è più semplice poi tra virgolette cioè più semplice proviamo a farla semplice e in realtà come potete immaginare scrivere del testo a schermo è tutt'altro che semplice perché bisogna cioè il rettangolo si può fare facciamo il rettangolo dovrebbe essere draw rec adesso questo non me lo ricordo ma dovrebbe essere draw rec draw qualcosa draw lips draw rec credo draw quello che vi pare ma tutte le operazioni possiamo trovare qualcosa altro subito non poteva essere draw rec è facile questo perché nelle GDI tutte le primitive grafiche possono essere o riempite o tracciate quindi si possono tracciare i contorni o riempire quindi quello che adesso immaginiamo come draw rec si può immaginare che fosse fill rec quindi riempiamo un rettangolo facciamo fill rect ok cosa gli serve? gli serve l'HTC quindi dove andiamo a disegnare l'HTC ce l'abbiamo già perfetto poi serve il rettangolo il rect quindi questo rect qui andiamo a vedere come è fatto è una struttura dati che adesso andiamo ad allogare facciamo rettangolo che mi piace questo e poi HBrush che è il pennello che continuiamo a riempire il rettangolo quello già l'abbiamo già visto come si fa qui abbiamo caricato il black brush ricordate quindi visto che adesso lo sfondo è nero possiamo immaginare che possiamo caricare tranquillamente il recta passato per puntatore si ok e poi passiamo questo object pro white brush no ovviamente nero su nero ovviamente si vede molto poco ok quindi questo è il modo molto elegante per fare il rettangolo le win32 l'unica cosa che manca è questo rectpick che va in qualche modo devo definire dove è questo rettangolo lo rivediamo subito per un secondo vi spiego cosa sta avvenendo questo rettangolo ha quattro componenti left, top, right e bottom sono in pixel quindi lo mettiamo in alto a sinistra e lo facciamo grande 100 mettiamo 100 pixel è un'attenzione parlando delle cose viste ieri di pixel quindi quello che sto facendo adesso è ho creato un rect che è un classico struct c quindi lo sto allogando sullo stack il rettangolo lo sto popolando con i suoi vari campi e sto facendo un rettangolo che parte nell'origine 0,0 quindi in alto a sinistra ed è grande 100 cioè per cento ma potrebbe essere questa cosa ma è un 200% no, è un quadrato non è un rettangolo ok a questo punto fill rect prevede che gli si passi hdc che è il puntatore al device context il mio rettangolo per puntatore quindi devo passargli la struttura del mio rettangolo che è nella mia memoria e poi gli devo passare un pennello un pennello un brush un pennello con cui andare a colorare ok questo lo otteniamo con tre pennelli quelli standard poi vedremo come si crea un pennello custom di qualsiasi colore però potete immaginare che sarà una chiamata a funzione che si chiama create brush ovviamente ok vediamo vediamo se questa cosa funziona ah beh è in esecuzione ancora ok ok ed ecco il nostro meraviglioso se se l'orno dovrebbe venire una cosa del genere anche a voi questa è la nostra applicazione è di una bellezza disarmante più o meno e ma qui fin qui ci siete posso ancora un attimo vedere magari il codice forse noi mettessimo un wait prima di fare un event si si vedrebbe il resize ci si va il wait esatto questo si può anche fare volendo in realtà qui si vedrebbe poco perché facciamo il vmp adesso infatti quello che volevo farvi vedere adesso è che questa vmp viene chiamata una singola volta stranamente questa è una cosa un po' particolare perché appunto se non deve Windows chiama il meno possibile vmp chiaramente essendo così onerosa la chiamata per cui in questo momento anche se sto ridimensionando la finestra in realtà vmp non viene chiamata tant'è che la finizione è estremamente fluido fa molto poco la vmp chiaramente sarebbe strano se fosse diverso però in realtà quello che ho la wait potrebbe essere una buona idea la wait in c standard la sleep mi sa che non ce l'ho per cui la sleep c'è un po' lo set in la quinta sicuramente vediamo cosa posso fare c'è una sleep della quinta dove chiaramente ed è si chiama sleep perfetto possiamo chiamare questa roba qui facciamo questo tentativo allora vediamo cosa c'è in millisecondi ne facciamo 10 secondi adesso quello che mi aspetterei di vedere è che per 10 secondi non vedo la la in realtà è così allora non potete vederlo perché è sul lato schermo però la finestra si è proprio bloccata e quando ci passo sopra ah no si vede adesso si è sbloccato ecco come faccio per vederlo questo allora vi dimostro anche le coordinate perché visto che si apre sempre di là posso dire a windows di aprirlo nella schermata di qua proprio senza andare un po' tentativi quindi vediamo un po' se riusciamo a fare questa schifezza qui vediamo se riesce no siamo quasi però ah no perché lo schermo è a destra quindi non è a sinistra ma è tipo 2000 sto provando a aprire oh non è bello ma quindi 2000 va bene facciamo 1600 tentativi e qui facciamo 1600 quindi sto non sto più chiedendo a windows di darmi una posizione certo da da da da da sistema ma la sto imponendo tra l'altro una cosa buffa che sta venendo adesso è che viene creata con i dpi dello schermo principale vedete che è tutto tutto sovradimensionato appena la sposta si accorge che è sullo schermo meno definito e rimpiccisce tutto questo è la se ricordate è quella quel magheggio di scalatura dei dpi automatiche che fa il sistema per fondo nostro però se ne accorge solo quando la finestra viene spostata vedo dei non torna qualcosa no non farò tanto vediamo un attimo ok già qualcosa ordinare Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Mi l'ho sbagliato io a non seguire cosa spazio. Sì, o comunque si non ha associato il numero giusto al... Ok. La domanda. In questo caso, se si invertono il prezzo left e right, il 200 su left è il zero su right? L'ordine con cui si specifica è uguale, che tanto il rect è un... In questo caso, se siamo all'left, il 200 è right, il valore zero esplode. Esplode, non credo, ma forse non fa nulla. Vediamo un po'. Perché, in effetti, il problema di prima era che stava creando un rettangolo che era... Esatto, era grande zero pixel, quindi giustamente non si vedeva. Ah, ecco, no, lo riaggiusta come vuole. Quindi, anche se specifichiamo al contrario coordinate, quindi è... Se mettiamo praticamente fuori, si può fare, quindi possiamo fare meno 50 e right mettiamo a 150, quindi è comunque un rettangolo largo 200, ma ne vedremo solo 150 pizze. Questo funziona. Quindi, esattamente come le finestre di Windows possono vivere in coordinate negative, anche le GDI possono disegnare, però poi non si vede nulla. quando si può rispondere la finestra si può andare di là. Si può andare di là, in questo senso? Abbiamo sentato il rettangolo 50. Se espandiamo la finestra da questa parte... Vedrà? Se espandiamo la finestra, cioè se la tagliamo così? No. No, se la spandiamo dalla fronte. Così? Non si può andare di là, in questo senso. Così? No. Non si può andare di là, veramente. Cioè... Non ho capito... Così, ma la finestra. Ah, ok. Cioè, ingrandirla qui. Sì. Ok. Si può ingrandire a sinistra, chiaramente, però l'ordigine si sposta insieme alla finestra, quindi lo zero rimane sempre ancorato in alto a sinistra. Ok. A questo punto, una cosa che ci torna utile è... Cioè, a questo punto, se vogliamo disegnare qualcosa a schermo, a volte ci è molto utile di sapere quanto è grande la finestra stessa. Cioè, magari vogliamo fare un rettangolo che è grande la metà dello schermo e vogliamo farlo in maniera procedurale e quindi ci sarà sapere quanto è grande la finestra di riferimento. Questo sarà poi anche utile per scrivere il testo e metterlo più o meno centrato. E quindi faremo una cosa del genere. Allora, c'è una funzione che si chiama get client rec, perché vi ho detto anche prima il client nel gergo di Winters 2 è lo spazio della finestra. Tra l'altro, la zona che va al di fuori della finestra... Un esempio con la finestra qualsiasi. Allora, qui... Stato qui, vediamo questo piccolo... Questo orrore grafico. Allora, la parte... Qui il client della finestra è la parte nera della console, no? Quindi la parte nera è client rec. La parte sopra è la caption bar o la title bar, quindi la barra dei titoli, che di norma... Cioè di norma, non fa parte del client rec. Quindi la parte del titolo non è disegnabile, normalmente, perché è la parte della finestra che gestisce Windows per conto nostro. Quindi non bisogna occuparsene in alcun modo. Se non che qui, a parte che già lo vediamo, il terminale fa dei barbatrucchi e ci disegna sopra uguale. Quindi qui Windows fa la non-client area, quindi la caption bar, la disegna lui. E poi sopra ci viene disegnato il terminale, per cui già intuiamo che comunque le finestre, se vogliono, possono disegnare anche nella parte non-client. Infatti, per quasi ogni messaggio che vi arriva, c'è anche la controparte non-client. Quindi c'è WM Paint, ma c'è anche WM NC Paint, che è non-client paint, che se volete potete intercettare per disegnare al di fuori della zona salda, diciamo così. Per cui alcuni programmi, in particolare i videogiochi classicamente che magari non hanno bisogno del titolo, in alcuni casi, oppure delle applicazioni molto grafiche che hanno delle interfacce avveneristiche incompatibili con qualsiasi cosa, qualsiasi standard, possono ignorare le cose standard e fare le cose loro. Ah, Visual Studio Code fa esattamente questo. Il terminale è un esempio, ma anche Visual Studio Code in realtà fa la stessa cosa, perché, avrete fatto caso, non ha la barra del titolo classica di Windows, perché ha una barra tutta sua, con tutti i pulsanti che non ho mai usato, peraltro non so cosa facciano. Ha la barra di ricerca qui dentro, quindi tutte queste cose che vanno a nascondere il titolo classico, che significa che... questo chiaramente può essere fatto, ma è molto più complesso per chi fa l'applicazione, perché deve fare tutte le cose che fa la barra del titolo standard di Windows e farla a mano. Quindi il trascinamento, l'ingrandimento e quant'altro, sono tutte cose che vanno reimplementate, perché poi non le fa Windows per conto nostro. Se noi non tocchiamo quelle parti lì, molto del lavoro lo fa Windows. Ok, quindi GetClientRect ci dà un rettangolo grande, esattamente quanto l'area client. Quindi qui facciamo un secondo rett che chiameremo ClientRect, per esempio, con un grande fantasia, e GetClientRect ha due parametri. Uno è la finestra che ci interessa, PageWindow, e poi il puntatore al rect, quindi il puntatore al ClientRect. Dopo la chiamata a questa funzione, ClientRect viene popolato, preparato da Windows, in modo da contenere top, left, right e bottom giusti che coprono tutta la finestra, tutto l'interno della finestra, dovrei dire. Ok, per cui, a questo punto, se adesso ignoro il mio rettangolo, un attimo, e faccio FillRect e gli passo ClientRect direttamente, non so se vedete cosa sto facendo, quindi sto ignorando al momento questo podio qui, è solo per farvi vedere. Quindi sto creando un rect tra le variabili, lo sto popolando con le dimensioni vere della finestra, ClientRect, e poi lo passo direttamente a FillRect. Quindi mi aspetterei che a questo punto, in 32 vada a coprire tutto lo sfondo, in effetti è quello che accadrà. Ok, a questo punto lo sfondo è bianco, ma non è bianco perché è veramente bianco, cioè rattaccia lo sfondo nero, poi sopra ci va il FillRect bianco, e a questo punto l'illusione è che lo sfondo sia bianco, e quando ridimensiono, semplicemente il FillRect viene richiamato ogni volta, e ricolora di bianco. Possiamo? Scusi? Possiamo interagire il board, allora per il tempo non può, come no? Sì, esatto, infatti avrei fatto, però il board avrei fatto un taglio a metà, però il board è più carino, quindi facciamo una cosa del genere. Possiamo fare esattamente quello che diceva lei, per cui facciamo un board di 10 pixel, per cui facciamo left e clientRect.left più 10, quindi spostiamo i 10 pixel verso l'interno. Ah, ovviamente clientRect, left e top sarà sempre zero, perché l'AraClient inizia sempre, non nell'origine per forza, quindi quello lì in realtà potremmo mettere direttamente 10, però per essere veramente sicuri che tutto vada bene, facciamo così. mentre il bottom bisogna rientrare, i 10, e il right, right meno 10. Ok, per cui mi aspetto a questo punto di avere un bordino nero e l'interno non si vede nulla. Cosa ho sbagliato? Ah, passo il rettangolo sbagliato alla funzione di disegnare, quindi ci sta. Bisogna passare il rettangolo modificato, io passavo clientRect, quindi giustamente usava quello per disegnare. Ok, molto meglio. Ok, ho trascinato ed è successo questo. Adesso vediamo perché. Anzi, rivediamolo al replay. Vi lascio fare. Poi ditemi quando avete questa cosa qui, questo bordo da... che fa un po' fa un po' insegnamento aria purtroppo, ma... questa è? Ok, ci siamo? Perfetto. Adesso, se provate a ridimensionare la finestra, accadrà una cosa molto gradevole, ossia questo effetto... orribile. Perché? Allora, perché... dicevo prima che quando... cioè, Windows chiama Wampaint soltanto quando proprio è costretto a farlo, se quando rimensioniamo e allarghiamo in parte la finestra. Se rimpiccioliamo, in genere ignora. Infatti vedete che finché taglio, Windows ignora completamente la cosa e semplicemente fa vedere meno dello spazio che c'era prima. Appena allargo, è costretto a ridipingere, ma lo fa in maniera molto strana, no? Cioè, insomma, non... cioè, non è quello che mi aspetto. Perché? Perché... sempre per ottimizzare, Windows non pulisce il buffer, ok? Quindi il buffer che abbiamo, lo spazio su cui disegniamo, non viene ripulito, quindi rimane sempre l'immagine sotto stanco. Cioè, noi vogliamo ridisegnare sopra la stessa immagine e l'effetto che vediamo è questa cosa molto, molto brutta, che, insomma, non è quello che vogliamo ottenere, ovviamente. Per cui, allora, ci sono vari modi per ovviare questo problema. Il modo più... più... cioè, che si usa classica, generalmente, è dire a Windows, guarda, non mi interessa delle prestazioni, delle ottimizzazioni che risalgono negli anni 90, ti prego, ridisegna la mia finestra, cioè, ripulisci la finestra ogni volta che viene ridimensionata. E per dire questo, bisogna dirgli, nella classe della finestra, dargli uno stile che si chiama Age Redraw, che vado a vedere esattamente come è il nome. class style Age Redraw, quindi qui, dentro la window class, nello stile, questo l'avevo lasciato a zero inizialmente, per far vedere come è di base, ma qui, in genere, si specifica CS Age Redraw, cioè, ridisegna ogni volta che la finestra cambia orizzontalmente, e Orbuliano, CS V Redraw. Ok, quindi stiamo dicendo a Windows, guarda la finestra, questa classe di finestre va ridisegnata ogni volta, sia che ci sia una variazione orizzontale, sia che ci sia una variazione verticale. In questo caso, una volta attivato questo stile, Windows ridisegna forzatamente la nostra finestra ogni volta che viene ridisegnata. Perché non ve lo fate? Perché non l'avevo messo subito? Un po' per farvi vedere questo comportamento, un po' perché questo comportamento, adesso non ricompilo, per cui continuerà a non funzionare, questo comportamento molto brutto andava bene per il mondo di Windows 98 ancora, forse ancora XP, non ricordo totalmente, non so quali di questi voi avete utilizzato, ma se ricordate, nei tech in Windows, le finestre non si modificavano in maniera interattiva, cioè questo trascinamento qui in realtà non era interattivo. Quando cliccavo qui, quello che avveniva è che compariva la sagoma della finestra, in sovraimpressione, che poteva essere ridimensionata, ma la finestra sottostante non moriva modificata. Veniva modificata soltanto quando l'utente rilasciava questa specie di sovraimpressione della finestra, a questo punto la finestra veniva ridimensionata e si risegnava forzatamente. Questo di nuovo perché i computer dell'epoca non riuscivano a gestire i dimensionamenti interattivi in questa maniera. Adesso anche Spi faceva così, però mi sembra infatti sì. Per cui c'era il bordino in grigetto, in sovraimpressione, e poi quando si lasciava la finestra si ripresentava. E questo funzionava bene per quell'epoca lì. Adesso chiaramente le finestre devono risegnarsi in maniera interattiva mentre vengono ridimensionate e si usano questi stili qui per dire a Windows sono pronto a gestire questo fiume di messaggi. Questo sempre perché Windows è super retrocompatibile, per cui le vecchie applicazioni si comportano ancora così, quindi si aspettano un singolo VM Paint dopo il ridimensionamento e lo resistono in maniera autonoma. Le applicazioni moderne dopo XP invece sono pronte a avere tanti VM Paint che arrivano in sequenza. Ed è quello che adesso, appena ricompiliamo, otterremo. Quindi ricompilando, adesso la nostra applicazione si ridimensiona in maniera fluida e quello che avviene dietro le quinte è che appena si sposta un pixel della finestra Windows pulisce il buffer e ci invia un VM Paint e noi ci disegniamo sopra. Anche se la finestra è ancora in uno stato di ridimensionamento. Adesso mi sono perso pensato a una cosa perché stavamo parlando dello slip. Vediamo cosa succede se ritardiamo la slip della nostra... cioè ritardiamo la message pump della nostra applicazione. Allora, qui ho uno slip. 10 secondi forse è un pelo eccessivo, quindi facciamo due secondi che è un po' meno più utile. Allora, attenzione. La finestra si vede, è stata disegnata. Finché la sposto non c'è nessun problema. Appena la ridimensiono, mi aspetto... Vedete qui... Appa cavallo. Ogni VM Paint è ritardata a due secondi, quindi ci sta mettendo una vita e mezzo a ridimensionare. La prepara. Ok. Perché le Paint sono bloccanti per la finestra. Ok. Nota bene, è bloccante... cioè questo slip impatta soltanto la nostra finestra. Quindi è chiaro che finché l'utente ridimensiona non riesce a fare altre operazioni perché sta tenendo premuto il tasto. Però VM Paint è a tutti gli effetti per quanto riguarda le Win32 è una chiamata bloccante. Nel senso che a noi ci è arrivato un messaggio ridisegnati. Siamo entrati qui nella message pump. La message pump dice ok, è un VM Paint. Siamo entrati nel codice che ci disegna. Qui stiamo aspettando due secondi. Quindi chiaramente quella operazione di ridisegno richiede due secondi in più e quindi in quel lastro di tempo la nostra applicazione non riesce a gestire altri messaggi. Ok. Quindi rimane effettivamente bloccata. Tant'è che non reagisce a nessun altro comando. Qui per fare un'altra dimostrazione ancora più evidente. metto 20 secondi di attesa. Adesso termino qui un attimo. Perché vedrete che se qui metto un'attesa di 20 secondi che cosa accadrà? Allora accadrà questo. L'interfaccia, la finestra verrà mostrata a schermo perché ci verrà VM Create. Verrà disegnata a metà nel senso che fino alla sleep, fino alla riga 31 viene eseguito. Quindi quello che vedremo a schermo sarà una schermata come ci aspettiamo con il bordino e tutto quanto. A quel punto entra in gioco la sleep. che blocca tutto e l'applicazione non riuscirà a processare i messaggi in arrivo. Ok? Adesso vedete che non riesce neanche a cambiare il puntatore. Il puntatore è rimasto quello lì del bordo. Il puntatore è quello lì del dimensionamento perché non c'è nessuno che riesca a processare il messaggio dello spostamento del mouse. Cioè qui il cursore deve cambiare in un puntatore no? Il puntatore standard. Adesso tra 20 secondi ecco, ce l'ha fatta. Perché è arrivato il messaggio il mouse è in una posizione tal di tali quel messaggio cambia il puntatore del mouse perché il cursore standard nostro è è questo. Ok? Quindi hai il dc arrow però non c'è nessuno che riesca a gestire il messaggio e a impostare il puntatore. Ok? Quindi stessa cosa. Chiaramente la nostra applicazione è bloccata d'altro non posso farci assolutamente nulla. Adesso compare il non risponde tra l'altro se la finestra per un toc non risponde ai comandi e quindi Windows non riesce a mandare le messaggi perché questa non li elabora quindi la coda si riempie di messaggi quello che avviene normalmente è che Windows ci appioppa sopra una finestra finta con scritto non risponde. Questo l'avrete già visto con applicazioni che fanno fatica a reagire quindi questa finestra qui è una finestra finta non è la vostra finestra questa è un'illusione ottica è una finestra che sta sopra alla finestra bloccata la emula per virgolette ripete lo stesso contenuto che c'era nell'ultima VM Paint e ve la lascia spostare quantomeno. Vedete che ogni volta si blocca diventa i secondi e Windows per mettere di spostare la finestra vi nasconde la finestra bloccata ce ne mette una finta sopra che però reagisce ai messaggi quindi quantomeno può essere ridimensionato questo adesso la finestra è ancora bloccata perché non reagisce ai messaggi la faremo non la faremo va bene e quindi in questa fase qui possiamo ancora interagire possiamo almeno chiuderla ok adesso in realtà è Windows che gestisce la finestra dice il programma è bloccato non posso farci niente a questo punto aspettiamo e aspettare significa effettivamente aspettare che l'eseguibile main.exe si degni di processare i messaggi che si stanno impilando sulla quota dei messaggi cosa che al momento non sta facendo se facciamo termina il processo viene terminato e la finestra viene terminata quindi si c'è una serie che è importante però è molto interessante si il sistema non è vero come è vero come è vero come se fosse un errore si si non ha modo di distinguere tra una cosa e l'altra quindi per per quanto riguarda Windows ma questo perché adesso qui la slip potrebbe essere abbastanza evidente è un errore o comunque vogliamo che si blocchi però in realtà per quanto riguarda Windows la visione che ha Win32 c'è una finestra con una quota dei messaggi la quota dei messaggi sta esplodendo perché sto mandando i messaggi e nessuno li sta svuotando vuol dire che c'è un problema dentro probabilmente l'applicazione si è impantanata da qualche parte sta aspettando la lettura di un file sta facendo delle operazioni di scrittura molto lente o ha qualche altro bug di qualche natura per cui l'unica è o aspettare che si sblocchi e si svuoti la coda o terminarla perché non c'è soluzione da fuori non c'è modo di fare molto però questo punto rende più evidente come funziona questo mechanism è una specie di complesso questa orchestrazione tra Windows che vi dà questa quota dei messaggi in arrivo che voi dovete per forza smistare per essere dei così degli attori reattivi dentro il mondo grafico delle Win32 appena questa cosa viene a mancare chiaramente la vostra finestra diventa ingestibile e poi appunto si usa quel piccolo escamotage della finestra finta per darvi almeno la parvenza di riuscire a spostare la finestra quello che avviene quando c'è la finestra finta è che quella finestra lì gestisce i messaggi di spostamento quindi vi dovete spostarla quantomeno di nasconderla e così via ma tutti i messaggi vengono comunque anche impilati sulla vostra applicazione quindi quando la applicazione si riprenderà finalmente avrà un grosso numero di messaggi in arrivo che poi faranno sì che diciamo così lo storico viene rielaborato a posteriori quindi lo spostamento viene elaborato in ritardo però viene comunque elaborato ok su questo adesso la sditto tolta che non era molto utile e ci mettiamo proviamo a fare la cosa la prima cosa veramente veramente grafica diciamo così così proviamo a scrivere sul nostro sul nostro schermo e lo facciamo con la draw text quindi abbiamo visto che con fillerex disegniamo un rettangolo con draw text disegniamo del test con funzione draw text allora draw text prende sempre hdc come parametro quindi dove vado a disegnare a scrivere il testo quindi il test questa è una costante di testo quindi va sempre dentro la magica direttiva text e qui ci mettiamo famondo famondo win32 atpdi per essere precisi poi ci va la lunghezza del testo se ricordo bene la lunghezza del testo in termini di caratteri se ricordo bene esatto quindi hdc il testo quanti caratteri stampare di questo testo questo possiamo specificarlo possiamo mettere meno uno per dire al sistema stampa finché non incontri un terminatore a zero e poi dove scrivere il testo quindi dove qual è il rettangolo che stiamo allocando per quello spazio per quel testo qui come poi lavorando col testo il testo è forse la primitiva che è al tempo stesso più utile più fondamentale per fare le interfacce utili ma è la più complicata che si possa immaginare perché il mondo dei font è complicatissimo come presentare i font a schermo è una cosa terrificante da pensarci e quindi le API che abbiamo a disposizione sono tantissime complicate e quant'altro e spesso hanno un'idea molto parziale di quello che sta avvenendo dietro le quinte per cui adesso facciamo finta di nulla e stampiamo su tutto il rettangolo quindi stampiamo sul client direct direttamente cioè mettiamo il testo dentro il client da qualche parte e quindi uso client direct come rettangolo perché se no se volessi stampare il testo veramente tutte le procedure sarebbero così cioè devo prima andare ad allogare il testo misurare quanto è grande il testo con il dato font su quello schermo quindi vedere quanti pixel occupa e a quel punto posso dire dove mettere il testo quindi le procedure al minimo è quello se poi il testo non entra perché il testo magari è troppo lungo rispetto alla finestra a quel punto devo rimpaginare rinformattare il testo mettendoci a capo e questa cosa devo farlo completamente a mano ovviamente e metterci a capo nel posto giusto rimisurare il testo e ripiazzarlo nel posto giusto quindi è molto complicato in genere questa cosa non si fa mai a mano si diventa scemi e quindi ci sono delle finestre apposta di windows che fanno questo lavoraccio per noi adesso facciamo la cosa più semplice possibile ossia stampiamo tutto lo schermo e tutta l'area client e l'ultimo parametro è il formato qui ci sono una serie di di valori che possiamo passare alcuni di questi sono per allineare il testo all'interno del rec di riferimento quindi l'idea è se occupiamo tutto lo spazio della nostra disposizione mettiamo il testo in mezzo quindi lo mettiamo con DT no DT center che è la centratura orizzontale attenzione il DT center qui magari vado a capo per maggiore chiarezza DT center poi devo fonderlo con DT V center che è la centratura verticale combinando queste due cose il testo sarà al centro esatto del rettangolo cos'altro c'è anche single line se vogliamo mettiamo anche questo non cambia molto single line gli dice mette tutto su una singola riga e infisca delle dimensioni quant'altro perché il nostro aiuto il nostro feed o draw rect in realtà può anche aiutarci in alcuni casi provando ad andare a capo da solo però in genere non è una grande idea oppure se lo spazio è poco può anche usare l'ellissi mettere i puntini in fondo al testo se il testo non entra nella anzi questo magari mettiamolo pure mettiamo c'è l'ipsis con la sensa word mi sembra sì dt end esatto mettiamolo questo dt end l'ipsis questo è un valore che indica a win32 che se il testo non entra nello spazio allocato e se non entra su una singola riga deve metterci punti e vedremo che in alcuni casi dovrebbe funzionare da sé vediamo cosa accade ok questo è nella sua primitività quello che ci aspettavamo quando ridimensioniamo client-rex si riadatta giusto perché abbiamo sempre la dimensione esatta dello schermo per cui il nostro testo è sempre perfettamente centrato se stringiamo molto il testo è troppo corto il testo a mondo gdi ok questo è molto lungo ok vedete che qui gdi per conto nostro mette i puntini quindi sta sta tagliando c'è una piccola bruttura nel senso che il testo va oltre il nostro bordo nero perché mi sono dimenticato di metterci il cioè abbiamo usato il client-rex questo che è tutta la schermata chiaramente e il bordino non è parte di questo spazio per cui in realtà se vogliamo evitare questo errore di sovrapposizione dobbiamo passare il mio rettangolo che come rettangolo su cui disegnare questo dovrebbe essere più gradevole quindi adesso il testo è dentro il rettangolino e questo effetto brutto non c'è allora due cose sulla bellezza la bruttura di questo testo allora questa font è molto brutta ovviamente questo è il font default si chiama system font degli windows 1.0 se vi ricordate gli screenshot che ho fatto vedere qualche lezione fa avrete notato che l'unico font di sistema di windows 1.0 era questa cosa qui e per compatibilità il font default delle windows 1.0 è rimasto questo quindi questo font qui se lo porta dietro windows da ormai 40 anni e non c'è modo di rischio darlo perché di default le applicazioni che usano che non specificano un font diverso per scrivere usano questo quindi questo è e questo ci piace si può cambiare ovviamente ci mancherebbe altro e altra cosa il testo vediamo si apprezza molto qui adesso lo vediamo questo è l'effetto di magnificazione che vi dicevo prima quindi adesso ho creato una finestra l'ho spostato sullo schermo con bassi dpi quindi il proiettore ma la finestra è stata creata senza essere concia dei ppi per cui windows adesso non ha ancora attivato l'adattamento scusate no in realtà l'ha attivata visto che la finestra è stata creata per questo schermo per cui la finestra è stata creata per un mondo a 96 ppi questo schermo ha circa 200 ppi per quello che vedete qui è che l'area client quindi l'area che stiamo disegnando effettivamente è stata allargata è stata zoomata semplicemente in maniera molto primitiva se guardate adesso si vede male il proiettore però se date un'occhiata ai bordi del testo il testo è un po' sfocato perché avviene quella cosa lo zoom senza grande attenzione che rende leggibile il testo su questo schermo qui su questo schermo qui è troppo grande cioè va oltre i 10 punti di default del testo per cui appena lo trascino Windows si accorge che lo schermo in realtà non è quello a 200 ppi ma è lo schermo a 96 ppi immagino il proiettore e quindi ci ripensa e lo riadatta a questo punto lo zoom lo perde e questa è la dimensione nativa di questo schermo qui e il testo è molto più nitido sul proiettore appunto non si vede molto bene ma se vedete sullo schermo il testo è precisissimo e non smussato esattamente come era il testo nel Windows 1 all'epoca ok e se ripasso delagramente si riadatta vedete che come come torna grande questo è un passaggio questo questo ingrandimento questo zoom automatico nel passaggio dello schermo non ci costa nulla cioè automatico il sistema e non ci costa neanche una one paint quindi non arriva nessuna one paint perché la superficie è già stata dipinta non va a ridipinta l'unico modo per ridipingere una finestra è cambiare dimensioni e a volte anche minimizzare e rimettere visibile la finestra causa un ridisegno non sempre ma a volte capita perché Windows per ottimizzare quando una finestra è minimizzata cioè abbassata alla taskbar può scartare il buffer di disegno quindi lo può deallocare a quel punto quando torna visibile la finestra deve ridisegnarsi un attimo di base con queste operazioni ok facciamo un'ultima cosa poi vi direi che possiamo interrompere perché abbiamo visto abbastanza poi continuiamo di là facciamo un ultimo elemento un'ultima prova di interazione rendiamo cliccabile il nostro test come la nostra finestra e processiamo un messaggio che è legato al mondo del mouse ce ne sono diversi vediamo vedere uno è WM left button up ok questo è il messaggio che ci arriva quando l'utente clicca in realtà rilascia perché è button up rilascia il pulsante a sinistra il primario diciamo così del mouse sopra alla client area della nostra finestra perché questo vale per tutta la finestra quindi in qualsiasi posizione io clicchi arriva il messaggio alla finestra di riferimento e se voglio riconoscere in qualche modo dove è stato cliccato posso farlo chiaramente perché il messaggio contiene alcuni dati aggiuntivi tra cui la coordinata in cui è stato cliccato il mouse vediamo un attimo se riusciamo a fare qualcosa di carino allora ecco questa è la specifica del messaggio il messaggio è le button up appunto ovviamente da questo ne consiglio che c'è r button up per il click destro e poi c'è anche button down che è il momento in cui si pigia il mouse ma non si è ancora rilasciato per convenzione il click avviene quando si rilascia il mouse di solito quindi il button up è quello che si processa per elaborare il il comando e quando arriva un messaggio di questo genere lparam che è uno dei nostri due parametri di riferimento contiene le coordinate le contiene come spesso capita nelle Win32 i byte erano molto pochi all'epoca per cui è tutto compattato dentro questi interi in maniera un pochino orribile per cui lparam in realtà è un intero lungo è un long di cui la parola la parola bassa è la coordinata x e la parola alta è la coordinata y questo per complicarci la vita ulteriormente per cui qui dentro qui dentro WML bottom up facciamo un blocco per essere puliti lparam contiene le coordinate facciamo una copia lparam non serve a niente però per chiarire il fatto che lparam che è il parametro che ci arriva ad ogni messaggio ogni messaggio ha sempre wparam quindi wide parameter e long parameter che sono uguali come grandezza adesso e possono essere hanno valori che dipendono dal tipo di messaggio chiaramente quindi in base al tipo di messaggio sappiamo come andare a elaborarli in questo caso lparam contiene le coordinate ma bisogna estrarle in qualche modo e lo facciamo copiando questo questo codice qui perché ci sono degli sempre delle delle delle funzioncine per processore che non fanno altro che estrapolare l'intero giusto da questo interone lungo ok quindi questo se andiamo a vederlo vediamo se per puro caso riusciamo a no va bene va bene questo comunque è una maschera di byte spostamenti vari nulla di praticamente esotico ma fanno le operazioni sui byte per tirar fuori x e y dal nostro parametro che senso si si si si hai ragione l'ho copiato brutalmente ma si si non avrebbe senso però è uguale è uguale è la stessa cosa l'ho solo copiato per rendere evidente che poi in effetti diciamo che era solo per chiarire il fatto che guardate sono nascoste dentro l'param però li stiamo tirando fuori da lì ok quindi x post tra l'altro questi non sono neanche dichiarati quindi questi sono degli interi direi ok questa è la posizione in pixel del mouse dove è stato cliccato tra l'altro il mouse ha tantissimi eventi in realtà tra cui mouse move e così via che vengono inviati ad ogni spostamento del mouse quindi in realtà se noi volessimo tracciare dove è il mouse possiamo farlo con questi messaggi questo è soprattutto il click ok adesso a questo punto cosa facciamo allora possiamo chiaramente fare un message box facciamo una cosa più banale che si possa fare facciamo un message box che scrive qualcosa quando clicchiamo quindi il message box ricordate che prende quel parametro e la finestra di riferimento di cui è figlia questo finora abbiamo sempre usato null perché non avevamo nessuna finestra ancora prima adesso il message box c'è il dialogo che spunta deve essere figlio della finestra stessa per a livello di di parentela per cui usiamo H window e ci scriviamo hai cliccato qualcosa di veramente furbo e come titolo clic sinistro e cosa ci manca manca un mb ok che è il message box classico che ci dà il pulsante singolo adesso qui non metto x e y dentro il testo perché in c aggiungi soltanto complessità senza darci dei veri benefici non gli è preso per niente secondo me queste punzioni qui si deve essere inventate questa punzione qui è più recente di no non so dà lo stesso errore anche a voi però non mi trova get x param come funzione vediamo se riesco a includerla dentro windows x che dovrebbe essere una serie di funzioni ecco quindi è dentro una un header aggiuntivo che che va incluso questo perché appunto windows è un è un'impalcatura di cose aggiunte col tempo quindi windows x sono una serie di estensioni a windows punto h che fa altre cose diverse quindi bisogna portarci a dietro apposta ok a questo punto la compilazione funziona e get x param e get y l param funziona ok compilo e seguo adesso se clicco compare il message box niente di praticamente emozionante ah un'altra cosa che adesso notiamo adesso magari questo veramente poi trompiamo andiamo di là quando il message box viene mostrato quindi qui siamo dentro la message pump proprio siamo dentro la mia procedura abbiamo appena elaborato l button up qui il click del mouse message box se ricordate è bloccante cioè il message box questo qui non ritorna finché l'utente non clicca su ok quindi è una chiamata che blocca l'esecuzione del nostro thread ed è bloccante perché l'idea è che noi adesso qui con questo message box non è rilevante perché il pulsante è sotto 1 però message box può avere più pulsanti può avere un pulsante due pulsanti tre pulsanti e il valore di ritorno di message box è pari al pulsante cliccato quindi se io qui avessi che ne so riprova a nulla no? classico message box in cui c'è un errore oppure che va a vuoto devo riprovare per ricevere il cliccato dell'utente io posso qui fare if message box chiamare message box quando ritorna posso verificare che il valore di ritorno sia uguale a ok che sia uguale a riprova che sia uguale a nulla così via e poi fare altre cose in base a quello che l'utente ha cliccato quindi message box è una chiamata bloccante il mio thread si blocca tant'è che adesso la mia message pump è tutta bloccata cioè il thread dei messaggi è tutto congelato perché la procedura è ferma qui dentro infatti se voi interagite con la finestra sottostante non ce la fate vedete qui c'è questo classico no? questo classico motivetto di Windows in cui c'è il dialogo che ha coperto che ha preso il controllo dell'applicazione e la sua interezza e l'applicazione dietro non è più interattiva non posso spostare non posso fare nulla finché non tolgo dai piedi questo message box questo è così storicamente perché message box è bloccante spesso lo si chiama la message procedure e quindi il thread in questo momento non può elaborare i messaggi che arrivano per cui è come se fosse è come prima quando avevamo fatto la sleep e la finestra è congelata perché non può elaborare messaggi qui è congelata Windows lo sa perché è bloccata dentro message box quindi è previsto che non possa elaborare messaggi tant'è che non li riceve la finestra è disattivata finché non clicco su ok appena fatto questo qui riparte il thread e riparte la message box ok e quindi riparte il thread chiaramente questo va bene andava bene per le Win16 nel vecchio nel vecchio modello delle applicazioni che sono poco interattive diciamo così che comunque hanno questo comportamento bloccante nel mondo moderno raramente vogliamo veramente che un'applicazione si blocchi interamente quando c'è un message box davanti per cui vedrete che tutti i sistemi moderni di programmazione aprire un dialogo non è più bloccante in genere come operazione quindi anche su Flutter quando apriamo un dialogo il dialogo vive a parte e sotto il resto della finestra continua a vivere e continua a fare delle operazioni questo per darvi l'idea che appunto in alcuni casi è necessario avere degli elementi bloccanti dentro la message pump che come ho detto prima la message pump deve essere molto rapida deve gestire messaggi molto rapidamente perché appena si blocca lievemente chiaramente tutta l'applicazione sembra non rispondere ok direi che facciamo la pausa andiamo di là e poi rendiamo un pochino più interessante la nostra applicazione andando a fare delle operazioni un pochino più cioè graficamente più interessanti e vediamo fino a dove diciamo spingerci con le win tentature è a