Allora, buongiorno, ripetiamo il discorso di ieri sulle piattaforme applicative, le piattaforme di applicazioni, e quindi questo ci darà l'occasione di parlare di varie piattaforme che citiamo giusto così per conoscenza, per nozionismo. Quella più interessante per voi, auspicabilmente, sarà Windows, perché poi, come vi accennavo prima, da venerdì prossimo cominceremo subito a fare laboratorio con le Win32, per cui intanto avete un'idea di quello che vi aspetta e poi faremo pratica con questa piattaforma. In particolare, appunto, vi dicevo, quello che faremo come laboratorio iniziale sarà una cosa molto primitiva, per cui vedete, qui vi parlerò un po' di primitiva, in senso molto educato, e vi parlerò della storia di Windows un pochino, e quindi vedrete da dove vengono le Win32, quindi le interfacce di programmazione per applicazioni Windows, che appunto vengono dagli anni 90, proprio che hanno un bel bagaglio di, prima in realtà, e un bel bagaglio di storia, e quindi capirete anche perché sono strumenti così obsoleti per certi versi. Ok, diciamo ieri appunto che quando programmiamo un'applicazione di qualsiasi natura essa sia, alla fine ragioniamo in questi termini, quindi abbiamo vari componenti e strati software con cui ragioniamo, io ho parlato ieri, poi adesso ho aggiunto delle animazioni entusiasmanti per rendere il video più avvincente, però lavoriamo su tre strati di astrazione progressivi, quindi il sistema operativo, che è la base fondamentale, il runtime, che è il sostegno, diciamo così, del linguaggio e non solo, eventualmente, su cui ci appoggiamo, e eventuali framework che possiamo utilizzare oppure no, quindi questo è completamente opzionale, il runtime c'è sempre per quanto scarno, adesso sì, a meno che non si programmi in assembly o in linguaggio proprio binario, col martello e lo scalpello, però diciamo che non si fa più, per ovvie ragioni, per cui il runtime in genere c'è sempre per quanto scarno esso sia, e poi c'è il separativo, chiaramente, che poi ci darà accesso in maniera astratta alle capacità della macchina. Ok, questo abbiamo visto la volta scorsa qual era lo scenario, quindi in uno scenario abbiamo un'applicazione che contiene tutto il runtime e eventuali framework, l'altro scenario è che il runtime invece carica l'applicazione e la fa eseguire, ma non cambia radicalmente il succo della questione, però cambia un po' lo stile con cui l'applicazione viene confezionata. Ok, siamo arrivati qui. Allora, in tutti questi strati che si parlano, di cui ho parlato prima, questi sono tutti strati software eterogeni, chiaramente, per cui quando proghiamo un'applicazione, questa sarà scritta in un dato modo, si appoggerà a un runtime che dipende dal linguaggio di programmazione e può fare uso di un framework che può essere scritto in qualsiasi altro modo possibile, immaginabile, e poi tutto questo blocco qui, il blocco applicativo del nostro programma, deve interagire col sistema operativo, quindi deve fare delle chiamate di sistema, deve fare delle interazioni, deve evocare i poteri del sistema operativo, lo fa facendo queste chiamate di sistema, e chiaramente il sistema operativo può essere scritto in un linguaggio completamente diverso da quello dell'applicazione, quindi classicamente i semperativi sono scritti con linguaggi in genere di basso livello, in genere in C o poco sopra, non è più tanto vero, però in genere è così. Ultimamente come linguaggio di programmazione così molto ambito per i semperativi sta crescendo in popolarità anche Rust, che è un linguaggio già più evoluto del C, chiaramente, però comunque adatto a scrivere componenti di basso livello, comunque sì, alla fine dei conti, questo è un binario che può essere eseguito o può essere richiamato da sopra, e l'importante è che questi componenti si riescano a parlare, quindi che riescano in qualche modo a comunicare, a inviarsi delle chiamate, a rispondere, passarsi dei dati e così via. Come viene questa cosa? Tramite dell'interfaccia ovviamente, quindi se avete programmato, avete già avuto a che fare con questi due concetti, seppure magari in maniera inconsapevole. Ok, per cui ci siete passati per forza avendo programmato almeno in C, mettiamo, però magari non siete stati necessariamente consapevoli al 100%. Le interfacce di programmazione si dividono in due grandi categorie, le ABI e le API. Le API forse sono quelle più comuni, cioè il termine più noto in genere, perché è quello che è più visibile al programmatore, perché è quello di cui si è più consapevole in automatico quando bisogna parlare con un altro componente software, quindi questo in genere è un termine che si conosce. Le ABI invece è un termine un pochino più ignoto, perché contengono una serie di informazioni che in realtà non sono molto interessanti per il programmatore, sono interessanti in realtà per chi si prende la briga del far parlare i componenti, per cui in sostanza chi crea il compilatore o chi crea tutta la toolchain di compilazione che voi usate per creare il vostro programma. Quindi immaginate di fare un programma in C, sempre l'esempio al C, un po' perché dopo il scontato che lo sabbiate, un po' perché venerdì prossimo avrete il piacere di programmare in C di nuovo, eventualmente, o il dispiacere. E quindi se l'avrete in C, avrete un compilatore che compila il vostro bellissimo programma in C, che può essere GGC o un suo parente alla lontana, e questo compilatore sa qual è il linguaggio della macchina su cui il vostro programma dovrà girare, quindi conosce la ABI del vostro sistema operativo e dell'hardware e così via, e quindi farei in modo che le vostre funzioni, la struttura dei dati e così via, siano compatibili con l'interfaccia binaria del sistema su cui gira l'applicazione. Questo è il motivo per cui, se prendete un programma che scritto in C è perfettamente portabile, lo compilate per Windows, non so, per una macchina X86 come questa, l'eseguibile non potete prenderlo e spostarlo su un macOS, su un ARM, perché ovviamente non parlano la stessa lingua in termini binari, e quindi l'eseguibile non può essere lanciato. Questa è una considerazione estremamente banale, però per farla in maniera compiuta, il motivo di questo è intanto perché le istruzioni sono diverse e perché non parlano la stessa lingua, quindi non possono comunicare. Quindi cosa contiene la ABI? Come detto appunto, per nostra fortuna, è una cosa di cui bisogna, cioè si può essere consapevoli, ma non bisogna studiarsela per poter usare, programmare una macchina, quindi per fortuna questo adesso lo scopriamo e poi la dimentichiamo un secondo dopo. Però cosa contiene? Contiene la cosiddetta calling convention, quindi tutte le convenzioni e le istruzioni, la guida, diciamo così, che serve per chiamare delle funzioni in un altro pezzo di software. Quindi come si fa a richiamare una funzione da qualche altra parte nel software, cioè nell'universo del software che compone la vostra macchina. Quindi, in sostanza, se gli argomenti di una funzione vengono caricate sullo stack, in che ordine, come vengono codificati gli interi, i numeri, le stringhe e così via, e in che modo poi saltiamo nel codice di destinazione in modo tale che poi questo possa essere eseguito e come il codice eseguito ci ritorna i dati, in sostanza. Quindi come funziona questo meccanismo primitivissimo che alla fine dei conti è il salto logico, quello che dice se dalle vostre funzioni di elaboratori elettronici, alla fine dei conti, quello che rende un elaboratore capace di eseguire gli oritmi è anche la capacità di saltare, quindi di saltare da una parte all'altra del suo codice. Il salto poi, quando parliamo di linguaggio e programmazione, diventa la funzione, la chiamata a funzione, e la chiamata a funzione deve essere in qualche modo specificata in maniera codificata. E la ABI lo fa. Quindi l'ABI, per esempio, la ABI dei programmi in C prevede che gli argomenti di una funzione vengono messi in ordine inverso sullo stack, in sostanza, quindi se la vostra funzione ha tre interi come parametri e si chiamano ABC, vengono messi in ordine CBA, e poi chi viene chiamato dall'altro lato sa che sullo stack ci saranno ABC, ma nell'ordine inverso, e quindi li leggerà in quel modo, dallo stack, ok? Visto che le due cose sono, quindi il chiamante e il chiamato, si capiscono, cioè sono d'accordo su questo modo di chiamarsi, allora possono parlarsi. Se non c'è accordo, ovviamente, poi i dati non vengono passati correttamente e le cose esplodono in generale, ok? Stessa cosa vale per il dato di ritorno, quindi nell'ABI in C sappiamo che il dato di ritorno viene messo in un registro, in particolare, quel registro può essere letto dal chiamante, perché lì ci sarà il dato che la funzione chiamata ha ritorno, ok? Quindi per farlo là. Poi se si può andare più o meno in dettaglio, molti linguaggi hanno convenzioni di chiamata diverse e in realtà anche Windows internamente ha più convenzioni di chiamata diversa per funzioni diverse, quindi per complicare le cose. Però l'importante è sapere che cosa si sta facendo, o meglio, l'importante è che il compilatore sappia cosa sta facendo, voi, noi, per la nostra fortuna, ci interessa poco. Altra cosa è come rappresentare i tipi, questo è fondamentale, quindi sapere che un int in C vale 32 bit, o un long vale 64 bit, un double sono 8 byte, e così, tutte queste cose qui, che sono convenzioni, bisogna saperle, perché chiaramente se non c'è, no, cioè se non c'è coerenza tra la grandezza dei dati, anche lì i dati non possono essere letti in maniera efficiente. e poi il name mangling è un'altra cosa che mi interessa in maniera relativa, però è come vengono rappresentati i nomi degli oggetti che possono essere chiamati dinamicamente all'esterno, ossia come viene manipolata, come vengono distorti, diciamo così, i nomi delle funzioni, così via che noi definiamo nel nostro linguaggio C, in modo tale che da fuori possano essere chiamati. Per farvela breve, questo magari non vedremo, lo vedremo in pratica, perché non c'è tempo, né è particolarmente utile, però è la convenzione verso la quale una funzione che si chiama, non so, calcola fattoriale, per dire, non so, qualcosa del genere, che può essere nel vostro codice, viene il numero della funzione stesso, che nel vostro codice viene convertito in qualche modo, viene mangled, viene distorto in qualche modo, e poi viene esposto, viene esportato ai chiamanti in un modo che è standardizzato, ok? Per cui chi da fuori vuole fare uso della vostra funzione, calcola fattoriale, sa che, come andare a cercarla in tutto il listato e richiamarla dinamicamente, se è così necessario. Questo è fondamentale, perché quando, faccio un esempio anche qui, molto astratto, se, non so, faccio un esempio che però abbia un senso, magari, ok, immaginiamo di lavorare sempre con le Win32, quindi lavoriamo un programma che lavora su Windows, e andiamo a chiamare una funzione che si chiama create window, la funzione che poi userete venerdì prossimo per creare una finestra, visibile. Questa funzione, questa funzione si chiama create window con la C maiuscola e la W maiuscola senza spazi, senza underscore e così via. Questo nome di funzione deve essere codificato in qualche modo nella grande tabella dei nomi delle DLL di Windows, perché da fuori il vostro programma deve poter capire dove si trova, trovare la posizione in memoria dove inizia la funzione e poterci saltare dentro in sostanza, ok, quindi il modo con cui questi nomi vengono codificati è sempre parte della ABI, ok, perché in assenza di questo non riusciamo a trovare la funzione dov'è, o meglio, il codice della funzione che ci interessa e andarci dentro, in virgolette, ok, quindi tutto quello che è legato a far comunicare i pezzi di software è specificato nell'ABI. Vedete un esempio? Un esempio di name handling sarebbe tipo la conversione di etiquette in assembly, sì, tipo, sì, esatto, è la stessa concetto, chiaramente poi in assembly stiamo lavorando su un livello molto più basso, ovviamente, però è la stessa idea, esatto, quindi una convenzione che ci permette di specificare dove saltare, dove si trovano i vari pezzi che ci interessano, esatto. Ok, l'API, questo ve l'ho detto, potete dimenticarlo subito dopo, l'API invece è quello che ci interessa perché l'API è la specifica per il programmatore, quindi per noi che dobbiamo in qualche modo interfacciarci con il codice e quindi è l'interfaccia che interessa a noi che scriviamo, quindi in qualche modo è, diciamo così, si, come si può dire, si manifesta nella maggior parte dei casi attraverso la documentazione del sistema che andiamo a utilizzare, quindi il sistema, appunto, le WIN32 per esempio hanno una vastissima documentazione che trovate online o sui libri e così via che vi descrive esattamente che cosa fanno i vari componenti del software, quindi del pacchetto dell'API WIN32. Quindi vi dicono per esempio, ok, c'è la funzione create window, vi spiegano cosa fa, intanto, perché si capisce dal nome ma non è così banale, vi spiegano, vi spiega quali sono i parametri previsti, chiaramente i parametri previsti sono noti anche all'API, cioè c'è una sovrapposizione di interessi, quindi l'API sa come codificare i parametri e così via, ma l'API vi spiega che cosa fanno i singoli parametri, quindi al codice non interessa la semantica, diciamo così, cioè non interessa che se passato in intero nella posizione tal dettagli a create window ha un effetto X, questo ve lo spiega l'API perché l'API si interessa delle cose che accadono sul lato, diciamo così, lato programmatore, quindi lato gli effetti che vogliamo ottenere, quindi sapere esattamente a cosa corrispondono i vari valori, i vari parametri, a cosa risponde il tipo di ritorno, quali sono le interazioni tra varie API diverse, varie funzioni diverse e così via, sono tutte parte dell'API, ok? Quindi è quello che noi studieremo brevemente, lavorando poi con le qui in 32 perché ci servirà a capire come si fanno le finestre, come si crea una finestra che è un pulsante, come si reagisce all'architecto di un pulsante, tutte queste cose qui sono descritte dall'API, ok? Quindi, e finché il software è coerente con l'API noi sappiamo come interagirci e riusciamo a fare dei programmi che poi interviscano in maniera utile e funzionale con il software sottostante. Quindi l'API dice l'ordine, l'API cosa fanno? E in sostanza sì, cioè l'API dice come passare i dati proprio a livello binario a una funzione che è codificata da qualche parte nel sistema operativo, nel runtime, nel framework, dove volete. l'API dice esattamente il comportamento, quindi la semantica, quello che avviene se io chiamo la funzione tal dettaglio, quindi anche i comportamenti in caso di errore, i comportamenti se tutto va bene, cosa che devo aspettarmi se chiamo in sequenza una funzione dopo l'altra e così via. Tutti i comportamenti sono codificati dall'API e se finché sono coerenti con quello che accade veramente mi permettono come programmatore di usare una piattaforma in maniera utile ed efficace. L'API interessa più che altro il compilatore, ok? E tutta la tool chain di compilazione, come poi all'atto pratico bisogna utilizzare i componenti della API. Ok. Spero che sia stato comprensibile. Comunque, come detto appunto, l'API ci interessa sapere cos'è giusto perché sappiamo che il compilatore fa delle magie per conto nostro e poi in realtà non ci interessa più. Per nostra fortuna. Ok. Abbiamo qualche esempio di API di di runtime in realtà per vedere qual è il flusso di una chiamata a funzione che avete sicuramente già utilizzato lavorando in C e vediamo come interagisce con i vari sottocomponenti. Quindi abbiamo visto che diciamo così per un'applicazione per un programma scritto in C in genere gli strati software sono questi. Quindi la nostra applicazione è questa cosa grigia con questi flussi di esecuzione blu bellissimi che vedete disegnati. poi c'è il runtime C che ci supporta quindi è tutto quello che contiene il runtime appunto quindi il sistema di esecuzione e la piccola libreria standard di C quindi printf scanf queste cose qui e poi sotto questo chiaramente c'è il sistema operativo che fa tutto il resto. Ok. Quindi questo è il nostro programma più primitivo come la Hello World che vi avevo citato la volta scorsa è fatta in questa maniera quando è in esecuzione. Quindi cosa avviene? quando la nostra quando noi facciamo fopen per esempio o fprintf o qualsiasi altra funzione di libreria nel nostro programma che cosa avviene? Che noi andiamo a chiamare una funzione che non è definita nel nostro codice finché noi chiamiamo funzioni qui dentro funzioni definite da noi i salti logici sono sempre interni al nostro blocco di software quindi non c'è nessun problema i problemi sono colpa nostra semmai esercizioni problemi quando andiamo a interagire con qualcosa che non è nostro facciamo un salto fuori dal nostro software quindi si salta nel runtime C in particolare se ragioniamo con la fopen la fopen ci permette di aprire dei file come sicuramente saprete quindi apre un file descriptor rivolto verso un file o un altro oggetto che somiglia a un file ok e ci ritorna un intero cioè un oggetto c'è un oggetto alla fine dei conti è un intero perché C non ha altri altri strumenti per identificarlo però è un oggetto file un file descriptor appunto questa fopen qui è implementata da qualche parte nel runtime C non ci interessa com'è fatta in realtà però noi sappiamo che poi internamente questo il runtime C da solo non può fare molto nel senso che il runtime è una serie di strutture di software che ci aiuta però non è che ha il controllo del seno operativo chiaramente è semplicemente del codice di sostegno ausiliario per cui a un certo punto il runtime sappiamo che dovrà parlare con il seno operativo chiaramente quindi dovrà andare a chiedere accesso al file a chi ha fatto il seno operativo e questo chiaramente poi dipende da come è fatto il seno operativo quindi può essere Linux può essere Mac OS può essere Windows e come questo pezzo qui è implementato non lo sappiamo ma potremmo anche andare a vedere lo faremo tra un secondo però questo cambierà in base al sistema che stiamo utilizzando quindi ovviamente cambiando il seno operativo cambierà il runtime in genere perché abbiamo cambiato anche tutta la toolchain per creare il nostro programma e quindi questo codice qui sarà radicalmente diverso potenzialmente quello che avviene in uno scenario Unix Linux microS derivati è che la fopen farà delle piccole operazioni di contorno e poi andrà a chiamare la open che è la funzione di più basso livello che è esposta dal seno operativo che è la funzione per aprire effettivamente i file c'è una sovrapposizione dove chiaramente il runtime c è stato nato in un ambiente con questa forma quindi la libreria standard c riprende i concetti del seno operativo e semplicemente ve li espone in maniera più astratta quindi fa molto poco lavoro ed è per questo che runtime c è molto piccolo perché fa molto poco per schermarvi da quello che è il seno operativo però fa quel poco che serve e giusto per farvi vedere questo è il codice della fopen di android chiaramente questo risale a non so che versione però non penso che sarà cambiata radicalmente questa è la fopen della libreria standard c che quindi è parte del runtime c che viene utilizzato da android quindi se voi programmate in android e alla fine dei conti provate ad aprire un file cioè in un'applicazione android quello che avviene è che andrete ad un certo punto a chiamare questa fopen qui che ha questa dichiarazione che riconoscerete perché è quella standard della libreria c di default quindi nome del file tipo di apertura qui vedete che avvengono delle cose non particolarmente leggibili però in realtà niente di particolarmente sofisticato che controlla i flag che siano più o meno corretti cos'altro fa? non molto comunque fa delle conversioni dei flag verifica delle cose e poi alla fine chiama open quindi cioè fa molto poco in realtà ok? e questa open qui questa è l'open del sistema operativo che viene da qua ok? quindi è perché android chiaramente è implementato sopra linux quindi alla fine userà i costrutti di linux per aprire i file e anche qui la cosa interessante è che il dato di ritorno quindi questa f qui è lo stesso dato che poi verrà tornato dalla f open stessa quindi mi sa che l'ho tagliato quindi non si vede ma quindi è proprio trasparente in realtà fa molto poco cioè fa veramente pochissimo lavoro però è quel poco che serve per rendere portabile il vostro codice perché immaginate di essere invece su cioè il vostro codice c no? la vostra hello world o quello che è in c è portabile sulla carta se noi andiamo a migrare ricompilare il programma per windows per esempio lo possiamo fare senza cambiare il codice qui della f open perché sappiamo che chi ha fatto il runtime c per windows avrà reimplementato questa cosa non usando la open ovviamente perché non c'è in realtà poi ci sarebbe anche però non è importante ma avrà usato la l'alternativa per win32 che mi pare che si chiami open file credo mi sembra non vorrei dire dovrebbe essere cose o read file non mi ricordo una delle due comunque l'alternativa per aprire e leggere i file è per win32 che hanno un comportamento più o meno simile e quindi in qualche modo riescono a mappare i comportamenti la differenza è questa che qui appunto le opzioni che vengono fatte sono molto poche quello che avviene nel mondo win32 è un pochino più sofisticato sicuramente perché i file hanno altri percorsi su windows quindi c'è la storia delle slash invertite sono dei percorsi speciali che non valgono su unix quindi la doppia backslash iniziale che può mappare dei file virtuali e così via quindi la fopen su runtime c per windows è sicuramente più complessa di quella però noi sappiamo il comportamento sarà lo stesso nella maggior parte dei casi questo ci permette di mappare le cose in maniera cioè ci permette di scrivere il codice portabile senza perdere troppo tempo per la completabilità ok quindi in genere la nostra interfaccia è usata in questa maniera la cosa più banale che si possa fare è la nostra applicazione chiama runtime direttamente quindi fa la classica fopen fwrite fprintf fscanf e così via parlo sempre del c per convenzione ma parlo su qualsiasi altro linguaggio per vostra convenienza e poi runtime parla con il seno operativo e si sbriga tutte le varie cose del caso se abbiamo un framework aggiuntivo il framework appunto è implementato se ce l'abbiamo è implementato in un linguaggio familiare la nostra applicazione e gira sullo stesso runtime ok quindi chiamare il framework significa in realtà avere una libreria aggiuntiva che fa del lavoro per noi del lavoro anche complesso volendo ma alla fine il framework stesso andrà a chiamare o il runtime o direttamente il seno operativo in alcuni casi ok questo per esempio per fare un esempio concreto di questo un esempio che abbia senso le ok per esempio le si windows forms avevo fatto l'esempio la volta scorsa abbiamo un'applicazione scritta in c sharp il framework è windows forms il runtime è .net ok è un'applicazione grafica con finestra e così via se usiamo i costrutti di windows forms per creare una finestra un pulsante e così via questi costrutti appunto pulsante finestra e così via sono dentro il framework noi possiamo utilizzarli possono appoggiarsi alle funzioni del runtime perché ovviamente windows forms è scritto in c sharp ovviamente per cui userà molte cose di c sharp ma poi per le cose che riguardano l'interfaccia grafica in senso più stretto chiamerà direttamente create window move window e così via che sono funzioni del senso operativo ok quindi in alcuni casi il framework può chiamare direttamente il senso operativo perché usa funzioni specifiche per quel senso operativo la cosa che a quel punto diventa più scomoda è che a quel punto usare quel framework quindi windows forms in particolare rende non portabile tutto il nostro blocco ok perché a quel punto noi sappiamo che la nostra applicazione magari si basa sul runtime che concettualmente è portabile ma usare windows forms lo rende non portabile perché windows forms non esiste per mac os per dire poi in realtà ultimamente esiste non è bello però si può fare un framework lo si può vedere come un'applicazione a sé stante direi di no no perché allora il framework si intende un insieme di librerie di supporto che utilizziamo e quindi in genere non hanno cioè non non possono essere un'applicazione a sé stante perché danno a noi dei blocchi di software utili quindi classi di supporto librerie funzioni di sostegno e così via che utilizziamo ma non hanno cioè non c'è il main che possiamo eseguire quindi il framework non può essere eseguito da solo è semplicemente una serie di strumenti che abbiamo noi che possiamo includere e che possiamo utilizzare per semplificarci la vita ma da solo non può essere eseguito adesso non mi vengono esempi in cui un framework che invece possa essere eseguito non mi viene in mente niente probabilmente ci sono dei scenari atipici in cui questo avviene però non mi viene in mente nulla ok quindi in genere appunto può anche non esserci come dicevo prima quindi il nostro hello world di base non ha il framework chiaramente quindi ha solo applicazione runtime e quindi questo problema del framework non si pone proprio ok poi se la nostra applicazione questo lo possiamo fare chiaramente chiama direttamente il separativo questo l'ho messo in grigetto perché in genere è mal visto è mal visto da un punto di vista di portabilità non mal visto perché viene alla polizia e lo impedisce quindi si può fare liberamente ma a quel punto la nostra applicazione viene legata strettamente al separativo quindi è come se voi nella vostra applicazione invece di chiamare fopen chiamaste direttamente open file in win32 a quel punto la vostra applicazione è legata indistruibilmente alle win32 e senza di quelle non gira è quello che faremo il laboratorio venerdì scusate lo chiedo avendo lavorato con spring boot adesso definisce un entry point l'applicazione è sviluppabile ah ok allora spring boot non lo conosco però se il framework ha un entry point tutto suo e poi noi ci inseriamo i nostri oggetti dentro cioè non so le cose vanno eseguite non conosco l'esempio in di preciso però sulla carta in quel caso il framework potrebbe essere direttamente eseguibile però è vero che diciamo così è un cambio di forma magari però il concetto rimane ben rimane lo stesso ok quindi dicevo prima usando le win32 venerdì prossimo faremo esattamente questo quindi andremo a non avremo nessun framework avremo il runtime c di appoggio ma lo useremo molto poco se non per avere il main classico e poi andremo direttamente a parlare con il sistema operativo che ci farà creare finestre e fare cose incredibili di bellezza inonorrabile e poi in alcuni casi ancora più rari si può parlare direttamente con l'hardware questo è possibile anche se chiaramente i sistemi operativi moderni lo cercano di impedire in qualsiasi modo perché in genere è sempre una pessima idea per la coesistenza pacifica delle applicazioni o dei processi sulla stessa sistema operativo però in alcuni casi se la vostra applicazione gira con permessi altissimi può farlo questo è il caso dei driver per esempio e così via che ovviamente devono farlo per loro stessa natura ok poi ci sono degli estremi a questi scenari che vi raccontavo quindi degli estremi da un lato e dall'altro quindi per esempio da un lato l'estremo più scarno è quello dei sistemi embedded che non hanno un vero sistema operativo ad virgolette gli sistemi embedded più semplici più di basso livello gli oggettini più scarni hanno un sistema operativo che è mezzo sistema operativo mezzo runtime quindi è una cosa molto scarna che fa girare proprio quel che serve che però viene compilato insieme a tutta l'applicazione vostra quindi quando preparate un'applicazione per questi sistemi qui voi programmate in un dato linguaggio poi la toolchain in realtà produce tutto un binario che comprende runtime sistema operativo e tutto quanto e poi viene copiato dentro la memoria del dispositivo e a quel punto gira tutto insieme quindi è un unico blocco bello bello compatto ed è indissolubile in qualche modo quindi questo qui e qui in gergo si chiama appunto che l'applicazione gira sul metallo quindi sull'acciaio nudo della macchina perché non c'è quasi nessun sistema non c'è quasi nessun stato software che ci protegge dall'hardware quindi bisogna avere una nozione abbastanza precisa di quello che si va a fare e dei vari componenti hardware che vogliamo programmare quindi i led le porte di comunicazione e così via perché di software di sostegno di aiuto ce n'è veramente poco ok l'altro esempio invece l'esempio estremo sull'altro lato quindi di più alto livello di astrazione in realtà potrebbe essere dato cioè così almeno concettualmente dalle applicazioni che a loro volta sono delle piattaforme software quindi se volete immaginarle in questa maniera esistono applicazioni che sono applicazioni a sé stanti ovviamente per cui conterranno un frame si baseranno sul runtime ovviamente girano sul sistema operativo ma a loro volta sono un sistema operativo per altri componenti software come i plug-in per esempio ok quindi in questo scenario mi viene in mente non so tipo Firefox che è un browser quindi già è un software molto complesso però si può estendere con una serie di estensioni e plug-in aggiuntivi che si possono installare questi plug-in vanno in esecuzione dentro il browser e quindi parlano direttamente con il browser se devono fare qualcosa ok non hanno accesso a tutto il resto in genere se sono ben programmati possono parlare con il browser però in effetti sono dei componenti software che se li vediamo dall'alto sono a loro volta delle applicazioni che girano sul sistema operativo che è il browser la virgoletta in maniera stratta ok quindi possiamo diciamo così mettere livelli su livelli e andare in maniera cioè così all'infinito a complicarci la vita però ecco l'idea è che in genere più in alto andiamo i minori saranno diciamo così le maggiore sarà distanza con l'hardware quindi i minori saranno le capacità di andare a toccare la macchina direttamente ok anche a livello di sicurezza ok cosa vuol dire qui ah ok stesso esempio di prima quindi anche qui poi vi parlerò della del web in sé perché anche il web può essere vista come piattaforma di sviluppo per applicazioni chiaramente per cui è esattamente quello che avviene in questo scenario eretico in cui appunto il browser è l'applicazione che gira sul sistema operativo le pagine che girano dentro il browser possono essere viste come delle applicazioni perché effettivamente ormai nel web nel mondo moderno lo sono a tutti gli effetti e quindi queste pagine qui che hanno un'interfaccia di comunicazione che è molto molto di alto livello con il browser però si comportano come delle vere e proprie applicazioni anche se non hanno accesso diretto al separativo tramite il browser a volte possono fare delle cose che somigliano molto a questo comportamento per cui questo sistema qui è concettualmente ormai abbastanza sdoganato e poi ne parleremo infatti però ecco è lo stesso modello dei plugin che si innestano sopra a altri strumenti di più alto livello che a loro volta poi si appoggiano a strade inferiore ok direi che possiamo divagare sugli esempi di piattaforme così vediamo anche un po' più in concreto che cosa sono le Wien32 e così via allora la prima piattaforma software che vi cito ma chiaramente ne esistono 8 milioni quindi in realtà sono citati un po' così a scelta completamente a caso ma più che altro per fama e per importanza per cui la prima piattaforma e forse quella più longeva per certi versi è quella del Macintosh quindi l'Apple Macintosh è questo computer iconico che era stato lanciato nel 1984 dalla Apple aveva questa forma molto graziosa iniziale e era relativamente poco cioè era relativamente economico per quanto si potesse parlare di comunque di oggetti estremamente costosi ma confrontato con i PC dell'epoca era abbastanza accettabile come costo aveva due capacità molto limitate però aveva avuto un successo cioè aveva avuto un successo diciamo così abbastanza inaspettato proprio per via della sua carineria si può supporre e questo ha dato poi origine a tutta la trafila di Macintosh e derivati fino ad arrivare ai moderni Mac quindi il Mac moderno che adesso si trova in ogni ufficio è figlio da virgolette di questo oggetto qui a livello concettuale poi chiaramente hanno avuto mille evoluzioni però la piattaforma software in sé è la stessa quindi lo stesso software che è nato qui concettualmente poi è figlio nipota e così via del no scusate cioè AVO del software moderno che gira su Mac OS moderni su il primo Macintosh girava il la prima versione la versione 1.0 di quello che si chiamava system software che poi sarebbe diventato Mac OS e adesso adesso Mac OS ma scritto in maniera diversa quindi è minuscola però è la stessa lo stesso concetto anche questo sistema operativo è lo stesso a livello storico ma anche cioè ha subito varie evoluzioni nel frattempo però concettualmente è lo stesso lo stesso filone all'inizio quindi su questo sistema qui questo era l'aspetto meraviglioso del Macintosh su interfaccia grafica che appunto era stata abbastanza seminale quindi importante all'epoca nel definire alcuni concetti che poi sono stati ripresi copiati e quant'altro in giro ma questi concetti stessi in realtà sono figli di altre idee che sono state ugualmente copiate all'epoca dai laboratori Xerox poi ne parleremo parlando di interfacce utente proprio però questa interfaccia grafica qui era basata appunto sul system software che era un ecosistema software abbastanza come si può dire abbastanza primitivo all'epoca abbastanza imberbe ovviamente che si appoggiava alle convenzioni di quindi le BI le convenzioni di di parlata del software del Pascal e aveva molti pochi strumenti per proteggere se stesso dalle applicazioni quindi aveva la memoria completamente condivisa tutte le applicazioni si parlavano passandosi dei dati con estrema liberalità e c'era molta poca protezione tra i processi in esecuzione per cui chiaramente sia molto semplice sia molto facile da programmare all'epoca per cui ha avuto un buon successo anche per quanto riguarda lo sviluppo del software su di esso e poi da lì si è andato evolvendosi ovviamente ulteriormente in parallelo quindi il contraltare di questo era Windows che era il separativo come si può dire principe per i i PC IBM e derivati dell'epoca questo è l'aspetto incredibilmente bello di Windows 1 dell'85 ha delle somiglianze molto vaghe con i Windows moderni ovviamente e la cosa che forse è meno cioè la cosa che sembra più strana è che le finestre nonostante si chiami Windows le finestre non sono sovrapponibili per cui non funzionano a finestre come ci si aspetterebbe a differenza di del Mac che aveva queste finestre trascinabili come ci si aspetta modernamente Windows 1 e Windows 2 non avevano finestre trascinabili quindi non erano sovrapponibili erano finestre a tasselli per cui andavano impostate e potono tagliare lo schermo a metà o in altre frazioni però non potevano essere trascinati una sopra l'altra a eccezione dei dialoghi i dialoghi questi qui andavano in sovraimpressione però il resto dell'interfaccia non poteva sovrapporsi stranamente ok quello che sarebbe arrivato con Windows 3.0 e derivato altra cosa a margine che è importante ricordare Windows 1 e fino a 3.11 in realtà erano ambienti grafici per l'utilizzo del PC però non era il vero sistema operativo il sistema operativo effettivo era sotto ed era MS-DOS sempre quindi era Microsoft-DOS che poi in realtà era un derivato di PC-DOS si chiamava quindi il sistema operativo effettivo era il DOS e poi sopra si impiantava Windows che faceva l'interfaccia grafica a tutto quanto quindi di base quello che avveniva per programmare un'applicazione di questo genere è che si utilizzavano tutti i concetti di MS-DOS come sistema operativo e poi sopra si faceva uso di alcune API che si chiamavano Win16 all'epoca perché erano tutto a 16 bit che permettevano di andare a creare delle finestre e reagire in qualche modo all'input dell'utente Windows in 6 ha avuto tre grandi diciamo così punti d'arrivo comunque punti di passaggio nella sua storia il primo e forse quello più determinante è stato con Windows 3.11 che era la versione che ha avuto la maggiore diffusione poi all'epoca che ha in qualche modo determinato poi l'egemonia di Windows negli anni dopo quindi nel 92 è riuscito Windows 3.11 che in realtà 3.0 prima poi 3.11 che era la versione poi più diffusa che appunto aggiunge le finestre sovrapponibili come vedete quindi c'è questa bella novità e soprattutto definisce in maniera abbastanza cristallizzata le API di programmazione per le interfacce grafiche che poi sono rimaste le stesse negli anni successivi quindi ormai nel 92 quindi sono passati 30 anni in 30 anni non molto si è mosso nel senso che le API sono rimaste più o meno coerenti perché vedrete che le stesse cose che poi noi faremo per fare una finestra su Windows 10 11 o quello che c'è in laboratorio sono stranamente molto simili a quelle originali quindi anche qui vedremo un sacco di elementi che richiamano questo mondo qua anche se chiaramente non sono più particolarmente rilevanti poi il 1995 nel 95 ovviamente è stato il salto diciamo così a livello grafico forse più più importante perché si passa da un un aspetto abbastanza semplice a l'interfaccia moderna che tuttora è abbastanza riconoscibile anche nelle versioni moderne per cui il pulsante start la barra delle applicazioni inferiore le cos'altro i menu nelle finestre e tutte queste belle cose che sono rimaste bene o male coerenti con CSS poi ne parleremo meglio però anche in realtà anche il Mac ha questa questa coerenza interna forse addirittura più forte di quella di Windows in realtà per cui le finestre sono rimaste più o meno simili la barra in alto con le opzioni è rimasta anche nel Mac OS moderno quindi molte cose sono state inventate quasi 40 anni fa e poi sono rimaste così per coerenza quindi stessa cosa vale anche per Windows e questa era la versione più popolare in assoluto quindi proprio sbancato c'erano le file come per per gli iPhone moderni per andare a prendere una copia di 1995 in maniera molto inaspettata e soprattutto è la prima versione di Windows che cerca di rimodernare un po' questa questa cosa obsoleta di Windows 3.0 e 3.11 e si inventa le Win32 che sono le interfacce di programmazione che effettivamente andremo a utilizzare noi poi venerdì prossimo ok quindi quando lavoriamo con le API di Windows molte cose risalgono a quest'epoca qui ma la forma finale è di questo mondo qua tant'è che tutti i concetti che andremo a utilizzare quindi le finestre i pulsanti in alto a destra i menu e così via li trovate nel codice nell'API e richiamano questo mondo qua tant'è che le nostre prime applicazioni avranno anche questo aspetto qui orribile grigetto delle applicazioni dell'epoca perché se non facciamo nulla e creiamo una finestra da zero in Windows 11 comunque avrà l'aspetto grafico di una finestra di Windows 95 per coerenza per non farla comportare in maniera inaspettata poi l'ultimo salto veramente grosso è arrivato nel 2001 con Windows XP che diciamo così ha cambiato radicalmente gli interni di Windows per così dire perché con XP c'è stato un cambio di kernel proprio quindi si passa da Windows quello originale a Windows NT che sarebbe sta per Windows New Technology che è il kernel moderno che fa da base a tutti i Windows moderni quindi in realtà da XP in poi quindi per altri 22 anni no sì 22 anni ormai c'è sempre l'NT sotto e anche anche Windows 11 moderno ha lo stesso kernel che e qui è importante distinguere due cose che espone sempre le stesse API quindi il kernel è cambiato sotto cioè il cuore è stato radicalmente modificato ma le API di programmazione che espone a voi i programmatori che volete fare degli oggetti grafici o qualsiasi altra operazione sono gli stessi di prima per compatibilità ok quindi per portarsi dietro tutto il software che esisteva già tutti i concetti che valevano qui valgono anche qui per forza ok quindi il kernel espone questo interfaccio di programmazione ed è più o meno coerente chiaramente sono cambiate un paio di cose perché sono cambiate i modelli di sicurezza tante piccole cose sono cambiate quindi alcune cose non funzionano più esattamente come all'epoca però in genere il passaggio era abbastanza indolore abbastanza più o meno ok quindi parlando di API allora la prima versione quindi Windows esponeva le Windows API chiaramente poi retrospettivamente adesso li chiamiamo Win16 per differenziare dalle Win32 si chiamano Win16 perché all'epoca Windows era a 16 bit e quindi tutte le API parlavano in 16 bit quindi non so gli interi erano 16 bit i double erano a 4 byte e così via e tutti i Windows dall'1 al 3.11 usavano questa interfaccia qui e le interfacce vivevano in tre file in particolare il kernel.exe user.exe e gdi.exe qui notate che all'epoca non c'erano ancora le dll quindi si sono soltanto eseguibili anche se questi tecnicamente eseguibili non erano questi sono i componenti fondamentali cioè i file di libreria che compongono il seno operativo ok di base per cui il kernel ovviamente ci si arriva nel kernel quindi vi permette di creare processi creare thread creare sessioni utenza e così via user tutto quello che riguarda l'utenza quindi la gestione della sessione dell'utente e i suoi permessi e così via gdi sarebbe graphic device interface ossia l'interfaccia al dispositivo grafico quindi quello che vi permette di disegnare su schermo e le gdi le useremo quindi sono rimaste quindi fino a Windows 11 ancora esistono le gdi sono lo strumento veramente primitivo che si usa per disegnare il suo schermo su Windows per cui immaginate che risalgono a Win 16 quindi risalgono abbondanti anni fa e quindi fanno proprio quello quindi fanno grafica proprio anni 80 vettoriale sembra appunto proveniente da un film di quelli un po' veneristici anni 80 e fanno esattamente quello poi è vero che ci si può fare un po' di tutto però insomma hanno una certa età le Win32 sono state proposte con Windows 95 come dicevo che è il primo salto a 32 bit di Windows e quindi era in qualche modo appunto un milestone importante da questo punto di vista con Windows NT vengono mantenute vengono riviste un po' e ripulite perché poi diventano l'API ufficiale fino ad oggi per compatibilità appunto sono fanno sempre riferimento al mondo di Windows 95 quindi anche oggi come dicevo prima e i file sono sempre gli stessi cambia soltanto il c'è un 32 in più per differenziarlo perché è a 32 bit e a questo punto si sono inventate le DLL per cui c'è la DLL le DLL sono l'estensione con cui Windows identifica le librerie dinamiche quindi sarebbe dynamically linked library quindi la libreria al al linking dinamico quindi sono librerie che possono essere richiamate dinamicamente dal vostro codice quindi kernel user32 GDI32 contengono le varie funzioni che ci interesseranno tra una settimana e che vi permetteranno di creare finestre creare cose di questo genere e voi andrete a fare riferimento a queste funzioni che verranno chiamate dinamicamente e vivono qui dentro con l'arrivo del 64 bit in realtà Windows ha sempre una politica della compatibilità totale e folle per cui hanno fatto una mappatura delle GDI32 in 64 bit si chiamano tecnicamente Win64 ma in realtà è semplicemente una mappatura con più bit ma sono rimaste le GDI32 quindi tant'è che tuttora si dice che si usano le GDI32 perché non c'è non c'è differenza se non nel numero di bit che vengono utilizzati per la codifica dei tipi ah sì avete una domanda adesso? Sì sarebbero gli SO di Linux sono la stessa cosa quindi le librie che possono essere caricate e richiamate dinamicamente perché sappiamo che dentro la libria c'è la funzione tal detali che si chiama tizio e possiamo caricarla dinamicamente e richiamarla quindi stessa identica cosa che avviene con le DLL ok tutta questa sequenza di librerie di API che vi ho detto sembrano appunto sembra molto facile ma in realtà facile non è perché hanno attraversato varie evoluzioni nel tempo nella storia di Windows tant'è che se proprio vi interessa io questo ho uscito sempre perché mi piace molto c'è questo libro fantastico che vi racconta la storia di Windows NT quindi come si parte dal 95 98 e si arriva a Windows Moderno con una serie di scommesse e di colpi di fortuna abbastanza importanti perché appunto la storia non è così lineare non è così semplice all'epoca come dicevo prima i PC IBM e i loro compatibili si appoggiavano proprio agli albori a MS-DOS quindi il soprattutto di bassissimo livello proposto da Microsoft e poi successivamente sopra MS-DOS era stato proposto Windows come piattaforma di interfaccia grafica per l'utilizzo di applicazioni grafiche e così via e aveva avuto un buon successo con Windows 1, 2 e 3.11 poi in particolare e IBM era il partner storico di Microsoft per questa situazione quindi IBM forniva i PC in sostanza e Microsoft forniva il software questa era un po' l'idea ma poi da questa partnership doveva nascere quello che si chiama OS2 quindi IBM OS2 che era il sistema operativo che avrebbe dovuto rimpiazzare tutto questo vecchio accrocchio che era MS-DOS più Windows questa era l'idea solo che nel frattempo molto software era stato scritto già per Windows 3.11 quindi c'era c'era molte applicazioni che hanno stato scritte per Win32 Win16 Win32 per cui l'idea era grazie alla collaborazione delle due aziende di creare OS2 IBM OS2 che fosse compatibile con Win32 quindi il senorativo nuovo di Zecca di IBM aveva poteva eseguire applicazioni per Windows senza che venissero portate senza che venissero tradotte questa era l'idea poi questa partnership esplode per vari motivi che potete leggere nel libro se proprio vi interessa comunque il finale della storia è che la compatibilità c'era però poi Windows 75 prende piede in realtà e nonostante ci sia compatibilità con OS2 i sviluppatori continuano a sviluppare per Windows perché tanto vale perché tanto sviluppo Windows e poi funziona anche su OS2 per cui tanto vale continuare a sviluppare per Windows e quindi OS2 in realtà non riesce mai a prendere piede e da lì a poco viene dismesso da IBM quindi non è mai successo proprio perché non c'era il parco software che lo giustificasse quindi non c'era l'interesse perché c'era già l'alternativa compatibile e quindi ne sono interessi per creare un nuovo software che fosse soltanto per OS2 di contro c'è anche una storia alternativa strana per cui per questa vecchia partnership che si sono tirati dietro Microsoft e IBM Windows stesso includeva un sottosistema che lo rendeva compatibile con OS2 almeno fino al 2000 stranamente quindi fino al 2000 si potevano eseguire applicazioni Pro OS2 su Windows con questa modalità di compatibilità anche qui giusto per citare altre cose che forse non mi saranno mai utili ma così può essere dare colore Windows NT in particolare è stato così rilevante nel suo sviluppo perché funziona a sottosistemi quindi ha vari sottosistemi per ogni per ogni piattaforma e per ogni interfaccia di programmazione tant'è che le Win32 sono soltanto uno dei tanti modi che possiamo utilizzare Windows NT è quello che viene usato nel 99% dei casi quindi Win32 sono un sottosistema di Windows NT che vi permette di creare finestre operare e quant'altro ma sulla carta Windows può eseguire anche altri programmi scritti per altre interfacce di programmazione OS2 è un esempio che però non esiste più l'altro esempio che esiste è POSIX POSIX è la super famiglia di Linux e Unix quindi anche lì sulla carta è possibile seguire eseguibili per POSIX su Windows che è una cosa molto esoterica però sulla carta si può compilare un programma per POSIX e farlo girare senza ricompilarlo su Windows penso sia una cosa rarissima che nessuno fa ma si può fare sulla carta e tant'è che gli utri Windows includono altri sottosistemi più moderni e in particolare da Windows 10 in poi c'è il sottosistema per Linux mi sembra che si chiami giusto che vi dà accesso a un ambiente vero Unix dentro Windows se volete quindi è molto comodo per chi sviluppa fa il sistemista magari su su Stato Linux e lo può fare dentro Windows stesso e da Windows 11 in poi c'è addirittura il sottosistema per Android per cui potete eseguire applicazioni Android dentro Windows in maniera nativa non l'ho mai visto in azione francamente però so che esiste sulla carta per cui è molto flessibile da questo punto di vista perché può eseguire vari vari software diversi perché ha varie interfacce opzionali di programmazione le Win32 sono soltanto una di queste però chiaramente è quella che copre la maggior parte dei casi d'uso ecco Linux Linux Subsystem mi dicono che si chiama quindi si è WSL sarebbe che potete installare e avere accesso a bene o male tutto quello che è un sottosistema Linux dentro Windows stesso ok e come dicevo le Win32 sono un'interfaccia chiaramente molto molto vecchiotta prima vi dicevo di Macintosh Macintosh era nato con Pascal in mente quindi l'invalorazione che era stata adottata era Pascal tant'è che tutte le ABI di Macintosh di MacOS e dei suoi precursori usano le convenzioni di chiamata le convenzioni di nome e tutte le ABI quindi le interfacce binarie di Pascal ok perché per convenzioni si usavano quelle del linguaggio in cui il seno operativo era stato già scritto Windows è scritto in C prevalentemente per cui tutte le sue API fanno riferimento agli standard di programmazione di C ovviamente ok quindi le API e la documentazione se voi andate a vedere la documentazione di Win32 sono formattate come se si parlasse in C ok quindi trovate il tipo di ritorno il nome della funzione le parentesi i parametri in ordine come sono dichiarate le funzioni nella libreria standard di C nonostante sia molto vecchia la Win32 è in stile è orientata agli oggetti almeno concettualmente questo lo vedremo dopo perché anche se il linguaggio C non supporto gli oggetti come sicuramente sapete si può ragionare oggetti in C chiaramente volendo per cui si possono avere delle funzioni che creano oggetti ed è il caso della create window che vi accennavo prima quindi la create window è una funzione che crea un oggetto che è una finestra vi ritornerà una un puntatore a finestra quindi una handle si chiama in gergo di Win32 una una manopola che che fa capo a una finestra quella finestra potete manipolarla con altre funzioni che operano su questo oggetto astratto che è la finestra quindi concettualmente è orientato gli oggetti perché la ragione in questa maniera quindi non è imperativo standard e in genere poi vi troverete spesso a portarvi dietro questo questo marasma di oggetti che sono finestre font penne colori tutte queste cose con cui potete combinare la vostra interfaccia grafica e ognuno è un oggetto che va creato e poi distrutto ok quindi va creato in memoria viene allocato poi viene distrutto poi successivamente quando non serve più quindi questo è il meccanismo essendo appunto in C non c'è il linguaggio non supporta questo concetto quindi va fatto tutto quanto a mano quindi bisogna creare distruggere manualmente le cose però ecco almeno concettualmente era già orientato verso qualcosa di più moderno la cosa veramente brutta delle Win32 è che visto che ha quasi 40 anni di storia ci sono tante funzioni che prima avevano un senso adesso non ce l'hanno più molte funzioni che sono riviste ovviamente molte funzioni che hanno parametri che non servono più perché sono così rimaste lì tipo oggetti ornamentali hanno molte funzioni che sono soppiantate le altre funzioni che hanno tipo il numeretto dietro 2, 3, 4 perché sono versioni successive della stessa cosa quindi in particolare la Create Window che cito sempre in realtà non si usa più cioè funziona ancora ma non si usa più perché c'è la Create Window X che è la versione numero 2 della Create Window che ha più parametri di cui alcuni non servono più ovviamente quindi è veramente molto obsoleta e quindi insomma non è proprio non è proprio bella da lavorarci in tutta onestà però lo faremo per ragioni storiche nei vari nella lunga storia di Windows ci sono stati vari tentativi di prendere le Win32 e buttarle dove meritano cioè nell'organico ma nessuna ha nessuno ha attecchito per ora perché tuttora le Win32 rimangono l'interfaccia che si usa prevalentemente perché non ce n'è una che è riuscita in qualche modo a a sopravvivere in qualche modo in particolare con Windows 8 l'unica cosa buona che Windows 8 ha provato a introdurre era il Windows Runtime e o in così in breve WinRT che l'idea era questa di avere un sistema astratto nuovo moderno sfavillante bellissimo che era costruito sopra le Win32 per compatibilità quindi sotto si appoggiava le Win32 perché chiaramente quelle non si possono buttare via veramente però sarebbe stata la nuova interfaccia moderna per tutte le applicazioni nuove di Windows questa era l'idea qui il modello era veramente a oggetti tant'è che i linguaggi supportati erano tutti a oggetti vero? sì python più o meno e ho detto una cosa non vera però comunque potenzialmente orientati agli oggetti e soprattutto aveva due fondamenti importanti ossia l'approccio era molto moderno per cui era completamente asincrono la programmazione adesso poi faremo una tangente sulla programmazione asincrona e soprattutto tutti i comprati software sono pacchettizzati in applicazioni e c'è il sandboxing dell'applicazione adesso poi vi spiego esattamente cosa intendo con questi termini però l'idea era quella di prendere le robe vecchie metterle da parte cioè usarle sempre dietro le scene perché dietro le quinte perché non si possono buttare via veramente però metterci sopra una facciata nuova e ripulita poi purtroppo questo non ha veramente funzionato però l'idea era lodevole ora per parlare di questi tre sottoconcetti quindi le tre modernità che sono state proposte la sincronia il packaging e il sandboxing tutte cose che sicuramente avete già sentito ma adesso le vediamo brevemente insieme si può fare sì sono ancora 10 in quarto perfetto quindi la sincronia questo poi lo vedremo anche meglio poi lavorandoci in pratica però cosa voglio dire con Async First allora tradizionalmente la maggior parte delle API vecchia scuola quindi che vengono dagli anni 80 o giù per di lì sono in genere sincroni nel senso che significa che le chiamate che noi facciamo a queste librerie sono bloccanti si dice questo sistema operativo l'avete già visto in abbondanza sicuramente però significa che do un comando alla libreria che implementa in questo caso la write no? di questo non è neanche c questo è unix direttamente gli dico di scrivere qualcosa su un file descriptor e questa chiamata rimane bloccata cioè effettivamente l'esecuzione del mio software si impunta su questa chiamata qui finché la write non torna e questa write torna soltanto quando tutti i bytes sono stati scritti ok? questa è l'idea se il file descriptor è una socket magari che scrive TCP su un altro server e sto mandando 8 gigabyte di buffer cosa che posso fare no non posso farlo perché è 6G comunque potrei farlo sulla carta vabbè mando molti giga questa chiamata è bloccante e soprattutto si blocca per minuti no? se siamo molto sfortunati e sono collegato con il cellulare magari ci mette anche qualche ora quindi il mio programma nel frattempo non può fare altro perché il suo thread di esecuzione quindi il suo flusso di esecuzione è bloccato in questo punto qui quindi questo chiaramente andava bene in un mondo dell'epoca bene male però ora siamo abituati a applicazioni reattive che fanno animazioni sono bellissime eccetera mentre fanno delle operazioni in background quindi questo modello con un singolo thread di esecuzione che si blocca ogni volta che fa qualcosa di utile non si può non va più bene per cui ci sono varie scamotage che possiamo adottare per rendere questo meno brutto meno bloccante però il sistema operativo ci può venire il sistema operativo o comunque l'ambiente in cui lavoriamo ci può venire in aiuto dandoci dei strumenti un pochino più sofisticati della write degli anni 70 di unix per cui questo lo fa per esempio win32 e ci dà una funzione che si chiama read file qui adesso l'esempio è un po' infelice perché qui era write e qui read però è ovviamente uguale leggere e scrivere è la stessa cosa se immaginate un tubo di byte se scrivete o leggete alla fine dei conti sono sempre byte che entrano ed escono non cambia molto e qui avete il primo impatto con quello che è la meraviglia dell'API di win32 vedete che bel guazzabuglio di lettere completamente a casa sono tutte fatte in questa maniera però ha un senso ve lo assicuro adesso vedremo insieme perché sono così così aliene all'occhio umano però prima di addentrarci in questa in questa zuppa di lettere le win32 a differenza delle API di basso livello di unix e così e di c per esempio su runtime supportano chiamate non bloccanti poi in realtà anche unix e le sue estensioni supportano non bloccanti quindi è un esempio quello di win32 perché poi ci lavoreremo però in realtà è un esempio che si potrebbe fare anche su altre piattaforme in win32 l'idea è questa io posso leggere e scrivere in maniera bloccante come sono abituato a fare e lo posso fare esattamente come lo facevo con la write precedente quindi esattamente alla stessa maniera ho gli stessi parametri peraltro sono solo camuffati con dei nomi più brutti quindi read file la handle è il puntatore file il file descriptor il buffer è il const char no scusate const void asterisk quindi il puntatore a void famoso che si usa per scrivere in questo caso per leggere per ricevere i dati questa roba qui è il numero della grandezza del buffer quindi quanti byte voglio leggere questo è il numero di byte che ho letto quindi la differenza qui è che nel mondo unix ci ritorna il numero di byte letti in windows ci ritorna un booleano che dice è andata bene non è andata bene e qui ci ritorna i numeri passati per reference però non cambia di stile ma non cambia la sostanza e poi c'è questo oggetto bonus qui che adesso potete ignorare perché se lo ignoro questa funzione qui funziona esattamente come la read di unix uguale ok a parte il cambio di stile se uso il questo sistema che si chiama overlap overlapped read and write quindi le letture e scritture sovrapposte sarebbe a dire è un sistema che usa windows per gestire le letture asincrone quindi deleghiamo la lettura o la scrittura a windows diciamo guarda voglio leggere questo file voglio leggere 20 giga di dati ok windows lo fa quando vuole e quando ha finito ci ritorna ci avverta del fatto che ha finito mandandoci un evento e un evento è un concetto di alto livello di windows quindi da qualche parte nel win32 c'è questo concetto di eventi che possono esserci inviate e dirci guarda è arrivata il file è stato letto è stato scritto è stato fatto quello che dovevi fare puoi continuare a seguire puoi continuare a riprendere da dove è arrivato oppure quello che loro chiamano le porte di completamento di io quindi un sistema di notifiche di alto livello che ci segnalano che qualcosa di input ha finito non entro troppo nei dettagli perché diventa molto complicato inutilmente però sappiate semplicemente che è un modo per dirti fai questa cosa qui il seno operativo lo fa nella maniera più calma ed efficiente possibile e poi ci notifica il fatto che ha finito questa chiamata qui torna subito quindi la chiamiamo il kernel prende in consegna questo ordine e read file ritorna subito a noi quindi noi possiamo continuare amabilmente per la nostra strada sapendo che a un certo punto questa scrittura finirà se non va se non fa errore ok questa è l'idea giusto per competenza vi accenno a due cose sullo standard Win32 qui perché potrebbe sembrare molto alieno allora i tipi sono tutti quanti in melluscoletto quindi differenza dei tipi dello stile classico in C che hanno sono tutti lowercase qui sono tutti uppercase per differenziarli e hanno ci sono questi questi tipi un po' strani che in realtà poi camuffano dei tipi molto più banali quindi handle è il puntatore che vi dicevo prima handle è la maniglia la manopola con cui possiamo agire su degli oggetti questo è una handle ad un file evidentemente quindi è esattamente identico al nostro file descriptor di unixana memoria e infatti se andate a vedere il type def di handle alla fine è un intero quindi non è che si diventa di nulla solo si chiama handle lp void è un long pointer to void quindi è esattamente questa roba qui è un long pointer anche queste ragioni storiche long pointer differenzia i pointer brevi perché in un momento di accavallamento tra 16 bit 32 bit il long pointer era un puntatore a 32 bit ok quindi chiaramente adesso modernamente sono tutti long pointer chiaramente viviamo nel mondo 32 bit 64 a dire la verità quindi sono tutti vedete che tutti i pointer che incontrate sono tutti l lp lp non ci sono più i p standard quindi lp è un long pointer to void quindi questo è il buffer d word è un double word quindi una doppia parola parola in senso di architettura proprio fisica di elaborazione per cui è un intero 32 bit questo è un puntatore a una parola a una doppia parola quindi è un puntatore a un intero quindi questo ci permette di passare per reference un puntatore a un intero e ricevere il numero di byte letti io qui sto parlando come se cioè di c schiettamente se non avete nozione approfondita di c magari sto parlando già arabo per cui bloccatemi se qualcosa vi confonde ok per cui soprattutto passare per reference per puntatore gli interi e così via magari cioè una cosa che in c si fa in maniera abbastanza comunemente però dovete averlo fatto per capire di cosa si parla ovviamente per cui se questo non è il caso bloccatemi subito e faccio una tangente breve su questo però se invece è tutto chiaro vado avanti così e questo appunto è un puntatore a una struttura datica a questo overlap che è l'oggetto con cui possiamo andare a ricevere gli eventi o a registrarci gli eventi per sapere quando l'operazione finisce ok quindi questa è l'idea questa cosa qui appunto non è bella però è così e quindi le quinteture poi quando le useremo avranno questa forma qui la create window in particolare la create window è la stessa cosa qui con una marasma di parametri che non finisce più veramente molto inquietante per da usare ok ora questa cosa qui ovviamente va benissimo si può usare e rende più comodo la lettura la scrittura dei file e così via ma in un mondo moderno bello spettacolare abbiamo dei linguaggi che dietro le quinte fanno esattamente questo perché alla fine da qualche parte devono prendere queste capacità sincroni dal sistema operativo ovviamente quindi i vostri moderni linguaggi di programmazione dico vostri come se io usassi il C no quindi i moderni di linguaggi di programmazione C sharp DART che useremo e così via hanno dei strumenti con cui camuffare queste cose orribili del passato e lo fanno con una sintassi che è molto più leggibile ok quindi questo qui se avete programmato in C sharp l'avrete già visto col sistema che si chiama task questo oggetto astratto permette di infiocchettare impacchettare una qualsiasi operazione asincrona in questo caso che ritorna quando viene completato ritorna una stringa quindi è possibile dichiarare una funzione che legge qualcosa come stringa legge da un file legge da una socket legge da un file in http e quando ha completato ritorna una stringa quindi i nostri dati che ci interessano e questo questo oggetto qui possiamo gestirlo come se fosse un'operazione asincrona quindi task è il nostro oggetto astratto ed è come se fosse l'overlap qui l'overlap è il nostro task quindi quello lì è l'oggetto con cui riceviamo gli aggiornamenti sulla lettura e qui lo facciamo tramite questo task qui identico e nei linguaggi moderni chiaramente c'è il bello che possiamo fare await di un task e sapere che questa funzione qui diventerà a questo punto veramente bloccante qui ho fatto un errore di naming qui questa asinc qui non ci sarebbe non torna scusate quindi con questa await qui posso mettermi in attesa che questo oggetto qui completi perché aspetto che task sia completo e a questo punto ottengo la stringa che mi interessava ok per questo è in C-Shark chiaramente per proiettarlo nel magico mondo di Dart che ci interesserà tra poco c'è la stessa identica cosa ovvio lateralmente rubata C-Shark si può dire e hanno cambiato tanti nomi e quindi il task si chiama future e la stringa è quella S maiuscola e se no per il resto è tutto uguale ok per cui e la asinc è in un'altra posizione quindi cambiano poche cose ma il concetto è proprio identico spiccicato e l'oggetto con cui ci portiamo dietro queste cose in asincronia da fare cioè in background da fare sono i future prego ma quindi se noi utilizziamo la sincronia mettiamoci nell'esempio il platform che ritorna si cioè dopo praticamente tutto il programma diventa cascata sincronia si si cioè quello è un problema è un la sincronia purtroppo è come si dice è virale nel senso che una volta che qualcosa diventa asincrona poi a cascata tutto diventa asincrono per definizione per cui quello si è una cosa allora questo posso fare un inciso più noioso se volete perché nel magico mondo degli anni 70 non ci fregava niente dell'esperienza utente andava bene fare le chiamate bloccanti e erano tutti felici così perché scrivere in maniera bloccante è anche molto comodo nel senso che noi sappiamo che faccio le mie cose poi ho un file da mandare in http per esempio faccio la write butto fuori 8 giga di dati l'utente aspetterà e pazienza tanto sono su riga di comando per cui se il programma è bloccato e sta facendo qualcosa o sta reagendo a mio input non c'è differenza questo è il bello riga di comando quindi se è bloccante non me ne accorgo nel mondo moderno di interfaccia utente chiaramente questo non avviene più perché l'applicazione seppure sta facendo qualcosa di impegnativo come mandare un file leggere un file operazioni lunghe deve essere comunque reattivo perché appena non reagisce più l'interfaccia utente si frizza si blocca e quindi l'esperienza utente ne subisce e quindi peggiora e quindi saranno questi questi oggetti questi costrutti aggiuntivi per permetterci di fare scritture e letture e così via in background quando usiamo questo sistema qui adesso qui io non sono andato nei dettagli perché poi in realtà non ci interessa molto visto che possiamo appoggiarci al mondo moderno dei C Sharp e Dart però se usiamo l'Io Overlapped e tutte queste cose in asincronia è vero che qui sembra specialmente un parametro in più però in realtà cambiare la nostra applicazione in modo tale che possa reagire in maniera sincrona agli input e output cambia radicalmente l'applicazione cioè a quel punto devo immaginate questo devo scrivere un file o leggere un file molto grande lo mando in scrittura con questa chiamata qui l'interfaccia utente quindi la mia applicazione rimane in esecuzione però in realtà poi dentro cioè nella mia applicazione dovrò gestire questi eventi questi segnali di completamento dell'input e output in qualche modo quindi avrò da qualche parte molto in alto nella mia applicazione un sistema che reagisce a questi eventi che sa cosa farci e sa come reagire in base a quello che sta avvenendo quindi in realtà tutta la sincronia in qualsiasi modo io la gestisca sia con questo modo un po' primitivo sia con questo è sempre qualcosa che cambia radicalmente la vostra applicazione quindi appena la vostra applicazione diventa asincrona dovete rivedere completamente in genere tutta la pila tutta la creatura del vostro software perché ovviamente il suo comportamento cambia radicalmente ok? quindi da sincrono ad asincrono sono vari modi per farlo però in genere poi la vostra applicazione viene stravolta in profondo però sì per rientrare qui in questo caso qui l'esempio cioè si diceva se questa è una funzione asincrona a questo punto anche questa può risonare un future ovviamente poi a cascata chi chiama perform deve fare await su perform e così quindi a cascata tutte le funzioni diventano asincrone e devono essere awaitate attese da qualcuno questo sì però la cosa bella è che abbiamo questo oggetto molto astratto che nasconde quello che avviene dietro le quinte questo per dirvi che quando voi vedete adesso faccio un esempio con C Sharp per esempio però quando vedete funzioni di libreria che fanno letture o scritture asincrone immaginate di avere di leggere un anzi facciamo un esempio con questo read file questo qui è una lettura asincrona in C Sharp scusate in .net avete varie funzioni per leggere i file chiaramente dentro system.io è il namespace che si occupa di scrivere leggere file così via gestire file ci sono varie che sono asincrone quindi per esempio file.readasync credo come questo genere read to end async comunque ci sono varie funzioni che permettono di leggere un file per intero in asincrono e ritorna esattamente un task con una array di byte o una stringa quello che è ora a noi sembra tutta una cosa molto innocua perché alla fine è una funzione ritorna un task e ritorna all'oggetto che ci interessa quindi noi lo chiamiamo facciamo await e ce ne infischiamo amabilmente però dentro la cosa bella che il runtime quindi .net fa esattamente questo il runtime è implementato sopra le win32 se siamo su windows e userà questa roba qui alla fine quindi qui dentro questa ci viene nascosto per fortuna non ci interessa usarlo però dentro .net userà input output overlapped registerà degli eventi rimarrà in attesa e farà in modo tale che il nostro task rimanga inchiodato rimanga bloccato finché l'evento di completamento di questa scrittura non viene sollevato a quel punto il task si sblocca diventa completato e il compilatore ha tutta questa infrastruttura in mano con cui può ripartire fare le partite di esecuzione da qui perché il task ha completato ok quindi in realtà tutta questa magia è gratuita perché ci viene data dal linguaggio e dal runtime però nascosto da questa bellissima pila di software che noi abbiamo scritto noi c'è questa roba brutta qui ok quindi questa esattamente come le Windows Forms ci danno un modo più elegante per usare le Win32 per fare le finestre è la stessa cosa quindi alla fine dei conti se andate a vedere il codice delle Win32 è delle Windows Forms è scritto in C Sharp però usa i concetti base delle Win32 quindi userà la Create Window che vedremo tra una settimana e così via quindi il sottobosco nascosto è questo qui però lo possiamo utilizzare in questa maniera più gradevole questa è l'idea ok e poi appunto vi sciso giusto questo è Dart quindi useremo questa forma qui non so se avete già esperienza programmazione asincrona perché appunto cioè leggendola così sembra abbastanza comprensibile immagino dovrebbe venire abbastanza naturale sappiate che però nasconde tutta una complessità che per fortuna ci viene appunto ci viene celata dal compilatore dal sistema dal runtime che fa molto molto lavoro per noi quindi questo è per quanto riguarda la sincronia quindi per tornare al concetto delle WinRT quindi le nuove API magiche che hanno stato promesse per Windows tutte le chiamate tutte le chiamate che potevano avere una durata di totti millisecondi erano sempre asincroni quindi cambiava proprio il modello quindi in Win32 e tutti i classici linguaggi di base è tutto bloccante poi se volete impegnarvi potete farle non bloccanti in Windows RT e in WinRT invece era tutto quanto asincrono e non bloccante per forza quindi proprio per sposare il nuovo modello di applicazioni fluide reattive e così via l'altra cosa che veniva così resa possibile con WinRT era il sistema di pacchettizzazione delle applicazioni e il sandboxing delle applicazioni adesso vediamo un secondo che cos'è e poi direi che facciamo una pausa per non svenire allora le applicazioni pacchettizzate anche qui non è una cosa moderna né rivoluzionaria però è l'idea per cui un'applicazione quindi come dicevo prima un'applicazione che potenzialmente è composta da tanti processi tante tanti eseguibili tanti file risorse e così via immaginate non so Photoshop una suite di applicazioni enorme sono vari giga di eseguibili perché internamente contiene non so quanti processi per ogni singola sottofunzione ha un processo dedicato ha 30 anni di storia per cui c'è una serie di accrocchi uno sopra l'altro ovviamente e così via tant'è che quando avviate Photoshop non so se avete avuto questa tragica esperienza avvia internamente anche vari server web non so perché lo faccia però dentro ha varie stanze di Node.js che vengono avviati e fanno delle cose misteriose che non voglio sapere cosa facciano però così quindi è una suite estremamente complessa che quando viene installata si porta dietro un sacco di oggetti tutti diversi per cui l'idea è che il sistema operativo abbia una nozione ad alto livello del pacchetto dell'applicazione quindi non soltanto l'applicazione quando la installiamo si porta dietro dei binari dei risorse e così via ma il sistema operativo sappia che l'applicazione tal dettaglio è composta da questo insieme di file e tutti quanti servono per farlo funzionare alla stessa maniera un'applicazione pacchettizzata può definire una serie di requisiti che le servono per funzionare quindi puoi dire per esempio la versione minima di Windows è la 8. quello che è e mi serve .net versione tal dettaglio e mi serve eccetera eccetera quindi puoi dichiararlo a prescindere quindi invece di lasciarsi installare e poi esplodere il runtime perché manca qualcosa il sistema operativo può dire ok questo non posso installarlo perché manca questo componente qui e eventualmente poi puoi installarlo quindi così una funzione che aiuta l'utente finale per gestire meglio il software e quindi durante il processo di installazione che poi a questo punto diventa un processo di installazione appunto pacchettizzato il sistema operativo può gestire in maniera più chiara questo appunto sempre per riferimento storico perché classicamente nei sistema operativi di anziana vetusta memoria l'installazione non era un concetto che esisteva ovviamente nel senso che per un sistema operativo io potevo prendere un binario metterlo dentro farlo eseguire oppure potevo compilare un codice sorgente per il mio sistema operativo e poi ottenevo un binario oppure scaricavo un pacchetto misterioso dall'internet e speravo che sperando che non avrebbe ristrutto la mia macchina e lo buttavo da qualche parte in qualche directory del mio computer mandando in esecuzione tutti questi strumenti quali siamo abituati comunque usando Windows che ancora funziona in questa maniera prevalentemente sono un po' appunto un po' obsoleti quindi l'idea è quella di dare al senso operativo il concetto proprio di avere un'installazione come pacchetto poterlo installarlo e poterlo anche rimuovere in maniera pulita successivamente ok questa è l'idea dicevo prima questa idea non è assolutamente nuova perché chiaramente ne esistono vari esempi anche in storia non recente quindi l'esempio classico è dpkg apt tutti i sistemi di gestore di pacchetti di Linux che forse avete utilizzato apt-get e così via aptitude e quant'altro che alla fine sono lo stesso sistema delinato in vari modi che permettono di installare pacchetti cioè applicazioni pacchettizzate in maniera abbastanza pulita rimuoverle senza andare a rompere tutto e così via questa idea che appunto non è nuova finalmente viene trasposta anche ad altri sistemi operativi il primo sistema operativo per end user che lo ha fatto è macOS che da tempo ha questa idea di pacchetti che possiamo copiare e installare cioè installare copiando il pacchetto intero sulla macchina e poi quello funziona senza che rompa nulla e cancellare il pacchetto cancellando il pacchetto fine quindi ha un sistema molto primitivo tra virgolette di gestione delle applicazioni pacchettizzate ma è molto funzionale Windows non ce l'ha mai avuto solo nelle ultime versioni finalmente si sta introducendo piano piano qualcosa del genere ecco qui questo è quello che vi ho detto un secondo fa che i sistemi operativi vecchi non hanno il concetto di installare un applicativo quindi non c'è proprio nessuna funzione standard che lo può fare per cui quello che noi riconosciamo come installazione e disinstallazione nel mondo Windows in genere sono degli eseguibili un po' magici mistici con dei pulsanti avanti avanti avanti fine che fanno delle operazioni nascoste a noi completamente opache quindi vanno a copiare file cambiano il registro spostano cose installano altri runtime e così via nella speranza che non rompono nulla poi possono rompere tutto perché in genere eseguono da amministratore eseguono con permessi elevati quindi sulla carta possono anche distruggere qualsiasi cosa che loro vogliano e ci lasciano in genere l'applicazione installata e poi c'è un eseguibile no speculare che è la disinstallazione che è ugualmente un eseguibile sempre che gira da superutente che va a rimuovere l'applicazione installata però anche lì bisogna fidarsi del fatto che non faccia danni questa cosa è una promessa di chi ha sviluppato l'applicazione ma è una promessa che può essere tranquillamente non mantenuta tant'è che spesso poi la disinstallazione è parziale non toglie veramente tutte le informazioni non è pulita a volte fai danni e così via quindi questa cosa qui esiste da da 30 anni e non è assolutamente ideale nei sistema operativi moderni appunto questa cosa si può fare in maniera componentizzata e quindi si può fare in maniera affidabile con tutte le dipendenze del caso e così via non me la vengo troppo lunga giusto per dare degli esempi però chiaramente per permettere di fare questa cosa un'applicazione pacchettizzata deve dichiarare come è composta a priori deve in qualche modo dare una dichiarazione astratta dei componenti che richiede e di quello che si porta dietro in Android questa cosa prende la forma del Android App Manifest che è un file XML che vive nel pacchetto stesso i pacchetti sono cerchetto qui sotto sì i package gli Android in Android ci sono questi pacchetti che si chiamano gli Android Package che sono gli APK come estensione in genere sono degli zip alla fine dei conti sono degli zip ripuliti con tutto il codice le risorse e il manifest al suo interno che permettono al sistema operativo di capire che cosa c'è dentro e di installarli e rimuoverli in maniera pulita il manifest dichiarà anche quali sono i permessi che l'applicazione richiede che cosa andrà a fare come esporla all'utente quindi l'icona il nome tutte queste belle cose quindi permettono al sistema operativo di avere una visione dell'applicazione come appunto un pacchetto a sé stante stessa cosa vale per come dicevo prima per tutto il bellissimo mondo di Debian Ubuntu e così via dove c'è da tempo in memore il pacchetto DEB che è il pacchetto di distribuzione dei binari per sistemi Debian che funzionano tramite dpkg apt, apt-get apt-tut e così via che appunto hanno una lunga storia per cui si poteva fare da tempo evidentemente nel mondo iOS si usa un information property file list che è il famoso info.plist che è il corrispettivo del manifest per iOS fa più o meno la stessa cosa e dentro WinRT quindi Windows Runtime si usa l'app package manifest che ha questa funzione questo nome qui quindi l'estensione app x manifest che è sempre un file XML che dichiara i suoi contenuti e si può poi le applicazioni sono dei cosiddetti app x quindi vivono dentro un app x bundle che è questo è un grosso zippone che di nuovo comprende tutto l'applicativo che può essere installato tramite Windows Store o Windows Package Manager che è diciamo così la copia di apt.get che per Windows che si chiama in maniera molto originale si chiama WinGet che esiste si può usare ma non è che sia particolarmente popolare però se se volete sperimentare potete installare una buona componente cioè molti software in questa maniera con WinGet da riga di comando WinGet quello che volete spesso funziona ok una volta che abbiamo le applicazioni pacchettizzate quindi possiamo gestirle in maniera più comoda quindi possiamo dichiararle una volta una volta per tutte installarle rimuoverle gestirle in maniera più comoda dal lato del seno operativo possiamo anche sandboxarle allora il sandbox in inglese è la come si chiama la conca di sabbia dei bambini dove giocano quindi dove possono ridursi in maniera impresentabile coprirsi di sabbia e fare tutto il disastro che vogliono e che poi li prendi li pulisci con il tubo dell'acqua e tornano come nuovi questa è l'idea senza che possano andare a rompere le cose al di fuori della sandbox ok quindi questa è un po' l'idea un po' il box dei bambini quindi è un ambiente sicuro che limita le capacità e i danni che può fare un'applicazione in esecuzione e quindi limita le interazioni tra applicazioni parallele quindi processi in esecuzione sulla stessa macchina e anche le interazioni col sistema operativo quindi limita alcune cose che di norma le applicazioni potevano storicamente fare senza limitazioni per cui per esempio possono esserci dei limiti sull'accesso ai dati limiti all'accesso delle feature del sistema operativo qui l'esempio più classico sono le applicazioni per Android che quando devono accedere a dei file vi devono chiedere il permesso quindi compare il pop up che vi chiede ma l'applicazione può accedere ai suoi file si no può accedere al GPS si no e così via o la fotocamera e quant'altro l'utente può garantire questi permessi in maniera esplicita se richiesto quindi ha una diciamo così riconosce che l'applicazione sta facendo qualcosa quindi può decidere se l'applicazione è degna della fiducia no e può fare queste cose questo perché appunto finché l'applicazione rimane nella sandbox tutte le sue chiamate tutte le sue chiamate del sistema tutte le sue le sue interazioni con il sistema operativo vengono filtrate attraverso la la garanzia di questi permessi quindi di base se il permesso non è stato garantito l'accesso al GPS per esempio ritorna sempre no ritorna sempre no bloccato e non ritorna i dati se l'utente ha sbloccato i permessi a quel punto le funzioni che permettono l'accesso al GPS per esempio funzionano come dovrebbero ok quindi l'applicazione può essere bloccata sul le sue attività possono essere bloccate sul nascere per impedire che accedano ad alcune funzioni e alcuni file isolano le applicazioni l'una dall'altra questo è abbastanza fondamentale nel senso che i processi di norma sulla stessa macchina in un sistema classico quindi Windows anche Windows moderni si possono parlare quindi un'applicazione qualsiasi sulla macchina può andare a leggere la lista di processi questo lo può fare e può ucciderli anche non c'è nessuno che vi impedisca di farlo potremmo anche provarlo poi lavorando con le Win32 c'è un sistema che vi permette di per esempio avere la lista delle finestre su schermo quindi la vostra applicazione ha una nozione può andare a scorrere tutte le finestre che sono su schermo e può chiuderle tranquillamente quindi qualsiasi applicazione di esecuzione sulla vostra macchina in Windows classico può chiudere le finestre può chiudere i processi può fare qualsiasi cosa essa voglia perché le applicazioni di Win32 non sono sandbox in alcun modo vivono in questo ambiente di Windows e possono fare bene o male quello che vogliono che chiaramente le rende molto potenti perché chiaramente possono fare cose anche possono andare a fare screenshot di applicazioni possono copiare applicazioni possono gestire altre applicazioni possono fare delle cose di sistema magari che ci sono utili però possono anche fare ovviamente molti danni sulla carta quando un'applicazione è sandboxed quindi viene isolata dal resto del mondo e quindi non ha accesso a queste capacità di base giusto per farvi anche qui un esempio in Android questo viene fatto in maniera molto di basso livello in Android se avete visto cioè il modello di sicurezza di Android di base di Android di Linux prevede che ci siano degli utenti sulla macchina sulla stessa macchina abbastanza c'è più utenti e questi utenti hanno permessi che non si intrecciano quindi ogni utente ha permessi sui suoi file sui propri file sui propri processi ma non può accedere a quelli degli altri di base di norma per cui in genere quello che fa Android in maniera abbastanza furba è che ogni applicazione installata sulla stesso dispositivo mobile sul stesso smartphone ogni applicazione corrisponde a un utente separato quindi stranamente diciamo così sfrutta questo meccanismo degli utenti di Linux non per isolare utenti diversi dello stesso smartphone anche perché lo smartphone in genere si usa con un solo utente raramente ci sono più utenti che toccano finestre diverse della stessa macchina però si usa questo scamotage perché si crea un utente nuovo per ogni applicazione installata quando è installata un'applicazione su Play Store la installate viene creato un utente anonimo astratto così quello ha la proprietà dell'eseguibile dell'applicazione e poi quell'applicazione gira con i promessi di quell'utente lì e quindi di suo di norma per come è fatto Linux non avrà mai accesso a tutto quello che riguarda le altre applicazioni perché sono utenti diversi quindi non possono mai parlarsi se non attraverso il sistema operativo che poi potrà decidere se fargli fare qualcosa o meno e questa è l'idea in sostanza ok quindi questo per quanto riguarda la sandboxing che sono appunto gli elementi che venivano introdotti da Windows RT qui adesso chiudo poi facciamo la pausa perché tutto doveva confluire questo era il piano del nuovo Windows in qualche modo doveva confluire in questo sistema che con Windows 10 è stato ribattezzato poi come Universal Windows Platform quindi una piattaforma nuova parallela alle Win32 che chiaramente rimangono qui e non si schiodano le Win32 come al solito permettono di fare applicazioni che vivono sui PC classici Windows però visto che poi il il parco macchine di Windows si era steso con Xbox i visori altri oggetti mistici e così via per programmare questi si erano inventati questa piattaforma nuova e sfavillante che veniva programmata con una serie di strumenti software nuovi che prendono il nome di che ci permettono di creare delle UVA delle Universal Windows Applications questo piano non ha funzionato in maniera proprio perfetta per cui diciamo così non è mai approdato non è mai diventato una cosa che funzionasse purtroppo per cui questa cosa esiste se volete sviluppare per Windows quello che potete fare è o usare le Win32 se vi volete veramente molto male o provare a usare gli strumenti nuovi del UVP e UVA per fare qualcosa di più moderno però sappiate che questa piattaforma moderna e sfavillante tuttora spesso non riesce a fare tutto quello che le Win32 permettono di fare purtroppo per cui si prego sì sì diciamo così storicamente era nato all'epoca di Windows Phone e quant'altro come terza opzione Android iOS e Windows Phone che doveva con questo sistema qui di universale permettere di creare applicazioni che fossero compatibili per smartphone e per PC alla stessa maniera quindi era all'epoca come? Backslash è un approccio successivo di cui parleremo che permette di fare applicazioni multiplattaforma però era proprio non era multiplattaforma quindi era solo per la previsione Windows che però potrebbero vivere sia su smartphone quindi Windows Phone sia su PC classici quindi con interfaccia abbastanza flessibile e dinamiche e sia su Xbox che su HoloLens che c'è eccetera sulla carta e qui questa cosa è ancora tecnicamente possibile quindi si può fare un'applicazione che gira anche su Xbox e si sblocca l'Xbox in qualche modo e si fa girare un'applicazione UVP questo funziona sulla carta però queste applicazioni qui sono molto limitate perché è Grazie. Grazie. Grazie. Grazie.