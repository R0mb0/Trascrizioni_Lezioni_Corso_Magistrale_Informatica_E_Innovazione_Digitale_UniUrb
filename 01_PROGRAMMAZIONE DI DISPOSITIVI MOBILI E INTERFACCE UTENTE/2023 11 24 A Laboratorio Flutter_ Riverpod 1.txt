ripartiamo da dove siamo arrivati la volta scorsa, ieri, e avevamo visto una serie di modi con cui andare a gestire la grafica della nostra interfaccia, quindi questo abbiamo visto con un certo dettaglio, le colonne, le righe, lo stack e così via, adesso in realtà ricancelleremo tutto, perché tutte quelle cose che abbiamo creato non erano praticamente interessanti dal punto di vista grafico, per cui andiamo a cancellare tutto, la nostra applicazione era in questo stato qui, il body dello scaffold era, conteneva la parte importante del grafico, togliamo tutto, eccetto il padding più esterno, quindi qui togliamo tutto, qui chiaramente se volete salvarvi il file da qualche parte ben venga, però per il resto non ci serve, dal center in poi togliamo tutto e finalmente proviamo a implementare la nostra famosa applicazione per la lista delle cose da fare, quindi l'idea è proprio quella di avere una applicazione in cui qui dove c'è adesso il ciao ci rimettiamo l'iconcina, l'iconcina per il più dove vogliamo che cliccandoci non incrementi il contatore ma si aggiungano nuovi elementi alla lista delle cose da fare, poi comparirà anche autocomplete, no, ok, va bene questo immagino, ok e metteremo questa lista appunto di cose da fare in interno. Allora quindi lo stato interno della nostra applicazione è una lista di cose, quindi una lista di cose da visualizzare e mostrare a schermo. Andiamo a attimo come si può implementare questa cosa in Dart perché classicamente quando andiamo a memorizzare dello stato interno abbiamo bisogno di alcune classi di supporto che ci aiutano a rappresentare lo stato, quello che in gergo si chiama il modello, il modello della nostra applicazione sono le varie classi di supporto che ci permettono di impacchettare o incapsulare in qualche modo lo stato che gestiamo, e trattandosi di un'applicazione che gestisce delle cose da fare, iniziamo subito creando un oggetto, cioè una classica che si chiama, quindi il nostro oggetto fondamentale è questa cosa da fare. Sono paddini, sì, qui adesso al momento non funziona neanche, ho messo un null giusto per, anzi, lasciamolo compilare, quindi metto un size box così almeno è valido. Ok, quindi... Ok, quindi... E anche il padding in realtà potrebbe essere all... Vogliamo essere... Quindi ho tolto tutto in sostanza, c'è solo... Vabbè, il padding c'è ma giusto per dare un po' di bordino, e per il resto mi aspetto che non ci sia... Nulla di rispetto. Vediamo se... Ok, quindi è più o meno questo. Allora, vi sto dicendo, appunto, creiamo il modello della nostra applicazione, quindi creiamo una sette classi che ci permetteranno di memorizzare i nostri dati. Dentro lib creo una cartella che si chiama models. Qui sono mille button con cui potete poter strutturare il codice, quindi adesso questa è un'idea, poi fate chiaramente come volete. Però in genere è buona norma avere una cartella o qualche ambito della vostra applicazione in cui mettete proprio i modelli base della vostra applicazione. To do item lo chiamerò. Dart, ok. E questa è una classe che impacchetta un oggetto di una cosa da fare. Quindi avrà un nome, un titolo, no? Quindi, che ne sa fare il bucato. Avrà una spunta che mi indica se l'ho fatto o meno, quindi ci sarà un booleano che dice fatto o non fatto. Puoi, possiamo metterci una descrizione opzionale, magari, no? Possiamo aggiungere dei dettagli, se vogliamo. E infine, per nostra comunità interna, ci metteremo anche un id univoco. Questo ci servirà non tanto perché poi viene messo all'utente, però in genere, no? Quando lavoriamo con dei dati che poi immaginiamo di dover memorizzare su un database o qualcosa del genere, quel dato plausibilmente avrà un id, no? Che nel caso del database sarà un intero autoincrementante o qualsiasi altra cosa. Quindi, in genere, può aver senso avere questo altro campo. Quindi, il nostro to-do item sarà class, ovviamente. Ok? Ci mettiamo dentro questi oggetti, questi campi, quindi il titolo. Qui notate che sto usando, sono tutti final, quindi come da... Come viene dettato... Come consigliato in Dart, faremo una classe modello che è immutabile, quindi non possiamo modificarla. Una volta che è stata creata, rimane tale quale. Final build done. Final string description. Quindi la descrizione che magari possiamo prevedere che sia opzionale, quindi la metto nullable. Ok? Quindi può essere o può anche non esserci. E infine serve questo id di cui parlavo, può essere o un intero o qualcos'altro. Noi direi che useremo un id, un guid, quindi un id auto globale a livello unico, poi potremo congelararlo, quindi sarà una stringa comunque. Però anche qui, se usarete un db o qualcos'altro, può aver senso avere un intero come stringa. Questo è completamente arbitrario, veramente. Ops. Quindi questo qui, devo servirci o no? In che senso servirci? Nel senso, l'id ci serve? L'id serve a noi internamente per capire quell'oggetto lì rappresenta quella cosa da fare, in particolare. Quindi immaginiamo che ci sia un database, a un certo punto immaginare, adesso non c'è chiaramente, però immagineremo, ci sarà a un certo punto un database che mantiene la lista delle cose da fare, l'id ci deve fare, come avete sicuramente visto al corso di manche dati e così via, l'id è la chiave primaria e quindi ci permette di identificare in maniera onivoca l'oggetto nel database ed è comodo averla perché possiamo fare delle query in realtà. Adesso sto già ragionando, pensando al database, che non è mai una buona idea, in genere parlando, il modello deve essere astratto come concetto, però è chiaro che viene lievamente sporcato da quello che poi dovremo andare a farci, per cui nell'ipotesi di doverlo mettere in un db, posso immaginare che ci sarà un id. In realtà questo vale sia che sia in un database locale, l'oggetto, sia che viva nella rete in realtà, perché se parliamo con un server nostro che traccia delle cose da fare, anche in quel caso, in genere, quando creiamo un oggetto, tu alla fine avràs un id che lo identifica in qualche modo, quindi in genere sia che lo storage sia locale su un database, sia che sia remoto da qualche parte della rete, alla fine questi id qualcuno dovrà assegnarcelo, quindi questo vale un po' per tutti i scenari. A questo punto manca soltanto il costruttore, come ci segnala anche Flutter, il costruttore sarà un costruttore const, per sfruttare il fatto che appunto sono tutte cose immutabili. I primi tre sono obbligatori e l'ultimo, la descrizione è opzionale, quindi può essere tranquillamente null. Qui possiamo anche mettere, ce la possiamo mettere esplicitamente, ma non serve, quindi possiamo lasciare così. Ok, e questo è il nostro modello di base. Nulla di più semplice. Ora, nel nostro, ah, un'altra cosa che, qui dicevo questo, questo oggetto che questi id qui, è un id, useremo questi guid, non so se è una cosa che avete già visto sicuramente, i guid sono questi identificatori univoci a livello global, quindi global e unique identifier, che hanno questo aspetto molto leggibile come questo. Sono, sono di, quanti, non mi ricordo, sono tanti bytes, per cui il fatto che vengono generati seduto casualmente, assicura che ogni guid sia, ah, grazie mille, 18 bits di, di dati, per cui c'era una garanzia, non al 100%, ma abbastanza, abbastanza, elevata, che siano veramente unici nell'universo, no, perché è impossibile generarne due identici, per cui, molto spesso si usano, proprio per questo motivo, e, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, che ci permette di generare questi, questi, questi, si chiamano sia guid che, che uid, a seconda del, di quale, a programma preferite, uid è, uniquely, no, è universal, unique identifiers, e, mentre guid è globally uniquely identifiers, quindi uid è più, più, su scala, più universale, piuttosto che planetaria, ma cambia poco. Ok, allora, proviamo, proviamo finalmente a installare un pacchetto, da pub. Quindi ci serve questo pacchetto qui, che ci fornisce gli strumenti per generare questi guid nel nostro codice, un pacchetto molto piccolo questo, è un pacchetto per Dart, che viene un pacchetto per Flutter in particolare, questo pacchetto si può usare sia che si usi Flutter, sia che non si usi Flutter, quindi è semplicemente un, del codice che in, in, in, in Dart ci permette di creare questi, questi, questi guid andando a costruirli in questa maniera qui. Questi alla fine sono convertibili in una stringa, quindi è molto comodo utilizzarli. Come si instano un pacchetto? Allora, si copia, qui sopra c'è un'iconcina trasparente, che ci copia il nome del pacchetto, su PubDev, e la versione attuale. Quindi basta cliccare qui, poi andiamo nel nostro Visual Studio, e facciamo PubSpec qui, e tra le dipendenze aggiungiamo la dipendenza aggiuntiva. Quindi qui sotto aggiungo, cioè incollo a tutti gli effetti, la stringa che mi ha generato il sito. Quindi non devo fare assolutamente nulla, è tutto automatico. Lo potete mettere dove volete, qui le dipendenze sono, cioè alla fine l'ordine è arbitrario, quindi mettetele come volete, conviene metterle in fondo. E qui non so se avete confidenza con questi tassi qui, questo significa che il nostro pacchetto, il nostro Package Manager, insalderà la versione 4.2.1, ma se ci sono versioni più aggiornate rispetto alla 4.2.1, con questo accento circonflesso davanti, gli diamo il permesso di prendere una versione più aggiornata fino alla prossima versione Major. Quindi fin tanto che inizia con 4, va bene. Perché l'idea è che quando cambia il primo numero della versione, questo è il semantic versioning, se avete con... anche qui. È un paradigma di versionamento che si chiama appunto Semver, o per gli amici Semantic Versioning, per cui l'idea è che abbiamo versione maggiore, versione minore, versione di patch, maggiore, minore e patch. Se c'è un breaking change, quindi qualcosa che cambia radicalmente, bisogna modificare la versione maggiore, in sostanza. Quindi noi abbiamo la garanzia che fin tanto che cambiano i numeri inferiori, non dovrebbero imparsi nulla. Al limite sono migliorie, ma non rimangono compatibili da loro. Poi è una garanzia così. È una speranza, perché è una garanzia. Però per questo c'è questo centri conflesso, per cui qui, se ci sono aggiornamenti, qui potrebbe tranquillamente includere 422, 431, ecco così. Ok, per far... Ecco, vedete qui, appena ho salvato, viene lanciato PubGet, perché viene scaricato il pacchetto. Questo lo fa in automatico. E per far comparire il pacchetto qui dentro, a questo punto non basta avere un altro restart, un altro reload, perché bisogna ricompilare l'applicazione, chiaramente. Perché altrimenti il pacchetto non viene compilato dentro il vostro APK di Android. Per cui quello che bisogna fare, in questo caso, quando si modifino i pacchetti, è terminare l'applicazione con Q della riga di comando e rilanciarla. Ok? Quindi che solito lo lasciamo fare, altrimenti il pacchetto non compare. Chiaramente potete comunque lavorare, lavorando, usando il pacchetto, però poi a runtime esplode, perché non trovo, non ho fatto modificare il suo genere, ricordatevi di fare, di rilanciare l'applicazione nella sua interezza. Ok, torniamo qui. Mentre il nostro compilatore fatica, gestiamo questo stato. Quindi, come al solito, adesso prima di introdurre RiverPod, introdurciamo poi i fondamenti. Quindi, da qualche parte, dobbiamo mettere la nostra lista delle cose da fare, per cui, dove la mettiamo, dentro un widget che gestisce lo stato. Il nostro, la nostra homepage è il candidato ideale, che al momento conteremo questo contatore, adesso semplicemente conterrà una lista di cose da fare. Ok? Quindi, qui facciamo list di to-do item. Ok? E ci mettiamo to-do items. Cosa di altro. Anzi, facciamo questo tipo così. Questo va importato. Ok, quindi, di base, ovviamente, i due item sono vuoti. Il nostro increment counter non ha più molto senso, per cui, creeremo una class, un metodo, usato, diverso, che si chiama add item. Ok? e ci possiamo mettere, magari, possiamo farlo da fuori questa informazione, vi è il titolo e descrizione. Quando andiamo qui a modificare il, andiamo a creare, è stato un oggetto nuovo, quindi andiamo a creare new to-do item e lo creiamo con il costruttore che conosciamo. Questo costruttore quindi prende almeno tre elementi, l'id ancora non lo sappiamo, lo facciamo tra un secondo, poi il titolo ci viene dal metodo. Done sarà false, quindi ci aspettiamo che quando aggiungiamo un nuovo elemento da fare, questo non sarà fatto ancora, no? Quindi questo è... mettiamo a false, qui poniamo description che può essere nulla, ok? Ci manca solo questo id che tra un secondo popoleremo e a questo punto lo aggiungiamo alla lista e lo facciamo dentro setState. Quindi facciamo setState, ok? E aggiungiamo a to-do items add new to-do items. Ok? Quindi sto segnalando a Platter che guarda, attenzione, questa lista, cioè il mio stato interno è modificato perché ho aggiunto un elemento e a quel punto ricostruiamo l'interfaccia e poi ci aspettiamo che venga visualizzata il nuovo to-do item. Ok, come si usa UID? Un attimo che vediamo se ha compilato. Ok, qui è partito, perfetto. Allora, UID, la libreria, deve essere instanziata da qualche parte e lo facciamo qui sopra. Questo verrà un po' strano, ma è così che si fa. quindi qui creiamo un oggetto UID che non è altro che diciamo così l'entry point tra virgolette della libreria, questo UID costante. Lo importiamo dalla libreria, questo ve lo fa tutto quanto questo studio, quindi non dovete fare, lo capisce da solo a dove viene UID. Importiamo il pacchetto. Questo UID a questo punto è l'istanza della classe che vi dà accesso ai vari UID univoci unici e così via che possono essere utilizzati. A questo punto qui dentro nell'add item qui invece di fornire stringa vuota vado a riferirmi a UID e qui vedete che ho vari V qualcosa che possiamo utilizzare per generare i vari GUID perché esistono vari algoritmi per generare questi GUID e sono tutti, hanno garanzie diverse di unicità e così via non è veramente rilevante. Quello più classico e casuale è il D4 che nel nostro caso va benissimo. Quindi chiamo P4 su UID e questo torna una stringa che rappresenta lo UID. Tra l'altro magari una cosa che potrebbe essere utile per il debug più che altro è mettere un override qui il QString lo può rifare non lo fa ok quindi qui metto un ToString così che quando faccio il debug print di un oggetto ToDoItem poi vedo in qualche modo cosa continua altrimenti mi stampa solo il nome della classe se non c'è il ToString override stampa solo il nome della classe che non è molto utile quindi qui ci mettiamo l'ID o tra parentesi magari id e poi due punti title title e poi mettiamo senza parentesi non so cosa cosa per senso e poi ci mettiamo se è done meno qui per scrivere questa cosa mettiamo done torna un sintassi un po' arcana ma quello possiamo usare anche degli emoji perché abbiamo chi sa come verrà stampato non lo so ecco su Windows tasto Windows punto non che sia utile mettete done e not done va benissimo uguale e dato non so se poi la console accetterà con gioia questi questi caratteri lo vediamo per un secondo ok quindi qui nel quando aggiungiamo un nuovo elemento lo posso anche stampare sto aggiungendo NewSuitItem ok quindi mi aspetto che questo compagni ok questo add item qui lo dobbiamo collegare a un pulsante cliccabile quindi questo lo togliamo e lo collego a questo on pressed qui che è l'on pressed di cosa? del pulsante floating button quindi questo più uno qua no? questo è questo codice qui è il pulsante che mi mette a on pressed non ci posso più collegare in creme tanto perché l'ho cancellato e soprattutto secondariamente perché quel metodo non perdeva parametri e quindi devo richiamare invece il metodo add item che ha due parametri opzionali cioè un parametro e un parametro opzionale scusate faccio add item e al momento ci scrivo sempre la stessa cosa quindi ci metto lore ipsum ok metto il codice una seconda adesso faccio l'altri start vediamo semplicemente se il codice è giusto e se lo stampa e poi vediamo ok ok quindi l'emoji c'è non è bellissimo però funziona ok quindi abbiamo una nostra lista che viene generata vedete che qui vengono generati degli id sedocasuali che sono unici si può supporre quindi adesso dovremmo avere 5 elementi chiaramente ancora non li vediamo perché non c'è nessuno che mostri lo stato però tra un secondo lo facciamo ce lo aggiungiamo altra cosa giusto per competenza una cosa che può essere utile qui avevamo questo pulsante adesso non fa più niente potrebbe essere buona idea collegarlo a un no cancello tutte le cose da fare cioè rimuovi la lista quindi banalmente non press qui ovviamente qui magari mettiamo un'icona più significativa non so se esiste qualcosa del genere si non so che aspetto abbia non è importante e qui dentro metto direttamente set state e faccio items faccio clear e basta ok quindi qui creo e svuoto la lista chiaramente qui qui chiamo un metodo che lo fa per un conto mio qui chiamo le test state perché sono dentro lo state comunque in ogni caso quindi cambia poco è solo un po' meno elegante magari però in questo codice qui sto mescolando stato e grafica chiaramente che non è mai una buona idea tant'è che è vero che classicamente si fa così perché se si lavora con state full widget bisogna fare così per forza perché abbiamo un widget che continua lo stato quindi necessariamente avrà stato collegata con driver pot andremo a districare questa cosa e fare in modo che queste due cose non si tocchino però per ora lavoriamo in questa maniera un pochino sporca se si può dire in qualche modo ok a questo punto dentro dobbiamo mostrare questi to do items giusto in qualche modo per cui che cosa facciamo intanto mettere metteremo una colonna qui nella dell'interfaccia principale qui del body metteremo una colonna vogliamo occupare tutto lo spazio possibile qui in alto con la lista che cresce e poi sotto mettiamo un testo che ci mostra quanti oggetti ci sono ok questa è l'idea e quindi quello che adesso qui per ragionare i termini di flutter è come facciamo e come fareste a fare questa cosa qui mettere solo un elemento espanse sotto l'elemento piccolo cosa usereste una colonna giusto una colonna verticale dove il primo elemento usa il widget expanded che lo allunga e poi sotto mettiamo un elemento che poi sappiamo che verrà messo un po' ok quindi facciamo questa cosa qui qui mettiamo una colonna che avrà una serie di figli adesso poi li aggiungiamo prima di metterci figli mettiamo specifichiamo come funziona la colonna quindi vogliamo che si espanda completamente in verticale sarebbe il main axis size di default è comunque max ma per essere espliciti lo mettiamo a max quindi la colonna prenderà tutto lo spazio disponibile da sopra a sotto chiaramente si trova dentro il padding quindi ci sarà comunque uno spazietto vuoto bianco che lo rende accettabile allo sguardo umano poi vogliamo che qui sull'asse principale in realtà l'animento non sarà importante perché c'è un elemento che si espande e l'altro che non si espande quindi in realtà questa cosa qui possiamo specificarlo o meno non cambia nulla quindi non lo specifico sulla cross axis invece quindi sull'orizzontale io voglio che tutti gli elementi prendano tutto lo spazio disponibile quindi metteremo stretch ok se non mettessi stretch tutti gli elementi potrebbero avere dimensioni diverse e quindi magari avremo un aspetto un aspetto un po' brutto in cui gli elementi si spostano in maniera imprevedibile magari proviamo anche a vedere cosa succede però con stretch siamo sicuri che tutti gli elementi vengono allungati da sinistra a testa sempre quindi hanno la lunghezza intera ok mettiamoci intanto l'expanded poi andiamo avanti quindi il primo elemento prende tutto lo spazio disponibile quindi ora metto null e poi sotto ci mettiamo un piccolo testo che mi dice quanti to do item abbiamo quindi metto un text e ci scrivo ho che cosa ho x cosa da fare dove x è la lunghezza della lista quindi abbiamo una lista che è to do items e questa è una proprietà che si chiama length che mi dà il conteggio quindi ho x cosa da fare punto questo non può essere const perché varia chiaramente e a questo punto qui dentro dobbiamo creare un un oggetto in qualche modo che che contiene una rappresentazione di tutti i vari to do item che abbiamo questo è un inizialmente dell'experto esatto esatto quindi al momento qui non c'è nulla magari c'è un size box giusto per per farlo partire adesso qui lo stato rimarrà per cui ho comunque cinque cose da fare perché nella memoria lo stato c'era ancora c'era ancora cinque elementi dentro la lista quindi qui compare ho cinque cose da fare qui se clicchiamo questo cresce e questo cancella quindi questo funziona ora manca soltanto quello che ci interessa veramente quindi il blocco centrale vi faccio vedere giusto per completezza due modi per fare la stessa cosa perché così c'è utile poi per quando parliamo di scrolling quindi diciamo così se volessimo mostrare una lista di elementi verticale di nuovo ci viene in mente la colonna chiaramente per cui di base se pensiamo a una serie di crescenti elementi possiamo immaginare che sia una colonna questo può andar bene ma non è ideale nel caso delle liste che possono crescere molto tra un secondo vedremo perché però immaginiamo di lavorare quelle colonne facciamo column di nuovo quindi dentro colonna c'è un'altra colonna di elementi che rappresentano questi to do item ora per portarmi avanti qui visto che mostrare un to do item a schermo è una cosa che la nostra applicazione farà in tante occasioni quindi lavorando con quello è ovvio che lo faremo più volte quindi già ci viene subito cioè abbastanza banale fare un widget a sostante che prenda un to do item quindi prenda un modello un'istanza di to do item e lo mostra in schermo quindi ci viene il nostro elemento della lista esatto quindi l'idea che prende un elemento della lista cioè un'istanza di to do item e poi lo mostra quindi il parlamento sarà un widget che nel costruttore prende un to do item e poi internamente lo mostra è un widget stateless perché non ha stato interno se non per lo stato con cui viene costruito quindi è un widget molto semplice che prende e mostra un oggetto fine ok per cui per fare questa cosa qui anche qui per fare questi widget riciclabili che ci possono servire in varie occasioni in genere è buona norma fare una directory dedicata che non ha creato giustamente ok e la chiamiamo widgets qualche cosa chiamarla in vari modi ovviamente e qui lo chiamiamo to do item viewer o display o quello insomma il nome può essere arbitrario chiaramente questo sarà un viewer sarà uno stateless widget stateless widget lo importiamo da uguale stiamo usando widget sta benissimo qui come siamo abitati a fare facciamo l'overwriting automatico e poi diciamo di creare il costruttore const subito va bene come dicevo prima che cosa prende in input questo oggetto prende in input to do item quindi facciamo final to do item e lo chiamiamo item qui va importato to do item qui sono andato relativamente veloce per cui se c'è qualcosa che non torna fermatemi subito il costruttore prenderà obbligatoriamente l'item per cui non può essere costruito senza un oggetto visualizzare ok per cui prevediamo che sia obbligatorio la chiave è opzionale e a questo punto bisogna semplicemente implementare la la la la la visualizzazione di questo di questo oggetto ok ieri abbiamo visto l'ho cancellato però ieri abbiamo creato un oggetto che era vagamente complesso era quel container viola con lombraggiatura verde con altre scelte estetiche di questa natura per faremo una cosa molto simile quindi andiamo a creare un oggetto che ha l'aspetto link quindi alla fine è un container che include una serie di elementi più o meno sofisticati il container ci dà il bordo il margine il padding se volete possiamo avere un'ombreggiatura così gradevole uno sfondo e così via cioè sono tutti gli elementi grafici che servono per rendere visibile il to do item come se fosse una specie di carta sovrapposte di le carte di android che sono vagamente gommose sovrapposte all'ombreggiatura sullo schermo in realtà per far prima potremmo utilizzare alcuni widget pronti di material design perché c'è proprio l'oggetto il widget tile che fa esattamente questa cosa qui però funziona in maniera un po' diversa perché adesso andremo ad implementarne uno che ha un aspetto simile ma un funzionamento così che è adattato alla nostra esigenza di mostrare un to do item per cui in questo caso la nostra build la prima cosa che farà come al solito qui per per comodità metto building this e ci metto anche l'item quindi stampiamo in debug che stiamo costruendo un oggetto così poi apprezziamo nei casi in cui riusciamo a ottimizzare le build che sia sempre utile avere il bug print qui il nostro widget custom e poi torniamo cioè il primo oggetto che torniamo è un container questo capita molto spesso di base il container è sempre il vostro widget numero uno perché vi dà la possibilità di personalizzare graficamente l'oggetto ok allora a questo punto immaginiamo di avere una specie di carta ricordate che ieri abbiamo usato decoration per dare un aspetto grafico al nostro oggetto quindi facciamo la stessa cosa box decoration lo decoriamo in qualche modo lo faremo dopo e poi come figlio diretto andiamo a metterci i dati quindi adesso immaginiamo come posso rappresentarlo questo schermo vabbè immaginiamo di rappresentare questo oggetto quindi abbiamo fondamentalmente abbiamo un titolo una descrizione forse una spunta e poi l'id che però in realtà non vogliamo mostrare l'id è brutto non è molto leggibile quindi lo nascondiamo quindi abbiamo tre oggetti la checkbox sarà a sinistra quindi la spunta per mettere il done titolo e descrizione saranno impilati a destra quindi abbiamo una colonna piccola a sinistra una colonna a destra più ampia e poi all'interno di descrizione sono incolonnato di nuovo quindi per fare questa cosa qui ci serve una riga per mettere a sinistra la spunta e a destra il testo ok questa riga si il suo main axis è orizzontale e vogliamo che prenda tutto lo spazio quindi max e size sarà max di nuovo e cross axis questo è l'avviamento verticale cross axis sarà start che voglio che tutti i elementi vengono spostati verso l'alto ok se necessario children qui dovete poi immaginarla chiaramente poi chiaramente lo adatteremo se qualcosa non torna lo adatteremo poi alla bisogna basta quello che abbiamo i figli cioè quindi la riga è a sinistra la spunta quindi qui ci metto checkbox checkbox che è il nostro oggetto checkbox ci chiede il valore quindi questo è un booleano cioè è spuntata o non è spuntata questa checkbox tra l'altro il booleano stranamente è un booleano nullabile perché l'abbiamo visto rapidamente in 32 però i checkbox possono avere tre stati in realtà quindi è spuntato non spuntato e chi lo sa cioè arbitrario è un terzo stato che non sempre si usa però in questo caso si può esprimere con nullo volendo però di base ovviamente siamo con boole questo oggetto qui avrà un valore che viene dall'item quindi il bannolamento sarà item.da ok quindi semplicemente io prendo lo stato tanto la cosa che dovete ricordare che quando un oggetto viene dal costruttore ed è final non può essere modificato cioè una volta che questo widget qui è legato in maniera indissolubile a queste istanze to do item to do item è immutabile questa è la cosa bella che è immutabile per cui sappiamo che nessuno può modificare quelle istanze to do item cioè non è che se l'utente clicca sulla spunta questo to do item poi il booleano cambia valore non è possibile il booleano è final quindi non può essere modificato ed è questo il bello dell'immutabilità questa istanza qui rimarrà sempre uguale per cui la build sarà sempre uguale cioè quindi questo danno qui una volta che è costruito quello vale vale o true o false e rimane fermo in quel modo se dobbiamo cambiare in qualche modo la spunta chiaramente andiamo a ricostruire il widget perché andiamo a costruirne un altro di widget con un to do item diverso non sarà più chiaro quando ci lavoriamo però ecco la cosa bella è che questo widget qui dipende da questo stato qui ma lo può usare come se fosse fisso quindi non c'è nessun legame non devo ascoltare aggiornamenti modifiche cose via perché io so che l'oggetto lì è fisso quando faccio la build io semplicemente lo mostro onchanged è la funzione che reagisce ai ai click dell'utente al momento ci mettiamo una funzione fasulla che prende in input la la la così puoi dire lo nuovo stato di di spuntatezza della checkbox diciamo così e poi farà delle cose adesso non farà nulla e non reagirà in alcun modo ok quindi a sinistra c'è la checkbox a destra ci sono titoli e descrizione e che vanno messi in pila in colonna e quindi ci mettiamo una colonna di nuovo ok la colonna è a questo punto allora la colonna su main axis questa volta la colonna va non si espande giusto perché non deve prendere tutto lo spazio verticale perché se no ogni oggetto ogni item andrebbe a prendere tutto lo spazio disponibile cosa che non vogliamo in realtà vogliamo che si si compattino l'allineamento non serve quando quando la colonna non si espande l'allineamento non ha molto senso e sul cross axis di nuovo il cross axis sarebbe lo spazio rimanente orizzontale a destra della spunta giusto il cross axis lo vogliamo che si espanda completamente quindi sarà di nuovo stretch ok children quindi questi sono i vari oggetti che vengono messi uno sopra l'altro il primo sarà il titolo lo c'è sempre quindi sarà text e di nuovo posso fare text qua nel item.title è quello visto che il titolo qui magari ci mettiamo uno stile un pochino più importante ma facciamo un po' adesso non perdiamo tempo e sotto ci mettiamo l'altro text che è il description che però attenzione può essere nullo giusto per cui in questo caso vi da errore perché questo se è nullo qui text non può rappresentarlo ok per cui in alcuni casi la descrizione non c'è ovviamente per cui anche qui possiamo utilizzare direttamente la sintassi di dart per indicare che quel widget ci va soltanto se item description è non nullo quindi if item description non nullo allora usiamo no qui in questo caso chiaramente qui strano che non ci arrivi da solo il compilatore dovrebbe arrivare da solo però qui ci sta ancora avvertendo del fatto che item description potrebbe essere nullo non è così in teoria però per dirgli guarda è sicuramente non nullo ci mettiamo il punto scambativo che toglie la nullabilità cioè gli stiamo garantendo al compilatore che description sarà sempre non nullo torna? sì esatto qui dietro ok adesso a questo punto vabbè prima di decorare quant'altro magari cominciamo a mettere gli oggetti nel utilizzare se non rimaniamo sempre col dubbio di cosa ne viene da questa cosa qui ok per cui adesso a questo punto vogliamo che dove vogliamo mettere i nostri oggetti qui dentro quindi dentro la colonna dentro questo column qui vogliamo metterci un array di oggetti giusto? quindi qui dentro vogliamo che questa lista di children dipenda dalla lista di oggetti che sono dentro il to do items ok? allora qui chiaramente ci va un oggetto dinamico quindi questo array qui sarà un array di widget che che contiene n widget dove n è il numero di oggetti nella to do list come facciamo a costruire una lista dinamica di oggetti? ci sono mille modi anche con la sintesi di dart però per renderlo più evidente lo facciamo da fuori quindi qui nella build dove tra l'altro aggiungo nella build della home page dove aggiungo classico building this per chiarezza andiamo a creare una lista dinamica di widget che poi useremo nella colonna quindi faremo list di widget ok? questo lo facciamo solo per test non è che si faccia necessariamente così questo è quindi l'approccio sbagliato però l'approccio sbagliato che ci serve per un motivo questi widget qui andiamo a creare con una lista di widget che sono i widget che corrispondono ai to do item della nostra lista quindi semplicemente andiamo a fare forward to do item win to do my course dobbiamo sentarsi mi confondo sempre no è giusto? ok quindi per ogni to do item dentro to do item cosa andiamo a fare? andiamo a aggiungere in to do item widget to do item widget andiamo a aggiungere un nuovo widget che è un to do item viewer che viene costruito con l'oggetto corrente questo chiaramente va importato questo ok? lo lascio un attimo copiare è chiaro che stiamo facendo quindi quando dobbiamo costruire la nostra interfaccia quando facciamo la build a mano andiamo a creare una lista di widget che poi andremo a mettere dentro la colonna ok? la colonna cresce al crescere del numero di elementi considerate che ogni volta che modifichiamo lo stato quindi ogni volta che modifichiamo la lista di oggetti più aden chiaramente la build viene rinvocata quindi la build riavviene ogni volta che viene modificata la lista e quindi in base al numero di elementi che ci sono creerà una lista più o meno lunga ok perfetto quindi questo oggetto questa lista qui questa è una lista di widget la possiamo passare al nostro al costruttore della colonna quindi qui invece di creare la lista di widget annidata la passiamo direttamente così ha senso? ok andiamo a vedere cosa cosa viene faccio un altro restart quindi arriva al 3A da 0 adesso probabilmente non sarà bello perché dobbiamo modificare le cose però dovrebbe quantomeno funzionare aggiungiamo elementi allora non è più per niente quando vengono queste cose qui è perché qualcuno degli oggetti riesce a fare il layout quindi vedete che qui ho aggiunto gli elementi ma si sono arrabbiati molto non capire perché così vediamo il motivo quindi una cosa così può non dire sì esatto quello che cerchiamo di ottenere quindi qui ho sbagliato qualche allineamento e adesso vediamo subito probabilmente è sì probabilmente manca qualcosa qui allora quindi qui di nuovo facciamo cross axis stretch e poi mettiamo access size mettiamo min vediamo all'attento tb poi vediamo se poi non era questo non allora Grazie. Per vedere se l'errore dov'è, tolgo un po' di expander, vediamo se riusciamo a ricostruire l'errore. Questo. L'errore che mi stiamo dando è che uno degli elementi è unconstrained, quindi non riesce a presentarsi a schermo, perché vedete qui che non riesce a trovare i riferimenti con cui presentarsi a schermo in sostanza. Per cui adesso semplifico un attimo la gerarchia degli elementi e vediamo qual è l'errore. In teoria... Potrebbe essere il viewer, immagino. Allora, un po'... Scegliamo questo. Sto compagnando delle cose, ma non sono belle. Siamo un po' tentativi. Prima o poi tolveremo il problema e ci sarà tutto più chiaro. Facciamo una specificazione qui, allora. E qui una cosa che è spesso comoda fare è semplificare direttamente la costruzione, togliere tutto e vedere se mettereci un elemento molto più banale le cose tornano. In teoria sì, ok. Quindi l'errore è da qualche parte qui dentro. Questo se non altro ci aiuta in questo senso. Ok, quindi qui abbiamo una riga che non dovrebbe essere un problema. Mettendo la min... No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. possiamo volentare, visto che sono tutti presenti lì. Ah, sì, interessante. Non so se era lo start o questo. No, quindi era questo qui. Perché? Perché ho messo stretch. Sì, non mi piace per niente. Ok, teniamoci start un attimo, poi vediamo perché fa così. Ok. Ok, non è proprio bello, ma più o meno va bene. E allora. Ok, quindi ricostiamo quello che abbiamo fatto. Cioè danni soprattutto. Allora, torniamo qui. Torniamo qui. Torniamo qui. Questo non l'ho toccato, quindi va bene. Allora, di base alcune notamari che costituiamo nell'interfaccia. Ovviamente, mentre adesso adattiamo le piccole elementi, in genere si fa in maniera iterativa, diciamo così, modificando, facendo piccole modifiche del codice, facendo sempre hot reload e vedendo cosa accade qui sul lato dell'interfaccia. E per esempio, qui ho quattro cose da fare. Adesso non è nella posizione giusta, quindi volevamo... C'era l'expanded prima, quindi adesso qui ci mettiamo l'expanded attorno. Speranza che non fosse quello l'errore. Ops, non questo. Expanded e soprattutto per distanziarli un po', mettiamo un size box qui sopra. Quindi qui, prima tra column e text ci mettiamo un oggettino che è alto 8, che non fa altro che distanziare gli oggetti. Vediamo se l'expanded qui non ancora funziona. Perfetto, quindi questo era come volevamo ottenerlo. Ok, poi i singoli oggetti, adesso è un aspetto ancora abbastanza primitivo, per cui per esempio il titolo lo possiamo rendere un pochino più importante andando a pescare un textile che dia più risalto. Al titolo andiamo a usare il tema, come al solito, il theme of context. Quindi facciamo esattamente come abbiamo fatto la volta scorsa, quindi carichiamo il tema del nostro contesto, che andrà a pescare il tema del material design, materiale eletto, scusate. E qui abbiamo vari text theme. Qui troviamo headline, per esempio, medium, che potrebbe essere abbastanza... Ok, vediamo se ci piace. Ok, forse è un po' di pelo troppo, ma va bene così. Ora, per separare... forse è un po' di pelo excessivo... Headline small. E per distanziare meglio gli oggetti, per far capire a cosa corrisponde il bio checkbox, a questo punto dobbiamo lavorare sul decoratore, quindi sulla decoration del container, che è quello che ci aiuta a separare un po' graficamente gli oggetti. Oltre a questo, anche il margin potrebbe esserci l'aiuto. Per cui potremmo, per esempio, mettere un margine su tutti gli elementi. Questo si applica a ogni singolo elemento della nostra due item. Quindi mettiamo margine sotto di 8 pixel, così che tra di loro sono distanziati di 8, con edge insets. Only usiamo, che ci permette di specificare soltanto un margine inferiore. Vedete che ci sono quattro parametri, tutti opzionali, da usare. Ci interessa bottom, mettiamo a 8. Questo veramente può essere const. In presenza del margine inferiore sui singoli elementi, potremmo poi togliere il size box qui di qua, perché a questo punto sappiamo che se c'è un elemento nella lista, quello già si distanzia sotto, quindi non serve quello. Ok. Ho tolto il size box qui, avevo messo questo oggetto qui giusto per avere un po' di spazzatura qui sotto, però adesso ho visto che lo spazio viene aggiunto da sicurei elementi, per il momento non serve. Però cambia soltanto la spaziatura, non molto. Forse qui il 16 è più credevole. E decoriamo rapidissimamente l'oggetto così lo vediamo meglio. Quindi facciamo color di sfondo sarebbe. Usiamo un... Ah, anche qui è buona norma chiaramente usare i colori del tema. Quindi anche qui dovremmo andare a fare team offer. Adesso per farla breve uso dei colori standard e basta. Però se volete usare, riciclare i temi e il tema, andate a caricare i colori primari e secondari, ho usato quindi ovviamente... Anzi, facciamo... Ok. Questa è più sensata. Quindi il primary color e... C'è un altro... Questa qui. Per esempio, il primary color è quella specie di viola. Questo qui, in realtà viene adattato in varie sfumature, quindi lo trovate in... Se cercate color, ne trovate veramente diverse. Per esempio, un'idea potrebbe essere di usare il card color, che è il colore che viene usato per le carte, quindi gli oggetti che hanno questo... Aspetto qui, vediamo che colore è. Ah, è il colore di sfondo stesso, quindi adesso non cambia molto. Non so, cosa dovrebbe... Piacerci. E possiamo usare anche il primary, per esempio, che è molto intenso in genere. E poi adattarlo con una sfumatura di... Più chiara. Quindi magari questo primary color lo possiamo fare con... Width Alpha. E... Che ne so, metterlo a... 50. Vedere se ci piace. Ok, già... Ci può stare. Ok. E possiamo anche aggiungere, come prima, un box shadow, che è giusto per farla... Veloce. Salvo color. Salvo per il dentario. Qui potete tranquillamente lasciare, solito poi tanto poi proprio il codice, non è importante avere... Un'ombreggiatura. Se non mi piace. Vabbè, lo sai che sicuramente è un array di ombre. Così. Ok. Ok. Ok. Non è bello. Non è bello. Non è bello anche questo. No. Non è bello. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. faccio grigetto così ampi margini di miglioramento ma diciamo che ci può star bene in tutto sommato e cos'altro e oppure ok a questo punto internamente serve ancora un po' di padding per dare un po' di aria al nostro oggetto quindi questo possiamo applicarlo direttamente al container mettiamo ok a questo punto quello che avviene è che quando creiamo modifichiamo la nostra lista si ribilda tutta la nostra home page quindi si ricostruisce e va ad aggiungersi a un nuovo elemento perché chiaramente alla ricostruzione la lista è più lunga e quando la convertiamo in una lista di widget abbiamo un oggetto in più che viene messo nella colonna quando sbordiamo vedete che avviene delle cose poco eleganti perché praticamente perché il a questo punto flattera una lista lunga di oggetti che sta cercando di mettere a schermo dentro la colonna la colonna per sua natura mostra sempre tutti i suoi contenuti quindi prova a espandersi per farli entrare tutti a questo punto la colonna è obbligata ad andare oltre i suoi limiti e che ve lo segnala graficamente in questo questo questa cosa abbastanza visibile che vi dice che c'è un bottom overflow di un tot di pixel che se non leggo bene ma 86 pixel per cui ci sono troppe cioè quei pixel lì sono i pixel di cui la colonna sborba rispetto allo spazio che avrebbe disponibile quindi come si fa a risolvere questa cosa qui? ora bisogna imporre alla colonna di rimanere costretta diciamo così dentro il suo spazio allocato e allora c'è una soluzione primitiva che però poi vedremo ci è utile in vari modi perché idealmente se ci pensate basta basterebbe racchiudere questo oggetto qui questa colonna troppo lunga in uno spazio che è scrollabile cioè vogliamo rendere scrollabile la nostra lista adesso notate che non è scrollabile non possiamo andare su e giù non possiamo scorrere in alcun modo a lista perché effettivamente la colonna non lo fa la colonna è uno strumento molto molto semplice che non permette di scorrere permette solo di mettere in pila delle cose e poi se ne può occupare qualcun altro per rendere scorrevole un elemento grafico in genere basta racchiuderlo dentro un oggetto che è il single child scroll scroll view quindi nella gerarchia adesso abbiamo è già un po' anidata però per essere per mettere l'insieme allora abbiamo il padding esterno che è lo spazio la colonna più esterna che mette semplicemente in pila questo testo e il resto poi abbiamo un expanded che occupa tutto lo spazio disponibile all'interno di questo c'è la colonna che cerca di mostrare la lista di widget ok quindi la parte che andiamo a scrollare in realtà è questa parte qui giusto? perché è all'interno dello spazio occupato all'expanded non è l'expanded che dobbiamo scrollare ma è lo spazio interno dell'expanded qui attenzione nell'applicare al giusto livello l'oggetto, la scrollatura per renderlo scrollabile come dicevo lo grappiamo lo incartiamo dentro un widget che serve solo tanto a quello quindi il widget si chiama single child scroll view eccola ok? ha un singolo child ovviamente già dal nome quindi ha una scroll view uno spazio scrollabile con un singolo figlio chiaramente la scroll view è utile soltanto se il figlio è più grande dello spazio a disposizione che ha la single child scroll view ok? lo spazio di questo widget qui sarà lo spazio preso dall'expanded e la colonna cioè se la colonna è più piccola non c'è problema quindi la scroll view non fa nulla se la colonna è più grande a quel punto la scroll view si occupa di mostrarla faccio un restart per vedere che cosa avviene cliccare furioso ok finché la colonna è piccola non c'è problema se la colonna cresce a questo punto l'errore non compare più e finalmente è scrollabile ok? quindi vedete che con un singolo widget aggiuntivo abbiamo l'effetto gommoso di scrollatura di Android e riusciamo a scrollare la colonna adesso chiaramente tutti i to do items sono tutti uguali quindi non è molto apprezzabile però stiamo andando su e giù per la lista prego scusi se mi metto una mano a un professore o su palestra per far capire che comunque la lista è più di più sì dovrebbe essere possibile direttamente dentro il single child's review se ricordo bene sì non mi ricordo c'è una cosa da aggiungere dentro il single child's review comunque cioè ve lo dico questo perché poi non lo useremo in realtà però è giusto per il decoratore c'è un decoratore della single child's review che serve proprio per raggiungere il classico elementino che compare scompare qui sulla destra adesso non si vede giustamente però va aggiunto all'elemento scrollabile in sostanza e questo si può fare però in realtà lo facciamo al volo perché perché useremo un altro oggetto per fare questa cosa meglio di questa perché il problema di questo della single child's review qual è? è che il si prego ah esatto sì mi sembra che sì bisogna creare un controller ci complica un po' la vita perché dobbiamo mettere il controller qui dentro però è una cosa che vedremo quando parleremo di del text edit e di altri strumenti complessi quando c'è lo stato in genere hanno questo oggetto quindi basta aggiungere lo scroll controller che vive da qualche parte del nostro widget quindi in genere viene costruito qui dentro qui dentro possiamo anche provare a non che questo è un esperimento di cosa? ah beh sì ok possiamo tentare non l'ho provato quindi chissà ok e proviamo a passargli vediamo che succede perché il new non diciamo che sia opzionale sono abituato C sharp purtroppo questo non è più consta a questo punto ma cambia poco e vediamo questo è completamente un esperimento ok mi ha salito molto no mi sa che bisogna ultimamente dire al controllo cosa fare da vedere questo comunque è una cosa utile perché magari lo faccio offline e poi ve lo carico sul progetto dopo in realtà non lo useremo però in genere quando c'è dello stato aggiuntivo da dire in traccia quello che si fa è si crea un controller legato al widget e proprio lo vedremo meglio quando parliamo poi di il text edit che è il classico widget che ha bisogno di un controller che lo gestisca adesso ritorno come era e facciamo fin di nulla e poi vedremo ora a parte il problema che non vediamo quanto è lunga la lista l'altro problema è questo che tutta la lista viene generata e renderizzata sempre cioè immaginatevi avere 8000 cose da fare che è una cosa molto spiacevole in generale se abbiamo una lista di 8000 cose da fare tutti gli 8000 elementi vengono renderizzati insieme ovviamente a quel punto Flutter non può ottimizzare nulla perché la vostra colonna dovrà contenere 8000 oggetti che vengono in stasera tutti quanti cioè immaginatevi avere una lista lunga 8000 elementi questa questo questo questo codice qui li prendete tutti quanti li converti in un widget ovviamente tutti 8000 chiaramente e a quel punto li mettete tutti in colonna e li mettete tutti quanti qui dentro la colonna dove sì questa colonna qui è obbligata a renderizzare tutti gli 8000 elementi per capire quanto è lunga la colonna ovviamente la colonna ha necessità di sapere quanto sono lunghi i suoi elementi per capire quanto è lunga lei stessa per forza deve far così e quindi il processo di presentare 8000 elementi a schermo è molto netto cioè può rallentare molto l'applicazione e questo lo potete vedere voi stessi in realtà se cliccate molto qui nel mio caso ci metto poco perché il cellulare è molto scarso però vedete che a un certo punto comincia ad arrancare un po' a perdersi dei fotogrammi in sostanza perché sta o ad ogni clic sta riaggiungendo l'elemento e sta renderizzando 120 elementi tutti insieme adesso qua lo scorrimento è abbastanza fluido però troverete un momento oltre il quale anche lo scorrimento comincerà a diventare un po' di nuovo ma è faticoso ci sarà un momento in cui adesso il clic è abbastanza vedete che ogni tanto qualche numero salta ok quindi vedete voi fino a dove arrivate però in genere a un certo punto il scorrimento diventa un pochino più faticoso per cui si usa praticamente qui perché appunto per calcolonna non ha consapevolezza di quanti oggetti sta mostrando a schermo li mostra sempre tutti poi si occupa la scroll view di mostrare una sezione ok quindi quella vi dà una visione limitata su un oggetto molto lungo che viene rappresentato tra l'altro altro problema in cui si può incappare in alcuni casi i widget molto molto grandi proprio incappano problemi di memoria proprio per cui la colonna in particolare se contiene troppi widget in casi molto molto straordinari può proprio non riuscire a renderizzarsi per le esigenze di memoria per cui può dire ho troppi elementi all'interno non riesco a stenderli graficamente cioè quello quando si arriva nelle migliaia immagino però può capitare per ottimizzare questa cosa qui e per fare le cose in maniera più semplice si usa un oggetto che è fatto apposta per visualizzare oggetti in una lista che è la nostra list view la list view è un widget standard di Flutter che non fa altro che fare quello come lavoro proprio per cui adesso toglieremo quello che abbiamo fatto finora e passeremo alla list view semplificando nettamente le nostre cose per cui alcune cose le andiamo a perdere quindi questa conversione qui non serve più non serve più fare questa cosa qui a priori quindi evitiamo di convertire tutti i nostri item in widget perché è un lavoro inutile cioè inutile perché ne vediamo perché ne vediamo otto o quant'è? nove al più ok? per cui è inutile convertirli tutti quanti in anticipo convertiremo quelli che ci servono questo non lo facciamo più e qui la scroll view ugualmente non ci interessa più cioè non scrolleremo più e neanche la colonna ci sarebbe quindi spogliamo tutto quanto quello che è figlio di expander torniamo qui ho perso un pezzo si, se parte questo null non vale chiaramente però ok siamo qui quindi abbiamo soltanto lo spazio vuoto torniamo a uno scenario pulito in cui non c'è nulla adesso ci sono 195 elementi in memoria cioè il nostro stato non l'ho resettato quindi ci sono ancora 195 elementi li presenteremo in maniera più efficiente sullo schermo come facciamo? con una list view appunto list view è un altro widget standard e ha vari costruttori che ci possono essere d'aiuto allora qui entra in gioco un altro pattern classico di Flutter che va un po' scoperto e apprezzato che è quello dei builder cos'è un builder? un builder è è un un widget che si costruisce costruisce o se stesso o alcuni suoi componenti quando c'è bisogno ok quindi è un praticamente è un widget che continua una funzione che viene invocata quando serve ok quindi è un oggetto che si riesce a costruire da solo tra virgolette questo pattern ricorre in vari punti di platto per cui è una cosa che bisogna un po' interci un po' nella nella nella nella nella nella nella nella nella nella nella nella nella nella nella nella nella nella è un una list view che quando c'è bisogno col builder questo questo questo questo costruttore va a costruire gli elementi di cui è composta ma costruirà soltanto gli elementi che servono di volta in volta quindi se mostra i primi dieci elementi di 8000 elementi costruirà soltanto quelli lì grazie al fatto che noi stiamo fornendo non una lista già pronta di oggetti ma un metodo quindi un builder con cui costruire gli elementi ok stiamo dicendo guarda ci sarà una lista di oggetti e dovrai costruirli seguendo questo pattern usando questa funzione qui ci sarà forniremo una funzione di build per convertire il to do item in un to do item viewer quello che è quindi in questo quando costruiamo list view builder siamo questo costruttore qui ci serve fondamentalmente soltanto un parametro che è l'item builder cioè la funzione che converte l'oggetto nell'array nei dati in un oggetto widget che lo visualizza quindi questo builder qui a cosa serve serve cioè gli serve è una funzione che ci dà un context di costruzione quindi un contesto grafico in cui costruire il nostro widget un intero che è l'indice dell'oggetto quindi è l'iesimo oggetto della lista e dobbiamo ritornare un widget ok quindi effettivamente è come se fosse una build come questa solo che in più c'è un intero che ci dice quale elemento stiamo costruendo nella rete ok quindi la sintassi di questo oggetto qui vediamo se è così carino da proporcelo esatto è context e index e dovrà ritornare un widget quindi possiamo usare la chiamata funzionale questo context qui sarà il context di costruzione della lista chiaramente l'indice è l'indice all'interno della list no come si chiama della to do items e quindi andiamo qui a ritornare che cosa un to do item viewer esattamente come facciamo prima adesso l'ho cancellato prima c'era il ciclo forno che andava a costruire facciamo la stessa cosa passiamo qui il nostro to do items iesimo dove in realtà indexesimo sarebbe a dire quindi andiamo a pescare l'indicesimo elemento dell'array ci costruiamo attorno un widget che lo rappresenta e basta e in realtà ci siamo l'unica cosa che bisogna ancora fornire al nostro list view builder è quanti oggetti ci sono nella vista questo non lo può sapere list view builder per cui forniamo come ulteriore parametro un item count chi gli dice guarda ci sono dot elementi nella lista altrimenti il builder non sa dove fermarsi e lo forniamo in questa maniera quindi quando quando quando clicchiamo sul pulsante per raggiungere un nuovo elemento questo elemento viene creato nella lista si aggiorna tutta la nostra interfaccia utente list view viene ricostruito con una lunghezza n che è pari al numero di elementi e forniamo un modo per convertire ogni per costruire i singoli elementi e forniamo vedere se tutto questo funziona dovrebbe ok e è molto simile a prima chiaramente non è cambiato molto però è cambiato moltissimo per come funziona quindi adesso abbiamo costruito soltanto tre sei otto probabilmente qualche item in più l'ha costruito perché chiaramente li pre li pre costruisce perché immagina che scolleremo quindi in realtà avrà costruito una decina di elementi in realtà lo vediamo perché lo vediamo nel debug quindi qui vediamo che ci sono un due tre sei nove undici elementi quindi ha costruito i primi undici elementi della lista scorrendo questo è il decimo ancora c'è questo è l'undicesimo e quindi è finito e nel first step non ha costruito quello sotto quello che sono costruiti a mano che scurriamo vengono costruiti a runtime vedete come sotto vengono costruiti e possiamo immaginare questo sappiamo che sopra quelli che sono passati vengono decostruiti ok quindi quelli che spariscono vengono dimenticati se torniamo su sarà costretto a ricostruirli esatto quindi la build viene reinvocata ogni volta che facciamo tre giù e questo è in genere come funziona anche se lo fa questo non è soltanto flat che si comporta in questa maniera perché se avete lavorato con android nativo anche android nativo funziona assolutamente così per le liste è solo molto più complicato da fare però l'idea è sempre quella quindi c'è una in realtà è un processo che si chiama di riciclo dei widget degli elementi per cui vengono scartati sopra e vengono ricrate sotto così da ottimizzare il numero di widget che sono visibili a schermo ok questo è chiaramente fin tanto che i widget non sono molto costosi da costruire però chiaramente lavorando in Flutter in genere questa è sempre la nostra ambizione di avere dei widget che non sono complessi da costruire che sono abbastanza rapidi nella loro costruzione e qui se clicchiamo su più uno vedete che aumenta il numero di cose da fare e la la lista si ricostruisce ma non perde la posizione della della della della di scrollatura per esempio qui sto adesso non so che elemento è che sto mostrando però sto siamo scrollati ok quando clicco sul più uno tutta la home page viene ricostruita perché c'è set state che rigenera tutta la home page tra l'altro qui nel debug vedremmo anche qui building a home page state quindi anche l'istview viene ricreata chiaramente ma nel ricrearsi non si perde per strada il fatto che è già scrollata ok quando viene ricreata semplicemente ricostruisci gli elementi che sono attualmente visibili e poi quelli che si creano ok quindi l'istview è già ottimizzato per essere utilizzato in questa maniera e minimizza le costruzioni e le build nella nostra interfaccia poi utilizzeremo ultimamente questa cosa però per ora direi che ci sta ok a questo punto potremmo provare a fare l'ultima cosa prima di fare perché poi dobbiamo passare a riverpod che è abbastanza importante che modifica per cui quello magari lo facciamo in tutta una carrellata perché prima di fare quello facciamo delle piccole modifiche potremmo metterci non so la spunta attivabile potrebbe essere sensato oppure no forse forse lasciamo perdere passiamo su da riverpod così non perdiamo tempo visto che il tempo è veramente poco allora termino l'applicazione e poi la facciamo ripartire aggiungendo il nostro riverpod quindi termino qui perché a questo punto dobbiamo passare a riverpod lo cerchiamo su pubdev perché ci si interessa il numero di versione riverpod è questo flutter riverpod ci interessa quindi è riverpod per flutter sono varie varianti in realtà c'è riverpod con i hooks e così via ci sono tante varianti però quello ci interessa nel nostro caso è questo flutter riverpod flutter riverpod esatto 248 al momento copiamo tutto e lo includiamo cioè lo inseriamo nel nostro qui il nostro pub spec lo mettiamo sempre qui sotto magari nel frattempo facciamo fare a pub get le sue magie allora a che serve il riverpod in sostanza serve per gestire in maniera diversa lo stato nel senso che per ora abbiamo visto che lo stato lo tenevamo qui dentro my home page potrebbe andare benissimo sto pensando se per rendere più evidente la cosa magari immaginiamo per rendere più evidente il problema facciamo così immaginiamo di dover fare di dover modificare questa questa lista quindi dobbiamo modificare in qualche modo la spunta ah tra l'altro la spunta ecco un buon esempio come facciamo a cambiare la spunta di un oggetto se gli oggetti sono immutabili facciamo un attimo qui to do item qui sappiamo che è immutabile quindi questo questo bull qui non si può mai modificare il problema di fondo è che questo bull come si fa a cambiare non si può cambiare perché l'item è immutabile allora nel nostro stato c'è qui dentro magari ci viene in mente di creare un metodo che è set done una cosa del genere che ci permette di flippare di impostare la spunta di un oggetto qualsiasi di impostarlo come si fa? allora dobbiamo in qualche modo cioè l'idea di fondo quando l'oggetto è immutabile è che dobbiamo costruire una lista che è uguale a quella precedente però l'oggetto che dobbiamo mutare va rimpiazzato con un altro oggetto quindi l'idea è che ricrea una lista identica a quella precedente con gli stessi oggetti ma l'elemento di cui vado a modificare lo stato va flippato ok? quindi crea una copia della lista uguale ma con un singolo elemento modificato in questo caso ci torna a utile la nostra string di prima quindi possiamo usare l'id del to do item per fare riferimento a un singolo due item specifico di cui vogliamo modificare lo stato e poi magari un booleano che ci indica se impostarlo a true o false ora qui l'idea è qual è? che vogliamo creare una nuova lista quindi che ne so final new list che è una copia della lista precedente così scorriamo gli elementi della lista precedente dalla lista attuale qui ci sono vari modi per farlo quindi questo è un tentativo adesso se lo voglio ottimizzare in to do item sto scorrendo gli elementi della lista vecchia ok e li sto li aggiungo e la lista nuova qui dentro? e final vabbè è uguale essendo to do item essendo immutabile anche se var cioè var cambia cambia perché così io volendo potrei scriverci sopra ma vabbè non so scrivere new ma a parte questo però sì cioè final più sata final meglio è perché comunque siete sicuri che le variabili non cambiano non cambiano sotto le le dita quindi questa è una copia della lista a questo punto dopo aver fatto la copia la sento quindi set state to do items uguale new list ok quindi sto creando una lista nuova che ha una copia di quella precedente e poi alla fine aggiungo lo stato e dico ok la lista adesso è diversa è la stessa perché ho semplicemente fatto una copia esatta della lista ora quello che voglio fare è che per l'oggetto specifico tal dei tali lo cambio quindi if to do item punto id uguale uguale l'id specifico allora to do item crea un do item che è uguale a quello precedente ma con una spunta diversa quindi qui ci metto to do item punto title no to do item punto title il booleano come lo voglio io e poi to do item punto description else aggiungo to do item così come è so se è chiaro new non serve mai dimentico sempre ok quindi se cioè le sto copiando uno per uno se incontro quello di cui stavo parlando ne creo identico con la spunta modificata tra l'altro qui l'occasione per l'occasione in genere è buona norma avere se l'idea è usare in questa maniera i nostri oggetti è buona norma avere anche un costruttore to do item che si chiama tipo with done che prende in input un anzi è un'estensione è un'estensione di vediamo non non non non non per usarlo così che sia corrente con col pattern possiamo fare un metodo estensionale su i metodi estensionali sono dei metodi in realtà non serve bene può essere un metodo statico basta quindi static to do item with done done non è anche static è distanza quindi questo è un metodo che ci ritorna un nuovo to do item partendo dall'istanza che abbiamo quindi id title done e description qui è incoerente quindi questo metto se no poi non si capisce quale ok quindi ho creato un metodo su do item che ci permette di fare questa costruzione qui in maniera più elegante quindi qui invece di far questo faccio prendo il to do item originale with done e fornisco done cioè sto sto mutando sto creando un altro oggetto mutato quindi quando gli oggetti sono immutabili buona norma non far darvi dei metodi di supporto che creino istanze mutate esattamente come era per i colori prima quindi una cosa che mi hanno spiegato con i stati quando cioè noi abbiamo definito la lista come final la lista e final sì qui esatto e no nella lista quella ok no in realtà questa potrebbe essere final perché non la rende immutabile la rende inassegnabile potremmo comunque modificarla aggiungere togliere le mezzi però questo caso la stiamo assegnando cioè con se fosse final non potremmo fare il valore non potremmo fare questo esatto non potremmo assegnare il valore potremmo comunque fare add eccetera perché comunque la lista è mutabile quindi anche fosse final potremmo fare questo se proprio vogliamo farci del male potremmo fare for todoitems.clear e poi todoitems.addall di ignoio anche se fosse è la stessa cosa sto pulendo la lista vecchia ci sono generazioni di un'altra lista però non cambia la sostanza quindi il final sugli oggetti come le liste non è molto utile perché vi impedisce di impostare e assegnare scusate ok tra l'altro tutta questa cosa qui si potrebbe poi magari faccio vedere un'altra questo processo qui di costruzione della lista aggiuntiva in realtà si può ulteriormente ripulire usando la sintassica di distanzazione degli array di darts proprio che è un pochino più elegante però è un pochino più arcano magari ve lo scrivo ma potete veramente ignorarlo invece di far così invece di costruire la lista e copiarla e così via potremmo fare direttamente così good items uguale niente assegno nuova lista e qui creo la lista direttamente dentro il dentro il costruttore è uguale copio è qui veramente senza no questo non è così chiaramente quindi qui dobbiamo tornare direttamente all'oggetto ok più leggibile non lo so però è più corto sicuramente quindi abbiamo creato tutto items lo stiamo rimpiazzando con un array nuovo che viene costruito iterativamente girando su tutto items e istanziando gli oggetti in questa maniera quindi qui non stiamo modificando una lista che già esiste ma stiamo creando iterativamente una lista o modificando quelli esistenti o mantenendo quelli esistenti decidete voi qual è la sintassi preferita questa chiaramente è molto più stringata però è anche molto più arcana l'effetto è identico ok quindi a questo punto possiamo modificare i nostri oggetti in realtà prima di ho rebuildato con Riverport prima di passare a Riverport vediamo se vogliamo che dentro il to do item viewer avevamo qui preparato tutto necessario per poter modificare la nostra checkbox in qualche modo dobbiamo cioè cosa vogliamo fare dobbiamo modificare in qualche modo lo stato dell'applicazione ci serve dal to do item viewer qui abbiamo un oggetto statico item non possiamo modificarlo in qualche modo bisogna in qualche modo fare riferimento allo stato dell'applicazione ossia alla nostra istanza di my home page state qui ok se ricordate abbiamo fatto qualcosa del genere la volta scorsa andando a scartabellare nel contesto e andando a rifrescare lo stato nella nella gerarchia dei dei nostri widget ed è una cosa che possiamo fare anche questa volta non possiamo farlo ancora perché questo stato qui non è visibile è incapsulato è privato al file main dart quindi c'è l'underscore quindi non possiamo fare riferimento a questa classe al di fuori di altri file però se togliamo qui l'underscore diventa visibile e nell'altro file qui questo è un modo in cui bisogna farlo non è proprio bellissimo ma si può fare con context andiamo a fare find ancestor state of type eccetera quale type mi serve my home page state lo pesco sono sicuro che esiste per cui punto sclamativo e a questo punto abbiamo accesso a non mi ricordo come si chiama set done vabbè non è importato se non lo vede abbiamo accesso al metodo set done che appunto modifica lo stato che cosa facciamo set done allora l'id ce l'abbiamo già perché l'id rimane uguale item.id e il done ce l'abbiamo uguale perché ci viene fornito qui come c poi in realtà questa c qui è un booleano nullabile in realtà per cui c qui si lamenta che va denullizzato possiamo farlo o col punto sclamativo oppure dando di default non so false se impugniamo che esiste non è nullo stiamo dicendo al compilatore guarda tranquillo so che sulla carta da time system quella cosa potrebbe essere nulla ma mi sono sicuro che non sarà mai nullo a runtime ok quindi semplicemente per dirgli è nullo tu considero come non nullo esatto cassa non nulla praticamente è chiaro che poi se non è così ovviamente può esplodere questo doppio intronativo è il null coalition si chiama quindi si sarebbe a dire che se l'espressione a sinistra è null allora usa l'espressione a destra che non usa quindi c'è un modo per avere un valore di default e non serve mai perché il checkbox quando clicchiamo sarà sempre true fault perché non è un checkbox attrezzato quindi comunque questa cosa sappiamo che non usiamo mai ok tutte queste cose qui per fare cosa per modificare quindi quando clicco sul checkbox cambio il valore dell'oggetto e scateno un rebuild di tutta a cascata tutta l'interfaccia giusto perché riparte tutto da zero vediamo se è vero ok ho i miei oggetti appena compaiono ok se li clicco funziona ok quindi a questo punto posso spuntare i miei oggetti e che cosa viene quando ci clicco il viewer va a pescare lo stato nell'albero dei widget va a parlare con l'oggetto di stato radice che abbiamo e gli dice guarda cambia lo stato dell'oggetto dal dettaglio quello ricostruisce il suo stato interno e poi a cascata ricostruisce tutti i suoi widget e questo funziona è efficiente? no perché chiaramente a cascata tutto viene rebuildato in automatico e non è quello che volevamo fare il nostro obiettivo sarebbe fare la rebuild soltanto di quello che viene effettivamente modificato idealmente questo non sempre è perfettamente possibile però un esempio adesso per quanto banale quando cambio la spunta qui quello che avviene è che viene ricostruito anche questo ho tre cose da fare è vero che è un esempio molto molto banale per cui magari non è proprio utilissimo però immaginate che qui sotto ho tre cose da fare sia un widget più complesso di questo chiaramente questo viene ricostruito anche se effettivamente quel numero la n che sta mostrando non è cambiato cioè non ho né aggiunto né tolto elementi quindi è normale che se cambio la lista mi aspetto che venga ricostruito non ci mancherebbe altro però se cambio la spunta perché dovrebbe ricostruire anche la parte sottostante non dovrebbe infatti con RiverPod riusciamo a così a rendere più settoriale la ricostruzione della nostra interfaccia perché riusciamo a esprimere in maniera più chiara cosa ricostruire e quando in realtà questo possiamo farlo già adesso se vogliamo con l'inherited widget se ricordate abbiamo visto brevemente la volta scorsa parlando di come si propaga lo stato se vogliamo fare le cose complicate scrivendo molto codice possiamo già farlo in realtà per cui adesso vi dico giusto come si farebbe poi lo facciamo con RiverPod perché si diventa si fa prima se volessimo farlo cosa dovremmo fare dovremmo nel nostro main il nostro stato è comunque rimane comunque impacchettato qui dentro a quel punto nella gerarchia degli oggetti non andremo a creare subito lo scaffold andremo a creare uno o più inherited widget che sono dei widget interstiziali per usare un termine completamente arbitrario cioè che sono tra lo stato e il resto dell'interfaccia che non fanno altro che autopopogare quello che è il dato effettivo quindi potremmo mettere un inherited widget che è che ne so to do item counter che espone un intero che vale 4 in questo caso e poi un altro inherited widget che espone invece la lista quindi che ne so il nostro inherited to do list che espone la lista completa degli oggetti questi oggetti questi due widget sono statici const e immutabili e semplicemente non fanno altro che impacchettare da una parte la lista e da una parte il contatore a cascata a quel punto questa sezione qui quindi ho 4 cose da fare può dipendere non da inherited to do list che espone la lista ma da inherited to do count counter quello che è che è l'inherited widget che espone soltanto l'intero a quel punto questo blocco qui questo widget qui è legato solo a quell'inherited widget e si ribilda soltanto quando quell'intero lì è cambiato ok quindi questa è l'idea quindi quando l'intero viene modificato l'inherited widget cambia e a cascata tutti i widget che dipendono da quello vengono ricostruiti la lista invece viene ricostruita semplicemente quando viene modificata a to do item list inherited to do list o quello che è insomma quindi abbiamo due widget due inherited widget che impacchettano due oggetti diversi che si comportano a migliore diversa per ottimizzare esattamente come avviene per il tema quindi il tema è un altro oggetto classico di cui quasi tutti i widget dipendono alla fine dei conti quando il tema si ricostruisce si modifica tutti i widget che dipendono dal tema vengono ricostruiti ok per cui lì possiamo specificare in maniera selettiva da cosa dipendiamo questo adesso appunto potremmo farlo con gli internet widget però quelli mi hanno chiesto un sacco di codici di essere scritti se ricordate la volta scorsa mi hanno scritto bisogna creare un widget tutta parte per impacchettare lo stato bisogna metterlo nella gerarchia bisogna propagarlo bisogna creare una serie di metodi che ci permettono di leggere quello stato lì e di esprimere la dipendenza dallo stato quindi è tanto codice per fare poco lo faremo in maniera molto più abile cioè più agile e veloce con RiverPod con lo stesso effetto quindi lo vediamo tra l'istante di là e interrombiamo fino alle 11 e un quarto direi o 11 e 10 al più e poi riprendiamo SAER A