ok allora ieri siamo arrivati a questo punto qua avevamo lavorato con i provider e ho fatto l'esempio dei provider che dipendono da altri provider sempre con il metodo del ref punto watch qualcosa perché abbiamo visto che possiamo fare dei provider che ritorno un dato più specifico che ci interessava per esempio con il to do items counter provider quindi un provider che in realtà che ritorna un dato composito comunque un dato derivato da un altro provider questa è una cosa che si fa si può fare spesso e rende evidente che sia nei provider che nei widget riusciamo a fare questo watch quindi per rimanere in attesa della modifica del provider che poi quando avviene quando il notificatore di un provider si scatena a cascata tutti i provider dipendenti e i widget dipendenti vengono aggiornati alla testa valore quello che ieri si era rotto tra virgolette o meglio non funzionava bene era che avevamo usato il trucco diciamo così del di questo provider qui questo provider fittizio che dà accesso a un singolo oggetto fisso che avevamo specificato nel file dei providers facendo l'overwrite di questo provider in sotto aree della nostra applicazione e con sotto intendo i singoli oggetti qui dentro quindi singole entry della nostra di studio e nella pagina che avevo quindi quando apriamo questa pagina qui passavamo alla pagina direttamente un provider scope con un oggetto pre compilato preparato tirato fuori dalla lista il problema di questo approccio che sebbene funzioni in lettura poi non funziona in quando si aggiorna l'oggetto perché l'oggetto effettivamente è nel nalbero di nostri widget vive il provider scope quindi vive proprio nell'angoletto del provider scope che troviamo era qui quindi quando quando l'utente clicca sui singoli oggetti acquida tra le cose magari poi lasciamo e lascio le commenti in altro modo la parte importante era questa diciamo quando navigo a una pagina che cosa faccio preparo un provider scope in cui metto un valore fisso questo item qui questo item è immutabile rimane nel provider scope quindi rimane nell'altro dei widget perché è dentro la route del nostro della nostra material app cioè del navigator della nostra material app e a quel punto nessuno può modificarla quindi anche se l'oggetto viene modificato nell'altra parte della nostra applicazione c'è nella to do item list come si chiama il provider tutto il provider lì ci sono c'è la copia di madre di tutte le oggette da do list queste vengono modificate e si scatena aggiornamento nel provider scope dentro cioè a a a a a a a a a a a a a monte della subito a monte della della pagina aperta secondariamente c'è questo oggetto che sebbene clicchiamo non viene alterato quindi tornando qui poi viene alterato perché questa pagina qui si aggiorna ma la parte più dettagliata non è notte giorni prego siccome noi non abbiamo bisogno dietro della nostra applicazione si in questo caso come facciamo un operario potremmo ad aggiungere al provider della visita con il non fire un metodo per aggiornare lo stato di un singolo elemento a chi lo aggiungeremo a quel provider? si si su due items provider esatto il nostro state notifier ce l'abbiamo definito noi si a vari metodi abbiamo il supporto di nenti ok tipo quindi in questo caso potremmo invocare dalla pagina del due item si il set down del notifier di tutta la lista con gli iddi dell'oggetto che abbiamo noi però è quello che già stiamo facendo in realtà però non ha effetto infatti nella pagina che stiamo a prendere è stato due item page questa due item page è questa vive sotto provider scope quindi vive qui dentro no? quindi vive qua che è questa accesso quindi a sia a cronin to do item provider che in realtà ha accesso anche all'altro provider quello che diceva lei il to do item provider quindi li vede entrambi qui dentro in realtà a cascata siamo andando to do item viewer quando clicchiamo sulla spunta il to do item viewer quando spuntiamo salve buongiorno e quando spuntiamo clicchiamo su c'è cox lo fa sul to do item provider in realtà quindi facciamo già quello che credo se ho capito bene suggeriva perché andiamo per modificare quella spunta non possiamo farlo sull'oggetto stesso perché se no dovremmo fare se volessimo farlo potremmo farlo no? se volessimo fare cambiare lo stato dell'oggetto facciamo l'ipotesi potremmo andare a leggere il provider questo qui no? che è quello che è famoso che contiene l'oggetto specifico nostro faremmo così no? con notifier potremmo avere accesso allo stato ma questo non ha il notifier proprio questo oggetto qui perché è un provider semplice è un provider che non notifica perché non viene aggiornato nel senso che questo qui è un provider schietto non ha stato interno cioè ha stato che dipende da qualcun altro quindi non c'è modo di rimpiazzarlo almeno di non sovrascriverlo però in cascata noi non possiamo sovrascrivere qualcosa che è più in alto di noi nella lista di widget adesso mi spiego c'è la nostra pagina qui dentro legge il current to do add provider e ne fa watch quindi nel caso cambiasse se ne accorgerebbe se qualcuno da fuori lo cambiasse però io non posso andare a cambiare i contenuti del mio scopo a meno che questi non siano dei provider che lo permettono di farlo quindi abitano dello stato interno e abitano di notifier questo provider qui è un provider solo a lettura in sostanza perché è un provider di quelli proprio semplici cioè di tu provider esattamente come il provider di un provider che avevamo fatto l'esempio più banale questo è una stringa ed è sempre quella quindi non cambia mai è in un provider perché ci fa comodo averlo in un provider però non c'è nessuno che possa modificare questo mondo a meno che non venga sovrascritto in un sotto ramo del nostro albero che era quello che avevamo fatto qui sovrascrivendo proprio il provider con un altro valore qua ok se il provider non è state non è un comodo che lo capiamo esatto se volessimo fare una cosa un pochino strana potremmo fare un rendere il current to do provider uno state provider però a quel punto diventa rischioso perché a quel punto diventa un provider costato e quindi ce n'è una copia per tutta l'applicazione in realtà poi anche questo può essere sovrascritto chiaramente per cui può esserci una copia per tutta l'applicazione e poi sotto possiamo solo scriverlo però ammesso che lo facciamo e possiamo anzi facciamo così lo vediamo subito cioè non vediamo in azione perché poi non funzionerà però lo rendono state provider non cambia molto quindi non cambia tanto la classe a questo punto qui dentro dove troviamo? qui? no qui esatto qui dentro finalmente ho accesso al notifier questa volta non mi da errore quindi posso fare notifier ho accesso all'oggetto questo mi da l'accesso all'oggetto notifier di to do item quindi ho state che ho to do item e quindi sulla carta io potrei fare questo quello che diceva lei quindi posso sovrascrivere lo stato con un altro oggetto che è sempre item con with done c c è il booleano che c ci si è spuntato meno e questa cosa qui facciamo così questo lo commentiamo adesso non so se funziona così schiettamente ma proviamo se non ho fatto altri errori dovrebbe addirittura funzionare dove ho fatto l'ora? su main ah ecco sì giustamente allora a questo punto quando faccio l'override del dato questo qui non è più un un provider semplice di cui possiamo cioè possiamo rimpiazzare con un valore bisogna rimpiazzarlo con un altro provider quindi abbiamo un override with che è una funzione che ritorna un oggetto e alla fine cambia solo la sintassi facciamo così e ci ne frega il giusto facciamo la stessa cosa sotto anche questa non so se chi ha cioè adesso lo faccio meglio facendo da solo ok cambia il tipo di override che facciamo nel primo caso è un provider che ha un valore fisso per cui facciamo override with value perché stiamo fornendo un valore fisso ugualmente al nostro scope inferiore non possiamo farlo per un state provider chiaramente perché quello è un provider più complesso che ha uno stato di partenza ma può modificarsi quindi adesso stiamo creando dentro il sottoramo della pagina un altro provider overrideato che ha uno stato ovviamente di partenza che è il nostro item e quando andremo a fare la scrittura to do item viewer andremo a rimpiazzare quello stato lì però è uno stato locale cioè uno stato di quel provider scope e basta questo qui adesso se ammesso che non ho fatto altri errori lo vediamo in effetti in azione apparentemente dovrebbe funzionare lo stesso la lettura dei dati ma ok questo funziona quindi è uguale a prima quando spunto qui questo funziona all'apparenza funziona ancora quando apro non c'è la spunta qui lo spunto o meglio tolgo la spunta torno indietro c'è ancora questo lo apro metto la spunta torno indietro non c'è la spunta perché ho cambiato il valore dell'oggetto in quel sottoramo della della della mia widget quindi c'è una copia di un item che posso cambiare ma non viene mai modificata la to do list to do item provider che è il provider principale che contiene i dati veri potrei fare un accrocchio aberrante facendo anche questo potrei modificarli entrambi ok potrei modificare la copia locale e l'errore non lo so vabbè la copia locale e e la copia del del to do item provider questo funziona ma è molto brutto ovviamente ok quindi ho due valori di di to do item il primo a livello locale perché so che è nel livello più basso del nostro albero e lo posso sovrascrivere non so perché non so perché mi sa che è già non nullo perché ah ok qui il compilatore mi vuole aiutare ma non lo fa è già non nullo perché qui l'ho già non nullificato per cui se qui non esplode vuol dire che questo ovviamente non è vabbè scusi prego praticamente toglie la nullabilità al al tip non può essere sì noi sappiamo che questo oggetto qui questo booleano non sarà mai nullo soltanto perché questo checkbox qui non è un checkbox a tre vie quindi i checkbox volendo possiamo configurarli per avere on off e indefinito però in genere di default non hanno il terzo stato di indefinito e qua compaiono in grigetto con delle no pure con un cerchietto non mi ricordo ho visto lei ha messo un paradoglio proprio solamente con lo scavato qui dentro non posso dire però ho un'altra pagina forse l'ho messo in fondo forse l'ho messo così forse perché in quel caso stavo denullificando il ritorno della funzione quindi sì è come se sì adesso non ho un esempio a portare in mano però in genere si usa dopo un'espressione quindi qui per esempio questa espressione qui ha valore string forse string nullable col punto di schermatino dopo diventa una stringa a tutti gli effetti quindi se ho una funzione che torna qualcosa che è nulla poi se la metto qui quel blocco di funzione torna un elemento che non è più nulla piccola domanda su Dart se noi facciamo punto schermativo c punto schermativo stiamo dicendo che vogliamo che il valore di c non nullo che lo utilizziamo non nullo è negato sì teoricamente sì non ci ho mai pensato ma è una cosa orribile sì non mi hai capito di farlo quindi non sì discutibile ma è così sì possiamo che ne so meno confondente forse così non è vero è peggio di prima vabbè sì è una cosa che non faremo mai no questo è non ho mai pensato sì ok quindi non so se è chiaro quindi qui sto scavalcando il problema però non è la soluzione ideale perché a quel punto ogni volta che modifico un oggetto nella mia tuturista devo ricordarmi di farlo in due punti ho due provider uno è una copia locale di un oggetto che ho da un'altra parte però non c'è si può fare ma il rischio di fare degli errori ovviamente è altissimo ogni volta che cambierò spunto devo ricordarmi di farlo in entrambi i punti se no poi ho valori che si scordano quindi no cioè no sconsigliato e per questo motivo torno sul provider originale quindi questo oggetto qui non è più uno state provider ma torna ad essere un provider perché è soltanto una come si vuole dire una faccia uno sguardo una vista per usare un termine dei database su un oggetto che ci viene fornito quindi significa anche che qui posso tornare a value tra l'altro questo questo vale anche per i provider che sono provider semplici quindi possiamo comunque questa cosa vale uguale possiamo lasciarlo così con with value è più evidente che stiamo fornendo un valore che è statico quindi da una parte conviene ok e di là torniamo a dover aggiornare quindi questa cosa qui non la facciamo più perché non funziona ovviamente non potendo modificare quell'oggetto e torniamo a modificare il nostro il nostro studio item il nostro studio item provider come si fa quindi a leggere cioè leggere essere in attesa di aggiornamenti di un singolo specifico oggetto nella nella nostra nel nostro stato ci servirebbe praticamente cioè a livello concettuale praticamente un provider per ogni singolo oggetto della nostra studio list della nostra studio list quindi abbiamo una lista di di to do item ognuno dei quali dovrebbe poterci segnalare il fatto che è stato aggiornato quindi vogliamo fare che questa cosa qui funzioni e questa cosa si può fare perché Riverpod lo provvede con un trucco che sono le famiglie di provider quindi è come se effettivamente stessimo creando una una serie di provider cioè un provider che ingloba una lista di provider tutti distinti e noi possiamo metterci in ascolto di uno soltanto di questi e è il caso cioè si usa comunemente quando dobbiamo abbiamo una una lista dinamica di oggetti che magari possono essere creati distrutti arrivare a scomparire e così via come dei nostri tutti item e noi vogliamo ascoltare selettivamente su tutto uno di questi andiamo a creare un provider di questo tipo quindi è una provider family in sostanza che ci permette di tracciare un singolo oggetto della lista stessa e lo possiamo chiamare per esempio lasciando in alternato questo adesso lo lascio sebbene siamo un po' sono dei provider molto simili che fanno un po' la stessa cosa per questo magari lo metto qui sotto lo chiamerò specific to do item provider mancanza di un nuovo migliore è sempre un provider è sempre un provider che non ha stato suo dipende dallo stato della to do item provider nel costruttore c'è family come funzione quindi stiamo costruendo un provider nuovo che non è un suo provider ma in realtà è una famiglia di provider e si distingue andando a specificare il tipo dobbiamo specificare l'oggetto che ritorna cioè l'oggetto che stiamo ascoltando che è il nostro to do item famoso e il discriminatore cioè un altro parametro che ci serve per poter discriminare i singoli oggetti della famiglia quale sarà questo discriminatore sarà l'id del to do item che se ricordate è una stringa quindi abbiamo la stringa è l'identificatore che discrimina gli oggetti e il to do item è quello che è l'oggetto stesso qui dentro c'è la classica funzione che ci dà accesso all'oggetto c'è ref che è il mondo dei provider e arg che sarà il parametro che stiamo ascoltando quindi l'id in sostanza qui sarebbe arg ma lo chiamo id che sia più chiaro qui dentro possiamo mettere un debug print giusto per quindi sto rebuildando il provider per il to do item id dal dettaglio ok e qui dentro cosa faccio ritorno il to do item dal dettaglio dalla lista quindi faccio come facevamo qui con to do items count provider ci ascoltiamo la lista quindi facciamo ref watch di to do item provider esattamente la stessa maniera item provider per cui siamo sicuri che quando la lista cambia anche questo provider qui cambierà non facciamo l'endit ovviamente ma andiamo a pescare l'oggetto con quell'id ci si può fare in mille modi se potete fare un loop in to a lista e quant'altro quello che faremo useremo un po' SQL SQL con where ci permette di andare a pescare un elemento da lista dove un predicato è valido quindi il predicato sarà la verifica che lì come? sarà uguali più esatto esattamente quindi andiamo a pescare tutti gli elementi da lista dove l'id è pari all'id fornito ovviamente sarà uno questo ritorna però uniterabile perché chiaramente potenzialmente ci sono più oggetti con quello ssd questo non c'è nessuna garanzia dalla parte del compilatore per cui vogliamo dirgli che vogliamo single elemento singolo di questa lista anche qui questo chiaramente devo fare return attenzione al single adesso lo scrivo un po' meglio attenzione al single perché il single vi ritorna l'oggetto singolo della lista iterabile quindi è un to do item non è neanche nullable quindi è un singolo oggetto ma torna soltanto se effettivamente la lista contiene un singolo oggetto ed è ritorna a quello se la lista contiene zero elementi o n elementi quel single lì esplode per correttezza quindi dobbiamo essere abbastanza sicuri che ci sia l'oggetto ci sia e che l'oggetto non sia ripetuto non può essere ripetuto perché i GUID sappiamo che adesso non possono essere ripetuti salvo coincidenze cosmiche improbabili però che ci sia bisogna essere convinto se se non lo sappiamo c'è single or null e ci ritorna l'oggetto o null e null è se non c'è o se è doppio o multiplo quindi il null vale in tutti i casi in cui non viene rispettata la singolarità dell'oggetto non c'è anche un first or null c'è anche un first certo c'è anche un first first or null c'è anche last dovrebbe esserci quindi possiamo cioè in base a quello che ci interessa quindi first e single in realtà sono equivalenti in questo caso perché sarà sempre un oggetto però single ci dà una garanzia in più e ci garantisce la non ripetizione dell'oggetto quindi se vogliamo essere difensivi dobbiamo mettere first per dire vabbè anche se sono due magari è un errore così è sfortuna e facciamo finta di nulla e non esplodiamo forse è meglio però al punto di vista della correttezza formale per quanto una to do list debba essere corretta formalmente single e più corretta quindi sì first è come se in un database faceste where tal detali limit one ok tutto questo quindi qui dentro stiamo stiamo rigenerando questo provider e pescando l'oggetto tal detali per cui dentro il nostro nostro to do list view finalmente possiamo andare a creare qui allora qui farò due cose diverse quindi quando creo la quando andiamo a visualizzare l'oggetto qui dentro posso continuare a utilizzare il provider scopo è il provider classico di to do item provider perché so che in questo caso se c'è un aggiornamento della lista da fuori qualcuno mi sta aggiornando ok nel senso che perché sono sicuro di essere dentro una list view che già fa watch di to do item provider no faccio watch di questo quindi sono sicuro che quando to do items provider cambia in qualche modo tutta la lista viene generata e a cascata tutti i suoi i suoi figli di questo genere qua quando sono nella pagina chiaramente questa garanzia non ce l'ho perché la pagina una volta che è stata creata rimane lì nello stack di navigazione e quindi bisogna fare quest'altro giro quindi qui dentro andiamo chiamato quindi per passare quest'oggetto qui al nostro lettore la cosa che conviene fare probabilmente è potremmo passare l'oggetto cioè l'id alla nostra pagina per esempio perché qui a questo punto non sarei più il provider scope perché non devo fare uno scope specifico è già il provider che è specifico quindi perché chi lo va a leggere sa qual è l'id di riferimento che gli interessa per cui in realtà la cosa più semplice da fare è dimenticarci il provider scope che non serve più fare l'override tornare direttamente la to do item page togliendo un paio di parentesi di troppo ok e modificando la to do item page in modo tale da farle leggere in automatico cioè passarle l'id direttamente quindi questa pagina qui conterrà l'id dell'elemento che deve gestire quindi lo possiamo mettere direttamente qui nella pagina foto to do item id per esempio lo metto nel costruttore ok a questo punto la pagina sa che cosa le interessa non fa più il watch di current to do item provider ma fa direttamente il watch di specific eccetera eccetera e e li passiamo al provider quindi il provider è così con questa la chiamata funzione prendiamo cioè accediamo al provider specifico della famiglia tali e tali passandogli questo ci ritorna un provider di cui facciamo watch a questo punto l'item qui si modifica ogni volta che viene modificata la to do list principale e a cascata poi ci permette di riconoscere l'aggiornamento dell'oggetto attenzione qui a questo punto non c'è più nessuno che fa l'overriding current to do eccetera eccetera questo oggetto qua quest'altro provider qui abbiamo perso il nostro provider scope mentre ah scusate qui quando quando costruisco la pagina chiaramente a questo punto devo passare l'id alla pagina quindi qui dentro dovrò metterci item.id lo fornisco nel costruttore vabbè qui non ho no vorrei avere accesso all'item ah non è ok non è ovviamente non è costante giustamente va bene così quindi qui ho l'id e però attenzione nella pagina quindi ho accesso al mio item dentro to do item viewer che vediamo qui to do item viewer è un un widget che fa watch il current to do item provider devo garantire che come c'è un provider scope col current to do item provider che ha un valore qui dentro nella lista deve averlo anche nella pagina per cui a questo punto nella pagina devo fare quella costruzione che avevo fatto prima qui metto il provider scope ok provider scope qui avrà l'override ok faccio l'override di current eccetera eccetera e faccio l'override di value e gli passo direttamente l'item ok ok ok allora qui le fonti di possibile confusione sono elevatissime cosa è successo quindi allora to do item viewer continua a fare riferimento solo a current to do item provider quindi qualcuno da fuori deve passargli un valore di current to do item provider che sia valido se no il nostro viewer esplode questo oggetto qui è il provider quello semplice che non si aggiunga in automatico però funziona perché qualcuno imposta un valore prima lo facevamo qui navigando quindi quando navigavamo creavamo una pagina che era già annidata dentro il provider scope che conteneva il valore questo abbiamo smesso di farlo perché non ci piaceva perché poi quella pagina non riesceva ad aggiornarsi in base alla lista di to do item a questo punto della pagina passiamo l'id che interessa alla pagina la pagina internamente può mettersi in ascolto grazie a specific to do item provider che ci permette di ascoltare un singolo oggetto della lista e a quel punto la pagina può fornire un provider scope al sotto elemento to do item viewer e dargli accesso al dato se non ho commesso errori gravi in teoria ok i miei oggetti entro qui dentro adesso a parte la grafica è un po' discutibile la spunta finalmente funziona notate che quando anzi torniamo io facciamo le flash da zero perché c'è questa chiamata qui rebuilding specific provider che viene chiamata quando la family no la specific provider viene costruito cioè quando serve un valore quando in sostanza questo provider qui fa accesso alla lista va a filtrare gli elementi per mostrarli a qualcuno per ora non ce n'è neanche uno perché non è mai servito questo funziona assolutamente come prima quando clicco qui improvvisamente si aprirà una pagina che fa riferimento a specific to do item provider e dovrà valorizzare quell'oggetto quindi ci clicco viene creato un provider della famiglia dal dettaglio con questo di qui l'oggetto viene fornito a tutta questa pagina e che potrà che può mostrarla a questo punto quando clicco qui cosa accade? si aggiorna la lista to do item provider a catena si aggiornano tutti i provider dipendenti quindi quando si aggiorna questo si aggiornano a sua volta to do item count provider perché è cambiato potenzialmente è cambiata la lunghezza della lista in questo caso non è cambiata perché ho solo cambiato un booleano e si aggiornano anche tutti i specific to do item provider perché potenzialmente si sono cambiati tutti i singoli oggetti e quindi questo viene rebuildato e quindi qui nell'out trovo il rebuilding specifico che c'è eccetera quando torno indietro finalmente la spunta c'è perché è stata aggiornata nella lista stessa tutto bellissimo quando la tolgo si riapre e anche questa torna a essere valorizzata in maniera corretta ok era così facile farlo ah no mi rendo conto che allora bisogna un po' entrare nella mindset di farsi del male con i provider però una volta che abbiamo capito i singoli fondamenti e alla fine ci siamo a questo punto non c'è più nessun elemento misterioso ci sono l'ultima cosa che aggiungiamo sono i future provider che servono per leggere dei dati che non abbiamo subito disponibili però a parte quello abbiamo fatto la cosa importante a ricordare che una volta che abbiamo l'approccio per progettare l'applicazione è semplicemente concentrarsi su quello che è lo stato interno della nostra applicazione quindi in base a quello che la nostra applicazione farà capire bene come è fatto il modello interno dello stato suddividerlo per quanto è possibile in sotto provider fare in modo che i provider si aggiornino in maniera corretta in base alla modifica dello stato che poi voi farete quindi tra un'interno di un po' tra il fatto di concentrarci sulle padine su questo per il tipo che abbiamo fatto sul parire i provider una volta fatti bene i provider non potete fare errori in un river pod questo è la cosa l'unica cioè il vantaggio di fare tutte queste cose qui adesso che le abbiamo fatte apposta un po' così un po' complicato per apprezzare come avviene a cascata questo comportamento però in genere allora se conoscendo river pod come funziona e sapendo che dobbiamo ascoltare i singoli to do items saremo partiti subito con un provider con un family provider che ci dà la visione di un singolo oggetto e quindi fondamentalmente quando avete uno scenario di questo genere qui avete una lista di oggetti che dovete gestire in genere la cosa che si fa è un provider generale che è il contenitore di oggetti che si manipola con tutti i vari metodi modifica questo togli questo togli quest'altro e poi una specie di vista che vi permette di ascoltare solo un oggetto così che poi a sottoparte la vostra applicazione potete dare semplicemente in pasto quell'oggetto lì e rimangono in ascolto di quello questo è comodo questo è comodo per due motivi in realtà perché questo specific to do item provider esattamente come il to do item counter provider fa sempre da cache interna e lo fa in maniera così automatica non vi costa nulla nel senso che abbiamo visto prima che se modifico la lista e non modifico la lunghezza da Riverpot ci risparmia delle rebuild perché questo ho tre cose da fare non viene rebuildato quando la lista cambia ma non cambia la lunghezza giusto? quindi quando cambio le spunte o tra un secondo quando cambiermo la descrizione che cambiano un oggetto ma non cambia il numero di oggetti questi contatti lo specific no il to do item counter provider non viene aggiornato non fa la notifica perché si accorge che il valore nuovo è uguale a quello precedente però quindi non fa modifiche questo vale anche per lo specific to do item provider in realtà per cui questo oggetto qui che in realtà è uno il provider con in realtà ne abbiamo n perché abbiamo un provider per ogni id che possiamo passargli sulla carta ognuno di questi provider qui in realtà se l'oggetto non cambia cioè se l'oggetto è identico non non aggiorna i widget dipendenti ok quindi se l'oggetto è sempre lo stesso to do item provider con tutti i campi uguali allora non non devo neanche aggiornarmi ok per cui adesso non è questo lo scenario in realtà però se avessimo due che ne so due sottopagine mettiamo una sinistra e una destra con due specific due item provider diversi uno una parte una parte all'altra se modifichiamo l'uno nonostante entrambi dipendano comunque da to do item provider quindi appena modifico la lista principale in teoria entrambi che vengono ricostruiti se l'oggetto non cambia non la notifica non passa ai widget e quindi i widget non ricostruiscono questo accorgesi che siano uguali gli oggetti dipende dalla funzione di eguaglianza degli oggetti in dart per cui in realtà manca una piccola cosa per far funzionare questa cosa perché adesso questo single questo noi qui diamo fuori il to do item il to do item se ricordo bene ci avevamo dimenticati di implementare l'eguaglianza per cui questa cosa ancora non funziona per farla funzionare bisogna fare l'overwrite dell'operatore uguale e a quel punto l'overwrite del nostro hash tutto qui ok cioè se qui facciamo l'overwrite del come era stessa ormai vorrei fare uguale ah no non è così verità mi sto confondendo con il chart ah sì e questo non serve cioè era così ma quindi if identico test e alter allora poi e se è un to do item allora io faccio possiamo fare la verifica che tutto sia uguale quindi che sostanzialmente il d sia uguale e anche lo stato deve essere uguale chiaramente quindi non ho due fagg per fare questa cosa e ok altrimenti vi torna ok scusate sì metterlo in in in in in in in salvo salvo il file lo fai in automatico ah quello penso è una cosa mistica che penso che sia l'estensione per d'arte di vista su che lo fai in automatico se non lo fa probabilmente può essere configurato immagino si può si può togliere non sempre è gradevole francamente però a volte è utile ok quindi qui stiamo verificando che tutto sia uguale perché perché normalmente non basterebbe verificare che l'id sia uguale per concettualmente avere dei due item che sono uguali in questo caso bisogna verificare che tutto sia uguale perché potenzialmente abbiamo due item che hanno stato diverso quindi potremmo avere due item id a che è done e un to item sempre con lo stesso id che invece è non done e questi chiaramente sono due oggetti tra loro diversi se lo implementiamo in questa da lista se l'oggetto è identico spiccicato al primo allora non devo ricostruire la l'ubbc dipendente ok allora rendiamo un attimo più carina la pagina di di modifica qui aggiungendo un un editor di testo che è una cosa molto banale però è una cosa che serve per cui lo facciamo al volo allora siamo qui dentro allora adesso per comodità tra virgolette lascio questo visore questo viewer qui lo lascio dentro la pagina così vediamo come si aggiorna in temporale in base alle nostre modifiche sopra ci metto alcuni campi per modificare i nostri oggetti per cui lo facciamo qui dentro il padding qui ci mettiamo una colonna una colonna che allegniamo tutto in alto poi ci mettiamo un style box per distanziare un po' ok e poi ci mettiamo un metterci l'oggetto magari e poi ci mettiamo un oggetto che si chiama text field ok che è il classico il campo di editing del test quindi dove l'utente può scrivere citare modificare le cose ora quello che ci si potrebbe aspettare in un text field è che ci sia un campo text o content o qualcosa del genere quindi un modo per fornirgli il testo nel widget stranamente non c'è stranamente ha un senso una serie di opzioni che sono in realtà di proprietà di parametri opzionali quindi per esempio avere l'autocorrect abbiamo il colore del cursore la cosa che lampeggia per l'input del testo abbiamo la lunghezza abbiamo il fatto che viene nascosto il fatto che si ridonda e così via quindi tutte cose di supporto grafico diciamo così ma nulla che riguarda il testo perché perché il testo di questo oggetto qui è parte dello stato di questo widget quindi questo è un widget che paradossalmente è molto sofisticato è molto complesso per quanto è un widget di base di flat ovviamente no il Win32 era secondo me utilizzato però anche il Win32 è un oggetto abbastanza banale è una finestra che si chiama edit se ricordo bene e permette di modificare il testo si comporta esattamente come il testo statico in più è modificabile nel caso di flat era un pochino più sofisticato perché dobbiamo avere un metodo un sistema per appoggiare lo stato interno del widget cioè il testo che l'utente scrive qui dentro deve vivere da qualche parte nel nostro albero di widget e non può essere nel widget stesso cioè il testo che l'utente qui scrive o modifica o comunque gestisce in qualche modo non può essere qui dentro perché se lo fosse ogni volta che rifacciamo la build di questo widget che contiene il text field andremo a perdere lo stato del di editing perché immaginate di avere uno state con lo widget un widget con dello stato lo stato è del widget stesso quindi è allo stesso livello del widget a livello di albero se qualcuno cambia il nostro item qui perché sto modificando il titolo o la descrizione e così via ad ogni modifica io faccio rebuild di questo di questo widget qui e mi sovrascrivo i dati del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del del cioè il text che sto modificando qui dentro deve essere un livello sopra e deve essere in sostanza qui dentro non so se mi sono spiegato in qualche modo però c'è serve un un obiettivo di appoggio che rappresenta lo stato interno del text field come si fa? allora si usa cioè il pattern che si usa in Flutter questa cosa che vale per il text field è il caso più comune ma vale anche per altri oggetti come beh tipo lo scroll view il single child scroll view che abbiamo visto brevemente la volta scorsa per scrollare anche lì lo stato di scrollatura quindi di scorrimento del widget anche lì va va lo stesso principio e poi vale per le schede le tab e così via quindi ci sono alcuni esempi in cui rivedremo questo stesso pattern però il il pattern è quello del controller quindi c'è un controller che è lo stato interno del widget e noi glielo passiamo in costruzione ecco questo certo qui questo controller qui che adesso metto null per tanto per contiene lo stato interno della nostra eh e eh la pagina del nostro del nostro eh del nostro widget per cui eh quello che avviene è che per poter tenere track per tenere un'istanza di questo controller che sarà in realtà un text editing controller il tipo come vedete qui un text editing controller dobbiamo tenerlo da anche parte nello stato della nostra applicazione nella fattispecie dentro lo stato di questo widget qui quindi per avere lo stato interno cosa dobbiamo fare rendere tutto questo oggetto qui la tutela di page un consumer stateful widget ok lo trasformo in stateful widget questo qui purtroppo non c'è la eh l'auto l'auto così come si chiama l'auto l'auto cambio del eh che ci dà questo studio per cui bisogna farla a mano quindi faccio l'override qua ops l'override ha fatto una brutta allora qui in alto mettiamo l'unico metro che ci interessa non è vero perché questo oggetto qui il final va qui a questo punto eh il costruttore lo mettiamo qui questo per cosa casaccia bene questo create state come no come al solito cosa fa ritorna un oggetto l'oggetto nascosto lì quindi lo stato quindi è la nostra to do item page state che extends ehm questo consumer state di quindi questa è la classe che comprende lo stato e che istanziamo qui quando andiamo a creare il nostro widget qui manca una parentesi Raffa ok ho modificato lo stateless widget in un stateful widget sostanza quindi ho fatto a mano quello che prima faceva per noi il nostro amico di San Studio cosa manca qui questo oggetto questo valore qui non è più qua ma è nel widget quindi devo fare widget di to do item pd questo non gli piace no perché ok ovviamente quindi ha la classe di cui è questa qui giusto ok a questo punto vede il tipo è all'ordine del campo ok e manca questo che è null che non può essere null per il resto eh lo vorrei dover corretto allora vuole cambiare ah la giusto il ref qui non c'è nella build ma c'è direttamente così la ref ce l'abbiamo in altro modo ok a posto ho aggiustato la la ricompilazione questo dovrebbe andare a parte questo controller qui che manca questo controller qui dove lo mettiamo lo mettiamo nello stato quindi qui nello stato posso mettere questo text editing controller ok che sarà il nostro controllore sarà un oggetto nullable ok perché farò l'override di altre due di altre due funzioni vediamo se lo fa fare lo studio no non lo facciamo a mano ci sono due metodi fondamentali dello stato che non abbiamo ancora visto perché allora quando abbiamo uno state full widget lo stato dei nostri widget hanno il metro build che normalmente avrebbe lo state less widget quindi lo state less widget non è stato per cui si costruisce da solo in presenza di stato esterno è lo stato che ci permette di costruirci quindi la build è dentro lo stato ma inoltre a questo ciò ci sono altri due metodi astratti di cui possiamo utilizzare vediamo se li troviamo un attimo qui dentro vedo di no perché sono nel no sono nella classe ho perso sono nella classe aiuto questo dovrebbe derivare a state quindi dentro dentro state abbiamo la definizione quindi qui dentro abbiamo eccolo no init state init state è il metro che viene creato una singola volta per quel widget quando viene aggiunto all'altro dei widget quindi inizializza lo stato una singola volta e poi c'è dispose che è da un'altra parte vabbè non è potato è dispose no dispose che viene chiamato ugualmente una singola volta quando il widget viene rimosso dal lato del widget quindi con init state e dispose abbiamo un modo per tenere traccia del fatto che il widget è stato aggiunto al nostro albero dei widget oppure è stato rimosso dal lato del widget quando non serve quindi facciamo il loro rete questi due metodi quindi init state e dispose sono entrambi metodi void void ok qui bisogna fare override se no dart non è contento ok ultima complicazione ve lo assicuro qui bisogna chiamare questi due metodi init state e dispose sono dei metodi andiamo a vederli qui che sono marcati come must call super quindi il metodo che fa i metodi che fanno l'override di questo metodo qui devono chiamare il metodo overrideato ok per come descritto per cui per essere dei buoni cittadini di Flutter anche perché se no poi bisogna fare prima di tutto super init state cioè bisogna chiamare praticamente l'implementazione della classe del metodo base se no Flutter non è contento ok quindi di base quando facciamo init state e dispose bisogna implementarli in questa maniera quindi è un override e bisogna chiamare la classe l'implementazione della classe base ricamitolo un secondo quando giusto per entrare nel meccanismo dei widget quindi i widget quando vengono creati da un altro oggetto che li utilizza quindi nel nostro caso nella nostra to do item page il widget viene creato da questo metodo qui quindi quando io clicco su un oggetto nella nostra to do list scateno questo metodo qui questo metodo crea una nuova root nell'albero dei widget ok che si sorpone alla root che già c'è e dentro quella root lì ci viene messo ci viene aggiunto un to do item page quindi quel nostro to do item page è il widget stateful che viene aggiunto all'albero dei widget e poi viene rappresentato finché un widget rimane nell'altro dei widget quindi finché la pagina è presente quella pagina scomparirà soltanto quando la distruggo cioè l'utente la distrugge navigando inietro quindi l'unico modo per rimuoverlo dall'albero è quando il navigator fa pop e quindi la pagina sparisce fin tanto cioè finché non avviene questa cosa il widget rimane lì e continua a fare build ogni volta che serve noi sappiamo che l'idea di Flutter è che i nostri widget si sanno autocostruire e lo fanno quando c'è bisogno quando c'è bisogno quando cambia lo stato del widget interno oppure se qualcosa li fa dipendere da qualche altro stato esterno quindi ci sono due metodi in sostanza uno è il famoso set state che abbiamo anche qui perché abbiamo questo è uno stateful widget quindi possiamo fare set state e avvertire Flutter che attenzione qualcosa è cambiato nel mio stato interno oppure l'altro modo è quello del watch quindi rimane un ascolto di qualcosa che se quello cambia il widget fa build quando la prima volta che viene messo nell'albero di widget faremo in it state e appena prima di essere tolto dall'albero di widget farà dispose il nostro Flutter nel frattempo tra in it state e dispose può fare build tutte le volte che vuole ok questa è un po' l'idea qui questo ci serve per inizializzare se c'è bisogno dello stato interno un pochino più sofisticato del solito ci serve soprattutto perché questo controller qui non possiamo costruirlo nel costruttore altrimenti saremmo stati più felici cioè potremmo anche provare a farlo ma non è non funziona sempre per cui potremmo cioè potremmo anche tentare di costruire il costruttore il controllore nel costruttore dello state però è meglio di no perché spesso i controller sono più sofisticati di questo e quindi in genere il pattern è questo ho il controller è nullable perché all'inizio non ha valore lo creo lo inserizzo qui dentro quindi creo un text editor controller eccetera eccetera ok qui adesso vedremo cosa contiene e quando la pagina si chiude faccio dispose anche anche il controller ha un metro dispose che preannuncia la dipartita di questo oggetto tanto qui essendo nulla volentoria lo devo rendere so che tanto non è nulla perché dispose posso farlo soltanto se è stato fatto in state quindi sappiamo che non sarà nulla cosa può contenere il nostro text editor controller questo oggetto visto che è molto facile per fortuna contiene soltanto la stringa quindi contiene la stringa di testo che quell'oggetto lì deve gestire cosa le facciamo modificare le facciamo modificare la descrizione mettiamo quindi per iniziare cosa ci mettiamo mettiamo text widget nessuno non deve avere accesso a widget qui abbiamo l'item ah no ho il giusto ho il soltanto l'it per cui in realtà non ho l'oggetto stesso per avere l'oggetto devo pescarlo dai miei dai miei provider quindi peschiamolo due item faccio ref dot ref ce l'ho perché qui nel nel consumer state ho accesso a tutti i vari widget faccio ref read perché devo farlo una volta sola questa non devo ricostruirla ogni volta di cosa di specific to do provider giusto sì di widget to do item id che è dd che è stato costruito questo oggetto questo dovrebbe tornarmi un to do item qui finalmente posso passare il testo qua e quale testo mi interessa description description potenzialmente è nullable per cui se non c'è descrizione lo metto a stringa vuole complicato inutilmente forse ma è così a questo punto abbiamo un controller che contiene il testo che è quello di partenza a questo punto lo agganciamo al text field il text field qui ci metto distanza ctrl come l'ho chiamato adesso finalmente questo text field qui che vive nel sotto albero della mia pagina è collegato al controller il controller è sempre vivo nel senso che lo inserizzo una volta e lo distruggo quando la pagina cessa di esistere il text field può essere creato distrutto quante volte vogliamo però è sempre collegato al controller per cui anche se viene ricreato e verrà ricreato perché ogni volta che modifico il text item stesso cioè prodossalmente mentre scrivo e aggiornerò il contenuto della description ricostruisco la pagina ovviamente per cui adesso ancora no però lo faremo tra l'istante intanto vediamo se tutto funziona poi poi parliamo qui adesso mi aspetto che voglio comparire un text field qui sopra con la mia descrizione bellissima che è la description di partenza di ogni item e mi dovrei permettere di modificarla ok quindi questo è il testo dell'id qui è il text field classico di material per cui vedete qui i text fields sono estremamente verbosi per cui stampano tante cose qui molto bello nel log e qui posso modificare il testo ok ha cantato e non è in multilinea per cui chiaramente accetto solo una linea però sulla carta per essere in multilinea ok adesso questo testo qui che tra l'altro posso cioè ha tutte le funzioni del text field classico di android in questo caso non cambia ancora il to do item chiaramente quindi tutte le modifiche dove rimangono dentro il mio fruggerato controller quindi il testo c'è ma è qui dentro e non viene propagato al to do item per farlo propagare bisogna mancano un paio di cose di supporto purtroppo per cui bisogna fare cosa bisogna fare to do item qui abbiamo fatto no with done questo metodo per ricreare il to do item modificando il checkbox facciamo la stessa cosa con with description questo quando lavoriamo con oggetti oggetti immutabili di solito si fa qualcosa del genere a qui possiamo anche usare la sintassi funzionale se ci piace di più ok come si si non mi ero perso non so digitare non guardandolo da sera ok questo va bene e manca però manca qui un metodo su to do list che ci permette di fare questa cosa qui quindi facciamo un set done con cioè no facciamo un set description che fa la stessa cosa questa cosa qui la copiamo totalmente la stessa cosa potremmo anche fare un replace un metodo replace che se ci permette di fare qualcosa di generico però tanto per essere proprio espliciti facciamo così ok quindi modifichiamo la lista aggiorniamo l'oggetto se lo troviamo altrimenti lo ignoriamo ok a questo punto dentro tutta la temp page quando qualcosa cambia nel text field voglio essere notificato qui c'è on e tutta qui ci sono diversi cambia un po' la cambia un po' la seman cambia un po' quando viene invocato on change viene invocato ogni tanto con un po' di delay ogni volta che c'è una modifica non microscopica sul text edit quindi ogni volta questo verrà chiamato tante volte on change da mano che scrivo on as in complete è una cosa un po' di alto livello che ci segnala il fatto che l'utente ha finito di modificare sostanze per cui è quando perde il focus sulla tastiera quindi si chiude o l'utente pigia invio o cose di questo genere ma in realtà è un differente che diciamo on change che siamo sicuri che verrà chiamato diverse volte non ricordo ok quindi questo ci dà la stringa e ci dà un metro che viene invocato quando la stringa è arrivata quindi value è la nuova stringa dell'oggetto in realtà abbiamo due modi per leggere la stringa perché possiamo anche leggerla dal controller stesso quindi questo possiamo leggere il text e questo è sempre la stringa del controller sono due cose identiche in realtà poi qui ci arriva direttamente nella funzione quindi usiamo quella e facciamo come prima quindi come con la spunta facciamo ref punto read di qwitems provider ok notifier notifier ci dà accesso a to do list qui abbiamo il nostro set description se non mi sbaglio ok l'indice l'abbiamo da qualche parte perché come ah dissi ah perché l'ho letto da qui ok item ID se no c'è anche sì questo item ID va benissimo altrimenti c'è anche widget to item ID è identico quindi questo è l'altro e questo questo è la value non ricordo se questo string questo non è un nullable va benissimo questo è un osetto ok vediamo se se gli dei di Flutter ci sono ci sono favorevoli ok ok e se giornate automaticamente anche sotto perché perché man mano che modifichiamo qui il testo si modifica il testo nel controller ma quello è soltanto un appoggio in realtà noi nel frattempo stiamo mandando ogni volta che c'è on change stiamo modificando lo stato della Tutorist item e a cascata cambia tutto si aggiorna la pagina quindi fare l'intera pagina questo qui rimane identico questo il text edit ha già il controller suo per cui se ne infischia abbastanza dei contenuti perché il controller non viene ricostruito chiaramente il controller è stato già costruito nel in-in-state se venisse ricostruito ogni volta anche lo stato dell'oggetto cioè se il controller venisse rimpiazzato vedreste cioè non riusciremo a digitare praticamente perché ogni volta che io faccio una modifica la modifica mi riaggiorna il text edit e mi mi mi sbarella il il campo di per cui funziona perché c'è una il controller d'appoggio che gestisce il text field che viene aggiornato ad ogni modifica però semplicemente l'aggiornamento non cambia nulla e sotto invece abbiamo il nostro classico to do item viewer che si aggiorna e rappresenta lo stato che gli viene passato e non fa assolutamente nulla se qui spunto la checkbox si modifica e se torno indietro in teoria trovo la checkbox messa e la descrizione aggiornata perché è tutto è tutto collegato e questo a questo punto cioè si apprezza meglio tutta la fatica che abbiamo fatto per fare questi provider benedetti perché a questo punto cambiare delle piccole cose è tutto automatico in sostanza ok per cui adesso se abbiamo 27 punti in cui si possono cambiare queste descrizioni non c'è nessuna fatica di ricordarsi dove è lo stato come viene propagato e così via perché lo fa tutto per quanto no se abbiamo fatto le cose correttamente se no poi bisogna andare a rintracciare i problemi non so se è il caso non so se è il caso di farlo ma qui potremmo aggiungere magari non ha senso farlo quindi lo tralascio però potremmo avere un altro text editing controller per il titolo chiaramente e vedremo che modificando quello si modificherebbe anche la bar chiaramente perché la bar di nuovo è parte della pagina quindi vive qui dentro anche questo possiamo farlo a costo zero quindi magari cambio semplicemente qui leggo il titolo e proprio brutalmente faccio quando faccio set description in realtà setto il titolo no beh ok e poi a questo punto ok e a questo punto qui faccio set per cui a questo punto giusto per non cambia nulla però per apprezzare che tutte le modifiche sono tutte a cascata e tutta la pagina viene ricostruita appena modifico il testo qui è che anche la bar qui in alto dovrà modificare ok questo era banale però sapevamo che avrebbe funzionato ok perfetto allora ultima cosa che facciamo prima della pausa è un altro pattern classico giusto perché prima l'ho accennato questo è utile per alcuni aspetti della vostra applicazione per ora la navigazione tra pagina quindi tra la pagina principale diciamo così e la pagina dettaglio viene fatta in maniera imperativa in realtà quindi facciamo navigator punto off context facciamo push se aggiungiamo pop se andiamo a togliere poi avete visto intravisto ci sono vari altri metri quindi possiamo fare delle cose un po' più complesse sul stack però possiamo togliere pagine finché non troviamo una pagina che ci interessa possiamo togliere tutte le pagine e tornare alla root quindi ci sono varie cose che possiamo fare un po' più più sofisticate però quello sono abbastanza dipendono poi dipendono da lo scenario della vostra applicazione in alcuni casi possiamo fare possiamo legare la navigazione tra virgolette allo stato dell'applicazione e l'esempio classico è quello del login quindi abbiamo appunto l'idea è quella di fare un set on fire provider che ingloba il profilo utente tra virgolette quando l'utente fa login si naviga si cambia paginata facciamo un attimo questa cosa qui e vedrete dobbiamo un po' andar di sticcare un po' le cose ma dovremmo farcela prima delle undici se non mi perdo per stada quindi proviamo a farlo prima cioè il primo passo che devo fare è prendere tutta la home page e renderla una pagina a se stante quindi quello che faccio sì è prendere tutta questa roba qui la prendo penso che finisca qui o meno e la sposto dentro pages quindi qui sarà home page diventa questo questo si chiama my home page ma cambia poco ma ma perché 27000 import la DominoБile è hehкая è Hoe Ok, dovrebbe esserci. A questo punto dentro la mia main, qui è molto facile perché a questo punto devo solo importare questo. Ok, e nel frattempo creiamo una piccola pagina di login. Quindi finora è tutto qua, non sono spostato la pagina. Cremo una pagina alternativa che è la mia login page. Ok, adesso la faremo per un istante. La login page la possiamo immaginare in vari modi. La visita conterrà due... ... quindi text field ci metteremo... ... lo metteremo subito stateful. State login page... ... ho dato questo ritorno ovviamente. Quindi sto facendo la cosa che avevo fatto prima per... ... per la... ... la pagina del code di modifica. Quindi qui serve in... ... qui se lavorate con Android Studio in teoria vi è un po' più d'aiuto quando fate queste cose qui. Quindi scriveremo codice in teoria. Ok, perfetto. A questo punto qui dentro creeremo una pagina molto semplice. Quindi faremo... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... Icebox Icebox 8 2 ok quindi avrò due oggetti username anche se poi non contiene nulla siamo disposti perché siamo dei buoni cittadini ok a questo punto li colleghiamo qua così che mi sono nulla in partenza così e qui control questo sarà lo username e poi sotto ci sarà la password e in più la password ovviamente la rendiamo non me lo ricordo williamo perfetto si basco da tutto si Perché stiamo usando un set per non un consumer? Perché non siamo legati al mondo di provider, qui dentro, però per ora. Ok. Cioè, magari in futuro anche sì, però... Ok, perché qui non facciamo ref watch di nulla, per cui il widget ref non ci serve, in sostanza. Se noi invece volessimo tenere a livello globale l'applicazione, non so, se non è un card, autorizzato se no con le credenziali... Ok. Ah no, comunque no, in realtà ci serve perché bisogna scrivere sul provider che siamo logati, quindi ho detto una cosa come tu, è falsa. Ci serve, deve essere un consumer state full widget perché ci serve il ref per poter scrivere da qualche parte che l'utente sia logato, giustamente. Quindi, giustamente... Sì, sì, sì, idealmente sì. Cioè, in realtà la cosa più facile che si può fare è lavorare con degli stateless widget, che sono quelli più banali, in sostanza, e poi quando serve fare watch di qualcosa, o implementate un consumer widget, oppure usate il consumer widget, quindi l'oggetto che abbiamo visto molto probabilmente ieri. Quindi se proprio volete, non volete scrivere una classe che deriva da consumer widget, eccetera, potete mettere qui dentro un consumer. Adesso qui non posso farlo perché potrei anche farlo, ma... In realtà posso farlo. E qui dentro ho... Un ref, credo, questo. No, ecco, sì. Codfers e quant'altro. Quindi se ho bisogno dello stato posso farlo dentro così, in questa maniera qua. Però... Sì, sì, no, in realtà sì, esatto. Sì, sì, cioè, nel senso se... Usare il stateless widget è quella cosa che è conveniente sempre. Anzi, se abbiamo soltanto stateless widget const, quella è la cosa che Flutter riesce ad ottimizzare meglio di qualsiasi altra cosa. Quello è un oggetto che non viene ricostruito mai, a meno che non venga proprio rimpiazzato a qualcos'altro, per cui è ideale. Quindi a livello concettuale di ottimizzazione sarebbe meglio utilizzare stateeless widget, normalmente, con dentro solo dove ci sarà il consumer. Esatto, esatto. Ora qui, questo oggetto qui è un po' più sofisticato, per cui non possiamo fare a meno di usare uno stateful widget, perché c'è dentro un text fill, tutto qua. Per cui siamo costretti ad avere un oggetto che possa contenere un controller che ha dello stato, ovviamente. Ma se c'è un stateful widget e in questo caso un bottone, un clicknet, modificare quel campo test, quello che faccio, appunto, notifire... Sì, sì, rimpiazza. Sì, sì, quello funziona. Sì, sì, in quel caso funziona. Questo è in realtà che lo facciamo qui, modificando il contatore, no, non più qui, era dentro un page a questo punto. C'è il contatore, no, quel provider che abbiamo fatto così, tanto per... che contiene soltanto un valore numerico, è questo. Il contatore che aggiunge sopra in alto a destra questo contatore qui, che non ha nessun legame con nessun altro elemento dell'interfaccia. Però funziona in quella maniera lì, effettivamente. Qui c'è quel contatore lì, che è il counter viewer, che è uno stateless widget const, no, che in realtà... qui abbiamo implementato con consumer widget, ma potrebbe tranquillamente essere un consumer implementato. Però attenzione, allora, sì, se qui mettessimo un... Allora, non è dietro. Se qui mettessi un consumer, questo qui, che poi dipende da fare refwatch e quant'altro, eccetera, no, perché è al contesto suo. No, ho detto una cosa, stavo temendo. Cioè, il rischio è che, modificando qualcosa di questo consumer qui, io vado a ricostruire tutta la pagina, tutta la homepage in cui si trova. Questo, in teoria, lo posso evitare. Quindi, il notifier non modifica solo per il modo che modifico, però, perché... Dipende... Il notifier dipende da cosa sto alterando, però, in teoria, quando un notifier scappi una notifica, riaggiorna tutto quello che ha fatto Watch, di quel provider lì. Per cui, la... Bisogna stare molto attenti. Cioè, nel senso, qui sto facendo, quando clicchiamo su quel pulsante lì... Ho perso. Ah, qui. Quando clicco sul pulsante, facciamo come diceva lei, no? Quindi c'è on press, è una cosa molto semplice, quindi faccio, leggo il contatore e ci riscrivo sopra. E qui è un'operazione molto, molto semplice, per cui non c'è nessuno stato da gestire. A cascata, chiunque abbia fatto Watch di questo oggetto qui, chiaramente viene ricostruito. Devo stare attento ed evitare che qualcuno faccia Watch di quell'oggetto a un livello troppo alto dell'albero. Quindi, bisogna stare attenti a farlo più vicini alla radice possibile. Quindi, in questo caso, il counterviewer ci è d'aiuto, perché è un oggetto veramente molto primitivo, che è stateless, in effetti, e non fa altro che ricostruirsi quando cambia il counter provide. Quindi, è un modo per encapsulare questa dipendenza dallo stato. Quindi, è vero che sulla carta potremmo scrivere tutto quanto in un singolo file, in un singolo albero di widget, usando i vari consumer annidati e fare tutto quanto in un singolo blocco di widget. Però è chiaro che diventa una follia poi a gestirlo. Per cui, quando riuscite a tirare fuori dai pezzettini, se li rendete stateless, const è ideale. Ed è quello che abbiamo fatto con lo state, con il counter viewer che fa, è sicuramente questo. Quindi, se usare il stateful per poter anche dividere le file, senza avere tutto questo file, o anche essere in questo modo, lo stateful widget? una volta che mi passate alla provider come approccio, in realtà non avete bisogno a meno che non ci sia dello stato proprio della pagina che dovete gestire. In questo, cioè, nella login page ci serve uno stateful widget perché abbiamo questi text field che senza un appoggio in cui è il testo in sostanza non funzionano. Per cui, questo deve essere stateful e serve dello stato che è locale alla pagina. Però, se non ci fosse questo, in realtà potrebbe essere tranquillamente stateless. Quindi, in realtà, nella maggior parte dei casi ve la cavate con lo stateless. Se non ha bisogno di text field e quant'altro, ci sono altre piccole cose che vedremo che hanno bisogno di controller come questo, tipo le schede. Però, in generale, se ne può fare tranquillamente a meno, anzi, più se ne fa meno, meglio è, anche perché c'è meno codice a scrivere ed è tutto codice molto noioso, come avete visto, quindi c'è questo in state, disposed, non stato, ma è tanto codice per fare molto poco alla fine. Quindi, ecco, questa è l'idea. Però sì, sulla carta potremmo tranquillamente fare tutto state, se serve qualcosa di cui accorgersi, mettere tutto in un consumer dentro il nostro albero. Ok, cosa volevo fare qui? Ah, sì, cosa volevo fare? e volevo, il 48 forse facciamo pausa da poco, però prima di farlo creiamo il modello di login, per cui l'appoggio dove mettiamo le informazioni di login del nostro utente, lo mettiamo nel provider, come al solito, e forse con la scusa potremmo renderlo direttamente un, lo facciamo dopo, un fisi provider, facciamo finta che il login sia immediato. Quindi l'implemento esattamente come questo oggetto qui, questo state notifier provider che include una to-do list, cioè, scusate, il notifier è to-do list, quindi creerò un oggetto al pari da to-do list che però impacchetta lo stato, quindi è uno state notifier di qualcosa, creiamo qui, chiamiamolo, chiamiamolo user profile, per dire, il profile farà extents di state notifier, di cosa? Di un altro oggetto che adesso implementeremo perché il pacchetto dati lo chiameremo user data, magari. Quindi, attenzione, sempre distinguere tra lo state notifier che è chi si occupa di notificare, no? Di cambiamenti nello stato e poi lo stato effettivo che è l'oggetto in genere immutabile che contiene lo stato. Ok? Esattamente come qui avevamo to-do list che è il nostro oggetto che permette di modificare i nostri to-do e poi l'oggetto che include veramente lo stato che in questo caso è una semplice lista di oggetti immutabili. Qui abbiamo fatto un po' diversamente, qui l'oggetto lo user data è una classe che conterrà username ma il passo magari non ce la mettiamo che non è il caso quindi solo username. Ok? Ovviamente può essere tranquillamente cons quindi questa è la classe più semplice che si possa fare con un singolo intero poi ovviamente si può complicare e questo oggetto qui avrà un costruttore che per esempio per esempio il tasto non lo ricordo super state ah manca il tipo quindi questo notifier cosa gestisce internamente dello user data ok? Questa è l'idea mi sto dicendo per un motivo ah perché non è lì ah perché non è portato la classe adesso dovrebbe arrivarci quindi cosa mettiamo qui dentro? Due due metodi che sono login qui poi faccio state ok se login va buon fine logout cosa faccio? Metto null ovviamente user data quindi deve essere nullable se no non funziona ok? Quindi cosa fa user profile user profile è una classe è un notifier molto molto semplice che o ha un user data interno e quindi l'utente è logato oppure non ce l'ha ed è nulla di partenza sarà nullo e quindi questo oggetto qui lo estendo dentro la mia lista dei provider qui dentro ci mettiamo il nostro user provider provider ok? che sarà uno state notifier provider ok? che la classe di riferimento è questa la classe che ritorna user data e quando viene creata quindi quando viene insanziata creiamo partiamo con user data può essere nullable importo questo punto ah sì va bene allora che vorrei e user profile che torniamo passiamo ok quindi ho creato un prego no era un approvazione ok quindi crea un user profile un provider che è un notifier provider che a sua volta avrà uno state da interno oppure anche no adesso qui dentro nella login page quando io clicco su login che in realtà non ho ancora dato il pulsante quindi qui sotto ci mettiamo un pulsantone i login e lo facciamo come e lo facciamo come il button e poi avrà un un press ok con la funzione questa funzione qui qui adesso ci serve ref eccetera ma sono partito senza consumer quindi tocca ribattezzare un po' di cose oppure sì ma forse conviene infatti forse cominciare così clicchiamo consumer e a questo punto qui abbiamo il builder che avrà tante belle cose ref child che sì in questo caso potremmo usare la nostra spazio funzione ah sì stiamo tornando un oggetto sì potremmo tranquillamente farlo perché ritorno solo questo se mi sono mi tracciato troppo per farlo però chiediamo che riesco a testare ok a posto quindi sulla carta qui potremmo fare così non c'è altro da scrivere è meglio è peggio chi può dirlo e qui a questo punto abbiamo ref e possiamo fare read del nostro provider che oddio ho qualche altro il nostro provider ok the notify in realtà questo va importato ok e a questo punto possiamo fare login e facciamo login con i dati che abbiamo dai controlli quindi control eh no text ovviamente e la password sarà control password non mi piace per niente ah beh perché potrebbe essere nullo ma non lo è ok questa che abbiamo fatto ok quindi a questo punto c'è il allora adesso per agganciare tutte le cose dobbiamo mettere e a questo punto nel main cosa dobbiamo creare dobbiamo creare per prova adesso la nostra pagina di login poi per ora chiaramente non fa ancora nulla però a questo punto lo facciamo dopo il caffè importiamo se tutto torna rebuild e qui avremo la pagina di login che sarà probabilmente molto brutta però per ora dovrebbe essere migliorabile ovviamente tra un secondo poi adesso questa cosa ha funzionato cioè il login è impostato ovviamente quindi siamo entrati con l'utente asdaas però ancora non è tra un secondo agganciamo le cose e vedete che entreremo di là ok prende pausa riattacchiamo tra dieci minuti abbondanti sì Grazie.