Ok, quindi parliamo del responsive design. Qui adesso utilizziamo l'applicazione che vi ho caricato una volta scorsa, che è gli elementi modificati rispetto alle persone che abbiamo visto insieme. Quindi ho migliorato una prova grossa, però ho modificato ovviamente l'aspetto grafico per renderlo un pochino più accettabile umanamente, però il funzionamento è lo stesso. Quindi qui abbiamo il nostro pannello di login. E poi qui a seguire abbiamo il nostro gestore di Tutu. Ok, che al momento questa cosa non la faceva, credo, in automatico. Al momento Tutu vengono generati casualmente con un contatore progressivo, che ci dà l'idea di quanti ne abbiamo intanto, che è utile, e poi genera una descrizione opzionale casualmente. Questo è tutto il codice per cui si dà un'occhiata, vedete com'è fatto, non c'è niente relativamente sofisticato. e ora a tutta questa applicazione che abbiamo sviluppato nei vari giorni passati insieme a guardarla, insomma a vederla pian piano crescere, aggiungeremo appunto un occhio di riguardo in qualche modo all'aspetto responsive, che per ora non è stato gestito in alcun modo. Per responsabilizzare appunto si intende la capacità di un'applicazione, o meglio di un progetto, l'applicazione appunto dell'aspetto di interfaccia utente dell'applicazione, di adattarsi allo schermo con cui ci si trova a dover fare i conti in qualche modo. Per cui specie con Flutter, che appunto nasce per essere multiplattaforma, capita molto spesso che gli schermi possano essere molto serogeni. Questo è più vero su alcune piattaforme rispetto ad altre, quindi in particolare Android è un buon candidato per scontrarsi spesso con questa problematica, perché i dispositivi Android spesso hanno schermi molto variegati, per cui possono esserci Android molto vecchi, che hanno schermi molto piccoli, con piccolo intento, sia piccoli fisicamente, fisicamente hanno dimensioni ristrette, sia in termini di densità soprattutto. Quindi spesso ci si scontra proprio con la densità dello schermo, perché le schermi molto vecchie hanno non soltanto un formato piccolo, proprio fisicamente, ma anche una densità abbastanza bassa, tant'è che poi i pixel disponibili sullo schermo sono molto pochi. E come sapete già, abbiamo visto nelle lezioni teoriche precedenti, è vero che Flutter ha misure astratte in termini di pixel, quindi non è strettamente legato alle dimensioni sullo schermo e si adatta sfruttando anche il sistema di Android, di adattamento dinamico allo schermo. Android, come sapete, non usa i pixel fisici dello schermo, ma usa i device independent pixel, quindi DIP, in sostanza, per identificare le grandezze, che appunto non sono legate alla quantità di pixel, ma sono legate a dimensioni fisiche dello schermo. Quindi quando noi esprimo qualcosa in termini di DIP, in realtà stiamo esprimendo una dimensione fisica. Questo in qualche modo ci permette di esprimere le nostre interfacce utente con un grado di libertà, sapendo che poi in qualche modo Android adatterà dinamicamente queste dimensioni sullo schermo effettivo su cui andiamo a operare. Però non sempre è tutto così magico e automatico, perché spesso degli schermi variano troppo perché questo approccio possa funzionare. Quindi immaginate di avere, non so, schermi che non sono... che hanno proporzioni molto diverse. Immaginate... Questo è capitato soprattutto negli ultimi anni perché a seguire un po' la direzione degli iPhone, anche i moderni Android hanno schermi sempre più verticali, invece che con la proporzione classica. Quindi hanno più spazio verticale mantenendo lo stesso spazio orizzontale. oppure se andate proprio sull'estremo di lavorare sullo smartwatch Android che alla fine dei conti usa le stesse tecnologie, in quel caso avete spesso spazi molto ristretti e spesso quadrati come proporzione. In quel caso chiaramente non potete contare sullo spazio verticale al quale sareste nuovamente arituati. Infine un'altra cosa che Android permette e rende le cose più complesse è che spesso... cioè insomma da Android classico, diciamo così, e alcune varianti di Android permettono la gestione delle finestre che va a complicare un po' la vostra vita. Con gestione delle finestre intendo che l'utente può suddividere lo schermo in dei ritagli in sostanza e affiancare dell'applicazione, che è una cosa che appunto viene, come sapete, viene da Windows 2.0, da 1.0 che già permetteva il ritagliare lo schermo in più ritagli per avere applicazioni affiancate. Questa cosa è stata riesumata come idea con Windows 8 che faceva la stessa cosa e poi di nuovo con Android che le versioni permette la stessa cosa. È una cosa che permette una certa possibilità all'utente, perché a quel punto può, non so, avere WhatsApp sopra e qualcos'altro sotto e copiare e incollare con la grande libertà, però a quel punto la vostra applicazione deve essere abbastanza furba e adattarsi a questi cambi di schermo abbastanza imprevedibili altrimenti. Per cui è ovvio che su una piattaforma mobile di solito si ha un certo grado di semplificazione perché in genere lo schermo ha questa forma qui, non è che varia chissà quanto, però è anche vero che negli ultimi anni le cose sono un po' complicate, per cui non è facile, cioè non è sempre possibile dare per scontato che lo schermo abbia questo formato qui. In piattaforma mobile la difficoltà numero uno in genere, come vi ho accennato la volta scorsa, è la rotazione dello schermo, che in genere mette già le passioni tra le ruote abbastanza importanti. Se riesco a gestire questa roba, questo lo vogliamo. Sbloccando l'orientamento, già soltanto ruotando, se Screen Copy non esplode, vediamo che l'applicazione chiaramente si adatta ed è ancora funzionale, però le cose sono cambiate, tant'è che alcune cose risultano un po' ostiche da utilizzare, quindi per esempio il nostro contatore più uno in fondo è un po' perso nel nulla lì sotto, non so se è impallata l'applicazione, ok. Quindi il contatore più uno è un po' perso nel nulla, la Function Button per via della presenza di questo oggetto qui è un po' inutile, nel senso che non sta galleggiando sopra nulla e anche i contatori sono un po' fine a loro stessi in questo formato qui. Per cui questa applicazione qui funziona ancora, si può utilizzare, però c'è largo margine di miglioramento. Questo vale anche per la scremata di login, andiamo a vederla, che si rompe proprio quando andiamo a usare la scremata inizontale. Ok, si rompe e allora qui la rottura dell'applicazione si nota, Flutter ve la rende abbastanza evidente, in genere intanto vi stampa delle robe spesso un poco comprensibili sul log, segnalandovi che c'è qualcosa che non riesce a fare il layout in maniera corretta, in più a livello grafico si vedono le parti che strabordano con questa specie di indicazione di costruzione in corso, che vi dà l'idea dell'area, cioè in sostanza è una rappresentazione negativa dell'area che manca alla UI per fare il layout in maniera completa. Ok, perché qui normalmente noi avremmo il pulsante login in fondo, questo pulsante qui ha una dimensione verticale di tot pixel e straborda di esattamente questa dimensione più verticale. Ok, per cui non ha lo spazio sufficiente per fare il layout di se stesso e l'interfaccia appunto fa questo errore. Questo errore qui compare soltanto in debug, ovviamente, per cui se noi compilassimo in modalità di release, quindi compiliamo effettivamente un'applicazione che può girare sull'applicazione, chiaramente non vedremmo questo errore, e un altro. Quindi rimarrebbe invisibile, però ciò non toglie e chiaramente l'interfaccia rimarrebbe potenzialmente poco funzionale. In questo caso qui in realtà rimane funzionale, ma rimane un po' esteticamente riscudibile, nel senso che il pulsante è comunque visibile in maniera sufficiente perché l'interfaccia sia utilizzabile, però l'utente se ne accorge, chiaramente per cui non è ideale. Adesso la prima cosa a fare in moda è risolvere proprio questi problemi qui che si risolvono in maniera abbastanza semplice, in alcuni casi, poi andremo a vedere un caso più complesso, che è invece il caso della schermata principale. Vedete qui, quando entra in gioco la tastiera, poi le cose si rompono con ancora maggiore vemenza, qui addirittura non riesco più a selezionare la password, quindi in qualche modo a questo punto, a meno che non riuscissi a togliere la tastiera, potete fare un po' di salti mortali, quindi si può fare, ma non è ideale, solo perché con Android, con il tasto indietro, con l'asta la tastiera, quindi riesco ancora ad accedere a quello che c'è. Ok, per concludere questo discorso, ci sono vari approcci con cui si possono gestire questi problemi di adattamento dello schermo. Come dicevo, in ambiente mobile, l'approccio più classico è dire, ok, tanto io so che lo schermo, bene o male, avrà un aspetto di questo genere qui, per cui prevedo, in sostanza, due modalità, la modalità verticale e la modalità originale. Quindi questo è l'approccio più primitivo, se uno dice, vabbè, tanto sono due orientamenti, poi per quanto magari, non so, tra tre anni arrivano a Android aggiornatissimi con schermi super densi, io so già che Flutter e Android insieme riescono a gestire questa densità elevatissima in un modo sufficientemente grazioso per dire, però abbastanza coerente con l'interfaccia utente. Quindi quello si può tranquillamente tralasciare, però almeno la rotazione bisogna prevederla. Se non vogliamo farne anche questo, cosa che in alcuni casi è possibile, in alcuni casi è quasi obbligatorio, per virgolette, nel senso che in alcuni casi la nostra interfaccia utente è così vincolata al fatto che l'interfaccia deve essere verticale che magari non vale neanche la pena di perdere tempo per fare la schermata orizzontale perché non c'è nessun modo diciamo così che ci viene in mente che sia che sia efficace. Ok? Viene in mente come esempio, un esempio classico sono i videogiochi, se non è un esempio che va bene per Flutter o va, anche con Flutter si possono fare videogiochi, però in genere non è una scelta come piattaforma se c'è un motore di videogiochi più specifiche, chiaramente, però nel caso di videogiochi spesso l'orientamento unico possibile è quello orizzontale, che è più schermo, perché in quel caso l'applicazione parte con quella modalità forzata, tra virgolette, mentre altre che non sono altre interfacce, apprezzato Facebook è un altro esempio credo, che ha soltanto l'orientamento per chiudare, lo uso raramente perché non lo ricordo, però mi sembra che non c'è la modalità orizzontale, perché lì si prevede che l'utente stia scrollando vorticosamente sul suo feed che è chiaramente verticale. una soluzione per quanto brutale a questo problema dell'orientamento è che si può bloccare l'orientamento, è una possibilità, quindi possiamo dire al sistema guarda, questa applicazione che stiamo lanciando deve girare soltanto in verticale perché motivi o soltanto in orizzontale, per cui per prevenire qualsiasi problema possiamo fare il lock cosiddetto dell'orientamento e lo facciamo all'avvio dell'applicazione che era messo, per cui in questo caso andiamo a aprire il nostro main qui andiamo a trovare il main allora qui prima di fare alcun che quindi prima di fare run app quindi prima di avviare Flutter e quant'altro possiamo andare a specificare gli orientamenti supportati dalla nostra applicazione e questo lo facciamo con System Chrome che è una System Chrome si è dato che è una parte di vediamo se me lo trovo devo importarlo ovviamente ok la set non so perché non mi dare il supporto vediamo se mi fa che si è appena svegliato quindi non è pronto ecco ok Interfactor Services questo System Chrome è in sostanza per Chrome si intende in genere la Chrome è la parte dell'applicazione sarebbe quella che è in gergo di Win32 è la non clientaria cioè la parte che non disegna clienti quindi la parte di schermo tra virgolette che quindi la varra interfinanzialmente così via i pulsanti così via quindi la Chrome è quella lì ed è anche il motivo per cui il browser Chrome si chiama Chrome perché diciamo così è la Chrome l'area non client del web la metafora è che Chrome è la la finestra sul web e quindi l'applicazione stessa Chrome è in qualche modo la parte non web del web per fare delle metafore così un po' discutibili e quindi qui possiamo specificare una lista di device orientation quindi orientamenti che la nostra applicazione supporta in sostanza ok per cui qui come al solito passiamo un array e possiamo passare device orientation si diceva orientation e qui ce ne sono quattro quindi port portrait sarebbe verticale landscape è orizzontale chiaramente e in più ci sono due orientamenti per ogni verticalità ogni orizzontalità quindi port it up è quando teniamo il cellulare in questa maniera qui adesso chi da remoto non si vede chiaramente per tenerlo in questa maniera qui port it down sarebbe l'orientamento ecco non se è previsto il default il default non va via davvero infatti sì nel default c'è solo quello di port it up che è questo lo down sarebbe tutto quanto al contrario quindi il giù sarebbe cioè il ciao sarebbe in fondo e poi c'è landscape right e landscape left ok quindi sono quattro orientamenti che sono che è possibile supportare e noi possiamo specificare quali noi vogliamo se non ci interessa orientare attimamente lo schermo basta specificare un singolo orientamento in questo modo qui la nostra chrome quindi il continuatore della nostra applicazione si blocca e non supporta orientamento e quando andiamo a fare delle cose prima che flutter prima di fare run app in genere è buona norma fare un piccolo una procedura magica diciamo così sotto with flutter binding cioè ensure it's alive questo in genere è buona norma richiamare questa funzione questo metodo qui su widget flutter binding che ci assicura che tutta l'infrastruttura di flutter sia già avviata prima di fare delle modifiche al sistema ok questo è un po' posso dire è un po' un mantra magico che bisogna fare prima di prima di fare alcun che con flutter perché prima di fare run app chiaramente flutter non è ancora stato interizzato cioè considerando che il main è il nostro punto d'ingresso qui flutter non è ancora avviato flutter si avvierà con run app con questa chiamata qui ci assicuriamo che flutter abbia già inizializzato le sue componenti interne e a quel punto possiamo cambiare prezzo non rientra adesso vogliamo subito facciamo chiaramente il restart a questo punto adesso intanto aspettiamo che sia bloccato in portata ok quindi adesso io mi aspetto che orientando in effetti rimanga bloccato ok quindi qui sto orientando sto cambiando ma la faccia è bloccata vediamo questa cosa qui quindi se qui specificassimo un altro orientamento che è device down dovrebbe permetterci di ruotarlo al contrario diciamo così questo altro vale per tutte le piattaforme quindi chiaramente vale sia per Android che per iOS e quant'altro e alcune piattaforme non hanno il concetto di ruotazione quindi la ruotazione al contrario non viene supportata evidentemente a questo immagino anzi senza immagino quasi al 90% dobbiamo sbloccarlo anche su Android immagino sul quando andiamo qui nel nel manifest perché eccolo qui ci sono vari configurazioni anche se qui vedo che orientation è settato questo è da investigare non so perché la ruotazione al contrario forse è una di Android che va ulteriormente convinto di gestire la ruotazione al contrario immagino però penso che dipende da questo specifico lei sta parlando su Android su Android ok no è Bungie che sia legato ad Android proprio per cui bisognerò vedere se c'è qualche altro incantamento da fare sul manifest cosa molto rubabile e per permettere la ruotazione al contrario però in genere con tutte cioè a questo punto significa questa vedete che ci sono anche limitazioni che dipendono da quattro ma questo perché questo è come gestisce Flutter internamente le ruotazioni è chiaro che l'applicazione in sé cioè la Chrome che noi vediamo qui quindi il contenitore di Flutter ruota comunque ovviamente sta essendo ruotato è internamente Flutter che sta ignorando la ruotazione quindi sta fermando la ruotazione ok quindi dicevo alcune piattaforme supportano la ruotazione alcune no chiaramente quindi per esempio se voi lavorate su ecco S per esempio ecco S se se direi di sì chiaramente adesso qui mi ho fissato all'avvio e quello rimane però se noi volessimo cambiarlo a runtime penso che potremmo non ho mai provato a farlo però penso che non sia un problema impostare questa cosa a runtime quindi magari invasora la pagina aperta possiamo impostare se vuole tenere direttamente nelle forze di da runtime sì sì sì però lì probabilmente è bene avere un sistema centralizzato che gestisce che in cui impostiamo di volta in volta cosa quale internet preferiamo in base alla pagina che rimane aperta quindi probabilmente volendo farlo in quel modo probabilmente conviene agganciare questa cosa alla navigazione o qualcosa che gestisce il cambio di pagina direi così poi dipende un po' dallo scenario in alcuni casi chiaramente può aver senso ruotare o meno anche in base alla navigazione interna di una singola pagina se abbiamo vari bottom le iconcine sotto che cambiano la schermata visibile alcune possono essere ruotabili alcune no quindi magari può dipendere da vari fattori ecco dipende un po' dallo scenario però in realtà se si può pensarci bene per la rotazione attivata o meno è una cosa che può confondere l'utente con gli scenari chiaramente per cui magari non è sempre ideale però magari è anche vero che magari avviando non so mostrando un video a schermo per esempio se si mostra un video a schermo magari si può forzare la rotazione al landscape immagino poi appena il video termina si torna all'orientamento dinamico questo è un senso potrebbe portare altri login per riposare ah si per esempio si esatto potremmo mettere anzi questo il login per come è permettato adesso il login si trova qui dentro quindi qui noi stiamo switchando nel login di volta in volta e allora potremmo prima di cambiare una volta all'altra potremmo mettere qui dentro impostare la rotazione in questo modo avere soltanto una parte dell'interfaccia che ruota meno questo può aver senso ovviamente in base allo scenario che vi interessa però in genere questa cosa qui si può fare e ha senso per alcune applicazioni specifiche ah volevo concludere il discorso con macOS perché alcune piattaforme non hanno la rotazione quindi macOS in particolare non ha la rotazione prevede che sia sempre landscape chiaramente mentre per esempio i windows moderni nonostante la maggior parte dei pc poi non hanno l'accelerometro non hanno modo di capire come sono orientati sulla carta hanno il sensore che identifica la rotazione in quel caso questa cosa è attiva ma spesso non viene utilizzata quindi in base anche alla piattaforma in cui vi trovate questa cosa va usata o meno e ha chiaramente valori diversi e significati diversi però in genere allora per rendere la sua applicazione più compatibile possibile chiaramente l'idea è di utilizzare questo blocco soltanto se veramente è utile e invece di adattare l'interfaccia per quanto possibile ai varie problematiche per cui torniamo allo scenario di prima in cui la rotazione c'è rotiamo e applichiamo poi la modifica minima che serve per far funzionare questa schermata di login proprio il minimo che serve è rendere l'interfaccia scrollabile quantomeno se rotiamo non può capire pronto? ah perché è rimasto allora sì perché con il hot restart non è ripartito veramente per cui rimettiamolo o riavviamo tutto magari così siamo sicuri che l'applicazione si comporta come deve ok mentre qui si riavvia allora il cambio minimo che si può fare è rendere quantomeno l'interfaccia scrollabile quindi quella è la cosa in genere quando vogliamo impegnarci il meno possibile quando abbiamo qualsiasi quantità di elementi di interfaccia che vanno mostrando a schermo e potenzialmente immaginiamo che la la verticalità dello schermo cioè lo schermo possa essere compattato compresso e rendere i contenuti quindi non più visibili il minimo che si può fare è mettere tutto quanto dentro un nostro review in sostanza quindi lo facciamo per la pagina di login che era da parte qui ok qui abbiamo la cosa ne abbiamo visto insieme però abbiamo visto l'effetto abbiamo l'interfaccia di login è uno stack che prende tutto lo schermo sotto abbiamo come primo elemento abbiamo un'immagine che fa da background quindi che carica un jpeg e poi sopra abbiamo una serie di elementi che danno il lordino eccetera eccetera quindi le parti che rischiano di essere non visibili non è tanto l'immagine l'immagine ci interessa ad un certo punto ci interessa più che altro i contenuti di quella specie di box centrale per cui i contenuti di quel box centrale dovrebbero essere contenuti in questa colonna quindi questa colonna qui è quella che comprende il titolo i due campi ok e poi il pulsante finale ok perfetto vediamo se questa volta funziona ok perfetto quindi questa parte qui almeno prendere questa colonna qui e brapparla come ci ricordiamo con un widget che è il single child scroll view ok questo single child appunto è una scroll view che ha un singolo figlio che ha una dimensione tal dei tali se serve questa scroll view ci permette di riscrollarla quindi non fa veramente il minimo che serve se lo riavviamo a questo punto dovrebbe compagire tutto ok adesso l'errore non c'è più non è bellissimo l'effetto comunque perché è scrollabile ma quel poco che serve quindi quei pochi pixel che strabordano che non sono veramente utili però immaginate appunto bisogna sempre ragionare che noi non conosciamo veramente la dimensione d'un schermo mai per cui il nostro layout deve essere comunque fluido e avere tutto quanto detto single child scroll view ci permette di dire vabbè alla peggio l'utente scrollerà ok a questo punto possiamo provare a fare appunto non è non è comunque un'esperienza molto bella ma è funzionale funzionale per me vuol dire ok riesco a scrivere e poi riesco a farlo qui però l'esperienza molto sotto no sotto come si dice sotto il minimo sindacale per cui dobbiamo fare qualcosa di meglio in ogni caso questo questo approccio qui quello del single child scroll view ovviamente vale soprattutto per le pagine con contenuti che possono essere lunghi quindi pagine con molto testo con descrizioni immagini e quant'altro lì in quel caso ha sempre senso metterci la scroll view in modo tale ad essere sicuri anche se siamo moderatamente convinti che entri su una singola paginata metterci questo previene eventuali mal di testa che sono difficili poi da debuggare perché in genere noi è abbastanza ragionevole fare debugging su alcuni dispositivi che abbiamo però è sempre c'è sempre per esempio su Android la minaccia di qualche dispositivo strano che ha uno schermo diverso prima di adentrare su questo aspetto qui ancora peggio adesso mi parlavo di Android però è ancora peggio la situazione sul web per esempio sul web abbiamo un mondo in cui il client può avere tutte le forme dell'universo per cui basta cambiare la dimensione dello schermo del browser e ovviamente la dimensione dello schermo cambia radicalmente sul web non c'è il concetto di orientamento ovviamente perché il browser è sempre orientato alla stessa maniera almeno sulla carta e però doveva combattere con vari schermi molto molto diversi per cui il browser stesso quando pensiamo a una pagina web ovviamente la pagina web è sempre scrollabile in verticale di default quando ragioniamo con un browser web in mente il documento medio sul web è sempre letto verticalmente se facciamo un'applicazione web in flutter questa cosa non lì è rispettata quindi di base un'applicazione web fatta in flutter parte come schermata unica che copia tutto lo schermo che non è scrollabile quindi il minimo che si può fare anche lavorando sul web è rendere più scrollabile per renderlo coerente con quello che l'utente si aspetta in un ambiente web ok allora per venirci per risolvere il problema in questo contesto qui useremo un widget speciale che si chiama orientation builder orientation builder è un builder quindi come tanti widget che abbiamo visto in flutter serve soltanto per ribildare l'interfaccia quindi sarà dotato di un metodo una funzione anonima che ricostruisce l'interfaccia attente e la ricostruisce ogni volta che cambia l'orientamento di schermo ok quindi in base all'orientamento il builder si rebuilda e serve solo a quella esattamente come il consumer legge i provider poi rebuilda l'interfaccia attente in base all'attornamento dei provider l'orientamento fa la stessa cosa per l'orientamento per cui in questo caso può aver senso distinguere l'orientamento all'ivenda di questa colonna qui ok quindi qui ci mettiamo il nostro orientation builder ok orientation builder avrà un metro che è il builder ovviamente e la differenza rispetto al builder classico il builder minimo al context e basta qui chiaramente abbiamo il context e l'orientation che ci dà una mano nel capire cosa dobbiamo fare quindi va bene context orientation e in base a questo possiamo distinguere definire cosa costruire anche in maniera puramente funzionale eh sì funzionale quindi possiamo fare orientation scusate uguale uguale questa è un'istanza di device orientation credo quindi se siamo in portrait fai qualcosa se siamo in landscape fai qualcosa altro se si mettono null null per farlo compilare questa roba qui la tagliamo via quindi questa colonna qui la togliamo questo child qui non c'è più e dovrebbe essere ok a parte che null non è un widget che gli piaccia quindi ci mettiamo in size box ok quindi questo è quello che si può fare per esempio per rendere il codice un po' più pulito possiamo nascondere la costruzione dell'interfaccia dentro due metodi quindi giusto per non sporcare troppo il codice facciamo build portrait e qui ritorno quello che c'è la prima quindi la colonna perché in portrait l'interfaccia prima mi stava tutto sommato molto bene e per l'interfaccia invece verticale è landscape invece facciamo qualcosa di diversa widget build landscape ok e facciamo qualcosa di simile agganciandoci a quello che avveniva qui dentro quindi prendi allora direi che possiamo fare e mettiamo tutto in una colonna comunque mettiamo il titolo quindi questa cosa rimane effetto l'accesso magari possiamo farlo più piccolo perché lo spazio verticale a quel punto è poco quindi invece di fare headline medium possiamo fare headline small per esempio quindi questo lo copio tutto in colonna mettiamo questo questo riduciamo a quindi chiaramente possiamo ribildare in libertà l'interfaccia possiamo fare un po' cambiare quello che vogliamo quindi questo lo lasciamo uguale ok questo va bene poi a questo punto user per password invece di metterli in colonna li mettiamo in riga per virgolette quindi li prendo così come sono separati da questo separatore e li copio dentro una riga ok la riga avrà di cindere e sono questi tre il separatore non dovrà essere un separatore di altezza ma un separatore di larghezza essendo lo spazio poco posso ridurlo un po' ok qui i textfield sono diversi ma sono comunque legati allo stesso controller quindi anche se io ruoto ok lo stato della textfield rimane legato al controller per cui sia che cioè mentre ruoto lo stato rimane alterato ok perché rebuild i contenuti della nostra interfaccia ma non il widget padre infine abbiamo il nostro login qui ah il consumer serve solo per poter scrivere nel login quindi ci lo mettiamo così com'è e il pulsante lo mettiamo sotto la riga giustamente ok se non ho fatto errori di ah no mi è mancato l'ultimo pezzo devo collegare le parti se no la cosa non funziona quindi se orienti le porte faccio build porte ok passo context e poi altrimenti faccio build let's get ok perfetto va a vedere se è perfetto graficamente sarà discutibile comunque però vediamo ok graficar bene ok ok Grazie. Ok, questa volta abbiamo sostituito quello giusto. Allora, un prof dove si rompe. Allora, direi che probabilmente è... Ci deve andare bene. Allora, direi che probabilmente è... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... la mano che io ruoto l'interfaccia tutto sommato ha un aspetto diciamo così, tollerabile sì il lampeggiante cosa imprende? il versore cioè questa cosa qui che ha l'effetto si deve schiacciare sull'imput qui? ok ah, questa cosa qui lei ha messo spazio tra i termini e il input testo cosa ho capito? cioè lei quando clicca qui si apre la sera e collassa tutto giustamente? ok, qui ecco, vedete che c'è un'applicazione ah, questa qui esatto ok e va sopra la scrittura ah, ah sì l'ho fatto in un certo modo no, questo è il text field da solo dovrebbe farlo correttamente quindi a lei compare username e poi sopra la barra di scrittura? esatto ah ah anche quando è così quindi username rimane in questa maniera qui in sostanza non si anima esatto ah ok magari poi ci guardiamo meglio perché non no, no, no è tutto cioè non c'è nulla di visual decoration che è tutto il pacchetto di i decori che però non c'è nulla ok ok non saprei forse sì però magari ci guardiamo dopo ok anche qui allora comunque la soluzione non è quella ideale evidentemente comunque la sera va sempre sopra allo schema però abbiamo quantomeno gli strumenti per cominciare a lavorare cioè per esempio login possiamo spostarlo qui a destra magari così abbiamo proprio spazio e effetto dell'accesso magari visto che non serve possiamo mettere nello scaffold per esempio possiamo fare varie cose e anche i bordi per esempio sono un pochino troppo generosi in questo caso possiamo ridurre lievemente questa cosa tra l'altro adesso ci siamo costretti cioè ho messo il orientation builder troppo in basso una gerarchia per poter cambiare il padding in basso alla rotazione però una cosa che sarebbe molto sensata fare è mettere il orientation builder più in alto per esempio qui e avere il padding a 16 quando è in portrait e che ne so a 8 a 4 quando è landscape così che questo bordo molto generoso in verticale venga collassato quando quando siamo in questa modalità qui ok però fondamentalmente è questo che si può fare come cosa minima ora per farvi vedere un'altra cosa che avviene termino qui in android un attimo e riavvio tutto sotto chrome perché una cosa abbiamo notato per errore prima è che prima la schema non ruotava perché avevamo lasciato tutto il blocco dentro un single child scroll view quindi era tutto tutto cioè anche l'orientation builder era dentro un single child scroll view perché in effetti l'orientation builder non usa questo è un po' strano non usa l'orientamento del dispositivo come riferimento infatti tant'è che questo elunqui non è device orientation ma è orientation cioè l'orientamento del widget stesso quando siamo dentro un single child scroll view visto che lo scorrimento è verticale allora l'orientamento del widget è verticale quindi in questo caso l'orientamento era cioè questo builder qui eseguiva sempre in orientamento portrait perché eravamo dentro un single child scroll view adesso qui abbiamo rimosso il single child scroll view l'idea era di metterlo qui dentro dentro portrait scev cosa che possiamo prografare quindi qui dentro possiamo mettere tutto quanto dentro un single child scroll view a questo punto se volessimo e però attenzione quindi che questo orientamento qui non è l'orientamento del dispositivo tanto è che adesso appena si avvia in modalità web vedremo un altro effetto buffo buffo come vuoi dire c'è un altro comportamento strano dell'orientation builder che è il suo comportamento sul web perché il web i browser hanno supporto a sensori dispositivi e quant'altro in maniera crescente chiaramente quindi sulla carta anche una pressione web fatta in flatter può capire se si trova dentro un dispositivo che è orientato in un certo modo in alcuni casi il browser ha accesso ai sensori per esempio agli accelerometri per dire e quindi può leggere l'orientamento però l'orientation builder ecco partito però un attimo solo l'orientation builder come dicevo in realtà fa riferimento all'orientamento del widget e in ambiente web l'orientamento viene inventato in base alla proporzione allo schermo ok per cui qui il comportamento è un po' strano nel senso che se non ci sono stati aggiornamenti nel frattempo di flatter cosa che è sempre possibile vedete qui si adatta non in base all'orientamento perché l'orientamento del browser non esiste tra virgolette già a meno che non ruotassi il pc però in base alla proporzione quindi questo è landscape quindi tutto la chrome è in landscape nonostante la rotazione sia fissa però c'è data quindi l'idea di flatter in questa cosa qual è? è che non importa veramente come si è presentato lo schermo qual è la superficie di schermo che è in disposizione dando per scontato che la cosa rilevante sia quanto spazio orizzontale verticale cioè quale sia il rapporto spazio orizzontale verticale ok quindi se usiamo orientation builder l'idea è c'è una modalità in cui ho più spazio verticale rispetto a quello orizzontale e c'è una modalità in cui invece è al contrario ok quindi questa è un po' l'idea e questa cosa può essere anche sufficiente per buona parte delle vostre interfacce se le vostre interfacce appunto hanno due modalità ben distinte una orizzontale quindi una landscape e l'altra è portrait quindi verticale non tutte le interfacce chiaramente sono così come dire essenziali perché a volte invece le interfacce possono avere vari gradi di libertà diciamo così di complicazione in base al nostro allo spazio disponibile dobbiamo farlo qui perché per esempio questa schermata che non vediamo adesso ma vediamo tra un istante questa chiaramente ha vari margini di miglioramento in base al non tanto all'orientamento che ci interessa fino a un certo punto ma al numero di cioè alla materia di spazio di puntare ok quindi qui useremo un approccio ben diverso e lo faremo prima su una pagina dedicata quindi giusto per fare una ripostrazione crea un'altra pagina molto semplificata che si chiama size page per esempio la copio della nostra text page no era qualcosa di molto semplice questa questa no perché c'era il letto ah questa può essere la più scarna quindi uso questa quindi questa page qui sarà la nostra size page questo è uno state less widget la tagliamo ok tutto questo non ci interessa ci interessa solo questa parte qui che copiamo interamente ok ok ok ok ok ok chiaramente tutte queste parti qui non ci interessa tolgo la button navigation bar via e poi qui dentro ci mettiamo qualcosa ok la agganciamo un attimo al al drawer se non la possiamo aprire e so Ok. Perfetto, questa pagina è molto essenziale. Allora, qui dentro usiamo una cosa, un'altra funzione, Platter, per gestire proprio lo stato dell'espositivo. Quindi orientation builder, vi diciamo, che non è legato allo stato dell'espositivo, nel senso che non necessariamente legge l'orientamento dell'espositivo, né va a vedere accelerometri e quant'altro. Se ci interessa quella cosa lì, c'è uno strumento molto più potente, che è la media query. E la media query, forse se avete lavorato sul web, è un concetto che già avete intrasentito, perché sul web e in ambito CSS, quindi la parte delle tecnologie web che si occupano dell'aspetto grafico, in CSS è possibile definire delle regole di layout che si attivano, si incentivano in base a delle media query, quindi a delle interrogazioni, quindi a delle query appunto, che si attivano, cioè sono on-off, in base allo stato del nostro dispositivo. La cosa più classica che si può fare è attivare, risattivare alcune cose in base alla dimensione dello schermo, quindi se lo schermo è più grande di dot pixel, allora fai delle cose, però sul web è possibile farlo anche per l'intervento dello schermo, è possibile farlo per altre, tipo se stiamo stampando lo schermo, pur se stiamo mostrando lo schermo, che sembra una cosa banale, però se la pagina web viene stampata, può attivare delle regole particolari che ne rendono più stampabile, per esempio togliere i sfondi, togliere i colori, cose del genere, e così via. Quindi questo approccio qui, diciamo così, viene un po' copiato in Flutter con l'oggetto media query, che si usa col classico sistema del media query off, build context, quindi come al solito, esattamente come il tema, che si faceva a team.off, team.off ci permetteva di legare, legare il nostro contesto al tema dell'applicazione, quindi effettivamente rebuildare l'applicazione in base al colore, ai fonti e così via, con media query avviene la stessa cosa, e stiamo legando questo build context qui, in cui ci troviamo, a alcune parti dello stato multimediale dello stato di dispositivo. Questa è un po' l'idea. Quali stati ci sono? Sono tanti. Quindi per esempio, se è attivata la navigazione accessibile, cioè se l'utente ha specificato da qualche parte del sistema che ha bisogno di assistenza perché magari è ipobedente o perché ha difficoltà di utilizzo del dispositivo, in questo caso, tutte queste specifici richieste vengono mediate da Flutter e poi ci vengono fornite come un semplice booleano, quindi appunto abbiamo un booleano che dice true, l'utente ha bisogno di assistenza, false, possiamo usare la navigazione classica. Se l'utente ha richiesto l'elevato contrasto, in cui se l'utente è ipobedente, magari può beneficiare di avere un contrasto molto elevato, quindi invece di usare, per esempio, colori, se non c'è più, colori, questo è abbastanza contrastato, però il colore un po', così, un po', come si vuole dire, pastellosi, con questo fioletto, magari potremmo usare dei bordi molto più forti e dei colori più marcati, in questo caso, se l'utente l'ha specificato, e così via. Quindi ci sono varie cose, tipo la necessità di usare l'ora 24 ore, la pixel ratio è il rapporto di pixel del dispositivo, se l'utente preferisce la presenza o l'assenza di animazioni, tutte queste cose che si possono specificare nelle impostazioni di Android e di iOS, e poi, fra l'altro, ci espone in questa maniera qui. Ok, quindi possiamo ricostruire l'interfaccia in base a queste specifiche dell'utente. Quello che ci interessa a momento, in realtà, è la grandezza dello schermo, quindi la size of, anche qui c'è orientation of, che è la stessa cosa di prima, quindi orientation of qui, del context, ci dà accesso all'orientamento, quindi questa roba qui ci ritorna un orientation che di nuovo è o portrait o landscape, ok? Però in questo caso, questa orientation of non è legata, non è simulata in base allo schermo, alla dimensione dello schermo, ma è reale, questo è l'orientamento reale quello è effettivamente portrait nel caso del browser web, varia su Android, o su iOS, e così via. In questo caso, ci interessa size of. Questa cosa qui ci ritorna un oggetto size che include larghezza e altezza, quindi height e width. Ok? Quindi con questi due oggetti riusciamo a discriminare, con questi due valori riusciamo a discriminare la canezza dello schermo, in sostanza. Poi ci sono alcune cose di supporto che c'è, quindi ci dà il rapporto tra le due cose, ci dà shorter size, cioè ci dice qual è il lato più corto, se quello più corto o quello orizzontale, e così via. Quindi ci sono un paio di campi di supporto che possiamo utilizzare per costruire un'interfaccia. A un momento ci interessa soltanto la larghezza, quindi ci metto final v che sarà in proprio in pixel, cioè in pixel, in pixel virtuali, chiaramente, la dimensione del nostro schermo, che a questo punto possiamo mostrare la schermo, quindi molto banalmente qui al centro del container ci metto un child che è un center e ora un child e ci scrivo text e schermo di quindi in realtà questo forse avevi senso farlo in questa maniera qui ok e qui ci mettiamo ok ok ok e qui ci stiamo trovando quindi sento sul web chiaramente il hot restart cioè ripartirei sempre da zero ok questo se ricordate che lo avevamo fatto più o meno nel win32 con con più codice però avevamo questo aggiornamento della scritta in base allo schermo a base ai pixel del quindi nulla di particolarmente sofisticato però in questo caso passiamo attraverso media query e cosa avviene ogni volta che ridipensiamo lo schermo cioè questo questo oggetto qui viene ricostruito perché lo abbiamo legato a questo oggetto quindi alla size no della della media query qui ci leghiamo specificamente alla size quindi questa cosa si aggiorna soltanto se effettivamente cambia la grandezza dello schermo se cambia l'orientamento le impostazioni di accessibilità tutte le altre cose del del dispositivo non ci ribilda qui semplicemente quando andiamo a a dimensionare l'interfaccia viene ricostruita ok e pian piano si aggiorna ok e e questo nella sua primitività in realtà possiamo anche legarci a tutta la media query quindi passa per media off e questo è un punto più brutale questo ci dà accesso a tutto l'oggetto media query data che contiene un pacchetto con tutti i dati quindi qui c'è e tutti questi booleani orientamento size e così via sono tutti già forniti però chiaramente a questo punto ogni volta che c'è una variazione di uno qualsiasi di questi valori tutta la nostra interfaccia si ribilda se ci siamo legati alla media query nella sua generalità ok quindi in questo modo possiamo settorializzare la ricostruzione media query funziona esattamente come il tema quindi media query vive da qualche parte del nostro albero the widget in particolare vive come la maggior parte delle cose dentro material app in questo caso quindi se ricordate navigator vive dentro material app theme a maggior ragione e anche media query vive qui dentro quindi nel caso utilizzaste invece la pressione copertino avreste comunque una copertina app che fa la stessa cosa quindi comunque media query che avete sempre a disposizione posto che la vostra interfaccia che la mette viva dentro un oggetto che ve la che ve la rende disponibile ok ora qui dentro nella size page possiamo adattarci in base alla grandezza per cui lo facciamo proprio al volo con un approccio che è quello che mutuiamo dal dal web per darvi un'idea appunto non so chi di voi ha il piacere di lavorare già sul web però quello che si fa spesso sul web è un approccio che è basato sui breakpoint quindi in sostanza si definisce una diciamo così un'interfaccia minima che va bene per i dispositivi mobili quindi si parte dall'interfaccia mobile e da un approccio che si chiama mobile first web development in sostanza per cui l'interfaccia si inventa con con con l'interfaccia minima che è il la dimensione più piccola quindi qui bootstrap se lo conoscete bootstrap è un è un middleware super strapopolare che era stato inventato a suo tempo da twitter per web e bootstrap previene una serie di breakpoint che identificano in questo modo qui quindi extra small small medium large extra large e i breakpoint sono questi qui sono i pixel effettivi della nostra disposizione quindi in base a questi poi la nostra interfaccia può variare in genere il il minimo che si può fare è avere un'interfaccia per extra small quindi per cellulare in verticale e poi appena scavagliamo e andiamo in small o in medium andiamo in interfaccia da da da serie da extra in sostanza poi se vogliamo bisogna avere più soglie qui spesso l'approccio è quello di avere una versione mobile per extra small poi da small a large abbiamo un'interfaccia per ipad tra regolette che è un'interfaccia media e poi se vogliamo bisogna avere un'interfaccia completa e complessa per i sbordi di alt a large che sono in genere gli scherzi molto larghi ok questo è un approccio possibile e quello che andremo a fare nella nostra interfaccia è molto molto bene possiamo farlo in maniera più o meno sofisticata però possiamo fare if size possiamo usarlo possiamo usare direttamente anzi possiamo facciamo così facciamo così magari possiamo colorare lo sfondo in base del coin magari la cosa che capisce senza quindi se la grandezza è usiamo quelli di bootstrap per comunità quindi se è più di 1200 allora usiamo il blu altrimenti se è più di medium 768 siamo in verde altrimenti va bene il rosso che sarebbe lo small ovviamente questo è un double quindi è stato double ah no scusate non parte questo però questa è la larghezza che ci interessa se non so quattro pixel alla propria disposizione però in teoria qui siamo in modalità iPad modalità schermo grande e modalità mobile chiaramente è un esempio di una banalità stratosferica però l'idea è che in base con questo switch molto banale scegliamo dove siamo e poi costruiamo interfaccia in maniera in tre maniere diverse quindi qui l'idea è che chiaramente questa cosa non la fareste a livello della singola pagina anche se in alcuni scenari può avere per senso però in genere si fa a livello della radice proprio quindi in questo caso nella pagina principale che non ricordo qual è homepage immagino quindi qui in sostanza andiamo a definire l'interfaccia che si adatta in mass alle tre modalità ok quindi questa è una cosa che si può fare ok ora proviamo a applicare questi questi strumenti che abbiamo appena visto a un'interfaccia come questa che adesso chiaramente questa è molto semplice però la compliciamo un pochino perché proviamo a sfruttare un pattern di interfaccia utente per così dire che è molto comune ed è il pattern master detail ossia quando c'è un'interfaccia del genere che ci permette di manipolare degli oggetti quindi può essere una galleria di immagini può essere una tutelisca in questo caso una lista di puntazioni una lista di qualsiasi cosa che vi venga a mente dove c'è una lista di oggetti da gestire e poi quando andiamo a operare singoli oggetti qui nella modalità semplice modalità mobile quindi una modalità che ande bene per un cellulare ossia questa clicchiamo sui oggetti e qui andiamo a cambiare delle informazioni quindi mettiamo delle cose e di volta in volta cambiamo le impostazioni quindi immaginate appunto di avere una to-do list vera e propria su cellulare funzionerebbe così ma su un'interfaccia mobile scusate un'interfaccia adesso più complessa ci aspetteremmo di poter selezionare l'oggetto più a sinistra magari selezionare qui e a destra se vorrebbe un pannello di detail appunto quindi avremo a questo punto la distinzione tra master list a sinistra e detail che è a destra quindi questa è un po' l'idea quindi se non come se fosse una linea su un drone si esatto tipo adesso non useremo navigation drawer perché navigation drawer nasce in ambito che quindi è difficile da utilizzare perché ha questo stato cioè la navigation drawer è o attivo o diattivo in base allo stato concettualmente concettualmente sì esatto tra l'altro navigation drawer in realtà si può espandere se uno vuole però non è questo lo scenario che ci interessa però sì abbiamo una barra a sinistra con gli oggetti e poi a destra invece un pannello di modifica in realtà è quello che accade su qualsiasi editor di gestore di name in realtà vediamo email a sinistra ma non deve essere il pannello di lettura o di scrittura e così via proviamo a farlo e usiamo i nostri amatissimi provider per farlo quindi per rendere la cosa più semplice possibile ah tra l'altro è una cosa che ci tornerà utile anche per la pensione mobile perché qui su smartphone si può immaginare la stessa cosa in alcuni casi non penso che nessuno di mail lo faccia veramente però se la ruotassimo in orizzontale ci potremmo immaginare di avere una lista a sinistra e poi molto compatto in alcuni casi però si potrebbe immaginare di fare in quella maniera lì ok quindi ci servono tre due concetti fondamentalmente adesso al momento abbiamo una lista che è il nostro torniamo su provider abbiamo la nostra lista il nostro to do item provider che qui esiste rimarrà così com'è ok quello che ci manca è un un provider che ci dà qual è l'elemento correntemente attivo no cioè che stiamo correntemente modificando in qualche modo cioè in realtà ce n'è già uno è il nostro current to do item provider ok mi sa che adesso non lo usiamo neanche più perché siamo passati ad usare il family provider quindi mi sa che non lo usiamo più usiamo in alcuni scenari ok quindi per farla per non fare troppi danni ai pezzi di cose che ho già magari faccio un terzo provider ancora e lo chiamerò selected to do item provider è un provider che ci dà un to do item forse ok perché ovviamente di base e parte con quindi è un provider che ah tra l'altro scusate è uno state è uno state provider perché possiamo possiamo modificarlo chiaramente ok questo chiaramente partiamo senza nessun provider e poi a un certo punto avremo senza un provider ora potremmo utilizzare il to do item qui come discriminatore però ci viene ancora più è ancora più astratto ancora più pulita la cosa se usiamo l'id per il to do provider adesso che ci penso quindi userò qui una stringa ok quindi una stringa forse che ci dà l'id del del to do item correttamente selezionato ok perfetto a questo punto nell'interfaccia grafica allora qui intanto andiamo nella nostra home page qui ok qui siamo nello scaffold generale qui siamo qui ci sono vari elementi che magari sono utili fino a un certo punto possiamo anche cominciare a scartarli un po' in giro magari togliere un po' di cose non servono questo è il pulsante in fondo questo è il contatore che ci serve fino a un certo punto quindi lo togliamo ok e tutto questo blocco che vede tutta la nostra home page questa cosa qui la metto dentro un cioè lego questa interfaccia qui alla media quindi qui faccio final size media query punto of context ok quindi questo mi dà la dimensione dello schermo e mi permette di fare il rebuild in base al cambiamento e qui avendo due modalità non faccio altro che determinare se sono in modalità largo e per essere in modalità largo io pesco il breakpoint di bootstrap che mi sembra è abbastanza ragionevole qui non ci inventiamo nulla perché questi breakpoint sono molto ragionivi bootstrap è super collaudato perché lo usa a mezzo web quindi ci sarà un motivo perché hanno scelto questi numeri e direi che di fidarci a mano su questi quindi is large che dipende da size maggiore o uguale di 90 ok quindi is large è un booleano e mi piace ah perché mi dimentico sempre sto leggendo la grandezza ok ah ok bene quindi se is large è true allora voglio la schermata vision 2 se è false la voglio normale quindi qui posso fare in vari modi la bar rimane uguale veramente quindi questa parte in alto rimane tale uguale diciamo che l'override lo faccio dalla colonna in poi quindi da il pad lo lascio da qui in poi scelgo cosa fare giusto ok per cui questa parte qui la togliamo ecco qui per maggior chiarezza size fissà cosa significa faccio due metodi che fanno la build in sostanza così non sporcchiamo il codice in giro qualcosa tagliato con troppa vemenza ok e qui mettiamo build small small che avrà build context context veramente se avessimo tre modalità piccolo medio grandissimo potremmo fare tre metodi adesso non è il caso di complicarci la vita quindi nel caso small usiamo la cosa di prima era questa ok quindi build small fa questa la da qui va benissimo e build large al momento non fa nulla se non tornare un un container rosso che ci indica il fatto che ci siamo ok quindi a questo punto dentro questo qui dentro il padding cosa facciamo discriminiamo col casco no col progetto alternario che ci piace tanto e facciamo build large context ok in teoria proviamo di volta in volta perché è sempre facile rompere le cose in flat qui magari ripasso l'android perché sul web si rompe sempre tutto non so perché comunque ecco qui siamo in large e qui a un certo punto entriamo nella normalità di qua lo stato come al solito rimane coerente quindi come sappiamo in flat se noi facciamo la rebuild possiamo cambiare liberamente tutti i contenuti però lo stato è tutto impacchettato dentro i nostri provider quindi non c'è nessun rischio che le cose si rompano più tanto ok quindi questo funziona tutto come prima sì è un po' brutale però è l'unica cosa che può fare in realtà per cui qui siamo obbligati a far così purtroppo questo valeva anche per il 32 il ridimensionamento dello schermo è una delle operazioni più brutali che si possa fare in interfaccia utente quindi quello rimane ok quindi adesso manca solo l'interfaccia grande perché il resto funziona tutto tutto quanto per cui non è che bisogna fare chissà quante regolazioni ok per cui andiamo confezionare l'interfaccia però più complessa quindi la andiamo a pescare lato turist che abbiamo amabilmente confezionato dentro questo turist qui per cui si fa subito allora facciamo prima intanto la prima cosa da fare è fare tutto in due righe giusto cioè una riga scusate due colonne abbiamo children ok a sinistra avremo la nostra to-do list che è uguale a quell'altra poi avremo una size box come al solito per distanziare un po' gli elementi se no sono un po' troppo accalcati e poi ci mettiamo una roba che è tutta da vedere ancora che è il nostro oggetto quindi di nuovo ci metto un container rosso ok questo è const questo pure mentre rebuild andiamo avanti allora a questo punto cosa mettiamo lì nel container allora ci mettiamo un oggetto che mostra l'oggetto modificato quindi è la stessa cosa che mostriamo al click nel senso ritrovo il click allora dentro la to-do list che possiamo qui sarebbe a dire andiamo qui dentro qua dentro quando navighiamo ah qui c'era tutte queste cose qui andiamo ad aprire una to-do item page che è to-do item page eccola qui to-do item page è la pagina quindi quello che è lo scaffold e così via che ci permette di modificare o visualizzare un oggetto quantomeno ok quindi è una pagina abbastanza sofisticata alla fine ci mostra un to-do item viewer che è l'oggetto minimo che mostra un viewer quindi quello che potremmo voler fare è estrapolare questi tutti questi componenti qui dalla pagina e renderlo un widget assistant se non spiego bene torniamo un attimo solo la nostra magnifica faccia se la ritrovo ah come è cresciata perfetto era quello che si poteva aspettare esatto grazie a riavvio su Android che facciamo prima e poi il breakpoint lo faremo sulla rotazione così facciamo prima allora appena si avvia comunque quello che voglio dirvi è che adesso qui abbiamo questo nostro to-do item page che racchiude lo scaffold labbar e tutti i vari componenti e poi ci mostra internamente due text field con il d e descrizione e cose via adesso per completezza l'avevo mostrato sia questi editor di testo per modificare l'oggetto sia lo stesso put-to item tramite tramite un'istanza di put-to item viewer che era il widget che usiamo dentro la lista giusto? era giusto per farvi vedere come funziona a toprata quindi non è che sia particolarmente utile perché qui questo oggetto qui lo toglierei per pulizia togliamo questo oggetto qui che non andrà a fare niente ok quindi la nostra pagina la continua semplicemente i due text field e poi ci mostra i valori dell'oggetto va bene ora per riciclare questo oggetto qui dentro un oggetto che non sia una pagina che cosa facciamo? beh molto banalmente prendiamo le componenti della nostra to-to item page e li rendiamo un widget di state per questa l'altra parte ok per cui questo editor di to-to item che chiamerò to-to item editor per esempio lo rendo un widget adesso un altro questo per competenza lo faccio vedere proprio in pratica per essere più chiaro di cosa intendo ci lo facciamo ok quindi sto qui ok questi sono i miei to-to item viewer che sono degli oggetti di widget molto semplici che non fa noto che leggere un widget è un to-to item e mostrarlo in maniera molto passiva quando clicco qui questo è il nostro to-to item page che ha varie cose accessorie e poi qui dentro avevamo incluso un to-to item viewer per competenza adesso faccio hot reload in teoria dovrebbe scomparire ok quindi la mia la pagina che voglio praticamente la pagina che voglio mettere qui a destra è questa parte qui questo blocco qui ok proviamoci allora quindi tutta questa bella roba qui la estrapoliamo dal body quindi qui il body lo manteniamo va benissimo così tutta questa colonna qui la togliamo via qui ora ci metto un size box provvisorio ok poi qui tra i widget creiamo un voodoo item editor si chiamerà ok questo sarà un editor in realtà sarà stateful però adesso per quantità parto sempre da stateless va bene ok poi ci mettiamo questo va bene qui ci mettiamo una build che è quella roba che ho tagliato da di là non so perché ho il maglioscoletto ok adesso mancano varie varie parti chiaramente item non so dove viene adesso qualcuno ce lo dirà e allora ragionare cos'è la cosa più sensata che possiamo fare allora il nostro item qui dato che mettiamo a posto le altre cose quindi questo lo convergo nel stateful widget ok da di là vado a copiare tutte le varie cose con il controller quindi queste cose qui le rubo proprio pari paro ok tutte le cose che servono di qua per gestire i due controller va bene poi questo va bene quindi questo oggetto qui da stateful care può tornare ad essere stateless un grande gioia ok ma la differenza qui ok ok ok quindi questa pagina qui noi la continuiamo a creare con un to do item dell'id quindi lo passiamo dentro potremmo fare la stessa cosa anche qui il mio to do item editor lo costruiamo con lo costruiamo con passando lì il to do item id tanto per quindi ho il to do item qui dentro va bene a questo punto qua dentro adesso io non posso leggere da ref perché non è non solo un consumer same widget ma lo divento per un secondo quindi divento consumer same for widget importo qui devo fare alcune cose qui tipo derivare da consumer state come era il nome così consumer state no si consumer state esatto va bene questo ritorno al consumer state no lo fatta sì ok adesso questo devo importare il provider ok ok tanti giri per fare poco adesso ho creato un widget stateless cioè è stateful ma come se fosse stateless è stateful giusto perché ha i controller dentro che devono traccia di quello che sto scrivendo nel blocco e quindi ho migrato le cose da page a editor in sostanza qui item perché numero dei ah perché lo tiravo fuori vabbè lo possiamo fare qui dentro quindi final item vado a fare ref watch di specific parola parola ok e vado a leggere widget to do item quindi ho il mio item quindi questa cosa qui si comporta come si comportava la pagina senza la pagina attorno quindi praticamente è contenuto e basta adesso posso usare questo oggetto qui dentro lato di page per cui qui dentro l'idea è che invece di andare a leggere l'item qui dentro perché non ho più bisogno vado semplicemente a costruire un oggetto di quel tipo quindi vado a costruire un to do item editor e gli passo il mio to do item p che è quello che ho per il costruttore portarlo ok questo non so se mi serve più immagini ah qui il titolo ok qui il titolo chiaramente adesso per lo dovrei leggere perché dovrei diventare un consumer perché mi avrei dimenticato che era anche il titolo dell'app bar non lo voglio rifarlo quindi ci mettiamo il tattoo item però si potrebbe fare rapidamente ovviamente passerebbe ah no siamo già un consumer ma scusate allora posso posso fare questo sono un consumer posso leggere quello che voglio e leggo il mio item a questo punto posso fare item punto tarte ok ci siamo tanti giri per non fare nulla perché adesso se io riapro l'applicazione in teoria sono da capa piedi perché ho fatto hot restart per pulizia quindi siamo qui login ok adesso qui non è cambiato nulla in teoria quando apro la pagina la pagina adesso è uguale ovviamente però è composta da un to do item page che include un to do item per fare la stessa cosa quindi però comunque il comportamento è ancora giusto nel senso che se io aggiorno le cose tutto funziona ok quindi si sono sono legati queste cose funzionano e se torno indietro la mia eh l'idea è stata aggiornata quindi ancora non ho fatto nessuna modifica eh drammatica adesso voglio solo verificare che ruotando lo schermo quindi facciamo questo sia in modalità eh larga cosa che non siamo perché il breakpoint è troppo largo allora cerchiamo un breakpoint più corretto qui chiaramente eh adesso non so quanto è esattamente la grandezza dello schermo ma ok qui allora questo 992 non è il breakpoint giusto ma che il breakpoint sia small o extra small quindi prendiamo questo come riferimento perché è un cellulare giustamente e ristartiamo relodiamo l'applicazione è piaciuto molto poco però la parte che è piaciuto molto poco però è una modalità del largo schermo quindi la cosa che non funziona è che il container non sa come mettersi giustamente perché non eh un po' tutto non sa come mettersi cerchiamo di aggiustare qui le cose allora la nostra riga come al solito allora un main exercise quindi la exercise max voglio che prenda tutto lo schermo main exercise alignment voglio in realtà non voglio usare spazi liberi per cui in realtà serve fino a un certo punto mi posso anche mettere center in teoria ok poi i singoli elementi voglio che prendano tutto lo spazio disponibile quindi to do list ci metto expand attorno e lo metto anche attorno al container ok quindi i due elementi a sinistra e destra prendono lo stesso spazio perché sono entrambi aspanzi se volessi che sono proporzionali in qualche modo potrei usare flex no per dare più più peso a un elemento piuttosto che un altro in questo caso voglio che sia tagliato a metà ok questo è più o meno quello che ci aspettavamo giusto quindi tutto funziona ancora questo funziona ancora e se apro navigo alla stessa maniera quindi questa cosa tutto sommato funziona ancora adesso voglio finalmente che questa parte qui a destra si ribildi in base a quello che avviene per cui a questo punto allora voglio che questo oggetto qui che cosa deve fare deve ribildarsi in base al provider selected giusto quindi con selected content provider io vado a pescare l'elemento attivo e lo faccio direttamente nella home page quindi qui dentro nella build large cosa faccio faccio final selected item id lo chiamo e faccio ref.watch tanto che posso fare watch perché ah no non ho ref però me lo passo widget ref ce l'ho qui e lo devo solo passare a build large in questo caso quindi lo passo qui ok sono per comodità perché mi serve il widget ref se non posso fare il watch nulla potrei fare anche su build small ma su build small non mi serve al momento quindi qui select the provider ok questa cosa la leggo quindi questo dovrebbe essere una stringa nullabile ok quindi allora qui in mezzo facciamo che allora dentro questo expended qui facciamo che expended id uguale null allora evidentemente l'utente non ha scelto nulla ok quindi metto un testo centrato e scrivo ok molto utile e invece se l'utente ha selezionato qualcosa che cosa vado a creare vado a creare l'oggetto no vado a creare il to do item editor che è questo oggetto qui che io vado a costruire semplicemente passandogli il to do item id che qual è è quello lì che già ho giustamente quindi qui faccio to do item editor e gli posso passare a selected item id sapendo che visto che non è nullo qui sarà costruito quindi questa è una stringa non nulla vediamo se dart ci arriva da solo penso che ce la può fare questo chiaro quindi se è nullo mostro il testo e appena qualcuno seleziona qualcosa metterò qui l'entro già dovrebbe funzionare manca solo chi imposta l'oggetto giusto? quindi serve che qualcuno qui vada a impostare questo questo click qui questo click qui da chi è gestito? è gestito da la to do list esatto allora qui cosa facevamo? se mi ritrovo qui qui andiamo diretti verso un'altra pagina che non è quello che vogliamo fare noi vogliamo andare a modificare lo stato del provider quindi qui questo andava bene lo taglio perché in alcuni casi mi serve ancora perché se sono in modalità mobile voglio comunque aprire la pagina di destinazione qui vado a fare ref read the selected notifier ok perché vado a modificare lo stato quindi state vado a scriverci l'id dell'oggetto selezionato quindi in questa maniera qui ok in realtà basterebbe questo per cui se ho fatto not to start adesso ho rotto la modalità mobile però riaggiustiamo una seconda altre cose che sono rotte ma facciamo finta che vada bene così ok adesso quando clicco qui che cosa viene qualcuno scrive su select the selected provider si rebuilda tutto e a destra compare il nostro oggetto ok da questo punto io se modifico qui adesso a parte che l'interfaccia anche qui bisogna prepararsi al fatto che la tastiera venga messa vedete che aggiorno gli oggetti e in tempo reale a sinistra la mia lista si aggiorna ok adesso migliorabile su vari fronti ma funzionale quindi adesso qui continuo a selezionare ah qui vedete che qui c'è un problema mio viene ricostruzione l'oggetto ma il controller rimangono gli stessi di prima vedete che non cambia il testo questa è una cosa che devo aggiustare per un secondo però già abbiamo fondamentalmente la navigazione ce l'abbiamo adesso la cosa che rimane è che in questa modalità qui non funziona la navigazione se io clicco clicco qui e non navigo più perché non c'è nessuno che naviga chiaramente quindi come faccio a riagganciarci alla navigazione allora serve qualcuno che navighi on demand se c'è bisogno di navigare si possono fare varie cose su questo fronte allora una delle cose è c'è una cosa più semplice che si potrebbe fare qui dentro nella to do list qua potremmo portarci dietro se siamo stati costruiti in modalità larga o stretta ok quindi qui magari nel momento che veniamo costruiti dentro build large build small magari qui mettiamo un booleano qui dentro ok e passiamo a to do list se deve navigare o meno questo è un modo che si potrebbe utilizzare quindi qui non diciamo di avere questo booleano nella to do list qui abbiamo costruiti in modalità che ne so modalità large no o true o false e poi in base a questa modalità large possiamo comportarci in media diverse quindi o modifico il select studio item provider oppure vado a navigare questo funzionerebbe ma è meno non è proprio in linea con i provider ovviamente per cui quello che si fa in genere è agganciarci di nuovo a questo select studio item provider che è il provider che ci dice se l'utente ha selezionato qualcosa per cui qui dentro quindi dentro la pagina principale la pagina che sa se siamo larghi o meno in sostanza quindi qui dentro sappiamo già in che modalità siamo c'è una funzione che finora non abbiamo visto dei provider che è listen che è quello che ci serve ref listen questo finora non l'abbiamo ancora visto listen cos'è? listen è un modo per agganciarci a un provider e non rebuildarci quando avviene qualcosa ma semplicemente fare qualcosa cioè fare un'attività mandare l'esecuzione un metodo per fare qualcosa e lo facciamo qui dentro quindi qui dentro l'eatrolister cosa facciamo? passiamo in provider ovviamente in select detail dettari ok e a questo punto non mi riva la presentazione ma ce la possiamo fare mi pare che si passa ah esatto quindi si passa il provider e poi si passa il listener che è una funzione che prende in input due oggetti cioè due oggetti dati da provider quindi in questo caso sarebbe la string in realtà quindi string string force e string che sarebbe in sostanza il valore di prima e il valore di dopo per dirla in maniera sensata prev next sarebbe quindi questo metodo qui viene invocato ogni volta che qualcosa cambia su questo provider qui mettiamoci il debug selected to do item provider cambia da prev a next adesso questo lo agganciamo e lo ranniamo un attimo noi nel debug nella console vedremo che cliccando di volta in volta comparirà il prima e il dopo andiamo così così è più efficace ok quindi adesso è cambiato da null a 3 3 2 2 eccetera eccetera quindi questa è la selezione ogni volta che clicchiamo quel listener viene invocato a questo punto qui dentro è abbastanza facile invocare la navigazione quindi if is large no se if not is large giusto perché navighiamo soltanto se non è large and next non è nullo perché next è una string annullabile perché il provider risponde a una string annullabile per cui se qualcuno deseleziona qualcosa in realtà non si può fare ancora però immaginiamo se il provider torna null e non vogliamo navigare su una parte ok in questo caso incollo la cosa di prima e navigo verso la pagina alla quale passo semplicemente il nuovo valore del selected to do provider provider ok not reload a questo punto se rimango in questa modalità qui i click funzionano in questa maniera qui appena switch nell'altra modalità rimango qui e cliccando il listener mi apre la pagina e a questo punto e tra l'altro il selected to do provider è rimasto impostato item 1 adesso vabbè facciamo item 5 magari ci mettiamo in questo caso se torno indietro e torno così rimane aperto sull'ultimo attivo quindi rimane aperto sul quinto elemento ok appena modificato quindi quel selected item provider rimane impostato sull'ultimo elemento che è stato attivato in sostanza per cui questo può essere sensato e cosa vuol dire su questo e c'era una cosa che vuol dire un secondo fa ma è appena passato di mente quindi secondo me era molto importante e non lo ricordo adesso ci sono alcune cose che non funzionano va bene quindi in realtà c'è questo elemento qui quindi il fatto che il testo qui non cambi è dovuto al fatto che i nostri è dovuto al fatto che i nostri studio item viewer qui questo widget qui qui no non è questo è un widget const che proprio devo cambiare in base a questo qui qui il problema di fondo è che lo stato viene mantenuto cioè quando il widget fa rebuild di cui io clicco il nostro to do item viene ricostruito ma flatter per economia mantiene l'oggetto di stato ok perché vede che non è stato modificato e quindi non viene alterato qui devo forzare la ricostruzione e prendiamo la non const e vediamo se anzi no lo lasciamo const qui ma lo vediamo non const nella tut nella home page in questa maniera dovrebbe ah no però questo non era con in partenza e non può essere neanche in effetti ah beh questo sono 4 minuti quindi lo risolvo in in serata e poi ve lo carico in quella maniera e che domani lo rivediamo però rimane questo il problema di fondo che lo stato viene mantenuto però fondamentalmente l'idea l'approccio è questa ok quindi soltanto con uso del provider e con la media query abbiamo creato questi soggetti di prima abbiamo creato interfaccia che potenzialmente è risposta che può essere anche più complessa di questo chiaramente perché se immaginate di avere una home page che ha non so una condizione di spazio ancora maggiore chiaramente possiamo avere un terzo elemento a destra con altre informazioni in che quel widget rimane collegato ai provider noi sappiamo che il provider è lo stato della nostra applicazione che vale sempre quindi il numero di widget che mettiamo a schermo in realtà non ci complica l'interfaccia avete visto come è stato facile aggiungere un elemento a destra che farlo a mano è molto incomplesso fatto in bag con altri strumenti che abbiamo dovuto copiare un sacco di logica di aggiornamento di stato e così via finché i widget vengono collegati ai provider sappiamo che a cascata sono sempre corrette a parte questo piccolo bug dell'editor a parte però in generale avessimo un terzo widget con un terzo provider che gestisce qualcos'altro e lo mettessimo qui a destra sappiamo che finché il provider è corretto e finché il widget si basa sul provider quella funziona in maniera dipendente dal resto del provider per cui a questo punto la nostra interfaccia è veramente a compartimenti e possiamo abilitare i pezzi come ci piace e come ci parte chiudiamo qui questa carrellata spero di sversare qualcosa perché era un po' un tour de force in alcune alcune parti più così meno compensibili forse di flutter però dopo vi carico il codice per poter rivederlo e domani aggiustiamo questo ultimo bug e domani andremo a vedere poi una CSS file che è sicuramente un mondo più imperativo e più classico rispetto a questo che è fatto dal punto di vista dovrebbe essere più più facile ok allora vorrei interrompo sicuramente a