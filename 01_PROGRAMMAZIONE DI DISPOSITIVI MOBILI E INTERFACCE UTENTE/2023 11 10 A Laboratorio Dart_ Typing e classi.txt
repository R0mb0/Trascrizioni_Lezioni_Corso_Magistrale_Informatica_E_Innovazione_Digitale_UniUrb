ok perfetto allora dipendiamo da dove eravamo arrivati ieri ieri mi sono accorto che ci vuole un po' di più a vedere tutto l'art per cui adesso investiremo queste altre due ore nel vedere le ultime cose in dettaglio perché alcune cose sono importanti da vedere in dettaglio come appunto le classi ovviamente le classi mutabili e tutta la storia che vi ho accennato ieri delle variabili final e const che abbiamo intravisto ieri ma adesso lo vedremo in maggior dettaglio quindi torniamo a dove eravamo ieri quindi abbiamo fatto una applicazione ma non manca il terminale abbiamo il terminale qua qui quindi con dart run teoria tutto ok e quindi abbiamo visto un paio di come funzionano i tipi basi come funzionano le funzioni come come fatto qualche qualche semplietto abbastanza semplice abbiamo visto infine le liste e gli insiemi e le mappe e in tutto questo avevamo confezionato una funzione print list che non faceva altro che stampare le liste sostanzialmente quindi prendeva in input una una serie di elementi e li stampava nel fare questo abbiamo visto così tangenzialmente in realtà già così l'aspetto degli oggetti di dart quindi abbiamo visto che per esempio list è una classe ovviamente che implementa una serie di cioè un'interfaccia in realtà che è l'interbo di oggetti e e questo vale un po' per tutti può valere per tutte le collezioni in dart per cui list implementa l'interfaccia iterable quindi iterabile set fa la stessa cosa quindi è ugualmente iterabile map no map non implementa iterabile direttamente quindi se apriamo la classe vedete che map è una classe astratta a se stante che non implementa interfacce però poi potremmo come iterare comunque sugli elementi di una mappa perché chiaramente si può fare ugualmente però già in questo vediamo che ovviamente dart l'immaginità degli oggetti ha tutti gli effetti e la sistema di classi e di classi derivate e interfacce somiglia molto a quello che si che conoscete sicuramente già da java c sharp e cose simili in realtà dart è un pochino più sofisticato di questo perché ha anche un concetto che si chiama che si chiama classi mix in che permettono di integrare delle classi piccole come se fossero delle interfaccette che però hanno anche un'implementazione quindi è una specie di mix un po' esoterico tra un'interfaccia e una classe a dirla a dirla in maniera un po' vaga non le vedremo perché comunque non si cioè nel nel nostro uso di Flutter poi non ci sarà occasione di utilizzarlo però sappiate che in realtà buona parte del del mondo ritogli oggetti di Dart lo tralascieremo perché non ci servirà chissà quanto lavoreremo con classi molto semplici quindi non andremo in dettaglio però sappiate che in realtà il sistema di oggetti di Dart è abbastanza sofisticato e appunto ci sono degli elementi abbastanza strani come mix in che non trovate in altri linguaggi quindi nella stessa forma ok tutto questo per tornare a printlist torniamo un attimo a questa funzione perché ieri l'avevamo implementata in varie salse e adesso la miglioriamo un attimo perché non è praticamente leggibile quindi ieri abbiamo visto che un iterable quindi l'iterabile è appunto questa vedete già tra l'altro è un mix in per cui anche qui vi accennavo il fatto che ci sono queste classi mix in questo perché iterable quindi l'interfaccia è sia un'interfaccia che spuole delle funzioni ma anche un comportamento però a noi all'altro pratico non interessa quindi fate finta che sia una classe astratta da cui poi list, set e poi alcuni elementi di Mac derivano poi qualcosa che accade in dettaglio non ci riguarda da vicinissimo si può iterare a mano come siamo abituati in C si può iterare con una specie di for each come siamo abituati da C-Shart per esempio ed altri linguaggi che hanno l'iterazione come un elemento di primo ordine in realtà in questa maniera chiaramente la lista è un po' illegibile perché viene stampata su più righe e per renderla più legibile facciamo una piccola modifica così vi do la scusa di vedere un'altra funzione del linguaggio e andiamo a fare la literazione su una singola riga per fare questo usiamo una funzione di iterable che è join appena l'interessence lo riconosce e con questo vediamo un attimo come funzionano i mixin nel senso che se siete abituati alle interfacce di Java e C-Shart sapete che le interfacce hanno, cioè definiscono i metodi che una classe deve implementare per implementare un'interfaccia quindi è il minimo di metodi che devono essere implementati affinché una classe possa esporre, possa essere riconosciuta come una tale interfaccia quindi per esempio in C-Sharp se avete un oggetto list.dt questo implementa in iEnumerable che non so scrivere però iEnumerable esporre una serie di metodi e quindi significa che list necessariamente deve esporre quei metodi lì per essere riconosciuta come un'istanza di iEnumerable quindi questa è l'idea in Dart questa cosa è molto simile quindi abbiamo list.dt ugualmente questa implementa o estende iEnumerable di t in questo caso iEnumerable è sia un'interfaccia quindi sia un insieme di metodi che il list deve esporre ma è anche una serie di implementazioni quindi si porta dietro una serie di codice già pronto che la classe quindi sta integrando per questo motivo si chiamano mixin quindi è un misto tra un'interfaccia pura di metodi che vanno implementati e una serie di metodi che sono già implementati quindi la classe si assorbe in qualche modo e integra in se stessa l'unico di questi metodi qui è il metodo join appunto il join è un metodo implementato dentro iterable e quindi è disponibile anche a list, set e così via il join cosa fa? il join mette insieme tutti gli elementi di una iterazione e li stampa tra virgolette in una stringa quindi serve per mostrare a video in genere gli elementi di una lista o qualcosa del genere con un separatore quindi noi vogliamo che gli elementi si sono separati da una virgola in uno spazio per esempio e quindi possiamo fare print iterable debunti e poi ci mettiamo tutto questo blocco questa funzione qui tra le graffe del dollaro anche qui attenzione alle parentesi qui è molto facile incartarsi con le varie parentesi in questo caso per rendere più legibile magari si può anche tirar fuori io mostro anche hit magari non è un buon nome joint magari ok in questa maniera qui noi tiriamo fuori una stringa poi la buttiamo dentro l'interpolazione e qui tra l'altro start ci suggerisce che le graffe non sono necessarie e qui appunto a vostra preferenza potete mettere lo stesso o meno e anche qui vi faccio vedere che spesso conviene cioè se siete sicuri che una variabile non la riassignerete poi dentro un metodo è sempre il caso di user refinal per proteggere voi stessi da cioè proteggervi da voi stessi così voi sapete che quella variabile non la cambierete più perché la usate in quel modo non volete che sia modificata quindi invece di var uso final questo se riuscite a farlo fatelo in ogni occasione possibile se lo stesso approccio in realtà si fa anche in javascript se avete esperienze in javascript dove ci sono due keyword per definire le variabili let crea le variabili in realtà c'è anche var ma è così in disuso let crea variabili che sono modificabili e const invece crea variabili che sono non modificabili poi in quel metro lì per cui anche in javascript in genere si consiglia usate const il più possibile così siete sicuri che il vostro codice fa quello che volete che vi aspettate stessa cosa con final di dart usatelo il più possibile prego ma con dart è instabile quanto javascript per queste cose? instabile in che senso? è che javascript fa un po' quello che vuole quando ci sono le variabili o le variabili e le capacità è già si fa quello che vuole nel senso che lo fa con criterio però un criterio che non ha senso però no no dart rispetta tutti i crismi che siamo abituati a pensare come ragionevoli che vengono da C quindi dart è simile a questo quindi lo scoping le variabili è quello classico e quindi immagino che fa riferimento al fatto che i var in dart sono visibili anche forse le funzioni queste cose sì no questo questo non avviene dart ha una sua logica che che è giusta insomma almeno da chi viene da da C e derivati ok quindi in questo caso qui abbiamo usato un metodo che è specificato sul mixin interball e quindi lo sfruttiamo in questa maniera e quando stampiamo a questo punto le stringhe le vediamo stampate in questa maniera che è sicuramente più legibile altra cosa che possiamo fare è ah ci arrivo dopo magari intanto vi ho già fatto vedere una cosa delle mappe questo l'ho fatto ieri togliamolo perché come dicevo prima map non implementa iterable quindi non è iterabile in sé quindi non possiamo scorrere gli elementi di una mappa direttamente e passarlo a printlist perché non rispetta quindi non implementa quella interfaccia quindi come facciamo mappa la gemmap espone tre campi tre proprietà che sono entries keys e values quindi possiamo leggere la mappa in tre modi diversi entries se riusciamo a vedere come sono dichiarate vedete qui che entries è un iterable di map entry di int e string quindi è un doppio generico un doppio generico come si legge questa cosa qui è una iterazione di map entry quindi elementi di mappa ognuno dei quali è composto da int che è la chiave in questo caso e string che è il valore quindi è una lista di oggetti della mappa mentre keys è la lista schietta di chiavi quindi questo è un iterable di int perché int è il tipo della chiave ovviamente e values ovviamente sarà un iterabile di string sono questi tipi qui perché li abbiamo dichiarati noi in questa maniera quindi chiaramente se cambiassimo chiave e valore cambierebbero direttamente anche i tipi del iterabile ok per cui in questo caso possiamo stampare o le chiavi o i valori o le entries quindi le coppie se vogliamo le coppie come abbiamo visto qui le stampa in questa maniera qui notate che non è particolarmente bello qui praticamente per ogni quando facciamo print list stampiamo i singoli oggetti li stampiamo con il metodo to string perché ogni oggetto quindi ogni ogni oggetto derivato da cioè ogni ogni stanza derivata da object che è la classe madre di tutto in sostanza ha due funzioni di base to string che se se corteggiava si sharp i derivati sapete che questo è il metodo di base che esiste su ogni oggetto to string e il hash code dove era il hash code che tira fuori l'intero dall'oggetto questo serve in alcuni casi per fare appunto per fare dell'operazione di hashing e quant'altro e poi c'è l'operatore di uguaglianza anche che vedremo tra un istante l'operatore di uguaglianza permette di confrontare un'istanza di un oggetto qualsiasi a un altro oggetto prego esatto esatto questi sono tutti sono tutti metodi virtuali in autonomia per cui possiamo fare l'override dei vari metodi poi nelle classi derivate cosa che molte classi già implementate nel runtime d'art fanno ovviamente e noi faremo la stessa cosa tra un secondo quando andremo a fare le nostre classi di base appunto sono questi i tre metri fondamentali che l'object espone e quindi di base quando facciamo una classe nuova è ragionevole immaginare di sovrascrivere questi tre metri toString viene utilizzato nel fare la stampa quindi quando andiamo a stampare l'oggetto qui dentro il nostro bellissimo printlist quando facciamo join questa join qui che cosa fa? è una join di oggetti e che quindi sono potrebbe essere qualsiasi cosa in realtà in questo caso sono degli oggetti di tipo lo dirò sono degli oggetti di tipo map entry quindi l'oggetto che arriva lì nel join è una serie di oggetti map entry e dart invocherà tutti i suoi map entry e map entry si stampa in questa maniera quindi è map entry poi come se fosse una tupla come diciamo ieri chiave e valore chiaramente se passiamo ad altri oggetti si stamperanno in modo diverso mentre se stampiamo direttamente le chiavi per esempio chiaramente questi sono degli interi e quindi mi aspetto a rivedere semplicemente l'intero si può sopporre ecco qua ok ultima cosa sulle iterazioni perché l'iterabile quindi è l'elemento base che usiamo per manipolare le mappe le liste di oggetti si possono anche l'iterabile stesso può essere manipolato ulteriormente perché espone una serie di metodi che possono essere utili per esempio per esempio lo trovo l'iterabile vi permette di leggere il primo elemento l'ultimo elemento verificare che sia vuoto non vuoto verificare che sia un elemento singolo questo in alcuni casi è utile se avete una lista di oggetti che però in alcuni casi magari è soltanto un oggetto ma in alcuni casi può per senso potete tirare fuori l'unico oggetto della lista se è presente questo single praticamente devi tirare fuori l'unico oggetto della lista se è unico se sono zero oggetti o più oggetti tira un errore sostanza quindi è un modo per essere sicuri che l'array è composto da un singolo oggetto e di accederlo direttamente cosa si può fare si può fare skip che permette di saltare gli oggetti nell'iterabile quindi per esempio se io faccio tra l'altro questo vi ritorna un altro iterabile quindi è un iterabile su cui chiamiamo skip e ci permette di saltare i primi due mettiamo ok vedete che questo skip torna comunque un iterabile quindi vi torna un altro iterabile che inizia semplicemente due elementi dopo se adesso compilo e lancio questa cosa qui vedremo solo gli ultimi due oggetti della lista qua quindi era un due tre due tre quattro tre quattro cinque quattro cinque sei eccolo quindi con skip semplicemente sono saltato avanti di due cos'altro c'è si possono fare un paio di operazioni accedere all'elemento ennesimo questo è l'accesso all'array in sostanza c'è il join come ho visto prima e così via ci sono anche dei metodi di verifica quindi per esempio any contains e every permette di verificare che un oggetto qualsiasi verifichi un praticato quindi che ne so un oggetto è una forma tale che adesso lo vediamo lo usiamo in pratica contains poi potete verificare che la lista contenga un elemento che rispetta un praticato e così via quindi possiamo fare varie operazioni sulle iterazioni un'altra cosa si può fare sulle liste per esempio è avere accedere a degli iterabili diversi per esempio reversed vi permette di accedere a un iterabile che legge la lista al contrario quindi si può girare l'array vi permette di leggerlo al contrario senza andare veramente a spostare gli elementi dell'array ve lo leggo solo al contrario quindi ve lo itera dall'ultimo al primo non tutti i iterabili possono farlo perché non tutti i iterabili sono implementati alla stessa maniera quindi possiamo accedere a reverse su list perché la lista alla fine dei conti è un array non possiamo farlo su una mappa perché la mappa non può essere girata perché la mappa ha una sola un solo ordine di lettura ok perfetto a questo punto l'ultima cosa che vediamo è vi ho detto che appunto Dart è un linguaggio fortemente tipizzato statico ovviamente fortemente tipizzato ha pochissimi costrutti pochissime funzioni che vi permettono di gestire il comportamento a runtime cioè tutti i controlli che dovete fare sui tipi e su quello che contiene i vostri dati si fanno in genere a tempo di compilazione questo vuol dire che a differenza di JavaScript Python e così via il compilatore fa la maggior parte del lavoro e poi a runtime siamo abbastanza sicuri che tutto funziona come deve l'unica cosa che possiamo fare a runtime è andare a vedere qual è il tipo di un oggetto nel caso in cui diciamo così c'è una un certo caso di incertezza per cui ogni tipo vi faccio farlo vedere di nuovo ah tiriamo per object magari object vi dicevo che espone to string hash code e l'operatore di eguaglianza ma espone anche runtime type parte esatto questo qui questo è una proprietà che permette di leggere il tipo di un oggetto a runtime ok quindi questo è diverso dal tipo che è visibile al compilatore qui in questo in questa funzione qui il nostro iterable qui è di tipo iterable di e quindi questo è il tipo a tempo di compilazione però chiaramente può essere qualcos'altro può essere una lista può essere una mappa può essere un set può essere qualsiasi cosa quindi quello lo possiamo leggere a tempo di runtime e per fare questo leggiamo runtime type per far questo possiamo stamparlo qui dentro per esempio quindi mettiamo qua leggo iterable runtime type per me devo farlo tra grazie se no non funziona runtime type ok a questo punto se risego il nostro programmino mi stampa dopo iterable mi stampa il tipo effettivo di quell'oggetto quindi questa cosa vedo che è list di int list di int qui notiamo una cosa strana qui il tipo è underscore set di int e qui è underscore compact iterable di int che cosa significa questa cosa qui allora mentre list è un tipo pubblico quindi è un tipo che noi stiamo utilizzando quando noi andiamo a creare list qua andiamo a istanziare un'istanza di questa classe list qua questo va bene quando andiamo a creare set evidentemente quando andiamo a leggere l'insieme attraverso iterable stiamo utilizzando una classe nascosta che chi ha creato il runtime di dart non ci permette cioè non ci può utilizzare abbiamo creato il set come come classe però in realtà lo stiamo utilizzando tramite una sottoclasse che è il underscore set se ricordate l'underscore in prima posizione vi permette di nascondere delle classi delle variabili dei dati e così via all'interno di un file quindi per impedire ad altri di poter istanziare quella classe in particolare o di utilizzare quelli qui dati in particolare quindi internamente set implementato in maniera tale da delegare poi la sua implementazione a un'altra classe che è underscore set quindi noi non andiamo a creare oggetti tipo underscore set ma comunque ci viene ritornato un oggetto di quel tipo lì ok in realtà non ci interessa vederlo in realtà già possiamo vedere qui questo è il costruttore di set e adesso questa sintase qui vi è ancora un po' aliene ma vediamo da un secondo che cosa significa però questo significa che set quando andiamo a costruire l'oggetto tipo set in realtà non costruisce un oggetto tipo set ma è un costruttore factory che tra un secondo vi dico cosa fa però è un sistema di dart per permettere a un costruttore di darvi un altro oggetto che non è l'oggetto che avete costruito quindi è una specie di trucco diciamo così e sotto sotto banco crea in realtà un linked hash set che è un altro oggetto che a sua volta chiaramente può essere implementato in vari modi questo dovremmo vederlo alla fine dovremmo arrivare al finalmente al underscore set da qualche parte quindi l'implementazione vera di set è nascosta o capata nel runtime di dart non ci interessa qual è la classe vera effettiva che implementa set noi la utilizziamo solo tramite della sua interfaccia sì sì esatto non la vediamo perché noi non possiamo creare nel nostro codice quell'undercore set non è visibile quindi io se faccio set mi dà errore perché non sa di cosa sto parlando quindi quell'undercore set è da qualche parte nel runtime da dart e io non posso vederlo però il mio modo per istanziarla è usare set quindi set è l'interfaccia diciamo così e poi quella lì mi dà un oggetto che io immagino essere un set ed è effettivamente un set perché implementa l'interfaccia di set quindi la posso usare come se fosse un set ma non è un'istanza di set è un po' come nel caso che esempio ho delle classi derivate c'è la classe base animale per dirlo poi ci sono varie derivate le azioni che sono cane, gatto eccetera eccetera e quando creiamo quando ci arriva un oggetto animale quello può essere un cane o un gatto e noi in realtà finché non siamo a runtime non sappiamo che tipo che tipo di animale è se noi lo riconosciamo come animale questo è un po' come la stessa idea quindi abbiamo un set che poi internamente può essere implementato in vari modi in vari modi il che tradisce il fatto che questo è un linked hash set vuol dire che internamente quell'insieme è fatto come una lista una linked list quindi una lista collegata di valori basati sul hashing dei valori perché vi dicevo che il set deve garantire che l'oggetto non venga aggiunto due volte per cui tramite hashing riconosce se l'oggetto è stato aggiunto già una volta e vi impedisce di riaggiungere in sostanza questo viene fatto con una specie di mappa di hashing in sostanza però come questo viene fatto in realtà non ci interessa quindi è un dettaglio movimentativo che non ci riguarda stessa cosa vale per la mappa che è di nuovo qui la mappa in realtà visto la mappa non è iterabile direttamente quindi noi accediamo alla proprietà keys che ci ritorna un iterable di interi in questo caso però poi come si è implementato quell'iterabile non lo sappiamo quindi in questo caso iterabile è in realtà un underscore compact iterable di int che è un oggetto x qualsiasi che noi non sappiamo come è fatto ovviamente però sappiamo solo che noi possiamo utilizzarlo come se fosse una lista di interi tutto qui però con una timetife noi possiamo andare a vedere come sono fatti gli oggetti e loro interi ok per cui a questo punto facciamo una prova più dettagliata su questa cosa dei tipi perché cosa potremmo fare una cosa che può essere utile proprio per vedere questa questa proprietà è fare una una funzione print details chiamiamo magari a differenza del print classico alla quale passiamo un oggetto qualsiasi o ok e poi magari in base al tipo che implementa in base al tipo che è a runtime decidiamo come stampare come rappresentare quell'oggetto questo potrebbe capitare in varie in varie occasioni quindi magari facciamo un controllo o vogliamo verificare che o sia per esempio un int se è un intero lo stampiamo come se fosse un intero quindi se if o la sintassi è molto lineare molto leggibile is int quindi se è un intero manualmente lo stampiamo in qualche modo else if o is double mettiamo stampo qualcos'altro e else tipo qualcosa di genere ok in questa maniera qui sto distinguendo in base al tipo dell'oggetto questo all'attrope andrà a fare cosa al runtime andrà a vedere il runtime type dell'oggetto andrà a verificare che sia che combaci con il tipo che sto specificando qui il tipo qui adesso sono int double sono due tipi di base che sono primitivi però può essere qualsiasi tipo quindi può essere una classe nostra una stringa un map un iterable e così anzi un iterable ha senso farlo quindi facciamo se if o is devo anche verificare che sia un iterabile oddio ho fatto salva e mi è sparato tutto ok adesso a questo punto una cosa molto potente di Dart è che all'interno delle graffe in cui abbiamo verificato il tipo di un oggetto il compilatore già sa che ho chiaramente un itero quindi in questo caso ho ci offre tutta l'interfaccia di int qui vedete che vi espone una serie di proprietà che non ci sono su obiettivi chiaramente quindi se io faccio ho puntato qui fuori ho accesso soltanto ai tipi base di obiettivi quindi ho hashcode runtime type to string e gli altri che sono abbastanza inutili quindi qui so soltanto che ho un oggetto se sono nel blocco che sa che è un intero a questo punto ho accesso a tutti i campi e le proprietà di int questa cosa quindi posso fare print integer posso scrivere is even anzi faccio o is even se è even stampiamo even se no stampiamo non non non non non non non non non non non non non non non non non non non non non non se è un double anche qui ho a questo punto già accesso tutti i campi di double quindi vediamo se è n a n se è finito se non è finito ci sono varie operazioni sul sul tipo e quant'altro quindi qui possiamo fare per esempio print double e stampiamo non so o qui vedete che double ha to string che stampa il double chiaramente poi ci sono vari double diversi che posso stampare con l'esponente con la pressione fissa e così via mettiamo che vogliamo soltanto un decimale per esempio poi se è un iterabile invece magari possiamo fare la stessa cosa che facciamo qui stampiamo il iterabile direttamente iterable di o e possiamo aggiornare l'iterable in questa maniera perché sappiamo che è un iterable quindi possiamo fare o join con lo spazio e qui ci scrivo invece che non so cosa sia ok ha un suo senso tra virgolette quindi in base al tipo che so che ottengo faccio altre cose e in base al blocco in cui sono che le metto ho accesso a altri metodi perché DART riconosce che all'interno di quel blocco lì siamo sicuri a runtime chiaramente che quell'oggetto è di un dal tipo quindi a tempo di compilazione posso darti accesso a una serie metodi perché il compilatore sa già che lì dentro li trova soltanto se o è di un certo tipo quindi da questo punto di vista il compilatore DART è più furbo di altri linguaggi dove invece dovreste fare il cast dell'oggetto invece prendere l'oggetto castarlo a un sottoggetto e poi avreste accesso ai vari metodi questo si può comunque fare giusto nota margine se volete castare qualcosa a qualcosa altro se siete sicuri che un intero è un intero per dire quindi faccio per esempio int i potete fare o as int e questo vi casta cioè è non necessario che vi dice di non farlo ovviamente perché o è già riconosciuto come intero da compilatore quindi è una cosa che faremo in C Sharp magari per castare l'oggetto veramente intero se vogliamo farlo la keyword è else quindi con else possiamo castare un oggetto a un'altra interfaccia se lo facciamo qui non necessario perché sappiamo già che l'intero intanto vale usare la variabile o se lo facciamo fuori invece non è necessario ma è rischioso perché può esplodere ok? quindi qui se l'oggetto non è intero questo runtime esplode prego ok quindi qui dentro quindi questo qui o as in questo questo qui cioè o ah così cioè sarebbe così stiamo castando il double in però non si non ha una idea non la si la stessa non si può ribattezzare quella ormai è allora la o ormai è un object quindi è di tipo object è genericissimo e non si può cambiare il tipo visto che il typing è statico ed è forte non si può variare il tipo di una variabile che già ha un tipo quindi o non si può cambiare qui il fatto che la o venga riconosciuto come un intero è il compilatore che vi dà una mano cioè è solo di nuovo è solo aiuto sintattico rimane un object esatto quindi se il compilatore ancora lo riconosce come object sa solo che ok io a runtime qui dentro avrò verificato che è un intero quindi ti posso dare praticamente accesso ai metodi che vado sull'intero e che so che quei metodi esistono e l'oggetto che tu hai in mano la o li implementa quindi non dovrebbe esplodere ok questa è l'idea se voglio castarlo forzatamente al di fuori perché senza verifica posso fare con questa intassi qui con as in quel caso qui però ho un'altra variabile i che è di altro tipo perché object o non si può cambiare il tipo una volta che è stato assegnato ok per cui questo printl test in realtà possiamo provare a usarlo in qualche occasione quindi stampiamo questi oggetti qui e vediamo che aspetto hanno giusto per apprezzare l'output così dovremmo andare vediamo cosa dà teoria dovremmo darci un output esatto quindi abbiamo integer odd quindi mi sembra che vale 1 quindi ovviamente no 1 2 3 quindi dispari e dopo le 1.1 tra l'altro qui ha troncato quindi era 1.123 qui ha troncato il primo decimale come ci aspettavamo e poi questi qui che bool e string non riconosce ancora il nostro metodo li stampa come altri oggetti però li stampa il runtime time perfetto ultime due cose sui tipi perché i tipi sono ossici quindi bisogna vederli bene ultima cosa da ricordare da dart non ricordo che versione in poi dalla 2 qualcosa in poi dart è cambiato radicalmente perché in in origine in dart tutti gli oggetti erano anche nullabili quindi era un po' come in java quindi tutti gli oggetti potrebbero essere assegnati cioè a tutti gli oggetti potevamo assegnare null volendo quindi questo o qui poteva diventare null possiamo fare così questo non si può più fare però si poteva fare e anche gli int quindi questo i qui questa variabile qui poteva essere diventare un intero null nullo era legale questo appunto in java si può ancora fare non per i tipi primitivissimi no però per i tipi generici sì perché sono tutti tipi solo heap in dart questo si può fare perché erano tutti tipi appunto potenzialmente nullabili questo è stato tolto perché era fonte di enormi problemi ovviamente il null è sempre un gran dramma in genere per cui adesso la nullabilità di una variabile deve essere imposta in maniera esplicita che significa che se vogliamo che una variabile possa essere null perché magari ci è utile o ha un senso particolare per noi nel nostro codice va specificato mettendoci il punto interrogativo subito dopo il nome della variabile per cui se vogliamo che object possa essere null bisogna metterci il punto interrogativo dopo per poter dire che quella o lì o è un oggetto o è null quindi vale per entrambi i casi quindi se non ce lo mettiamo print details di null non è valido ok? questo vi dà errore perché print details non accetta valori null ok? se ci mettiamo il punto interrogativo a questo punto lo accetta ma a questo punto noi qui dentro dobbiamo verificare cioè dobbiamo verificare a questo punto se è null entriamo in questo caso qui dove il nostro codice potenzialmente esplode perché o runtime type di o non è nulla giustamente non è fatto che o è nullo non possiamo chiamare questo oggetto qua per cui a questa chiamata qui ci aspettiamo che tutto vada a esplodere non l'ho fatto perché è molto simpatico da per fortuna perché ci dà che il tipo è null e il valore è null quindi ci protegge da noi stessi in questo modo però in genere il compiutore avrebbe dovuto avvertirci se avessimo chiamato che magari possiamo fare mi sa che anche anche il hash non riesco non riesco a farvelo esplodere su richiesta comunque questo oggetto è potenzialmente null noi lo sappiamo e anche il compilatore lo sa quindi se noi andiamo a fare delle operazioni potenzialmente pericolose questo ci ah ecco l'esempio potrebbe essere questo iterable nullabile ecco se io lo casto a iterable nullabile quindi è un oggetto iterabile ma potenzialmente nullo in questo caso chiamare join non è possibile perché in questo caso l'oggetto o che è iterabile oppure null quindi è o un oggetto iterabile oppure null non posso chiamarci join perché se è null chiaramente non posso gioinare alcunché per cui in questo caso il compilatore vi dà un errore di sintattico e vi dice guarda non posso fare questa chiamare questa join perché l'oggetto su cui stai chiamando potenzialmente potrebbe essere nullo e chiaramente posso ulteriormente specificare qui che non voglio evitare che sia nullo quindi se è un iterabile o un null se non è null chiamo join quindi posso andare a nidare ulteriormente in questo caso il compilatore sa che in riga 41 in questi due blocchi qua il valore di o è iterabile nullabile non è null sicuramente quindi è un iterabile e quindi join è legale chiamarlo il compilatore è molto furbo in questo caso perché staticamente riesce a determinare il tipo di un oggetto e garantirvi che quella join lì sarà sempre valida perché sarà un oggetto valido quindi la null safety è stata una cosa giunta in corsa dal linguaggio d'art ed è una cosa molto utile perché vi protegge in moltissimi scenari cosa devo dire su questo tutto può essere nullabile quindi in realtà anche gli interi per esempio possono essere nullabili quindi questo int qui potrebbe essere un intero nullabile va benissimo significa soltanto che posso metterlo a null cosa che altrimenti sarebbe illegale quindi a questo punto si può fare e così qua quindi object nullabile è il tipo forse il tipo più generico che si possa spiegare quindi è un oggetto e quindi già è il tipo base che vale per tutti ed è un altro tutto è anche nullabile quindi può essere nullo in realtà c'è un ulteriore sistema ancora più labile che vi ho accennato ieri che è dynamic perché noi possiamo definire anche un oggetto come dinamico ok vedete che qui in realtà non cambia molto quindi questo codice qui rimane rimane comunque legale questo codice qui rimane funzionale e se lo risolviamo funziona senza problema dynamic infatti equivale sulla carta a object nullabile quindi più o meno stiamo parlando della stessa cosa a livello concettuale non cambia moltissimo dynamic è solo un modo per dire al compilatore guarda su o fai finta che non c'è nessun tipo proprio ignora qualsiasi cosa accetta qualsiasi cosa io scriva perché so quello che sto facendo questa è un po' l'idea quindi dynamic disabilita il type checking sull'oggetto o fine quindi a questo punto o quando voi fate qui o puntato vi dà gli oggetti di base di object però in realtà non tutti vedete quindi vedete quelli fondamentali che sono sicuramente tutti gli oggetti anche per null e basta perché a questo punto il compilatore non ha idea di cosa gli state passate potrebbe essere veramente qualsiasi cosa quindi a questo punto il compilatore non sa cosa fare e non vi dà aiuto però potete scrivere qualsiasi cosa io posso scrivere qui ciao e questo è legale non dà errore perché evidentemente c'è un metro ciao su questo oggetto qui è ovvio che quando lo eseguo poi ciao esplode perché non assiste stavolta ne aspetto che esplode ok a questo punto ho un'eccezione perché ciao non era implementato sul metro però il compilatore lo prende per buono e dice vabbè fai come preferisci sì sì ci dà vantaggi a tempo di compilazione perché diciamo al compilatore guarda non darmi fastidio con i tuoi errorini qua e là perché prendi per buono quello che sto facendo e va bene così questo l'unico scenario in cui è veramente utile questo è quando andiamo a fare il parsing di dati che daremo cioè da da un file da qualcosa di esterno per esempio quando andiamo a recuperare i dati tramite HTTP nelle nostre applicazioni che andremo a implementare quando scarichiamo dei dati da remoto capita spesso che questi dati hanno una forma arbitraria che può essere qualsiasi cosa quando andiamo a interpretarla in Dart va castata in qualcosa che sia leggibile lì spesso si usa Deremic per dire so che formato hanno quei dati lasciami fare quello che voglio senza che io debba castare tutto con estrema fatica ai dati ai tipi secondo Deremic io dico sarà così per forza se a quel punto esplode è colpa mia perché mi ha dato male il caricamento dei dati ok quindi questa cosa qui la lasciamo qua questo ciao qui è legale però prego in questo caso abbiamo un progetto alternato che è un problema commerciale c'è un modo per il try di try catch di down sì c'è il try catch che si può sì sì c'è il try catch adesso lo vediamo tra un secondo con un altro esempio però si può try catch tutto qua quindi si può fare try anzi non ho provato mi piace per niente com'è ah beh sì mi piace ma c'è di piano non deve facciare nulla in realtà non lo stampiamo ah possiamo stampare l'ex così ok a questo punto dovremmo vedere cioè l'occezione è questa qui no such method error e quindi vabbè ok sono più chiamate sullo stesso o di oltre che sono print detail giustamente esplode e quindi possiamo fare try catch della chiamata questo non è un problema e quindi il runtime esploderà però lo possiamo gestire tra l'altro appunto se usiamo dynamic per caricare i dati chiaramente ha molto senso farlo dentro un grosso try catch che ci protegge dal caso in cui magari i dati cambiano e quel tipo di accesso che facciamo non è più valido ok benissimo e a questo punto direi che è ora di implementare una classe tutta nostra perché abbiamo visto per le salse il type system vediamo come fare una classe nostra per farlo e allora le classi possiamo implementarle sia nel nella funzione nel file stesso o più comunemente dentro libro quindi le mettiamo qui dentro c'è la nostra libreria di classi andiamo a creare qui un nostro point point punto data andiamo a creare una classe che è un punto geometrico geografico su x e y in sostanza niente di niente di praticamente astruso però ci permette di vedere i mille modi che abbiamo per creare degli oggetti con vari costruzioni allora la sintassi per creare le classi è è abbastanza classica quindi letteralmente quindi class nome della classe per standard di sintassi le classi hanno sempre la maiuscola la prima lettera maiuscola in genere a differenza delle variabili e dei metodi che in genere hanno la minuscola come iniziale un punto che è composto da due campi interni che sono x e y ok quindi facciamo x e y ok e a questo punto ci aspettiamo che ci possa essere un un costruttore che va a preparare questo è codice non corretto che mi sta scrivendo delle cose che non sono corrette è corretto nel senso che ci dà proprio errore di di compilazione perché perché in darts le cose funzionano in maniera un pochino diversa rispetto a quelle che siamo abituati a da c++ e csh questo è tutto ragionevole fin qui ma il costruttore non va bene perché ci dice che il campo non nullo x e y che sono due interi non nulla vol se volessi se fossero nulla vol sarebbe proprio questi sono dei campi che sono anche nulli in questa cosa x e y sono dei campi non nulli che devono avere per forza un valore quando vengono istanziati dart è un po' particolare perché il codice che viene eseguito nel corpo del costruttore è come se fosse codice che viene eseguito dopo la costruzione dell'oggetto questo sembra una cosa assurda ma è vero purtroppo penso che in effetti anche in c sharp anche in javascript anche in javascript non è costruttore o ha delle cose fasulle che sono dei costruttori java e così via effettivamente è così il codice del costruttore viene eseguito dopo che l'oggetto è stato costruito cioè l'oggetto viene costruito in memoria quindi in memoria viene allocato un blocco di memoria per l'istanza di point il compilatore fa le varie operazioni di preparazione dell'istanza point a quel punto esegue il vostro corpo del costruttore ma il costruttore può fare cose arbitrarie chiaramente ma non è detto che valorizzi tutti i campi della vostra classe quindi può tranquillamente non assegnare nulla x o non assegnare nulla y e noi non sapremo mai se esegui nella sua interezza perché qui il costruttore come sapete non possiamo fare qualsiasi cosa possiamo fare operazioni illegali a livello aritmetico e il costruttore in teoria non può proteggerci da questo giusto possiamo fare accessi alla rete possiamo fare http get possiamo fare cose sulla carta astrusa perché dentro il costruttore è codice libero quindi può fare quello che vuole da questo punto di vista quindi Dart ha perfettamente ragione e non può permetterci di inizializzare i campi della classe nel campo del corpo del costruttore perché c'è il rischio che noi si faccia delle porcherie e quindi a quel punto la classe sebbene sia stata costruita ha dei valori che non sono legali perché x e y non hanno nessun valore per cui Dart vi impedisce di fare questa cosa qui che lo blocca proprio e vi obbliga a usare una cosa che esiste in pochi linguaggi e viene dal c++ cioè usare la lista di inizializzazione delle variabili che è una sintassi un pochino astrusa che dopo i due punti vi da vi permette di esprimere una lista di valori di espressioni a cui da assegnare ai campi della classe quindi in questo caso noi cosa facciamo facciamo this x uguale a x this y ops non so scrivere punto più questo è legale perché a questo punto questo non è codice libero qui non stiamo seguendo cose che a noi ci piacciono quindi non facciamo accessi all'http non facciamo accessi ai file non facciamo cose che possono lanciare eccezioni siamo semplicemente assegnando i valori ai campi della classe e a questo punto Dart può dirci ok quando costruisco il punto io sono sicuro che appena dopo averlo costruito tu stai assegnando i valori a tutti i campi se tra l'altro se non lo faccio quindi se mi perdo per strada la y Dart non si lagna perché Dart vuole che assegni anche la y ovviamente quindi qui mi dice che costruire point non va bene perché y non ha un valore ok quindi ci obbliga ad assegnare un valore a tutti i campi così che così che quando il punto è stato costruito quando la memoria è un punto sappiamo che x e y hanno un valore che non è nullo ok quindi questa questa è l'idea della della lista di iniziatazione dei campi di Dart è un po' astruzzo però questa cosa esiste già in C++ se volete se avete coraggio di usare C++ si può fare in C++ si può fare entrambe le cose che si può fare un linguaggio un po' più liberale sia usare il corpo che si fa di solito o usare la distruttazione dei campi poi altri linguaggi successivi l'hanno dimenticato per strada quindi si sharp e java non hanno questa funzione se l'hanno per come si fa la distruttazione ah sì ok sì giusto possiamo fare base di qualcosa quello si può fare si può creare si può chiamare il costruttore la classe base sì quello è vero però non si può inizializzare i campi con in quel modo questo è giusto però sì ha ragione per cui questo si può fare anche in Dart se avessimo derivato da una classe possiamo fare super si chiama qui come in Java e però ecco stessa cosa in questa cosa però possiamo inizializzare i campi in più in realtà visto che a Dart cioè chi scrive Dart piace perdere poco tempo per scrivere le scrivere il codice questa cosa qui può essere ulteriormente resa più elegante perché possiamo scriverlo direttamente nella lista dei parametri quindi tutta questa cosa qui possiamo scartare questa lista inizializzazione così e scrivere direttamente this x e this y questo in automatico è tutto è solo zucchero sintattico piace scrivere in questa maniera quindi è semplicemente il compilatore che ci dice guarda i due parametri del costitore point sono x e y e sono degli interi perché sto auto assegnando subito x e y ok quindi questo è equivalente a quella cosa di prima questo è identico a questo una volta compilato quindi point semplicemente quando lo costruisco di là nel codice che richiama point semplicemente va a inizializzare x e y con degli interi necessariamente ok poi vedremo altri costruttori ancora più astrusi di questo ma per ora ci accontentiamo perché andiamo a creare un oggetto a questo punto però per crearlo prima ci serve anche poterlo stampare per cui come spesso capita vediamo se qui ci aiuta un attimo il studio code perché qui in alcuni casi no non ci vedo per niente no va bene grazie lo stesso allora facciamo l'override di toString così che poi possiamo stampare il punto questa idea quindi toString è specificato in questa maniera ci veniva un aiuto in qualche modo no non l'ha dimenticato niente toString quindi questo questo sovrascrive il toString di object ok e ritorniamo x e y tra parentesi tonde no come si esprime di solito quindi x virgola e y in questa maniera va bene ok stampo toString va benissimo così questa è una delle cose più strane di di Dart quando facciamo l'override di un membro di una classe derivata dobbiamo annotarlo con questa cosa che viene direttamente da Java con questo con questo con questa chiocciola override e marchiamo il metodo come un override della toString quindi in questo caso in questa maniera esplicitiamo il fatto che se qualcuno chiama toString sull'oggetto base su object invoca in realtà toString della nostra classe quindi point chiaramente deriva anche se non è esplicito deriva ovviamente da object come tutti gli oggetti come se facesse così ma lo fa in maniera implicita non serve dirglielo e quindi toString copre l'implementazione del toString di base come e in C Sharp invece l'override è proprio una keyword del metro quindi è così in questo caso invece è una una marcatura del metro che poi ci si perde a tempo di compilazione ok andiamo di qua perché a questo punto vogliamo utilizzare il punto quindi dopo tutta questa queste belle cose qui magari possiamo commentare questa roba per farla ancora più semplice quindi andiamo a creare un punto ah no forse non posso farlo ok point no 10 e 20 ok poi chiaramente non lo vedi ancora perché non è stato importato e tutto l'importazione funziona a file quindi bisogna importare la libreria quindi con control punto su Vista Studio vi dà i suggerimenti vedete che point in realtà esiste in varie purtroppo point è una classe abbastanza comune quindi la vediamo in varie librerie che già Vista Studio vi suggerisce adesso non importate quella sbagliata importate quella nostra quindi importiamo il package hello world che è il nostro pacchetto e poi il file poi in punto da questo include tutto il file a questo punto P è una variabile potrebbe essere troppi un file quindi è un effettamento uguale e poi stampiamo il dettaglio di possiamo ritenire questa cosa e se tutto torna ci dovrebbe tornare un oggetto che poi stampa 10 e 20 esatto quindi abbiamo un punto quindi è un tipo non previsto 10 e 20 ecco questa cosa del ciao la commento si stampa tante cose poco utili ok abbiamo creato il nostro oggetto point allora magari ci piacerebbe avere più costruttori per costruire il punto in vari altri modi potremmo avere un costruttore che ci dà il punto origine per esempio il punto 00 un costruttore per darci un punto che ha solo un valore y non ha solo un valore x e così via non è che sia un caso di uso particolarmente intelligente però immaginate che ci possa essere utile avere più modi per specificare i punti questa cosa si può fare però un'altra stranezza di dart è che c'è soltanto è possibile fare un costruttore senza un costruttore di default in altri linguaggi c'è una distinzione tra il costruttore di default che è il costruttore senza parametri il costruttore questo che non ha parametri e gli altri costruttori che invece hanno i parametri e la scelta di quale è il costruttore che si utilizza avere tramite i classici la selezione dell'override più corretto quello che match ai tipi che andiamo a passare questo in dart non funziona perché in dart il method match in una maniera un po' diversa quindi non c'è questa distinzione in base ai tipi che passiamo ma bisogna dare dei nomi ai costruttori quindi c'è questa cosa un pochino strana un pochino arcana per cui i costruttori in dart possono essere o il costruttore di default che non ha un nome che è questo in questo momento è questo costruttore qua che ha soltanto il nome del point quindi il nome della classe oppure altri costruttori che invece hanno un nome specifico come si traduce in codice questa cosa qui per esempio se vogliamo esprimere un punto verticale un punto che ha soltanto la y come valore si scrive in questa maniera quindi poi nome della classe punto nome del costruttore tutto il lowercase perché è come se fosse un metodo e a questo punto questo costruttore qui può avere altri parametri può funzionare in maniera diversa in questo caso magari non ci serve la y dell'asse verticale a questo punto andiamo a inizializzare il punto in che modo mettendo x a 0 e y anzi x y se no poi non si capisce qual è e y a y tra l'altro questo vi suggerisce che non è proprio bellissimo per cui si potrà direttamente fare x punto y come nell'altro costruttore prego si anche quello si può fare adesso non abbiamo ancora visto i metodi del default però si può fare anche così oppure si può fare così ci sono mille modi per fare i costruttori questo è uno in questo caso appunto stiamo defaultando l'x a 0 in questo caso un'altra cosa si può fare è per esempio avere ribattezzare questo in chords magari e fare in modo che quello di default abbia dei valori che sono 0 magari questo può avere senso insomma ci sono vari modi per implementare delle cose molto simili e a vostro giudizio chiaramente come fare queste cose un costruttore può anche invocare il costruttore di base dall'altro o altri costruttori per esempio se facessi questo dovrebbe essere possibile fare cioè posso invocare un altro costruttore da un altro costruttore quindi posso fare questo posso farlo così? però in realtà devo rilasci da solo non voglio dire niente però posso sicuramente chiamare quello di base si forse forse forse ah è così ah ovviamente non lo posso fare perché il punto è zero potrei fare questo che però non è molto sensato potrei cambiare tutto posso cambiare il costruito di base con this però il costruito di base non ha parametri quindi in questo caso non è l'effetto che voglio ottenere quindi non lo faccio però si può ridirgli tutto il costruito di base se questo ha senso nel nostro caso in questo caso in realtà non ce l'ha e quindi la x la mettiamo a zero ok va bene e non ce l'accetta non mi ricordo la sintasa esatta perché prima dava errore ma la stessa volta l'ho accetta c'è tantissimo se lo integro a questo punto ah ok quindi era solo il infatti sembrava il il intelligence che si barellava ok in questa maniera qui siamo ridirigendo un costruttore all'altro se ha senso così magari se un costruttore fa inizializza i valori e poi fa qualcosa questo non l'abbiamo fatto ancora ma qui chiaramente possiamo avere un corpo del costruttore che fa delle operazioni queste qui vengono fatte appena dopo il punto di essere costruito quindi è subito dopo la costruzione quindi viene fatto qualcosa di inizializzazione in questo caso vertical sta delegando a cords queste operazioni di preparazione in qualche modo dei dati nel sull'altro lato come funziona questa come si creano questi oggetti allora a questo punto vedete che vi dà errore il il costruttore perché il costruttore di senza nome il costruttore di volt è quello che non prende parametri quindi questa cosa non è più legale bisogna fare per forza così ok quindi questo qui è point e basta se vogliamo fare un punto preciso bisogna fare point punto e poi o cords o vertical in base a quello che ci interessa e verticalmente prende soltanto l'asse delle y mentre se creiamo un altro punto aiuto e qui sarà 15 principiare frecciandomi clamorosamente con le parentesi ok quindi dall'altro lato andiamo a invocare nominalmente il costruttore per quello che vogliamo questo è questa è una cosa che in Flutter si usa tantissimo perché in Flutter poi i vari widget che andiamo a utilizzare hanno tutti dei costruttori diversi in base a quello che ci serve quindi ci saranno vari modi per costruire lo stesso oggetto in base a quello che ci interessa ok questo è un esempio giusto al volo per darvi un altro esempio di questo anche nel per esempio le liste di che ne so vedete che list punto anche list ha una serie di costruttori specifici di list di base crea una lista vuota però possiamo creare esplicitamente una lista empty di qualcosa possiamo creare una lista piena di qualcosa che ci permette di esprimere come riempita possiamo generare un array di elementi con una funzione che li genera possiamo creare una lista non modificabile e così via quindi ci sono vari costruttori diversi che hanno effetti radicalmente diversi e poi avremo otterremo una lista che è sempre un oggetto di tipo lista però internamente sarà o pieno o vuoto o bloccato o così via quindi questa si usa in varie occasioni ok ora un altro cioè un problema potenziale della nostra classe magari è voluto magari no però i campi quindi x e y sono accessibili da fuori cioè io posso da fuori nel codice client che usa la classe posso tranquillamente prendere la x e cambiarla a un valore qualsiasi e quel valore viene modificato quindi da fuori io ho accesso diretto ai campi intimi di point quindi in genere quando la programmazione oggetti prevede che in genere le classi non permettono di accedere ai campi interni perché devono fare il capsulamento proteggetato e così via come si fa in dart appunto non ci sono grandi primitivi per farlo se non di mascherare di nascondere il campo a livello di file quindi va fatto va messo l'underscore davanti al campo se vogliamo renderlo privato non è privato la classe ma è semplicemente non visibile al di fuori del file è un senso importante quindi qui possiamo fare underscore x underscore y ok quindi chiaramente bisogna cambiare il nome per le variabili sotto ovviamente così così così così così e anche qui nella stampa ok quindi siamo come prima non è chiamato nulla l'altro pratico di là questo accesso qui alla x è illegale ok quindi questo setter qui non esiste e quindi il tempo di compilazione ci darà errore perché non possiamo andare a modificare la x in realtà cioè la x non esiste proprio in realtà quindi più che modificarla non esiste più perché c'è l'underscore x che però non è visibile quindi questa cosa qui questo accesso qui non è possibile farlo underscore x come siamo abituati a da javas sharp derivati chiaramente è possibile esprimere dei così di getter e setter sui campi privati per cui possiamo esprimere dei aggiungere dei metodi che permettono di modificare o leggere un campo che non è visibile al di fuori come si fa? la sintassi è abbastanza semplice è un è un è una proprietà quindi è un campo barra metodo tra virgolette che viene espresso in questa maniera int get se è il getter nome del campo e poi il codice che ci permette di accedere al campo questo è il getter della x chiaramente qui il codice può essere più o meno sofisticato quindi adesso sto tornando alla x quindi è una copia del valore però potrebbe essere fare le operazioni più complesse e possiamo fare anche il setter chiaramente quindi il setter è uguale il setter è di tipo void quindi non ha tipo di ritorno adesso il void può essere ignorato quindi non lo mettiamo quindi è set x e come unico parametro avrà il valore quindi value deve essere intero chiaramente perché x è di tipo intero e quindi possiamo fare x uguale value ok? non ho fatto altro che mascherare la x a questo punto fuori risulta che c'è una x che possiamo leggere e scrivere quindi questa operazione qui diventa valida quindi su p ho una x che ha sia getter che setter quindi possiamo sia leggere la x px questo è veramente da questa si confonde ok? quindi questo fa l'operazione int get x quindi quello è chiamato il getter qui dunque quando c'è un assegnamento invece questo è il setter quindi il set x a value la sintassi è un po' diversa rispetto a quella di C sharp derivati però è la stessa esatta cosa tra l'altro possiamo anche fare un getter che non c'è nulla con la x per esempio non so qualcosa che mi interessa quindi è una distanza facciamo che sia un double questo magari ok e quindi la distanza d'origine sarebbe la x la seconda la la la la la la la la la la la la la la la la la la la quindi perdonate eventuali errori è così giusto tra vero ho finta che sia vero ok qui ho usato la sintassi alternativa alla sintassi funzionale no quindi si si si vuole scrivere questo non so perché ho perso anche gli operatori più corretto o più corretto doveva essere qui voglio non non voglio non non voglio dire quanto sia ignorante più geometrico facciamo finta che sia corretto non ci importa però il codice è corretto quindi non ci interessa però in teoria è questa e questa è la sintassi quella corta ma ci venite a esprimere la stessa cosa qui potremmo fare anche per questa x qui visto che non fatto che tornare un valore potremmo fare direttamente così se volessimo essere più stringati però non cambia molto e tra l'altro se per esempio non vogliamo che che ne so che il valore sia minore di zero perché devono essere i valori positivi possiamo anche qui dentro verificare che no se il valore è minore di zero allora impostiamo x a zero magari o diamo o diamo in eccezione non so adesso dipende un po' dal nostro scenario quindi in questo caso il punto non può essere messo no in valori negativi in questo caso ok e da fuori ovviamente si comporta esattamente con un get normale quindi qui avremo distance from origin che è una proprietà e possiamo leggerla in maniera diretta ok e quindi ho messo che questo sia vero facciamo filtri sì va bene così ok ora a questo punto vi faccio vedere l'ultima ah no un'altra cosa questa è stata dall'origine chiaramente però possiamo anche esprimere la distanza tra due oggetti tra due punti magari no tra punto e punto per cui facciamo così double distance from gli passiamo un punto other non so come chiamarlo e in questo caso noi stiamo passando un'altra istanza di punto alla nostra istanza di punto per cui a questo punto abbiamo due punti this non a parte che è la nostra istanza del corpo della funzione che siamo e other che è l'altro punto quindi in questo in questo campo qui in questo in questo in questo blocco di codici qui possiamo fare la distanza tra due punti che è eh sì visto sì qui ci dice che il peso non serve a niente ha ragione anche lui va bene e poi fine l'y che invece ha meno y ora qui notate che allora qui io posso usare l'arrore però possiamo usare qui l'underscore y abbiamo accesso a questi campi qui perché siamo nello stesso file quindi perché qui è lo stesso file quindi tutto tutto quello che contiene l'underscore in realtà a noi è visibile quindi tranquillamente possiamo utilizzare accedere a questi campi qui non possiamo accedere perché il campo è privato quindi la nozione di privato non esiste in alcun modo se noi separiamo cioè splittiamo su due file diversi questa questa funzione qui per qualsiasi motivo sull'altro file quella quella underscore x underscore y non si può vedere ok quindi non c'è c'è non la classe non può nascondere i suoi campi in maniera arbitraria possiamo nascondere solo a livello di file quindi se la la classe la mettessimo fuori potremmo comunque parare esatto esatto infatti se facciamo una classe statica tra virgolette che è fuori dalla classe che chiameremo distance between magari a e poi b qui chiaramente per far prima la potremmo implementare come a distance from no distance from b e faremo prima ovviamente però questo è troppo facile e quindi se vogliamo fare la stessa cosa possiamo fare va final di x che è a x meno b x e in c sharp questa cosa non sarebbe legale perché qui dietro non abbiamo accesso ai campi privati della classe ok questo si potrebbe fare soltanto se questa è un'altra cosa se potremmo fare anche quello facciamo questa cosa imparata come si fa questa cosa questo dovrebbe essere corretto quindi in questo modo qui abbiamo accesso tutti i campi privati della classe perché siamo nella stessa classe qui possiamo farlo comunque perché ovviamente siamo nella classe stessa quindi sarebbe strano se questo non avvenisse però qui abbiamo accesso non perché siamo nella classe ma perché siamo nel stesso file quindi questa è importante distinguerlo in più potremmo anche fare una classe statica nella classe stessa questo non so quanto abbia senso ma possiamo fare anche questo è double static ok così ci mettiamo la solida adesso vediamo la allora la distance from è un metodo distanza quindi un metodo su un'istanza di punto abbiamo un punto e chiamiamo il metodo distance from e da fuori che aspetto da questa cosa a questo aspetto distanza tra punti e la chiamo facendo cos'è p distance from beh l'altro punto quindi è un metodo distanza perché io ho un'istanza p e sull'istanza sto chiamando distance from e passo il secondo punto quindi è un prevede che ci sia un'istanza di partenza che è quella che è come se qui avessi un test no è come se è come se avessi ok distance between questo qui è un metodo statico un metodo statico significa che è un metodo della classe ma che non prevede il test quindi non va invocato su un oggetto ma va invocato in generale sulla classe perché è un metodo che vale per così su tutta la classe quindi come si invoca quello si invoca con point distance between quindi diciamo così è visibile esattamente come i costruttori perché non prevede che ci sia che esista già un'istanza ma viene fatta su due punti quindi è vert e p in questo caso ok mentre l'altro oggetto ancora che è questa funzione qui distance between questo è un metodo globale del file ed è un terzo modo per scrivere la stessa identica cosa quindi questo qui lo chiamiamo invece con distance between direttamente senza punto ma si comporta la stessa maniera ok questo è visibile qui perché abbiamo importato tutto il file point quindi abbiamo importato tutto il file point quindi in tutto il nostro file qui hello world punto dart abbiamo accesso tutti i dati e i dati tutti i contenuti del file point tra cui anche il metodo ok che non richiede nessun point perché effettivamente è una classe è una classe è un metodo così di primo ordine di primo livello e quindi visibile direttamente dato che io ho usato la radice quadrata sqrt questa me l'ha importata in automatico il servizio studio ma vedete che ha aggiunto import art math che è la libreria matematica che contiene le varie cose floor square eccetera questo metodo qui è dentro la libreria dark math ed è un un metodo di primo ordine quindi è di primo livello quando importate dark math vi importate tutti questi tutti questi oggetti qui che diventano visibili al livello del vostro file quindi è come se nel vostro file compagli è come se comparissero c'è già il punto quindi in realtà stiamo già confondendo un po' le cose però c'è la la e c'è vari logaritmi ci sono cos'altro c'è min max e così via quindi c'è varie operazioni che sono utilizzabili direttamente come delle funzioni di primo livello come se fossero direttamente nel vostro file ok questo dovrebbe essere più o meno chiaro spero a questo punto facciamo l'ultimo mistero da da da vedere è l'uguaglianza tra oggetti perché vi ho detto che un oggetto no la classe object che è la classe fondamentale di ogni istanza in sostanza implementa cioè espone to string hash code runtime type che vi dà accesso al tipo runtime e poi espone anche l'operatore d'uguaglianza l'operatore d'uguaglianza se riusciamo a vederlo un attimo a questo aspetto qui ce la farà in csharp forse l'avete già visto e si chiama equals e non lo carica in questo momento non è importante vabbè comunque si si scrive in questa maniera qui perché l'uguaglianza si fa con l'operatore uguale uguale quindi facciamo l'override non tanto di un metro che si chiama equals qualcosa ma facciamo l'override dell'operatore direttamente uguale uguale quindi si fa esattamente l'operatore ritorna booleano quindi l'operatore d'uguaglianza ritorna un true o false è un operator uguale uguale e come parametro ha l'altro operando quindi l'altro oggetto che chiaramente è di tipo object ok anche questo è un override quindi va marcato con override esattamente come il toString sopra questo lo vediamo dopo adesso ci da ancora un warning ma lo facciamo per un secondo qui dentro andiamo a verificare se l'oggetto è effettivamente identico a un altro oggetto cosa serve questa cosa qui serve se il nostro oggetto deve implementare in qualche modo una uguaglianza più sofisticata di quella di di base ma prima di andare avanti lo commento un attimo per far vedere l'effetto di questa cosa perché immagiamo di essere qui di fare tutte queste belle cose facciamo facciamo due nuovi punti identichiamo il resto separatore allora chiamo un punto che è il nostro più uno e sarà un punto con coordinate zero e dieci e poi crea un punto due che è point vertical dieci ok quindi sono due punti entrambi entrambi sono alla coordinata x zero y dieci quindi se io stampo questa cosa qui mi aspetto che siano identici cioè identici a livello di coordinate ok qui sono all'atto pratico sono uguali però se io vado a verificare più uno uguale più due sì o no faccio più uno uguale uguale più due dentro le graffe questa cosa qui mi tornerà false ok quindi più uno non è uguale più due perché perché secondo dart sono due oggetti diversi in effetti ha ragione sono due oggetti uno e più uno l'altro è più due sono due istanze separate di point quindi non possono essere uguali quello che fa internamente quando l'operatore uguale uguale non è overrideato quindi non è stato reimplementato come? controlla sì controlla che l'istanza sia la stessa quindi e lo fa anche anche se sharp e l'altra di base fa esattamente la stessa cosa il metodo che fa questa verifica internamente si chiama identical quindi questo metodo qui che è che è un metodo di base del runtime di Dart permette di verificare se due oggetti sono identici vedete che è un metodo che prende due object nullabili come input a e b e vi ritornate un soltanto se sono la stessa istanza quindi se proprio puntano sono due puntatori e lo stesso blocco di memoria quindi qui posso fare più uno identico più due e qui chiamerò identical più più due e chiaramente a questo punto questo tornerà false esattamente come l'altro perché non può essere diverso ok entrambi va bene a questo punto se noi overrideiamo l'uguaglianza possiamo rendere più cioè semanticamente più corretta l'uguaglianza perché noi vogliamo che i punti siano uguali se puntano al stesso punto concettuale geometrico quindi in questo caso come facciamo allora di base possiamo fare con lo stesso il matching del tipo perché qui abbiamo un object può essere qualsiasi cosa perché chiaramente al runtime possiamo fare l'uguaglianza con qualsiasi cosa quindi possiamo fare anche questo quindi p1 uguale 1 per dire questo è sempre false ovviamente mi auguro ok qui sto verificando che p1 è uguale al a me questo dato ci dà ci dà ci dà che sono cioè ci dà un warning al senso che dice il nutre che fa questa verifica non tornerà mai non tornerà mai true però questo tornerà sempre soltanto a false quindi qui dentro possiamo fare il type matching in sostanza del tipo quindi if o is point quindi se è del nostro tipo che riconosciamo a questo punto possiamo andare a leggere i campi di o perché sappiamo che è un punto e quindi quando è che i punti sono uguali quando underscore x è uguale a o x and y uguale uguale o di underscore x qui possiamo leggere underscore x e underscore y di o che è un oggetto punto perché siamo sempre al stesso file ok se non è un punto che cosa sarà necessariamente false perché non ha senso confrontarlo con altri tipi che sono stringhe interi double altre classiche in realtà se volessimo essere estremamente liberali qui potremmo anche fare il match della stringa per esempio e verificare che la stringa se volessimo fare le cose molto complicate potremmo andare a fare il parsing della stringa a vedere se esprime lo stesso punto ma è un po' troppo sfisticato forse per il nostro caso tutto ok quindi in questo caso qui dovremmo poter eseguire e a questo punto mi aspetto che uguale più 1 uguale più 2 sia true a questo punto quindi ok più 1 uguale 1 è false ovviamente più 1 uguale più 2 è true perché quello ha chiamato l'operatore overrideato nostro e ha verificato che sono equivalenti ma sono ugualmente l'identità non è la stessa perché sono due istanze diverse di nonostante punti non hanno lo stesso la stessa coordinata tra l'altro qui nell'operatore spesso per convenzione si fa prima una verifica di identical cioè if identical this e o allora sono sicuro che sono lo stesso oggetto cioè per far prima per non dovere se l'oggetto è praticamente complesso e non vogliamo perdere tempo a verificare l'uguaglianza effettiva se identical tornato vuol dire che è lo stesso puntatore quindi è inutile andare a vedere i dettagli posso fare il ritorno subito e tornare a true perché necessariamente saranno la stessa cosa mi piace ah il nome non è o ma è other vediamo se riusciamo a fare la ci è inutile qui per per convenzione qui il nome è other perché la classe base object prevede che si chiami other e non o quindi per carineria sarebbe bello chiamarlo la stessa maniera ma cioè è uguale perché poi il nome del parametro chiaramente non viene propagato quindi alla fine è solo tanto bene ok ci siamo quindi questo torna e funziona a questo punto tanto se modifichiamo il punto possiamo anche fare questa prova qui se p2 lo spostiamo quindi la x la mettiamo a 100 questo possiamo farlo perché il valore è modificabile da x cioè il setter visto quindi a questo punto la seconda esecuzione sarà prima sarà true e poi sarà false quindi qui l'uguale è true e poi l'uguale è false e a questo punto chiaramente i due valori sono diversi e non tornano più ok ultimissima cosa su questo qui vi da un warning sul fatto che abbiamo variato l'operatore d'uguaglianza e ci dice guarda dovresti vorrei dare anche hash code per coerenza questo perché perché se gli oggetti sono uguali cioè se gli oggetti sono uguali devono tornare anche lo stesso hash code per convenzione questo perché in alcuni casi quando usiamo cioè se volessimo usare il point come chiave in una mappa cosa che potremmo anche fare se facciamo una mappa di point e string magari non so abbiamo una mappa di punti a cui associamo un'etichetta sento questo è un oggetto che possiamo esprimere attenzione però perché qui la mappa usa point come chiave quindi per poter andare a vedere se a quel punto è già stato impostato o meno nella mappa quindi perché quando andiamo a fare un assegnamento sulla mappa andiamo a fare questo alla fine quindi possiamo fare questa cosa che è un po' e qui ci siamo punto uno va bene magari va allocato e mappa può essere quello che fa che passa beh cosa non ho capito non è il nome della class qui in caso è mappa è uguale mappa non vuole point di la mappa è con me grazie aperta e chiusa stai dicendo qualcosa con la schiaffa aperta e chiusa si ah si si ok ci sono grazie grazie mille alla chat grazie giusto ok quindi dovevo iniziare la mappa vuota veramente giustissimo e quindi questo sto usando il point come chiave e quindi il nostro dart usurà point per indicizzare gli oggetti per cui mi aspetto che dopo questa operazione qui la mappa contenga sempre soltanto un punto giusto perché ho assegnato alla coordinata 10 10 il valore di chiave e voglio che sia univoca e in teoria questo internamente la mappa lo fa usando l'operatore d'uguaglianza quindi va a vedere se nella mappa c'è già un punto uguale a quello e quindi riassegna la stringa allo stesso punto ok però per efficienza internamente la mappa viene implementata come una mappa con con i vari bucket di hashing quindi è una hash map internamente per ragioni di efficienza e quindi se non sovrascriviamo anche hash code qui c'è il rischio che questa cosa qui non funzioni cioè che vengono immessi due oggetti uguali perché la mappa ignora che siano uguali perché la condizione di fare l'operatore d'uguaglianza è che se un oggetto è uguale a un altro oggetto devono ristrutturare lo stesso intero dal metro hash code ok questo lo trovate in tutti gli altri linguaggi anche per cui adesso non lo implementiamo perché non ci interessa però adesso sono tutti uguali per forza quindi questo non è di nuovo non è legale però potremmo farlo dipendere dalla x e dalla y per esempio in questa maniera qui siamo sicuri che se un punto è uguale ad un altro punto quindi hanno x e y uguali risolvono lo stesso hash code perché è x per y non è un hash code proprio geniale perché non è non è uniforme non è equidistribuito eccetera eccetera però può andar bene quindi la condizione importante è che se implementate questo dovete assicurarvi che il hash code ritorni lo stesso intero se gli oggetti sono effettivamente uguali questa è la prima cosa se sono diversi è meglio se ritornano hash code diversi ma possono ritornare hash code diversi ma cioè non necessariamente devono essere diversi se l'oggetto non è uguale detto bene sì ok a questo punto passiamo sull'ultimo campo importante per per dart che sono gli oggetti immutabili perché abbiamo visto questo è un oggetto una classe abbastanza abbastanza classica appunto in cui possiamo andare a creare degli oggetti dei punti poi possiamo anche modificarli andando a fare l'assegnamento tramite i setter che abbiamo definito qui questo va benissimo nella maggior parte dei casi però in in flutter in pratica spesso conviene che i nostri oggetti siano immutabili per evitare problemi a runtime che cosa significa questa cosa qui che se noi ragioniamo in termini immutabili cioè che se allogliamo una classe non la modifichiamo più da da quel momento in poi quando è stata costruita special se lavoriamo con l'interfaccia utente dove gli oggetti vengono passati in giro per l'interfaccia utente se ci assicuriamo che gli oggetti non vengono modificati in runtime in maniera imprevedibile ci ci preveniamo un sacco di grattacapi inutili perché una volta che un oggetto ci arriva sappiamo che quello oggetto rimarrà per sempre immutabile e rimarrà con quei valori lì e quei valori non possono essere modificati così improvvisamente sotto le nostre mani in sostanza e questo ci impedisce di fare gli errori poi a runtime durante la costruzione della nostra interfaccia utente poi vedremo quando lavoreremo con FlutterC sarà più chiaro del perché questa cosa è così importante però sappiate che Dart ha tutta una serie di strumenti molto potenti anche per lavorare con oggetti che sono immutabili per questo andremo a fare un punto che è effettivamente equivalente a questo ma che è immutabile per cui andremo a creare un immutable point Dart magari non Dart ok questo sarà il nostro immutable point ok la differenza fondamentale è che ci saranno chiaramente sempre due interi x e y final int x e y così espressi e sono finali per cui vuol dire che quando la classe è stata costruita quindi quando l'istanza di immutazione è stata creata x e y non possono essere alterati in alcun modo esattamente come un final è immutabile dentro un blocco di code quindi questo questo più uno qui non si può riassegnare perché è final quindi non posso scriverci sopra un'altra coordinata perché è illegale ok questa cosa non si può fare perché è final alla stessa maniera un oggetto immutabile con dei campi final una volta costruito non è più modificabile adesso copio i costruttori così ce l'ho già allora copio questi costruttori che ti piacevano la classe ha un altro nome prego allora qui quando abbiamo un'opera quindi non li possiamo riassegnare però ci ci vieta nel caso avessi una tutta lista non ci viede anche se quello fosse file non ci viede di non fare la lista tramite l'eserbista esatto esatto allora è immutabile fino alla certa questo è vero nel senso che le liste sono sempre un problema così caldo perché per ragioni di efficienza le liste di solito non sono veramente immutabili e sono dei array modificabili però è vero che abbiamo intravisto molto poco in realtà però esiste esiste le liste non modificabili quindi ci sono queste liste unmodifiable che è il nostro modo cioè uno dei vari modi che abbiamo per creare delle liste che effettivamente non sono modificabili a runtime quindi è vero che una lista in generale anche se è final questo è comunque modificabile che possiamo modificare la lista non possiamo chiamare il puntatore la lista ma possiamo chiamare la lista e i suoi contenuti se lo creiamo come lista non modificabile questo ci ci permette di di avere la garanzia a runtime che questa lista qui non possa essere modificata sulla carta si può comunque modificare perché ha i sessi metodi quindi potrei aggiungere un 4 qui ma questo esplode a runtime quindi non c'è diciamo così le liste sono un po' borderline da questo punto di vista non c'è la garanzia totale a tempo di compilazione che nulla cambi invece quello che ci garantisce l'immutable point però c'è una garanzia runtime del fatto che non possiamo modificarla però è il compito nostro proteggerci da noi stessi quindi se quando usiamo delle liste poi lo faremo lavorando con delle liste vedete che ci passeremo sempre delle liste non modificabili però per evitare di fare degli errori ok perché quando si tengono in pancia degli oggetti modificabili capita spesso che poi lavorandoci con l'interfaccia utente ci sono varie copie di questi oggetti e se uno è modificabile può poi causare problemi su altri punti dell'interfaccia del codice ok già è tardissimo quindi c'è quello di spicciarmi ok allora questi punti qui non si possono modificare quindi qui anche se io facessi per esempio anzi no adesso faccio i classici accessori quindi x è questo magari prima oppure se stessi come questo y è quest'altro niente da fare ok così il setter non posso farlo quindi questa cosa qui non vale ok questo è un errore perché x non è modificabile quindi questa cosa non posso farla aiuto ok quindi come si fa a lavorare con dei punti immutabili beh è molto facile in realtà perché se mi serve modificare un punto non faccio l'altro che creare un secondo punto che prende il primo e lo modifica in qualche modo ok quindi lo posso fare a mano oppure molto spesso si fanno anche dei metodi dei costruttori accessori che ne so per esempio una cosa del genere che crea un punto che prende la y del punto di precedenza e sposta la x per esempio quindi in questo caso è un costruttore che crea x e la la riassegna e prende la y dal punto di origine una cosa del genere ah dovete ho impariato classe ma perché questo ok per esempio poi potrei fare una move wire che mi sposto da y e così via quindi abbiamo dei metodi che permettono di creare delle copie di un oggetto modificandolo lievemente veramente il punto è una classe molto semplice che ha due campi quindi c'è poco da fare quindi non serve a molto però immaginate di avere una classe molto più sofisticata che magari ha tantissimi campi ha molto senso avere dei costruttori che permettono di creare delle copie di una classe modificando uno o più oggetti della classe un'altra cosa che si può fare e questo dovevo arrivarci prima ma noi sono già ai 50 quindi devo già tagliare corto in qualcuno mi chiedeva prima dei valori di default in in dart si può fare si può fare ancora di peggio in realtà si può fare si possono avere parametri opzionali e per nome cioè nominali così detto questi parametri qui che vedete in queste liste sono tutti parametri posizionali cioè nel costruttore chords ci sono due parametri del costruttore interi x e y e sono in quell'ordine quindi il primo parametro vale per la x il secondo parametro vale per la y e va bene stessa cosa per move x che ha un punto e poi un intero però in dart spesso o meglio in dart non tanto ma quanto in flutter in flutter spesso si hanno degli oggetti che hanno dei costruttori molto grandi con fino a 20 o più parametri del costruttore tutti opzionali però che si usano tramite i nomi dei parametri stessi quindi facciamo così lo chiamano set oppure move facciamo così quindi questo è un non è un esempio in realtà non è ah beh ci proviamo qua e allora quindi è l'outher point poi voglio una lista una di parametri opzionali di metodo affarenzi quadre esatto e qui ci posso mettere int x e int y in realtà qui devono essere nullabili veramente che possono essere nulli ok a questo punto nel mio costruttore cosa faccio? faccio x vale se x è nullo mi sono incartato una cosa in un esempio molto brutto però date pazienza e ha molto ragione ecco perché Dart mi sta dando errore per l'altro perché stai assegnando cose che è nulla qualcosa che non lo può essere ok allora questa intassi che non è molto intelligibile al momento però ragioniamoci insieme allora questi due parametri qui sono due parametri opzionali e quindi possiamo metterci o non metterci un chat qualcosa sì giusto giusto possiamo ottimizzarlo ulteriormente questo però in realtà questo lo vediamo tra un secondo e qui perché volevo avere sempre il punto di partenza qua in questa cosa abbiamo quindi x e y che sono nullabili sono opzionali entrambi se li impostiamo stiamo sovrascrivendo la x e y del punto di partenza quindi stiamo spostando un punto che già esiste sovrascrivendo opzionalmente x e y se x e y sono entrambi nulli semplicemente copiamo il punto ok come giustamente fanno notare nella chat c'è un esempio ancora più intelligente da fare che non ho pensato al volo perché la stessa cosa si può fare anche nel costruttore di base chiaramente quindi in questo costruttore qui possiamo fare this x e this y questo chiaramente non serve più ah beh però non sono così nel caso qui mi avessimo messo mi piace ha ragione anche lui un attimo soltanto per il modo per ripetizzarlo giusto però è nato il giro del underscore qui quindi allora facciamo bisogna fare così per forza e poi nella lista di costruttore nella lista di inseritazione possiamo fare questo ok ok ok anche questo è un altro modo per farci del male in senso che qui stiamo specificando che il costruttore default ha una lista opzionale di parametri con nome quindi questi non sono posizionali sono nominativi con x e y sono entrambi opzionali per cui devono avere un valore default quindi c'è zero di default per entrambi e poi inestilizziamo x e y sul lato di là quindi sul nel costruttore cioè nella parte in cui costruiamo i nostri punti che aspetto ha questa cosa allora quando creiamo un punto facciamo vediamo un punto questa volta se ricordate appunto i punti sono ah sì ovviamente ovviamente sì ok quindi sono punti immutabili di default qui vedete che x e y sono messi a zero quindi questo valore qui sarà un punto che vale zero ok ok poi se vuoi impostare semplicemente la la x a questo punto posso farlo con che sintassi con x uguale un valore così e si usa questo sintassi qui per cui il nome del parametro due punti il suo valore se li imposto entrambi chiaramente a questo aspetto qui ok e poi posso usare anche il nostro move di qui prima per cui final p6 può essere per esempio p4 move ah no è dal costruttore quindi prendo prendo p4 e sposto o x o y perché vedete che sono x e y che sono opzionali quindi posso fare anche move di nulla questo creerà una copia di p4 mentre questo sposterà p4 su un altro valore di x a parte che ci dà errore perché non stiamo utilizzando le variabili ma vedremo il to string mi sa di no copiare il volo ok ok tu solo vedete che cosa ne esce ok quindi in questa maniera qui abbiamo vari modi per fare qui tra l'altro queste cose opzionali valgono sia per i costruttori che abbiamo usato in costruttori ma vale anche per i metodi quindi chiaramente anche i metodi possono avere queste sintassi qui in cui ci sono dei parametri posizionali che sono sempre obbligatori quindi in questo caso se non c'è nulla funziona come in C come C Sharp o in Java questi qui sono richiesti per richiamare il metodo dentro le graffe in questa maniera qui questi questi parametri sono opzionali tutti quanti e o sono nullabili quindi di default oppure hanno un valore di default che usiamo altrimenti ok in alcuni casi possiamo anche richiedere che siano impostati quindi in questo caso possiamo fare required x per esempio che a questo punto non serve perché vogliamo che il nostro il nostro punto abbia dei valori che non siano ok con required stiamo comunque usando dei parametri nominali non posizionali ok in questo caso di qua no qua questo punto qui non è più legale perché il costruttore senza parametri non esiste ok dobbiamo dargli esplicitamente x e y ok perché sono entrambi required e il vantaggio di averli nominali è che non vanno dati così in una lista cioè uno dopo l'altro ma vanno dati col nome questo è utile perché possiamo invertire l'ordine chiaramente nel caso del punto diciamo che è utile per così dire però se abbiamo una lista molto lunga di parametri e vogliamo essere sicuri che l'utente sappia cosa sta assegnando a quale parametro in quel caso è molto utile perché qui l'assegnamento ai vari parametri è esplicito quindi sto assegnando un dato valore alla y e un dato altro valore alla x ok ed è questo questo è non sono riuscito a ok qui stavo facendo errore giustamente sono già le 11 quindi facciamo una pausa non sono arrivato al punto di spiegarvi bene come funziona il sistema dei const quindi di là concludiamo questo ultimo aspetto di Dart e poi finalmente vediamo Flap per insieme ok 우