Quindi abbiamo la nostra radice qui del main che adesso va su login page e si ferma lì. Adesso serve un oggetto, un qualcosa, che ci permette di switchare quello che mostriamo a schermo, quindi o login page o home page, una delle due cose, in base allo stato di login. Per cui qui ci mettiamo un oggetto intermedio, che per far prima probabilmente conviene fare con un consumer, mettiamo il nostro amato consumer, che va importato credo, che ha un builder, che avrà un context, un ref, un child che non ci interessa. Qui dentro dobbiamo fare, insomma, metterci in attesa del nostro user profile provider. Ok, quindi lo leggiamo. Questo ci dà accesso a user data. Ok. Ok. E a questo punto l'unica discriminante è se user data è impostato, abbiamo fatto login, se non è impostato, abbiamo fatto login, quindi se user data è uguale uguale null, facciamo come primo, quindi facciamo return login page, perché potente potersi loggare. Questo è const. Else potente è già loggato e quindi ritorniamo, cosa? My home page, in sostanza. Qui c'era questa stranezza di Flutter, in cui andava passato il titolo. Il titolo qui in realtà posso approfittare e passare qualcosa di variabile che dipende dalla user data. Quindi per esempio, visto che non è null, posso metterci il profilo dell'utente dal dettaglio. Qui metto username, questo si chiamava. Ok, quindi qui sto valorizzato. Questo verrà scritto poi nella bar, in teoria di my home page. Per cui, se questo l'ho fatto in maniera corretta, in maniera molto rapida, abbiamo fatto uno switcher che a quel punto ci permette di fare digit, ci fa fare login. Ok, quindi quello che volete, faccio login, clicco e ha fatto lo switch. Ha fatto login, ha cambiato user data. Che cosa è successo? Che questo consumer qui si è aggiornato e si è ricostruito, questa volta con my home page, e gli ha passato i dati profilo Mario, in questo caso. Ok, che l'utente Mario avrà eventualmente i suoi oggetti. Adesso manca un'altra cosa, che è il logout, che abbiamo fatto il login, che il login avviene di là. Tanto non si può tornare indietro, questo non è, cioè non ho navigato, questa è una cosa importante da distinguere. Si può fare login anche navigando tra le pagine, con navigator, eccetera. Però adesso abbiamo legato la navigazione, cioè quello che vediamo a schermo, allo stato, a un provider. Quindi in questo caso nessuno ha fatto navigator push, pop, modifiche varie, e quindi non c'è nulla da tornare indietro. Ok, se adesso torno indietro, torno sulla... esco dall'applicazione. E non è quello che volevo fare. Ok, perché non è stato un passo di navigazione. Se ho rotto tutto. Ok, qui adesso è ripartita l'applicazione, ha fatto restart, ed è partita senza user data, perché Flutter ha fatto restart e quindi il dato è sparito, quindi bisogna rifarlo. Ok, quasi si è rotto nel profondo qui. Diamo... Riproviamo. Anche si è rotto lì. Ok, adesso facciamo capire perché non ha funzionato lì qualcosa, si è incartato. Ci penso e ci arriviamo. Ok, comunque, agganciamoci anche il logout, che è quello che ci permetterà di fare avanti e indietro tra la line e la home page. E per fare logout direi che lo mettiamo qui in alto. Qui avevamo la pulsante per cancellare tutti gli oggetti della Google RISP. Tanto vale, metterlo in alto. Lì e aggiungiamo quindi una action in alto, qui, dopo quella per cancellare. Può essere qualcosa che si chiama logout. O simile. Non ho la voglia di farlo. Va bene, faccio finta che il logout esista. Ah, esiste, in effetti. E qui faccio ref.read, user profile, eccetera, eccetera. Notifier, che ci dà il metodo logout, che cambia lo stato dell'applicazione. Ah, non so scrivere. Ok, molto meglio. E a questo punto... Posso farlo clicco qui e torno qua. Ok? Adesso potremmo aggiungere anche un'altra cosa che magari possiamo ricordarci dell'ultimo login, e quindi precompilarlo o altre piccole cose, però non cambia la sostanza nella questione. Ok. Ah, visto che ci siamo, abbiamo fatto... Abbiamo fatto... Ah, un'altra cosa qui. Tornerà... Può tornare... Complicare un po' la vita. Allora, qui stiamo navigando con questo approccio. Qui vedete che tra l'altro il fatto che il user profile provider sia... Venga modificato non modifica anche il provider, chiaramente, della Todo Risk. Quindi la Todo Risk rimane piena anche se faccia logout. Questo, in base alla vostra applicazione, può essere sensato o meno. Magari quando fate logout potete anche dimenticare delle cose che l'utente aveva già caricato. Quindi in questo caso, cosa faremo? Il nostro provider, questo qui, potrebbe legarsi a Todo Risk provider e andare a scatenare la pulizia in questo caso. Se riuscite a legare tutto quanto tra provider, è il caso ideale, ovviamente, perché in quel caso i provider si autocostruiscono a vicenda e non c'è il rischio di inconsistenza tra i dati. Altrimenti, in alternativa, potremmo fare qui... Quando facciamo logout, possiamo fare sia la pulizia dei dati, sia il logout, perché chiaramente poi il fatto che la pagazione funzioni dipende dal fatto che noi ci ricordiamo di fare queste due operazioni inizie, in modo che non è mai una garanzia al 100%. Se vogliamo prendere queste due operazioni e mettere un grosso metodo globale che si chiama Perform Logout, che fa queste due cose, è un altro modo per accettarsi di non fare errori, altrimenti la cosa fondamentalmente corretta è legare o la Todo List al nome utente o viceversa l'utente al Todo List. Però fare un watch tra i due provider è la cosa ideale. Idealmente viene da pensare che dovrebbe essere la Todo List provider che si lega all'utente, quando l'utente cambia si scatena una modifica anche della Todo List. Ok. Ah, questo può arrivare a questo. Qui adesso quando navighiamo, quando clicco qui su uno di questi oggetti, questo continua a funzionare, quindi in teoria non dovrebbe darci problemi, ma fate attenzione perché quando... Cioè... Adesso non posso fare logout perché non c'è il pulsante, però questa navigazione rimpiazza... Cioè la pagina che si mette sopra, questa pagina qui, si mette sopra a tutto questo blocco qui. Quindi, se per un motivo o per un altro vediamo sloggati adesso in questo momento, in realtà questa pagina continua ad essere aperta. Non so se vi spiego. Cioè se qui ci fosse un logout, anzi magari aggiungiamo un logout qui sopra che non ci costa poco tempo. A home page, prendo direttamente il pulsante questo qui, e lo copio dentro la mia Todo Item Page. Non ho Todo Item Page, comunque ha l'appare in alto, l'appare non ha la sua nazione ancora, ma posso chiungerne una a costo molto ridotto. Ok, a questo punto se faccio Out Restart, ovviamente riparterò con login. Dai. Ok, creo gli oggetti. Adesso ne apro uno, faccio logout, e non ha fatto niente. In realtà sotto la pagina principale ha fatto logout, perché sono due pagine, e quella sovrastante non è intaccata dal user profile, e quindi non è cambiata. Perché? Adesso se torno dietro dovrei vedere la pagina del login. Ok. Perché? Attenzione, questo è per complicarci la vita, però lo dico per... Perché così è. La navigazione, cioè il navigator, di cui facciamo navigator.off qualcosa, eccetera, in realtà stiamo parlando del navigator che è incluso di default dentro Material App. Quindi è qui dentro che stiamo navigando, e la pagina alla quale andiamo si sovrappone a questa, che è quella che fa login e logout. Per evitare che si accada, perché magari va bene così, però nel nostro scenario no, perché abbiamo fatto logout e rimane la pagina che non dovremmo vedere, dobbiamo mettere un navigatore più in basso nel nostro stack di widget, ossia lo possiamo mettere qui sopra, così tutte le operazioni di navigazione che effettuiamo non riguardano login page, sono due rami diversi dei nostri widget. C'è la parte, c'è login page, che ha il navigator, questo qui, però non lo usa tanto, quindi non è importante. Mentre l'altro ramo, cioè utente logato, ha tutta un'altra navigazione a sostante. Perché qui dentro, adesso proviamo, non sono sicuro al 100% che tutto questo funzioni come deve, però in teoria sì, navigator, che dovrebbe avere initial route, dovrebbe essere, esatto, questo è definito assolutamente come questo, ah no, questo non funziona così, vediamo se... dovrebbe essere questo, ah non mi ricordo perché ci sono, ci ho pensato adesso, per cui non mi sono ridocumentato, potrebbe essere questo qui il metro che ci genera, esatto, la prima route e qui dentro cederiamo una route che non fa, è un po' intricato per tutte le cose di Flutter, chiaramente, qui dentro creiamo la nostra page, adesso se non ho fatto dei clamorosi errori, e soprattutto se mi ritrovo con le parentesi, no? ok, no comunque, se mai un page, ah questo vuole, ah questo vuole un array di, dovuto fare così forse, vediamo se ci piace, ah no, mi chiedo parentesi, mi chiedo di nuovo parentesi, ce la faremo, ma non è oggi il giorno, ah qui manca, no, questo giusto, questo giusto, ah questo, ok, ci sono, perfetto, giusto? ok, vedo ora che non ho attaccato la corrente, ok, ok, non garantisco che funzioni, l'idea è questa, per averci preso, andando a tastoni, vai, vai, vai, ok, ok, adesso se non vale errato, se vi passo navigo, navigo dentro il navigator, il primo che vede, quindi quando faccio navigator.off, come al solito, quel off build context, va su nel build context, nell'albero dei widget, e si ferma al primo, quindi si ferma al navigator, questo, e non quello che viene esposto da materiale, che ha un navigatore tutto suo, e a questo punto faccio logout, per cui è quello che voleva, se adesso rifacciamo questo step qui, viene ricostruito, cioè questo qui si rebuilda tutto, rebuilda il navigator, per cui ritorniamo alla initial route, quindi dovremmo ripartire dalla scala principale, ci sono ancora i to do, perché non li abbiamo puliti, però il funzionamento adesso a questo punto, è corretto con quello che vogliamo fare, ok, quindi anche questo, qui, ritorna, cioè funziona estremamente come il provider scope, quindi ad ogni livello possiamo mettere degli oggetti di riferimento, che ci sono importanti per la nostra, i nostri widget, e più, cioè, in base al livello in cui li mettiamo, ovviamente avranno uno scope, quindi un controllo più o meno ampio, di quello che faremo, questo navigator qui, ha uno scope più piccolo, e quindi riguarda soltanto il sotto albero del widget, che è attivo quando l'utente è logato, se no non c'è proprio, ok, quindi il navigator tra l'altro è ovviamente uno stateful widget, per cui quando viene messo nell'albero del widget, appena facciamo login, sovrerebbe a dire, cioè quando questo si rebuilda, e aggiunge il navigator al suo albero, questo qui farà in its date, come abbiamo visto poco fa, andrà a creare il suo albero, le sue varie rotte di destinazione, andrà a creare la pagina, e così via, e a quel punto comincerà a gestire lo stato di navigazione dell'applicazione, quando l'utente fa logout, questo qui non viene più costruito, quindi si perde, viene tolto, e andrà a fare dispose, e tutte le pagine di cui è composto, che sono una in partenza, ma poi possono essere più, se l'utente avrà delle pagine a sottostanti, andrà a ristruttare anche loro, ok, questo è un po' il meccanismo. ok, adesso, sempre sul tema navigazione, vi faccio vedere rapidamente, spero, degli esempi sempre di navigazione, che possono essere qui, speramente, utili, allora, direi che ci conviene fare, non vuoi perdere troppo tempo su questa cosa, però, vale la pena forse, allora, facciamo così, dentro my homepage, un'altra cosa che non abbiamo ancora visto, è il drawer, che è un'altra cosa a base dello scaffold, lo scaffold ha tante piccole componenti, uno appunto è, questo è un generato drawer, che in sostanza sarebbe quella parte a sinistra dello schermo, che possiamo trascinare dentro, su Android, anche su Gmail, su altre applicazioni abbastanza grandi, che hanno varie schermate, spesso c'è questa, c'è un iconcina qui in alto a sinistra, che è, che ci suggerisce, che c'è un drawer appunto, un cassetto, che può essere trascinato dentro, e che possiamo poter aggiungere in questa maniera qui, per farlo, e per aggiungerlo a varie sottopagine, andiamo a mettere qui un widget, tipo drawer appunto, e lo andiamo a definire, da una parte comune, quindi mettiamo qui il widget, lo chiamiamo nav, un drawer magari, andiamo a dart, questo è proprio status, perché non ha bisogno di fare con uno stato, e quindi va bene così, così qui dentro ci mettiamo il nostro drawer appunto, c'è un widget in default, che si chiama proprio drawer, che ha l'aspetto standard del drawer, il drawer in genere è fatto da una serie di elementi, in verticale, questo sarà una colonna ovviamente, vogliamo che sia estesa su tutta la, l'ampiezza del nostro, del nostro drawer, quindi lo usiamo così, qui dentro ci mettiamo una serie di, children, adesso vado un po' rapido, perché tanto sono tutte cose che, standard, e qui c'è un altro oggetto, che si chiama drawer header, che ci permette di mettere, il header classico, dei widgets, qui ci metto, applicazione, ok, poi sotto ci mettiamo, un oggetto qua fino in fondo, e poi, adesso qui magari, abbiamo dato cosa si vede, così cominciamo ad apprezzare, cosa compare, questo va bene, ok, questo lo vediamo qui, ok, non porto, e per far prima, per fare il rebuild, nel provider qui, invece di partire con il provider nullo, ci metto, ok, cioè parto autologgato, che non è proprio una grande idea, ma è quello che, così, non devo mettere ogni volta, il nome utente, ovviamente ho degli errori, così, ok, e anche qui, lo scaffold, in automatico, si adatta al fatto, che il drawer esiste, quindi qui troveremo appunto, un iconcina, che indica la presenza del drawer, e, lo scaffold, gestirà, il trascinamento da sinistra, facendoci fare questo, ok, questo è il drawer in sostanza, adesso qui, questo è particolarmente brutto, questo è il drawer header, appunto, che ci dà questo spazio qui, qui sotto, possiamo metterci un'immagine, una foto dell'utente, eccetera, adesso, non c'è niente, chiaramente, appena sotto, di default, c'è la lista delle opzioni, quindi questo è il nostro, expanded qui, questo qua, che contiene ancora nulla, in genere, qui ci si mette una lista di pulsanti, no, e, una lista di pulsanti, si può creare in vari modi, uno è, cadere una colonna, chiaramente, però visto che, non sappiamo quanto è altro lo schermo, e, non vogliamo perdere tempo con questo, usiamo direttamente una list view, anche in questo caso, la list view è quella che abbiamo utilizzato, per gestire la lista di oggetti, la list view va benissimo con oggetti, di cui non conosciamo il contenuto, ma in realtà va bene anche, se conosciamo già gli oggetti che ci sono, cioè, va bene in entrambi i casi, la list view la possiamo veramente usare, in qualsiasi scenario, in cui c'è, uno spazio, verticale, con degli oggetti, che l'utente deve scrollare, e, quindi possiamo tranquillamente usare, sempre, la list view, ma con un altro costruttore, useremo, la list view, con il costruttore di default, se ricordate, di qua, no, questo era il singolo oggetto, era il drone page, allora, qui abbiamo usato, list view builder, se ricordate, lo avremo, su builder, che, praticamente, gli fornivamo, quanti oggetti deve costruire, e poi una funzione con cui costruire gli oggetti, perché, appunto, non sappiamo quanti sono, e poi questi cambiano, dynamicamente, per cui, viene fatto in maniera funzionale, nell'altro scenario, quindi nel drawer, in realtà, questa cosa non avviene, perché abbiamo i pulsanti, sappiamo quali sono, per cui, qui c'è un costruttore di default, prevede che si possa passare, direttamente, c'inter, quindi un array, statico, di oggetti, che vengono, semplicemente, resi scrollabili, quindi, qui dentro possiamo metterci, quello che vogliamo, anche il text, in fondo, quindi possiamo metterci, in fondo, alla lista, e poi, possiamo metterci, qualsiasi oggetto, anche qui, visto che, material, quindi la libreria, material, ha una serie di widget, standard, che rispecchiano, lo stile, di android, anche qui, c'è list tile, che è, il chassico pulsante, che sta bene, nel drawer, che è composto, da un titolo, e un on tap, quindi qui abbiamo, un title, che è un, un text, alla fine, un page, e qui c'è un on tap, che viene scatenato, quando ci si clicca, ovviamente, e poi appena sotto, ci mettiamo, un altro list tile, ops, ci mettiamo, bottom bar, nav, che è quello che faremo, tra un secondo, cioè, una delle varie modalità, di navigazione, che vi mostrerò, ok, non è quasi, perché, ok, adesso vediamo un attimo, come aspetto, e poi, lo implementiamo, ok, non è proprio bello, questo testo qui, è orribile qui, ma questi pulsanti qui, vedete che sono, cliccabili, tra l'altro, se io ruotassi, lo schermo, così, non così, ok, ok, ok, questo spesso esplode, questo non ha funzionato, ecco, visto che, vabbè, scrolla molto poco, però visto che sono dentro, una list view, questo è scrollabile, quindi, nel caso ci fosse, un terzo elemento, potrei, vederlo, senza, dovermi preoccupare, di questa cosa, questo, ne parliamo meglio, la settimana, dopo che viene, perché la rotazione, è una cosa che, spesso complica molto la vita, nel fare le applicazioni, le interfacce, per cui, dobbiamo farci attenzione, ok, nei vari clic qui dentro, cosa andiamo a fare, andiamo a navigare, ovviamente, e, per cui, adesso, questo, tralascio un attimo, qui, ci viene naturale fare, una cosa di questo genere, navigator, punto, off, context, che è andato a pescare, il navigator, quello, speciale, di homepage, push, questo, va bene, adesso, cosa pushiamo? Pushiamo una pagina, che adesso farò, nuova, nuova, che ci permette, di fare un altro tipo, di navigazione, che può essere interessante, che potete usare, nel vostro, progetto, e la chiamerò, bottom bar, navigation, page, dart, ok, allora, qui vado a fare, una pagina, che assomiglia, tutto e per tutto, alla new page, quindi non perdo troppo tempo, ah no, non è vero, questa è troppo complessa, ti facciamo, ma, anzi, non state, adesso, scrivo, scrivo meno testo, ok, metto questo, poi converto in stateful, ah no, facciamo finta che, ok, qui dentro faccio, come al solito, scaffold, bottom animation, ok, poi questo avrà un body, qui come sempre, ci mettiamo, un body, così, questo avrà un child, ok, e qui poi ci mettiamo qualcosa, quindi qui ci metto, oh, salve, vedeteci, ok, quindi questa è, una pagina con lo sfondo rosso, in sostanza, abbiamo visto il drawer, un secondo fa, abbiamo visto la, l'action bar, e così via, c'è un'altra cosa, piuttosto utile, nello scaffold, che è la bottom navigation bar, quindi è proprio, a quello che ho chiamato male, bottom bar navigation, bottom navigation bar, in realtà, questo oggetto qui, ci possiamo mettere, varie cose, verranno mostrate sotto, in fondo, dalla pagina, di solito ci si mette, una bottom navigation bar, proprio, che è il widget, che ha l'aspetto giusto, per essere in quella posizione lì, e che cosa fa di bello questo, in sostanza, è una, una barra, appunto, con vari, vari concili, ognuna dei quali, è, a sua volta, un bottom navigation bar item, quindi, un oggetto, un iconcina, che va lì sotto, che ha, in sostanza, fondamentalmente, una label, quindi un testo, e un'icona opzionale. Proviamo a metterci l'icona intanto. Non mi ricordo. Esiste? Ok, va bene. Apice, c'era. Ok, e poi ci metto una label. Ok, quindi questo è l'oggetto numero uno. Tre, quindi sono tre oggetti qui, qui sono tutti i const, in teoria, quindi possiamo metterlo, direttamente qui. Ok. E questa pagina qui, la possiamo costruire, cioè, possiamo aprirla dal, perché qui dentro ci mettiamo, push, material, page, root, avrà il suo builder, che avrà il suo, context, che ritorna, la button, il bar, anche il page, che dobbiamo importare. Sarà const. Ok, vediamo l'azione, vediamo che succede. Ok, ok, ok, ok, ok, clicco qui, file push, per cui mi aspetto che venga sopra un'altra pagina, è stata messa sopra, vedete come è fatta questa parte dello sfondo nostro del container, qui sono tre elementi nella bottom bar on negation, e sono tre pulsanti cliccabili, al momento non sembrano funzionare, ovviamente, per cui clicco, ma non accade nulla, perché veramente devo registrarmi a cambiamento di stato, e soprattutto devo cambiare lo stato della mia pagina. In questo scenario qui ci serve di nuovo uno state full widget, perché ricordarci di qual è la sottopagina, o comunque qual è l'icona attiva qui sotto, è compito nostro, cioè esattamente come nel caso della login page, avevamo il controller, che dovevamo tenerci noi dentro in pancia, come si dice, dentro lo state, per avere accesso a qualcuno che si ricordasse che cosa aveva scritto l'utente per l'istante, all'assistente di caminiera, dovevo farlo noi, qui nella bottom bar navigation, perché qualcuno deve ricordarsi di qual è, no, la sottosezione attiva in ogni dato istante. Come si fa a scegliere una sezione, cioè una sezione, un item attivo diverso? Beh, qui dentro c'è una proprietà, un campo del costruttore, che si chiama current index, che è un intero, che va da 0 a n-1 oggetti che sono dentro gli items, quindi qui questo può andare da 0 a 2 in sostanza. In partenza ovviamente vale 0, di default, però ci serve un modo per cambiare questo 0, e renderlo 1 o 2, perché con questo costruttore qui, Flutter sa qual è l'icona che deve attivare qui sotto, delle tre. Ok, quindi questo qui andrà reso alterabile in qualche modo. Come si reagisce ai click? Anche qui c'è un on tap sulla barra, che ci permette di gestire il click dell'utente, dato qui c'è un parametro che è l'index, cioè il nuovo indice dove l'utente è cliccato. Se uno tappa, cioè in base al bottom bar del item che clicchiamo, chiaramente arriverà un on tap diverso, o un indice diverso. Ok, questo int script va numerizzato da qualche parte, per cui ovviamente è completo nostro, dobbiamo rendere tutto questo blocco qui, da state class qual era, state cool, perché a questo punto quella pagina lì ha uno stato interno che è la pagina correntemente attiva. Lo convertiamo, molto rapidamente, per cui cosa accadrà? ci sarà un int current index, lo chiamiamo, inizia con zero ovviamente. Ok, questo index qui lo posso usare direttamente qui, quindi lo passo, adesso qui magari c'è un page index, per non confonderci, no, era un po' strano, questo è il numero del parametro, questo è il numero della variabile. Ok, a questo punto dentro l'on tap cosa avviene? Bisogna modificare questo page index, per cui facciamo set state, esatto, set state, ok, modifichiamo page index, e lo aggiorniamo. A index, ops, ok, secondo me sono perso nulla per strada, no, ok, a questo punto possiamo navigare, possiamo navigare perché la pagina ha l'indice che viene modificato, e ogni volta che quell'indice viene modificato, viene ricostruito l'intera pagina, e sotto il bottom-up navigation, viene costruito con un indice diverso. Ok, quindi adesso, ecco, adesso si vede molto poco, però il testo si ingrandisce, e diventa viola il pulsante attivo. Quindi, adesso, non mi ha dato pranto, per mostrare mai, le pagine, andiamo, praticamente, a fare un switch. Sì, esatto, esatto, facciamo un switch case, quindi, facciamo praticamente quello, sì, lo possiamo fare direttamente qui dentro, no, lo possiamo fare direttamente qui dentro, però per rendere il codice un pochino brutto, potrebbe aver senso fare, build page, che usa page index, per distinguere, no, tra i vari, tra i vari, se ne capiamo, se ne capiamo, se ne capiamo, uno switch, oppure un altro di, di, di, di fail, se ne capisco, quello che volete, sicuramente poi, qui, adesso è, se ne spettano l'intero, magari, voi avete, si possono essere scenari, in cui, le condizioni, di cosa mostrare, sono più complesse di questo, magari. e, non so se qui l'avevo fatto in altro modo, vabbè, no, però comunque non importa, e quindi facciamo che, per farla molto breve, qui, no, vedete, è zero, e poi, giusto per proteggerci, da alcuni problemi, che però, Dart vuole che sia l'ultimo, perché non è simpatico, quindi, se proprio qualcosa va storto, è quell'indice D, è fuori dal seminato, facciamo così, quindi, a Gray non ce l'ha, perché scrivo con la E, giusto? Come? No, sono passato, è vero che Gray, tutti, sono un'intero a. Sì, c'è un, un momento di, un grise britannico, non so perché. Ok, ok, ok, ok, ok, domanda, in questo caso, secondo me stiamo utilizzando, un, un, un, un, un, un, un, un, un, un, un, un, un, un, un, un, un, un, un, Readyctic, ci dice cioè questo ok cioè ci conviene utilizzare un widget in questo modo o lavorare direttamente con funzioni cioè una funzione è uguale cioè questo visto che Flutter è molto cioè possiamo fare vari if perché Flutter permette di farlo anche dentro il codice dentro i costruttori e va anche bene anche quello solo che secondo me si diventa tanto candidato è brutto il codice per cui secondo me conviene farlo di stegarlo un po' però alla fine cambia poco meraviglioso una bellezza spavillante ok e e questo è uno dei tanti modi in cui si può navigare e in realtà è la stessa cosa che facciamo già con login no in realtà con login è la stessa cosa solo che siamo legati a uno stato che non è della pace ma è uno stato che è dell'applicazione però alla fine l'approccio è lo stesso però va più che bene l'altra cosa che voglio dire su questo la cosa da ricordarsi è che le varie le singole pagine qui che sono attive o meno vengono costruite o non costruite quindi in realtà c'è sempre soltanto un widget attivo alla volta e quindi ricordatevi che adesso qui chiaramente sono tutti i container colorati e basta però immaginate che ci sia qualcosa di più complesso ricordatevi che nel cambiare qui l'indice in sostanza andate a costruire e distruggere i widget e quindi la vostra gerarchia di widget è sempre pulita tanto un ramo che è quello correntemente attivo appena cambia il pulsante il ramo viene perso e se ne crea un altro con un altro container in questo caso esatto esatto non è così non sono sovrapposti non si vedono di loro o ce n'è uno o ce n'è un altro per cui questo può essere voluto o non voluto però in base a quello che vi serve può essere usato anche per il look sì sì in realtà è quello che già facciamo in altro modo per il look quindi in realtà quando siamo qui e dove siamo qui facciamo la stessa cosa ma la facciamo in migliore diversa quindi qui dentro abbiamo questo consumer qui che legge il provider e in base no qui è come si fosse uno switch qui è come si fosse lo switch dall'altro lato in base a un dato x sto costruendo un ramo là oppure l'altro è per il mio libro è un messo di vedere lo scopo in modo che si è sconnesso con la mia persona in un certo senso io in un caso posso fare in modo che ho uno switch e il mio senso è in C0 ok è di modo da avere comunque i partner sullo stesso livello anche se sono più grandi si si ho sentito di dire contatto del prima che sono più usare usare questo approccio qui per fare la gestione del login si si come no si si ok forse quindi se rendessimo questo oggetto qui la radice più o meno della nostra applicazione qui dentro potremmo andare a leggere lo stato dell'applicazione che è l'utente di dati quello che mi pare piace e poi qui dentro nel costruire la pagina discriminata in base al login per esempio quindi questo si può sentito fare forse si è un po' più pulito di quello che abbiamo fatto qui questo abbiamo proprio accrocchiato al volo però concettualmente è la stessa cosa non cambia niente la cosa che cambia fondamentalmente però è dove è lo stato cioè qui lo stato cioè qual è la la sottopagina che ho aperto vive soltanto qui dentro quindi è legata a questa bottom bar navigation page tant'è che se qui apro la pagina 3 più riapro riparto dall'aprima chiaramente questa istanza di bottom navigation è stata distrutta e ricreata e riparto sempre da zero se voglio per qualsiasi motivo ricordarmi che ero nella pagina 3 e c'era qualche altra informazione se lo voglio persistere dentro l'applicazione dovrei renderlo uno stato dei provider cioè dovrei spostare lo stato renderlo qui più generale così l'applicazione si ricorderebbe no che ci ricorderebbe perché i provider sono tutti quanti globali per cui sono tutti visibili a tutti se mettessimo no indice di pagina aperto come provider quindi current index provider per dire qui dentro al riaprire della pagina ci troveremo sulla pagina di prima perché quello va il provider sopravvive alla pagina però tutte le la controindicazione è che tutte le pagine cioè tutte le istanze di questa pagina qui se dipendessero da provider avrebbero lo stesso provider quindi non so magari voi avete più istanze di questa pagina quando navighiamo sull'una adesso può essere più o meno giusto in base a quello che vi serve allora abbiamo soltanto poco io vorrei parlarvi anche delle schede dei tab quindi delle schede quelle proprio quindi potete immaginare adesso magari saltiamo l'ultima cosa che manca qui è la la barra delle schede quindi sotto c'è la navigazione della botta navigation bar potete intuire come se avete già visto nelle varie applicazioni che qui sopra si possa aggiungere un'altra linguetta con le varie schede averte in parallelo per un browser o un'applicazione che gestisce documenti o quello che viene in mente non lo facciamo perché non c'è tempo però magari completo l'esempio e poi quando ve lo carico lo trovate si fa alla stessa maniera in maniera cioè in maniera molto simile a questo esempio qui usando una serie di di di di widget che si chiamano tab tab bar view tab bar controller così via vari oggetti che servono per gestire la navigazione tra le varie schede però alla fine più o meno è lo stesso meccanismo quindi possiamo avere una barra in alto una barra sotto che permette di paginare attraverso delle sottopagine in sostanza lo schippiamo se no poi non c'è a fare tutto perché voglio farvi vedere molto col tempo rimasto e con la stanchezza accumulata che è il scenario ideale ovviamente per fare questo lavoro come si fa a caricare dei dati da da remoto per fare questa cosa non si trovo nei vari decidimenti che servono sono qui sono qui quello che potremmo fare andremo a usare un servizio esterno per caricare dei dati remoti allora immaginate che la nostra magnifica applicazione adesso ha varie sottopagine adesso ne aggiungeremo un'altra che ci permetterà di accedere a una lista di foto dell'utente scenario ipotetico quindi ci sarà una pagina aggiuntiva quando lo apriamo andiamo a scaricare le foto dell'utente lo facciamo usando questo sito che si chiama json placeholder che è un sito che ci fornisce semplicemente dati in formato json così di esempio il json qui ve lo cito giusto perché non lo abbiamo fatto finora è un formato interscambio di dati nativo di javascript che però è diventato super popolare in generale per cui in genere quando si lavora con delle api remote via http online nella maggior parte dei casi queste parlano sempre di json ormai per cui è proprio la lingua franca dei dati online come funziona sono una serie di end point si chiama quindi una serie di percorsi http che possiamo scaricare che ci risondono una serie di informazioni fasulle ci sono dei post fasulle che ci dà è un array di 100 elementi di un'idea di quali contiene misure di id un titolo e un body così a casaccio ci sono i commenti i commenti fanno il tiramento ai post ovviamente di prima ci sono gli album le foto gli utenti quindi se volete implementare un servizio fasulle che fa delle operazioni online questa è una buona fase di partenza perché vi dà un paio di elementi tra l'altro sono anche elementi più specifici quindi potete scaricare per esempio il post con id numero 1 e così via quindi è proprio un api a tutto tondo che permette di scaricare i dati ci interessa al momento questa qui questo endpoint qui che ci dà l'accesso a 5000 foto sono molti dati qui in lentina ogni foto è composta da queste informazioni qui quindi id id isolo url e così via adesso il fox è accorto che è json e ogni lo dirò ogni foto contiene un link a un'immagine piccola un'immagine grande che sono immagini così molto significative sono dei colori ok e questo è quanto vogliamo fare questa cosa per farlo prima di tutto facciamo un'altra pagina ancora quindi adesso copio il nostro bottom bar navigation che ci era piaciuta così tanto anzi no forse non la copio faccio la gallery page per chi abbiamo tutto va bene qui riesco a farlo stateless quindi questa sarà la mia gallery page extents consumer widget perché dipenderò da dai provider voglio fare il tuo altro provider chiaramente anche qui va bene override guardo ok e così ok qui rubo qua lo scaffold perché non voglio riscrivere ok non ci interessa non ce l'abbiamo qui mettiamo semplicemente una lista di oggetti questa sarà la gallery ok qui ci mettiamo un size box per il momento ok questa è la pagina perfetto la colleghiamo al drawer se no non c'è modo di aprirla copio di style aggiungo gallery questa è la gallery page ok l'impalcatura c'è ah beh qui devo importare il material ok ok allora allora vediamo cosa possiamo fare tra un secondo chiaramente questi oggetti qui quindi gli oggetti che vado a scaricare questi oggetti qua ovviamente verranno presentati da una classe interna quindi si vedrà un modello foto ok qualcosa del genere un photo item che in cui metteremo queste date qui però prima di fare questo che avrete bisogna andare a scaricare questi dati in qualche modo e lo facciamo con un pacchetto che si chiama HTTP quindi è molto fantassioso e a me qui non ce l'ho non importa e allora lo chiamiamo photo provider o gallery provider o quello che volete sarà un future provider per per per per distinguere dagli altri che cos'è un future provider è un provider che vabbè ritorna quello che vogliamo ma la cosa importante è che la funzione no che che istanzia quel provider non ritorna l'oggetto subito immediatamente ma ritorna un future di un oggetto quindi un oggetto che può essere atteso in sostanza significa che qui invece di fare cioè invece di avere la sintassi classica a ref e poi questa deve immediatamente ritornare qualcosa no qui sono tutti provider sincroni nel senso che quando riverpod li va a chiamare devono subito dare una risposta il free provider invece è più tranquillo non deve non avere questa quest'ansia perché ha sì ref ma è asincrono e può metterci il tempo che vuole ok può fare le operazioni asincroni che preferisce a un certo punto dovrà tornare a qualcosa che diciamo a mostrare a schermo qui dentro andiamo a usare questo questo http allora per importarlo ci serve pubdev per cui vediamo se ci importa ipod app è il gestore di pacchetti di di darts per cui penso che lì più della solo però secondo me per criteri per quindi quando ci serve un pacchetto che non è tra quelli standard diciamo così lo andiamo ad aggiungere qui nel pub spec le dipendenze che l'abbiamo già fatto per uid che era il generatore di ud l'abbiamo fatto per flat river pod che era il che è il river pod e lo facciamo anche per http questo appunto non so se è necessarissimo però vediamo e quando modifico le dipendenze del pub spec yaml la cosa che devo riprendermi di fare è che devo terminare l'applicazione e rebuildarla da zero perché altrimenti l'autre start non trova il pacchetto quando quando riparte per questo lo lasciamo lasciamo fare pub get qui che andrà a scaricare http e tutte le dipendenze e esploso ma praticamente non serve questa specifica realtà sponzata vero perché è un'idea di produzione che secondo me è incluso di risconti io sto ricordando cose di un di un di un latter dell'anteguerra vediamo se importiamo direttamente il pacchetto un rambo un rambo è recente è di tre giorni fa quindi direi che ci siamo se non lo trovo che non mi piace per niente non è una cosa che mi rassicuro più di tanto ma possiamo farlo perché c'è una incompatibilità tra dipendenze di questo e questa specifica qui che è il nostro flutter che però io so che è l'ultimo andiamo un po' se è vero forse sono io che sto usando un flutter dell'anteguerra è una cosa che è tutto sommato possibile lui vuole 3, 2, 0 sì ecco no infatti per cui sto usando ok usiamo qui 2, 0 quindi HTTP ha una dipendenza vedete che dopo 1, 1, 2 no scusa dopo 1, 1, 1 richiede a questa specifica qui noi usavamo eravamo compatibili con un SDK di flutter più vecchio quindi dovremmo a questo punto però essere c'è questo non ci nasconde l'output quindi chissà andiamo all'Sdk andiamo a HTTP 1, 1 e dovrebbe risolvere l'apice l'apice praticamente fa l'auto upgrade se è disponibile della prossima versione minore quindi praticamente mettendo 1, 1, 0 il rischio era che si passava in automatico a 1, 1, 2 perché sono tutte versioni minori quindi qui per esempio se uscisse domani 4, 2, 2 quindi sarebbe quella anche se non dobbiamo aggiornarlo qui per fare in automatico se uscisse il 5, 0 quella non viene presa l'idea è che le modifiche che rompono qualcosa salute dipendono dalla versione maggiore se le cose sono fatte niente da fare a me perché io non ho resti capo di uso ok torniamo indietro qui allora ho preso conto la soluzione effettiva sarebbe di addornare Dart che ho installato evidentemente una versione vecchia se lo faccio adesso perdiamo gli ultimi 40 minuti sicuro per cui lo faccio a casa forse e metto l'environment che è la versione di Dart che ho sicuramente installato nella 3.1.5 ok Prendiamo la guida di invocare questa funzione, lo so. E assente. Un attimo. Ok. Mi piace. Allora, intanto compiro poi... Le dico. Beh, se non compiro perché questo chiaramente non fa nulla. Ok. E allora, in realtà, tutti i provider sono fatti come una funzione. Quindi c'è una funzione dentro che viene invocata per creare il valore di cui abbiamo bisogno. Quindi qui creiamo il profilo dell'usente dal dettaglio, qui andiamo a pescare un valore della to-do item list, eccetera, eccetera. Quindi stessa cosa vale anche per il future provider. Quando qualcuno andrà a bisogno di gallery provider, che è la nostra pagina di gallery provider, ovviamente, andrà a lanciare questa funzione qui. Solo che sapendo che la funzione non ritorna il valore in sé, RiverPod in automatico farà un po' di gestione interna e lancerà il mezzo di una funzione che va ad accedere ai dati e ci notificherà dei vari stati che quel processo può avere. Ok. Adesso ci sono un esempio. In questo caso, noi abbiamo creato il provider, come un provider, chiede la red, non ci sono 5, eccetera. Ok. In questo caso, ci sono un caso, quando avessimo tre diverse richieste. Ah, sì. In questo caso, noi abbiamo queste tradizioni, che abbiamo definito di gallery provider, questo provider non è un provider. No. Sì. E quando vado a fare un gallery provider, oh, ho detto come, è tutto per l'invito. Sì. E adesso faremo comunque un watch. Un watch, ok. In quel caso cosa c'è? Quando viene scritto watch, lui manda la richiesta e aspetta? Praticamente sì, esatto. Cioè, aspetta? Quindi quando c'è un watch, chi è profano la richiesta? Mi. Allora, quando facciamo watch, diciamo, guarda, a me interessa il valore di questo provider qui. Per cui, se è la prima volta il provider viene invocato, farà questa richiesta qui, questa refql, e andrà a far la richiesta. Poi rimaniamo in attesa che questa richiesta venga terminata. Appena si modifica qualcosa, quindi lo stato cambia, il fatto che abbiamo fatto watch, ci rebuild. Quindi adesso lo potremo fare un secondo. Nella nostra pagina avremo, ci metteremo a fare watch di questo provider qui. Il provider potrà avere tre stati possibili. Rotto, in attesa, poi dati. di base, il primo stato che avrà sarà in attesa, perché non ha ancora i dati. Rotto sperabilmente non lo sarà mai, perché si romperà se la richiesta HTTP fallisce, o se il parsing fallisce, o se avviene qualcosa di strano. E l'altro stato è quello che, i dati sono stati presi, sono stati letti, per questo punto possiamo metterli sullo schermo. Quindi con la stessa watch, noi facciamo, scateniamo lo scaricamento e gestiamo tutti i vari passaggi che poi potrà versare alla richiesta. Poi come diceva lei, se abbiamo bisogno di più dati, qui è soltanto la gallery, quindi è soltanto un provider, dipende un po' dal nostro scenario, cioè se avete alcune sezioni di dati importanti, quindi la gallery, i commenti, i post, queste cose qui, può aver senso avere tutti i provider separati. Se no, poi ne faremo un altro per le foto. Se abbiamo un provider, un free provider, che deve scaricare delle foto, possiamo usare il trucco, il sistema delle family. Cioè facciamo un photo provider, family, in cui andiamo a specificare qual è la foto che vi interessa e quel provider sa esattamente quale foto, come andarla a reperire e poi c'è la popola. Però in tutto il caso, in tutto il caso, possiamo dire che ci riscarica un'attività di dare un'auto. Sì, ah, quello... C'è nel senso di, tipo, per il provider, in un caso, che invoca la... E qualcosa che dobbiamo fare esplicitamente, c'è sui provider, non l'abbiamo ancora visto, perché non c'è stato un motivo di farlo, c'è un modo di obbligare un provider di perdere lo stato e ricaricarsi. Quindi si può fare da fuori, c'è un metro che... obbligare il notifier a dire, ok, dimentica tutto, riparte da zero. Ed è quello che se... Quando facciamo il refresh, per esempio, è quello che vogliamo fare in questo caso. Allora, vediamo se intanto ha compilato qui. Ok, perfetto, ci siamo di nuovo. Ok, per cui a questo punto, se ci siamo, posso finalmente usare HTTP. E non funzionava, non... avevo sbagliato a importare, cioè, avevo... dovevo aggiungere il pacchetto HTTP per avere accesso all'HTTP client. e... l'ho aggiunto qui, però evidentemente la persona che c'è qui adesso, 112, dipende, ha le dipendenze da Dart 320, e io ho Dart 3.1.5, in salato, quindi, per evitare di aggiornare Dart e tutto quanto, adesso, semplicemente ho usato una persona vecchia di HTTP, però, non penso che cambi radicalmente. No, ok. E ora, mi parli di... mi ricordo come... sì, uno dei... ha un nome simile. qui dentro, quindi, andiamo a usare HTTP GET, qui, questo metodo qui ha una serie... questo oggetto che si usa da vari metodi che fanno le varie richieste HTTP con i vari... no, i vari metodi, i vari verbi HTTP. GET è quello che è più comune per scaricare i dati. Ci si passa a un URI, un URI è un oggettino che rappresenta un URI, ne facciamo il parse per crearlo, che c'è un costruttore che ci permette di fare il parsing di una stringa che contiene un URI, qual è l'URI che ci interessa? È questo. Ok. Il percorso della pagina lo mettiamo così. Ok, questo ci ritorna... che cosa? GET ritorna un future di response, questo è l'HTTP response, chiaramente, quindi, essendo un future posso fare l'await. Ok? Visto che il future provider qui, await vale. E quindi diventa bloccante. Diventa... Sì, cioè, il bloccante, questo metodo qui parte e si impunta, si blocca qui in attesa che la richiesta abbia successo o fallisca i termini, ma chi aspetta fuori non è bloccante. Quindi la nostra interfaccia rimarrà fluida perché non attende che quel valore sia pronto. Perché il future provider sa come gestire queste cose. E chiaramente, allora, questo qui non possiamo mettere dentro un writer classico perché GET è appunto un future e dobbiamo fare la wait. Se vogliamo fare le cose brutte, possiamo farlo anche in maniera sincrona, volendo. No, possiamo fare GET TTT e poi qui... Allora, facciamo. E questo ci torna un future di response, però qui in realtà se vogliamo possiamo fare degli accrocchi per farlo in maniera sincrona. Ci sono dei magheggi da fare e per accedere letteralmente alla risposta, però in quel caso questo metro qui diventa affidamente bloccato. A quel punto di là la nostra interfaccia effettamente si bloccherebbe in attesa che quel valore venga valorizzato. Ok. Allora, qui facciamo dei controlli veramente di base, qui leggiamo lo status code, no? Come sicuramente ricorderete se lo status code è 200 significa ok, quindi va bene, se non è ok non ci piace. Ok, chiaramente non ha bisogno di errori fatta meglio di così, ma ora ci accontentiamo di cose molto rapide. Ok, a questo punto dobbiamo andare a fare la decodifica di questi dati. Questo response qui cos'è? è un oggetto complesso che tra i suoi vari campi ha un oggetto body. Quindi uno è il status code, chiaramente poi ci sono varie altre cose che ci possono esserci e poi c'è body che è la stringa decodificata della response oppure se devo scaricare dei dati binari come avverrà con le immagini per esempio, le immagini sono scaricate e sono dei bytes chiaramente, possiamo leggerle anche come bytes che in dart non c'è un modo diretto per usare i bytes per cui si usa una lista di 8 è il modo che ha dart per rappresentare gli arreghi byte in sostanza. Però in questo caso sappiamo che è il testo. Il testo lo passiamo a un metro che si chiama json decode che ci permette di decodificare queste cose. viene importato una domanda questo è del runtime quindi non importa nulla è già tutto quanto dentro dart convert è già incluso quel pacchetto json decode di cosa? Della stringa quindi questo passiamo a json decode una stringa e json decode cosa fa? Allora ci ritorna lo dirà un dynamic è un oggetto chi lo sa che cosa è? Boh non mi interessa a quel punto il testista di Dart alza le mani e dà fai quello che vuoi stai lavorando con dati che dipendono dalla stringa quindi io non posso darti la mano giustamente per cui bisogna fare un po' di un po' di salti mortali per decodificare questi dati perché noi sappiamo a questo punto e questo è l'aspetto che secondo me è l'aspetto più terrificante di Dart lavorandoci a questo livello è come vengono manipolati i dati dinamici in JSON perché bisogna fare dei salti attraverso dei dati nativi di Dart e non c'è alcuna sicurezza per cui qui in genere si mette tutto un grosso try catch si incrocia le dita e se tutto va storto esplode e pazienza però è così ma il motivo per cui funziona così purtroppo è perché Dart non ha la reflection che sarebbe la reflection sarebbe la capacità di autoanalizzare il suo stesso codice a runtime è una cosa che Java e .NET e Python hanno perché sono linguaggi di altissimo livello e poi vengono compilati non in codice binario ma in codice intermedio per cui hanno la capacità di dire questa classe è fatta con questi componenti sono questi attributi e così via Dart non ha questa capacità perché non c'è proprio la reflection in assoluto per cui per esempio se avete usato HTTP in .NET Java e Python in genere si fa una classe che rappresenta l'oggetto che vogliamo leggere quindi un oggetto di questo genere si passa la decodifica JSON e la decodifica JSON mette i dati dove devono stare e lo fanno fatto in Dart non si può fare perché Dart non ha modo di capire che questo deve essere messo in un campo che si chiama al-mrd perché non ha idea di come si chiama il campo se non si conosce come il tuo oggetto di ah no in quel caso siamo proprio in quel caso no si può fare uguale però certo siamo veramente in alto mare però qui siamo in alto mare in qualsiasi linguaggio si vanno perché bisogna avere a quel punto bisogna fare delle euristiche non so bisogna un po' sì no esatto con altri in un'unità ci si può un po' arrangiare però comunque bisogna andare a leggere i campi cercare di interpretarli in base al nome cioè diventa molto astratto in genere il json è un frodo di interscambio perché sappiamo che è formato A se no usiamo il testo semplice no volevo chiedere perché il json ricordo di un mappolo di string e dinamica allora potrebbe ritornare a una mappa di string e dinamica ma non perché noteremmo come fatto con il json perché il json ci sono vari cioè il json può essere un po' fatto come vuole perché potenzialmente il json potrebbe essere anche non so dove scriverlo ma cioè per esempio eh cioè non so nemmeno potrebbe essere chiaro però questo qui è json pari uno perché è un intero è proprio no dipende dal dallo standard che ci piace però in realtà se noi siamo veramente molto molto superanti e in parser in dart lo è è valido ma non che è per forza perché da da da da sì sì no da standard assolutamente sì però sulla carta ci sono alcuni casi in cui tranquillamente possiamo avere non degli oggetti proprio in teoria se noi avevamo un valore puro direttamente questo è json e non c'è nulla che possa fermarci da questo cioè per convenzione in genere quando un API ritorna qualcosa in json lo fa in un oggetto però attenzione perché la tania anche che sarei già qui e già qui non è vero e questa cosa qui non ci ritorna un oggetto ci ritorna un array direttamente così per cui non sappiamo se è una mappa un array un error perché appunto mi capisco cioè alla fine non è proprio formalmente corretto però se il json è questo è comunque un stream array di far salvo quindi noi all'altro pratico dobbiamo lavorare con il json dobbiamo pregarci per quello che stiamo lavorando dobbiamo sapere esatto dobbiamo sapere i dati con cui stiamo lavorando ma questo in realtà non dipende dal linguaggio questo è anche vero c'è la magia che adatta sappiamo già come è fatto il formato dei dati se l'API cambia è ovvio che poi il nostro client si rompe ma è nella natura delle cose quella quindi dobbiamo partire da qui e capire cosa ci verrà dato quindi ci verrà dato un array di oggetti e ogni oggetto è composta 5 campi per cui per come la vede Dart JSONDecode questo sarà una lista di dynamic ogni dynamic sarà un oggetto quindi ogni oggetto poi internamente è una mappa dove la chiara è una stringa e il valore è un dynamic perché ogni valore chiaramente può essere di tipo diverso e poi qui ci sarà un intero più intero più una stringa più una stringa più una stringa quindi per farla breve qui posso castarla quello che voglio perché Dart si fida ciecamente di me non potrebbe fare altrimenti quindi io faccio foto list la chiamo e quindi questo ritorno al dynamic però io lo butto dentro un list al dynamic e al compiatore andrà bene ovviamente e a questo punto ognuno di questi elementi è in realtà una mappa di string dynamic come dicevo qui per cui possiamo fare foto list questa è una lista quindi ha tutti i metodi della lista c'è un metodo che è cast cast praticamente scorre la lista e cast ogni elemento ha un altro tipo ok quindi posso castare a cosa casto ogni elemento diventerà una mappa di string dynamic ok turist perché avanti così non lo so ah perché no ah l'hai visto come minore di ok quindi questa cosa qui a questo punto questo turist qui ritorna una lista di maps di dynamic a questo punto ognuno di queste istanze di map qui è un oggetto di questo blocco quindi è un oggetto di questo di qui internamente quella mappa avrà un campo albnt un campo id un campo dalbnt un campo url un campo thumbnail url ok va bene a questo punto possiamo lavorarci in teoria e creiamo il nostro modello che accetta questi dati quindi qui ci metto foto item ok qui dentro ci mettiamo è una classe equivalente a to do item per gli effetti quindi sarà ugualmente mutabile ugualmente semplice sarà una ok quindi com'era albo e d quindi albo e d si vende sempre peggio title qui i nomi sono equivalenti ma solo per convenienza per programarsi come vogliamo anzi qui facciamo per dimostrare che non c'è nessun legame ok va bene ci serve un costruttore chiaramente quindi facciamo così ok per convenzione giusto per per convenzione quando si si deve passare del del del json e spacchettarlo dentro un oggetto di solito si fa un metodo un costruttore scusate che si chiama from json un costruttore che non può fare questo from json sempre per convenzione prende in input la rappresentazione come oggetto in json che è quella di prima quindi map string dynamic dynamic che è il nostro pacchetto json che a questo punto possiamo utilizzare per popolare il nostro oggetto lo facciamo qui nella nella nella nella lista di inizializzazione per cui cosa facciamo id è uguale a json accediamo all'elemento id e visto che questo è un dynamic dobbiamo no no è un id è un intero ci arriverà solo penso sì album id json di album id qui come indice eh no perché è una mappa e la chiave è una stringa quindi non non possiamo accedere per posizione e quindi bisogna accedere per forza per chiave e poi non abbiamo garanzia che cioè se accedessimo per posizione dipenderebbe da come cerriano i dati che non c'è garanzia che questo non cambi però per esempio PHP per esempio è molto più come si dice è molto più tollerante a questo punto di vista per cui le mappe in PHP possono essere sia per posizione sia per per a me ok quanto può essere meravigliosa questa cosa lo è adesso non lo vediamo però c'è un modo che non è elegante neanche per idea c'è un modo per fare questa cosa però non è veramente automatico è un è un passo di precompilazione che fa dei passi mistici legati all'esame di build che nel compilarvi il progetto vi autocrea questa serie di di costruttori però tanto vale scriverlo a mano poi se uno volesse potrebbe anche fare il metodo adesso non ci interessa però se se dobbiamo anche scrivere l'oggetto adesso non ci interessa però in genere creeremo no esatto esatto il tojson che non fa altro che ritornare una mappa no così che tojson e a questo punto qui dentro creeremo l'oggetto che rappresenta il photo item ok a questo punto nel provider di nuovo qui allora l'ho castato qui adesso a questo punto devo crearci gli oggetti di cui prima per cui c'è un altro metodo che può fare al caso nostro che è map quindi cast passa nell'iterabile e li casta tutti a map quella mappa lì map è una funzione che viene applicata a tutti gli elementi della lista e fa qualcosa e li elabora in qualche modo per cui essendo tutti gli elementi una mappa di stake dynamic viene abbastanza naturale fare photo item from nason che è il costruttore di prima devo portarlo però a mjson gli passiamo un elemento esimo che è proprio una mappa e a questo punto dopo tutto questo passo di gioia questo tourist qui è una lista di photo item che è quello che volevamo avere in partenza ok quindi questo a questo punto sarà beh magari si è più chiaro prima ce l'abbiamo in json sporco e poi lo lavoriamo e se tutto va bene abbiamo finalmente gli oggetti e a questo punto possiamo ritornare a il sito ok ma come se lo fa in auto cioè lo sa lui nel senso che lui il file provider quando andiamo a dirgli ma dimmi un po' dammi un po' la lista di photo item lui parte dello stato sto aspettando il file provider quindi parte quello stato lì qui questo metro inizia ad eseguire si blocca qui poi fa le sue cose eccetera eccetera quando ritorna qui il file provider diventa valorizzato cioè al suo volo quindi a meno che non lo facciamo con un R6 o ritorniamo l'autunzione il produsione non dipende esatto esatto affinché non avviene qualcosa di finale cioè esplode o ritorna qualcosa di valido è in attesa ok tanto qui ovviamente qui potremmo esplodere in altri modi qui ci sono varie altre opportunità per rompere le cose e oppure potremmo fare delle altre wait chiaramente quindi qui abbiamo tutta la ricchezza del sistema di future di darts che possiamo utilizzare se vogliamo e visto che torniamo a una lista di photo item alla fine il future provider sa che è un future provider di list di photo item quindi alla fine dei conti noi sappiamo che quando questo future provider terminerà nella migliore delle ipotesi abbiamo accesso ai nostri famosi photo item per cui a questo punto vedete che è abbastanza facile a questo punto perché nel nostro gallery page ok questo è già un consumer widget per cui siamo già in grado di fare ref watch di foto ok lo importiamo a questo punto noi sappiamo che questo qui no avrà vedete qui sono dei non c'è più il dato diretto non c'è più subito la lista che potrebbe ritornarci però ci sono dei metodi molto simpatici come is reloading is refreshing is reloading is refreshing is reloading has error has value eccetera con cui possiamo andare a discriminare cosa mostrare dentro la nostra schermata ok questa è un po' l'idea e per mostrarlo c'è un metodo che è quello proprio che si usa in genere che è when che ci permette di discriminare in base a quello che contiene il il nostro provider adesso lo vediamo un secondo allora intanto me lo metto da parte quindi questa è la mia foto foto list diciamo così anche se non è la foto list è ancora un oggetto è una sync value ok quindi un valore async che può avere un valore però non si sa quando adesso qui dentro nel sidebox invece di questo ci mettiamo un no facciamo direttamente così il photo list when when allora di nuovo qui si può parlare la sintassi però una volta che si capisce come funziona è abbastanza facile sono tre builder si sono tre funzioni e funziona come tutti i builder di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di di no watch di qualcosa la list view a un builder che viene costruita quando la lista viene creata viene popolata e questa è la stessa cosa è la build quando cambia qualche modo quindi i casi più comuni sono error che ci viene fornito un oggetto che è l'errore cioè questo builder qui è un builder perché ritorna un widget ottiene le exception e la stack trace, che volendo possiamo mostrare. Però direi che allora, quindi facciamo R e stack trace non la mostriamo, ma non ci interessa. E qui ritorniamo un... Facciamo una cosa brutale, quindi il container... Quindi comunque, queste sono tutte cose che devono ritornare a un oggetto. Esatto, esatto, sempre, perché nella build io devo sempre ritornare un widget, questo non posso fare altrimenti. Poi faccio un center, e il center avrà... Abbastanza espressivo, sì. E qui ci mettiamo l'er, quindi stampiamo anche il testo, così per l'utente può allegrarsi di quello che è successo. Ho fatto sicuramente qualche errore con le parentesi. Perché non gli piace? Ah, beh, che roba zoom. Beh, finiamo che gli altri. Ok, poi loading. Loading è ancora più facile perché è quello che viene mostrato quando non c'è ancora nulla da mostrare, quindi non ha neanche il dato, cioè è proprio una cosa di questo genere qui. Qui facciamo un center, anzi un const center, tanto se lo vuole. E come c'è, ci mettiamo un widget classico che si chiama Circular Progress Indicator, che se lo costruiamo così, molto semplice, è semplicemente il coso che viene. Ok, ultimo caso. La rinunzione è tutta lì. Ok, in questo caso abbiamo la lista finalmente, per cui abbiamo la lista, per cui la funzione è la lista. Ritorniamo l'oggetto e cosa torniamo? Torniamo la list view, ovviamente. List view, che ha un builder, poi, ecco, troppo un po' così. Il filter qui avrà l'indice. Così poi faremo in modo che sia più bello qui, magari. Il filter vuole anche il numero di oggetti. Che è questo, e che è list length, ovviamente. Ok. E poi, beh, ogni oggetto, adesso magari facciamo una cosa breve, però... direi che ci mettiamo semplicemente il titolo, vai. Che è list indexesimo... Ah, sì. Era mezzo funzionale, mezzo no? Ah, sì. Ah, manca il context. Ok. Ah, di nuovo fatto questo errore. Ok. Vi avuto, vediamo se funziona. Ah, ok. Il cellulare non è online. Ok. Non ha neanche la renda, perché questo è un problema. All'iphone, aspetta. Non ho scoperto più. No, ma riesco a collegarmi. No, vai. Poi era un buon modo per dimostrare come ho fatto un errore. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Ok. Adesso parliamo di 27 mila notifiche, Temo. L'ha fatta? Allora qui ovviamente finché sono qui il future provider è già valorizzato, per cui se torno indietro e mostro la galera di nuovo, cioè il future provider non si ricostruisce da solo. Qui è rimasto l'errore di prima e salvo refresh volontari da parte nostra non si aggiusta. Sì, esatto, si aggiunge un pulsante qualsiasi, qua c'è anche lo slide, cioè bisogna fare varie cose per forzare il refresh, che è quello che si fa, oppure un time out che dopo un seconde rifare il refresh, quindi ci sono mille scenari possibili. Direi che c'è speranza. Ok, adesso è in attesa. Magia. Ha caricato 5 mila costi, cioè ha fatto il parsing, l'ha caricati, adesso chiaramente mostra solo il testo, adesso ovviamente la prossima volta cariciamo anche l'immagine, però a questo punto è un gioco veramente facile, nel senso che bisogna fare, anche qui sono vari modi, bisogna fare direttamente, caricare l'immagine come immagine con il widget image di Flutter, perché sono immagini remote, oppure bisogna fare un provider di immagini, anche lì bisogna fare con la famiglia e passare l'url dell'immagine e fare in modo che ad ogni elemento qui ci sia un provider per quella specifica immagine, poi appunto avremmo anche un effetto gradevole in cui ci sono dei blocchetti col caricamento e un provider poi appena ottene l'immagine ce la mostra. Quindi a cascata potete fare in questa maniera. Adesso ci accontentiamo di questo e per mostrare che la cosa cambia, cambia, adesso... Mi ho perso? No, dove? Per mostrare che la fotolist cambia ci mettiamo anche uno shuffle qui, c'è un metodo molto comodo che è shuffle, che semplicemente riordina la lista, per cui vedremo che quando facciamo refresh, che se no non cambia nulla, la lista viene sconfussolata e a questo punto aggiungiamo, come si diceva, un closing action button, un po' incursante qualsiasi. Lo mettiamo qua. Ok. Ok. Ci mettiamo anche del testo. Ok, qui dentro facciamo refresh. Read the gallery. Ah sì, ci sta. Notify... Ah no, sì. Ah no, perché già è spusato. No, è Notify. Non so, non ricordo cosa devo fare. Ah, scusate. No, è proprio... Ho sbagliato un po' di direzione. È qui sotto. Ok, ovviamente. Quindi è direttamente sul ref. Allora, la differenza è questa. Invalidate vi rende... È un po' come l'invalidate di Win32. Cioè lo segnala come non più attuale. Per cui la prossima volta che qualcuno lo legge verrà aggiornato. Però non costringe ad aggiornare. Per cui se facessimo invalidate non si aggiornerebbe fino alla prossima caricamento della pagina. Cioè la prossima volta che qualcuno fa botch. Ok? Quindi è tipo... Dimenticate e poi la prossima volta lo ricarichi. Refresh invece costringe il free provider a ricostruirsi. Perché a questo punto qui facciamo gallery provider. Provider. Così e se tutto va bene dovremmo... Ah, questo è... Sì, allora questo qui è una... Anche il refresh è sempre asincrono sulla carta. Per cui possiamo attenderlo. Non è particolarmente utile, però è così. Ah, ritornato. Ok. Così, è giusto. Questo è completamente inutile perché in realtà il refresh viene scatenato. Chiaramente ha una durata. Per cui adesso qui facciamo questa wait completamente fasullo. Poi, se c'è tempo vi faccio vedere rapidamente uno scenario in cui il fatto che il refresh è awaitable è utile. Cosa che si è rotta qui? Cosa che si è rotta? Che sta? Ok. C'è qualche... Qua si va bene. C'è qualche parentesi che ho completamente... Fatto esplodere. Beh, se funziona... Prima non può essersi rotto adesso. Non è... Ho visto nel void... Ho rotta qui qualcosa. Ah, ok, sì. Ah, sì, scusate, sono scemo io, ma proprio profondamente. Ovviamente è inutabile anche questo, quindi... Stavo tornando... Nulla. Ah, perché fai... Perché sono... Eh... Sono incartato da solo. Ok. Sì, vale buona notte. Scusate, eh. Eh... La stanchezza. Ok. Grazie. Ok, a questo punto forse ce la facciamo. Ok, c'è due user, beh, non ci sono gioco niente. Questa è la tua warning. Ok, ciao. Andiamo. Ok. Ok. Ok. Ok. Ok. Lo carica prima volta e sono scombustolati, però il primo elemento è 1, 2, 90. Se faccio refresh... Ah, no, ok. Refrescia, ma non viene scatenato il... Quindi dovrei farlo a mano, quello del caricamento. Perché mentre... Ah, il problema è questo. Che mentre sta caricando, i dati vecchi non li temi. Sono ancora in memoria, per cui non vedo mai il... Dov'è? Il loading. Adesso, la prossima volta, magari facciamo rapidamente, c'è un modo per farlo in maniera più elegante col trascinamento dall'altro, il pattern pro classico, del UI, no? Che tu trascini verso la sua lista e la lista si aggiorna. In quel caso riusciamo a farlo con un caricamento più elegante. Però il funzionamento, meno male, è questo. Quindi ogni volta che clicchiamo, effettivamente, dietro le quinte viene ricaricato e poi si aggiunga. Potremmo fare una sempre... Potremmo fare una cosa di rispetto, esatto. Questo è un fatto che... Arriva un mondo dalla cache. Sì, sì, esatto. Cioè, mentre... Quando fa refresh, il valore di prima rimane ancora... Rimane in memoria. Poi quando il TripAdvisor si è ricostruito, si rimpiazza. Ok? Possiamo forzarlo a dimenticare lo stato e poi... Però cambia, rettamente, cosa. Questa idea. E mentre chiudiamo, chiaramente lo stato rimane. E quindi, una volta che è costruito esattamente come tutti gli altri provider, non vengono modificati, a meno che non siamo noi a dirgli dimenticati dei dati. Ok. Direi che per questo oggi ci fermiamo qui. E a questo punto rimangono poche cose di celle, da dire volete. La persistenza dei dati, che ancora non ho visto. Vedremo SQLite e scrivere i file in memoria. E poi vedremo un po' di design responsivo. Quindi vedremo tutte queste belle cose che vi stanno finora, come si comportano quando chiudiamo lo schema in genere, se rompono tutte. E vedremo come gestisce alcuni di questi esempi. E mi sa che bene o male, poi ci fermiamo lì. salvo dubbi specifici. E poi, se c'è il tempo, vediamo rapidamente un'occhiata ad Android. Si può supporre che vogliate pubblicare qualcosa su Android potenzialmente. Vediamo il manifesto. Questi sono alcuni aspetti di Android. Allora, lo scritto sul file system, in realtà è con le due preferences. Quello sicuramente lo faremo. E poi faremo... Ok, il file system, non ho idea di adesso, se bisogna forza un nuovo rispetto. Sì, esatto. Bisogna andare a sbloccare la struttura su... Non, non, non, non. Se scriviamo solo su file locali dell'applicazione, quello lo possiamo fare sempre. Quindi quello, un punto, ne parleremo brevemente, quando siamo su ambiente mobile, tipo Android, lì la risposta dei file è un po' più intricata. Ci sono alcuni spazi dedicati in cui possiamo scrivere. quello più semplice è lo spazio locale dell'applicazione che è privato all'applicazione. E quindi neanche l'utente sulla carta vuole scriverci se non tranne dall'applicazione. E poi ci sono gli spazi condivisi dove provo per scriverci e per leggere bisogna avere la provazione del dato. Va bene. Vi auguro un buon più di settimana e poi questa volta ci provo a farcela. Vi carico questo codice ripulito sul... sul... sul prendere così poi se volete potete riprenderlo in mano da qui. No, no, si può fare. Se vi sa... Se a lui vi piace, non è un problema. Quindi potete fare tutto con lo stato dei widget. Non è un problema in sé. che sono due che ha avuto gli anzi che se volete fare... Esatto. No, no, è un esempio. Non è un esempio. Sì, no, capisco molto bene. Cioè, RiverPod... Il scoglio è alto. Cioè, la barriera è abbastanza elevata da superare. Una volta superata poi ha un sacco di agg interne che mi aiutano parecchio. La cosa del CIS provider è molto bella perché fa tante cose in automatico che altrimenti fare a mano diventa... Ma questo è il periodo. Sì, sì, il periodo. Sì, sì. Il periodo è un sacco. Cioè, nel... Potete, in un caso di un'altra... ...dessimo, far una chiamata... ... ...