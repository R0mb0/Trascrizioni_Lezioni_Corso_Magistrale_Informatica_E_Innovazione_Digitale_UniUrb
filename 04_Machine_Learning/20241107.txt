benissimo allora intanto bentornati quello che vediamo oggi è la prosecuzione brevemente vedremo nei primi minuti terminiamo il notebook relativo all'esercitazione della volta scorsa sono rimaste poche cose ma vale la pena ovviamente terminare darci un'occhiata e poi l'altra cosa che vedremo è invece comincieremo un nuovo notebook relativo alla regressione lineare però prima di fare questo riprendiamo brevemente il notebook d'esercitazione 2 vi ricordate vi ho parlato della capacità di vettorizzazione di python e quindi in particolare di numpy per cui diciamo i cicli for sono laddove avete la possibilità di utilizzare l'implementazione nativa siccome questa sfrutta un'ottimizzazione a livello di codice vicino alla macchina che è decisamente sofisticata ed efficiente vale la pena farlo per cui abbiamo visto un esempio se non ricordo male sul prodotto scalare ma è ancora più evidente se noi andiamo a fare questa operazione che è quella di anziché andare a prendere il prodotto ecco questo l'avevamo visto facciamo un'operazione di moltiplicazione tra matrici allora qui in questa cella o quello che è stato codificato è un semplice prodotto tra tra due matrici x e y quindi un'implementazione in cui avete numero di righe numero di colonne di x e di y e poi fate un'interazione sul numero di righe di x un'interazione sul numero di anni data sul numero di colonne di y e quello che fate è semplice e poi la terza iterazione andate ad accumulare il risultato del prodotto riga per colonna quindi la definizione del prodotto riga per colonna quindi se la mandiamo in esecuzione questa è la funzione è la cella relativa alla funzione e qui quello che viene fatto vengono generate due matrici x e y che hanno una dimensione 200 per 200 quindi sono due matrici quadrate 200 per 200 e quello che viene fatto un attimo cerco di annotare direttamente il codice qui vediamo se ce la faccio allora vediamo un attimo non riesco a trovare allora vi dicevo che qui andiamo a generare appunto queste matrici 200 per 200 e poi invece quello che facciamo è attivare i due contatori ne abbiamo due tipi uno misura il wall clock time l'altro cpu time probabilmente sono due cronometri che permettono di misurare il tempo e questa iterazione che utilizza la libreria tqdm serve semplicemente per andare a creare quella barra di progresso nel nell'esecuzione del codice che vi fa vedere a quale percentuale di esecuzione del ciclo siete arrivati e quello che facciamo invece qui è effettuare un duplice cicloforo annidato in cui andiamo a fare una scansione attraverso le colonne e poi le righe e in cui andiamo ad accumulare il risultato in questo modo quindi utilizziamo un non andiamo a invocare direttamente la funzione ma utilizziamo anche qui un un implementazione manuale e quindi abbiamo un ulteriore diciamo possibilità non tramite non tramite la chiamata funzione ma direttamente di implementarlo perché uno potrebbe avere il dubbio che magari è la chiamata funzione che genera dei problemi invece così non è poi invece abbiamo un ulteriore e qui ovviamente chiaramente qui andiamo a vedere il risultato e qui blocchiamo il cronometro e poi andiamo a vedere quanto ci abbiamo messo dopodiché quello che viene fatto sotto ok allora equivalentemente avrei potuto utilizzare questa funzione matrix mull ok che l'abbiamo messa qua sotto ok perfetto benissimo allora quello che viene fatto qui sotto invece è invocare direttamente la funzione di numpy che si chiama matmull avrei potuto scrivere con la chiocciolo avrei potuto scrivere utilizzare l'operatore dot eccetera come abbiamo visto la volta scorsa questa è l'implementazione altamente efficiente che sfrutta la vettorizzazione e andiamo a vedere qui c'è semplicemente un check di qual è la somma perché chiaramente il risultato è una matrice giusto per vedere che la somma dei valori torni è semplicemente una sorta di sanity check per verificare che sia tutto a posto qui ovviamente abbiamo fatto partire il cronometro e qui l'abbiamo fermato di nuovo quindi fino adesso sono due cronometri con due operazioni e poi c'è l'ultimo che sfrutta la funzione che abbiamo implementato sopra quindi tre risultati due con funzioni scritte a mano diciamo e l'altro con funzioni native di numpy ed ecco vedete l'esecuzione vedete tqdm vi dice delle 200 iterazioni dove siete arrivati il risultato è questo cioè la somma dei valori dentro la matrice questo è il tempo di elaborazione questo è il risultato che avete ottenuto con il vettorizzato vedete che i risultati chiaramente sono gli stessi gli algoritmi devono essere chiaramente corretti quindi sono le stesse matrici alla fine però vedete che il tempo di elaborazione sia che voi fate un'invocazione con la funzione che avete scritto sia che utilizzate il codice comunque quei due cicli quei cicli for annidati che noi abbiamo abbiamo costruito all'interno della funzione hanno un tempo di esecuzione dell'ordine di 6-6 secondi laddove il tempo di esecuzione utilizzando solamente la funzione implementata di numpy è dell'ordine di un millisecondo ok questo è chiaramente decisamente un salto di performance notevole quindi il messaggio è utilizzate sempre le funzioni native di numpy e non andate laddove possibile non andate a scrivere del codice che risulta probabilmente molto più inefficiente ok allora qui sotto quindi questo diciamo conclude quello che volevo farvi vedere riguardante la la la vettorizzazione e l'altra cosa che che vi volevo far vedere sì chiaramente quello che non vi ho detto qui è che qui viene utilizzato il tqdm per fare il tracking dell'esecuzione ma chiaramente c'è una prima iterazione lungo la lunghezza di x cioè sono tre cicli for annidati quindi è un algoritmo che ha complessità cubica ovviamente è sempre lo stesso qui invece vediamo introduciamo un'altra libreria molto utile dell'ambiente python che è matplotlib che è una libreria per fare i grafici il plotting qui diamo una breve una breve introduzione ovviamente la cosa migliore come sempre utilizzarle provare vedere che cosa come funzionano e andare a vedere studiare la documentazione se c'è qualche problema uno è a di dubbi ovviamente quello sono di solito tutte queste che stiamo vedendo non paio matplotlib e anche la prossima che introdurremo che sai che sono ben documentate quindi sono un sacco di esempi un sacco di di documentazione ufficiale che spiega bene come funziona qui utilizziamo in particolare un modulo della libreria matplotlib che come sempre accade per queste librerie abbastanza articolate contengono tanti moduli e diciamo questo questo piplot offre un sistema di plotting che è molto simile a chi chi conosce matlab è molto simile a quello ma chi non lo conosce vedrete è abbastanza intuitivo allora per fare questo quello che dovete tenere presente che dovete importare vabbè qui importiamo numpy come sempre e poi importiamo questo appunto modulo della libreria matplotlib lo chiamiamo plt per semplicità per rapidità dopodiché quello che facciamo calcoliamo ad esempio calcoliamo una funzione di cui abbiamo impostiamo le coordinate x e calcoliamo le relative coordinate y quindi la x la definiamo come allora questo comando numpy che cosa fa? vi permette di definire dei punti che sono spaziati in maniera equidistante tra 0 e 6 volte pi greco quindi questo è np.pi è il pi greco spaziati di 0.1 ok? e quindi corrispondono 6 volte pi greco a tre periodi di un'oscillazione sinusoidale che viene definita qua come np.numpy invochiamo la funzione seno applicata a questa griglia di punti dopodiché la cosa più semplice da fare appunto per se vogliamo graficarla è invocare matplotlib in particolare diciamo il modulo pi plot quindi plt ha un metodo una funzione che si chiama plot a cui passate x e y poi invocate la funzione show e il grafico appare ed è questo ok e questo è molto comodo ovviamente con un po' più di diciamo di lavoro quello che potete fare potete fare il plot per esempio di più linee tutte insieme potete aggiungere titolo, leggenda, etichette degli assi quindi per esempio qui viene generato di nuovo lo stesso asse delle x viene calcolata una prima funzione che è il seno che è quella di prima una seconda funzione che è il coseno e poi vengono plottate e quindi viene plottata la riga 10 la prima funzione quindi x y seno la seconda funzione è y coseno in funzione sempre di x poi vedete con il comando xlabel gli passate una stringa che è l'etichetta dell'asse delle x ylabel gli passate un'etichetta dell'asse delle y poi potete mettere un titolo gli passate una stringa con il titolo e anche una leggenda in cui avete due argomenti che sono le due funzioni perché noi andiamo a plottare due funzioni diverse quindi abbiamo due stringhe separate dalla virgola dell'agenda e il risultato è questo possiamo anche nella stessa figura fare dei plot diversi diversificati utilizzando la funzionalità subplot che funziona in questo modo allora di nuovo definiamo le due funzioni y seno y coseno in funzione dell'asse x esattamente come abbiamo fatto prima qui lo facciamo sempre tra prima era tra 6 volte pi greco adesso 3 volte pi greco se non sbaglio quindi va bene a parte la differenza nell'asse delle x che appunto prima era ma no anche qui era 3 volte pi greco mentre qui eravamo partiti da 6 volte pi greco nel primo esempio ok poco male ovviamente non cambia nulla dopodiché quello che si fa si definisce una griglia in questo caso una griglia che ha altezza 2 e ampiezza 1 quindi andremo a definire due subplot ok voi potete anche definire una griglia con più subplot su ogni riga più subplot su ogni colonna eccetera quello che fate è semplicemente settare con il comando subplot questa griglia vedete che ha due elementi e qui stiamo andando a vedere il primo di questi due elementi siccome ha altezza 2 e ampiezza 1 quindi stiamo dicendo che stiamo prendendo in considerazione il primo e qua vedrete che quello che cambia è il secondo ok quindi sono due grafici andiamo a vedere quello diciamo con coordinate 1 1 e poi quello con coordinate 1 2 ok dopodiché imbocchiamo la funzione plot imponiamo il titolo e lui si riferisce al primo e poi andiamo a fare la funzione plot del coseno a cui andiamo a sovrascrivere anche lì il titolo e il risultato è questo se lo mandate in esecuzione chiaramente voi in questo modo riuscite a costruire dei grafici con più plot sotto plot eccetera è molto comodo qui abbiamo l'utilizzo della funzione che permette di fare il plot degli histogrammi si chiama hist e quello che dovete passare a questa a questa funzione è l'array di cui volete andare a plottare l'istogramma e il numero dei beans i beans sono dei contenitori in questo caso sono 40 in cui lui va a mettere praticamente lui va a suddividere l'intervallo in cui ha generato questi in questo caso vengono generati 10.000 numeri con una distribuzione gaussiana di questi 10.000 numeri ovviamente ci sarà un minimo e un massimo lui suddivide quel range minimo e massimo in questo caso in 40 sotto intervalli e va a vedere quanti elementi dei 10.000 che ha generato cadono in ogni intervallo e poi va a plottare l'istogramma quindi è una distribuzione di frequenza in questo caso di questa distribuzione gaussiana quindi ci aspettiamo ovviamente una campana gaussiana poi ci andiamo a mettere un'etichetta che sarà l'asse delle x e sulle y mettiamo per esempio frequenza che è la stringa giustamente poi ripetiamo la stessa cosa anziché avere qui sono 10.000 punti con una distribuzione gaussiana normale quindi valore medio 0 e varianza 1 sigma quadro uguale a 1 qui mettiamo sigma 5 uguale a 10 quindi imponiamo un valore medio diverso e una varianza diversa generiamo sempre la distribuzione normale ma con questo valore medio questo valore di sigma e generiamo questi in questo caso sono 100.000 punti sono molti di più e quindi aumentiamo anche il numero di beams perché possiamo avere una griglia più fine e il risultato quindi saranno due plot e questi due plot vengono fatti sullo stesso grafico e vedete il primo plot chiaramente è la prima gaussiana quella blu che è centrata nello 0 e ha varianza 1 questa è centrata sul 10 perché il valore medio è 10 ha una varianza più ampia perché è 5 gliel'abbiamo imposta vedete che qui vediamo anche che il numero di bin è maggiore perché lui ha suddiviso questo intervallo in 500 parti uguali chiaramente è più fine riesce andare a vedere ogni bin più piccolo va a vedere qual è la frequenza di valori che ricadono in quel bin quindi è più fine la griglia su cui andiamo a vedere questo questo istogramma ma vedete che sono molto significativi perché vi fanno capire immediatamente che tipo di distribuzione di distribuzione statistica si tratta ok oltre a NumPy vi segnalo anche che c'è un altro modulo che si chiama SciPy che è un'altra scusatemi libreria che è un po' un insieme di di di un package che ha sotto librerie una serie di librerie specializzate si interfaccia con NumPy ma sono specializzate per svolgere determinati compiti quindi per esempio l'equivalente dei toolbox in MATLAB diciamo fanno diverse cose qui ve ne faccio vedere una in realtà questa stessa cosa si può fare anche dentro NumPy cioè la trasformata di Fourier per insomma calcolare la trasformata di Fourier la cosiddetta fast Fourier transform qui vengono generati mille punti sempre con distribuzione normale viene importato il package scipy e da lì dentro la la libreria fftpack che è appunto quella relativa ai calcoli sulla trasformata di Fourier viene importato quindi fft dopodiché quello che si fa molto semplicemente è prendere il vostro vettore calcolatela fft in questo modo e andate ad accedere alla parte reale di questa trasformata di Fourier e poi potete fare il plot e questo è il plot vedete la parte reale della trasformata di Fourier quindi con scipy riuscite poi a fare diverse altre cose ma adesso non è non è diciamo parte del nostro programma però sappiate che esista quindi mettendo insieme numpy scipy e anche altre librerie che sono quelle che vedremo a partire adesso dalla seconda parte dell'esercitazione di oggi introduciamo una nuova libreria specifica per il machine learning si riesce a costruire un ecosistema estremamente articolato che che permette di fare diverse cose poi di framework specializzati per il machine learning ce ne sono diversi vedremo vedremo soprattutto lavoreremo con scikit learn avremo modo anche di vedere prima della fine un'esercitazione dedicata a tensorflow che è un framework molto popolare per le reti neurali anche quello non è l'unico riparleremo più avanti però insomma una panoramica alla fine direi che avremo modo di averla su tutte queste cose va bene allora allora adesso apriamo questo nuovo notebook che trovate sempre su blended learning quindi il file lo avete lo potete ripercorrere quindi di nuovo vi ricordo l'utilità di andare a ripercorrere queste cose quindi usare questo codice come base per esplorare un po' questi strumenti e oggi cominciamo un po' a vedere appunto come implementare alcune cose che già nelle lezioni di teoria abbiamo visto già da un po' nella fattispecie la regressione lineare quindi diciamo cominciamo a ripercorrere alcuni degli argomenti che abbiamo visto nelle lezioni di teoria anche anche sull'esercitazione e quindi vedremo l'implementazione di alcuni di questi di alcuni di questi modelli tramite un codice python in questo caso oggi vediamo la regressione lineare la vediamo in due modi prima con un'implementazione che sfrutta numpy e in particolare un'implementazione delle quelle che abbiamo chiamato equazioni normali perché vi ricordo che la regressione lineare tramite funzioni di costo ai minimi quadrati è uno dei pochi modelli per i quali riusciamo a ricavare una soluzione in forma chiusa e questo prende il nome di equazioni normali poi vediamo anche come utilizzare la libreria scikit-learn che introdurremo per risolvere lo stesso problema allora intanto procediamo per ordine mandiamo in esecuzione il primo la prima cella di questo di questo blocco di codice allora qui quello che possiamo dire è questo allora la prima cosa che possiamo notare è che va bene importiamo matplotlib l'abbiamo visto poco fa proprio la libreria per per per la grafica accanto a questa non è strettamente indispensabile però in questo caso implementiamo scusatemi importiamo quest'altra libreria grafica che si chiama seaborn la importiamo come con il nome di sns e qui semplicemente settiamo i valori di diciamo di default di questa libreria ma allora non è strettamente necessaria però vi permette di arricchire le funzionalità di matplotlib per esempio poi la utilizziamo creando dei grafici abbastanza anche questi estremamente diciamo dall'aspetto oltre che grafico estremamente professionale gradevole ha anche delle funzionalità ulteriori perché poi vedremo per esempio un esempio di un grafico che si chiama pair plot che permette di fare delle cose non banali con poche linee di comando e poi importiamo un pair ok fino a qui fino a qui è standard poi quello che quello che facciamo adesso qui è questa cosa generiamo una serie di dati che sono così strutturati allora la prima cosa questa scusate riprendo l'armo momento di annotazione ok la prima cosa vi dicevo che facciamo qui alla riga 1 è settare il generatore di numeri pseudo casuali settarlo attraverso un seme fisso che permette di garantire la riproducibilità di tutte le cose che facciamo cioè nel momento in cui settiamo il generatore di numeri casuali a quel valore siamo sicuri che tutti i valori che vengono utilizzati poi che vengono generati dal generatore di numeri casuali da lì in avanti potranno essere rigenerati allo stesso modo anche quando avremo chiuso il notebook e l'avremo riaperto in un'altra per un'altra istanza a partire da questo stesso sito ok l'altra cosa che possiamo vedere è che vengono generati 50 numeri qui con la funzione RAM che vi ricordo li genera uniformemente tra 0 e 1 vengono generati 50 valori e e poi vengono moltiplicati per ognuno di quei valori per 10 dopodichè quello che viene fatto quindi qui stiamo settando vedete l'asse delle x è come se io prendessi dei valori tra 0 e 1 quindi in realtà poi diventano dei valori tra 0 e 10 perché li moltiplico per 10 e vado a prendere in questo intervallo un certo numero di valori casualmente che sono 50 dopodichè quello che facciamo con ognuno di questi valori di x lo andiamo a moltiplicare per 2 e ci togliamo 5 quindi stiamo costruendo una retta y uguale 2x meno 5 poi a questa retta aggiungiamo a ognuno di quei valori ulteriore rumore casuale tra 0 e 1 e adesso andiamo a vedere il risultato il risultato sarà saranno dei valori che sono distribuiti lungo una retta quindi saranno una cosa stiamo facendo una cosa di questo tipo noi stiamo creando dei valori che hanno allora una distribuzione che idealmente si appoggia sulla retta y uguale 2x meno 5 io sono andato a cercare nell'intervallo tra 0 e 10 una 50 punti ok per ognuno di questi 50 punti sono andato a vedere quanto vale il corrispondente su questa retta e ci ho aggiunto del rumore che li fa saltare un po' sopra un po' sotto questa retta poi andiamo a vedere con il comando scatter che cosa succede comando scatter che cosa fa vi genera dei punti quindi per ogni coordinata x per ogni coppia x y vi va a mettere un punto alla coordinata x virgola y la differenza con il plot è che plot unisce i punti mentre scatter vi vi disegna solamente il punto queste sono due print in cui andiamo a stampare la shape quella che è la forma degli array che abbiamo generato e qui quello che facciamo vedrete che quelli che generiamo siccome sono degli array numpy sono degli array vi ricordate la volta scorsa ve l'ho detto che sono hanno una shape che sarà semplicemente in questo caso 50 virgola invece con questo comando new axis quindi quello che trovate alle righe 7 8 è nulla di più che la la possibilità di aggiungere una dimensione e quindi a quel punto vedrete che la shape diventerà da 50 lo scrivo da 50 virgola niente passerà a 50 virgola 1 questo ci serve per comodità di manipolazione cioè noi esplicitamente diciamo che a quel punto non lavoriamo più con un vettore ma lavoriamo con una matrice che ha una dimensione però pari a 1 quindi è sempre chiaramente un vettore da un punto di vista matematico ma da un punto di vista di numpy questo è un array diverso da questo come dimensione e ci serve per poi far tornare insomma tutti i conti perché quello che vogliamo fare è poi adesso lo andiamo a vedere implementare il modello però intanto generiamo i dati e vediamo che cosa succede ok vedete che succede esattamente quello che vi avevo detto vedete abbiamo generato questi 50 punti tra 0 e 10 di ognuno coordinate x y siamo andati a fare lo scatter plot quindi a identificarlo e vedete sono appoggiati lungo questa retta che è esattamente quella che vi anticipavo prima questa è la retta che idealmente c'è sotto ed è quella che come obiettivo vogliamo ritrovare poi nel quando andiamo a fare adesso la regressione queste sono le shape che vi dicevo questa è la shape dei dati come li abbiamo generati e questi sono quelli che invece abbiamo aggiunto una dimensione quindi poi è 1,50 adesso faremo la trasposta ok benissimo allora regressione lineare il nostro modello è il prodotto scalare tra il vettore delle feature x e il vettore dei pesi dove il vettore delle feature ha in cima un 1 quindi è 1 e poi la feature 1 la feature 2 eccetera ok l'implementazione tramite le equazioni normali e qui l'occasione per andare a ripassare se non ve lo ricordate quello che abbiamo visto quando abbiamo parlato delle equazioni normali è che noi sappiamo ricavare il vettore dei pesi w in maniera analitica in forma chiusa una volta che abbiamo costruito la matrice x la matrice x è una matrice che vi ricordo ha una prima colonna con tutti 1 e poi ci sono x1 x2 x3 tutti i vettori del vostro dataset quindi vi costruite quella matrice e poi quello che fate è prodotto della matrice trasposta con se stessa ricavate la matrice inversa prodotto per x y è il vettore in cui avete tutte le etichette quindi le varie risposte per ognuno dei in questo caso sono 50 punti per ognuno dei 50 punti noi dobbiamo sapere chiaramente qual è il valore corrispondente di y ma lo sappiamo in questo caso li abbiamo chiaramente generati noi quindi quello che stiamo facendo è costruire un modello a partire da quella distribuzione di punti abbiamo 50 punti bidimensionali in due dimensioni conosciamo il valore delle due feature delle due coordinate della unica scusatemi coordinate perché è unidimensionale non due dimensioni è una sola e sappiamo la risposta ok quindi sono delle feature unidimensionali sappiamo per ogni elemento di x qual è il corrispondente valore di x ok e questo è il codice che implementa questa formula qua allora prima cosa facciamo la la trasposta di x quindi il nostro e andiamo a stampare la shape e quindi andiamo a vedere che cosa intanto intanto lo mando in esecuzione poi guardiamo il risultato un po' alla volta vedete la prima cosa che facciamo siamo arrivati qua e la shape e abbiamo 50,1 abbiamo 50 punti ok ognuno dei quali ha una sola coordinata una sola ficcia dopodiché quello che andiamo a fare è andare a generare un certo numero di 1 in particolare quanti beh quant'è la la forma qui andiamo a prendere shape di x virgola 0 che è 50 quindi noi andiamo a generare 51 e li mettiamo in un vettore che chiamiamo once dopodiché andiamo ad appendere questo vettore once davanti al vettore x quindi andiamo a creare la matrice che è quella che abbiamo chiamato matrice dei dati ok che è proprio questa che è la matrice in cui avete vi ricordo 1 1 1 e poi qui avete scusate me la scrivo ne avete tanti quanti sono ovviamente i punti e poi qui avete scusate quant'è la dimensione qui avete x1 x2 e qui avete xp punti ok questa è la cosiddetta data matrix dopodiché quello che fate è questo allora andiamo eravamo arrivati alla riga 6 alla 7 l'abbiamo creata abbiamo detto y è la trasposta di del vettore delle risposte quindi quello era l'avevamo generato come 1 50 adesso chiaramente 51 e poi andiamo a stampare le dimensioni quindi abbiamo per riepilogare la matrice x che è 50 righe e due colonne ok quindi e y che è 50 righe e una colonna quindi è in realtà direi la trasposta di questa perché se noi mettiamo il numero il numero di di punti sono 50 in questo caso quindi è 50 ok direi che sì no è corretto fatemi pensare sì 50 righe due colonne perfetto ok sì sì 50 righe due colonne quindi in x abbiamo i 50 punti ok per ognuno dei 50 punti io 1 e la coordinata x 1 e la coordinata x 1 e la coordinata x ok se avessi avuto altre coordinate avrei avuto la coordinata x1 la coordinata x2 la coordinata x3 eccetera per y o per ognuno di quei punti la corrispondente il corrispondente valore di y1 y2 fino a y2 e sono 50 quindi la dimensione ecco adesso andiamo a vedere che cosa la dimensione del del mio problema è qua e adesso quello che vado a fare vado a costruire che cosa vedete prendo x faccio x trasposto per x perché facciamo x trasposto per x invochiamo la funzionalità di matplotlib per andare a effettuare questo prodotto tra matrici quindi utilizziamo matmull quindi stiamo facendo x trasposto per x e vi ricordo che questo è equivalente a un sistema poi di la risoluzione di un sistema di equazioni lineari quello che stiamo facendo ma adesso ci arriviamo tra poco e la cosa interessante è che quindi dobbiamo fare vi ricordo x trasposto per x ok e il risultato lo chiamiamo a va bene quindi questo lo chiamiamo a poi facciamo x trasposto per y il risultato lo chiamiamo b ok e lo eseguiamo quindi questo è a e questo è b e andiamo a vedere quali sono stampiamo anche quali sono le dimensioni di a e b e andiamo a vedere le abbiamo stampate più sotto e vedete che la dimensioni di a e b sono queste a è una matrice 2 per 2 perché è una matrice 2 per 2 perché è x trasposto per x e x trasposto per x chiaramente è 2,50 per 50,2 il risultato è 2 per 2 abbiamo una matrice x che ha dimensione 50 per 2 quindi x trasposto ha dimensione 2 per 50 questo viene moltiplicato per una matrice 50 per 2 e chiaramente il risultato del prodotto riga per colonna ci dà una matrice 2 per 2 ok e questa è la dimensione di a b b è il risultato di una matrice che ha dimensione di un prodotto tra una matrice che ha dimensione 2 per 50 per un vettore che ha dimensione 50 per 1 numero di righe della prima scusate il numero di colonne della prima è uguale al numero di righe della seconda deve essere e di nuovo questi due numeri mi danno la dimensione 2 per 1 del risultato che è quello che voglio ottenere e intanto abbiamo fatto un check delle dimensioni che è quello che ci aspettiamo ok poi che cosa facciamo beh calcoliamo il risultato il risultato è semplicemente né più di meno né più né meno scusatemi forno un attimo su la risoluzione di questo che è un sistema lineare questo è un sistema lineare in cui noi abbiamo questa che è la matrice eh l'avevo scritto prima scusate questa è la matrice appunto A questo è il vettore B e noi vogliamo ricavare la nostra incognita questa è la soluzione del sistema lineare A per X uguale B dove X in realtà scusatemi chiamiamolo A per W uguale B perché è W che è la vostra incognita e quindi che cosa facciamo molto semplicemente invochiamo la adesso cancello un po' di cose perché qui se non si legge più invochiamo alla riga 15 la funzione solve l'abbiamo vista la volta scorsa la volta scorsa scusate della libreria l'inalg l'inampai che prende la matrice A prende il vettore B e vi restituisce la soluzione del sistema lineare di equazioni A per X uguale B lo scrivo in modo che rimane in questo caso non è A per X ma è A per W per evitare confusione ok A per W uguale B e questo W io qui ho chiamato W star N E perché sta per dire è un vettore W che è il risultato del tuning della regressione lineare N E per dire che è normal equation ok per ricordarci che l'abbiamo calcolato con l'equazione normal qui alla riga 16 andiamo a vedere qual è la dimensione perché lui ci restituisce chiaramente un vettore allora questa è abbiamo detto 2 per 2 questa è 2 per 1 anche W sarà 2 per 1 e infatti se andiamo a vederla la sua shape è 2 righe e 1 colonna e quanto vale questo vettore allora il risultato lo andiamo a stampare questo vettore ha due componenti questa è la prima e questa è la seconda che cosa rappresentano quei due numeri rappresentano esattamente i pesi che sono la soluzione del problema ai minimi quadrati della regressione lineare che noi abbiamo abbiamo risolto in questo modo tramite le equazioni normali e guarda caso questo è meno 4,998 che è quasi 5 chiaramente a meno di un'approssimazione che il risultato questi sono algoritmi numerici quindi chiaramente hanno delle approssimazioni numeriche che si portano dietro ma è 5 quindi questa è l'intercetta quindi è il il termine di bias quindi quello che abbiamo sempre chiamato W0 scusatemi l'abbiamo chiamato non W0 l'abbiamo chiamato B quando abbiamo quando abbiamo introdotto la teoria comunque è quello è il termine di bias e queste due due che cos'è? mi ricordo da dove siamo partiti siamo partiti da una retta che aveva una pendenza 2x meno 5 5 è esattamente il termine di bias meno 5 e 2 esattamente la pendenza a meno di approssimazione numerica della retta quindi abbiamo trovato esattamente quello che volevamo e adesso per ulteriore verifica quello che possiamo fare è questa operazione abbiamo quindi questo è quello che di fatto è il nostro modello il nostro modello è rappresentato da questo insieme di pesi in questo caso molto semplice perché è un vettore di due elementi noi questo punto lo possiamo congelare mandiamo in produzione il nostro modello di machine learning e possiamo testarlo testarlo cosa significa? significa che arrivano dei punti nuovi di cui vogliamo fare la predizione della regressione questi punti nuovi li generiamo in questo modo li generiamo tramite il comando la funzione scusatemi l'in space generiamo 100 punti tra 0 e 10 equispaziati ok questa è una notazione equivalente a questa qua qui semplicemente introduco con questa notazione non un qualcosa in cui semplicemente vado ad aggiungere una dimensione quindi come al solito qui cosa succede che genero un vettore che è 100 virgola come dimensione mentre qui esplicitamente dico che quello è un 100 virgola 1 quindi è un array numpy in cui dico esplicitamente che ha due dimensioni questo per comodità proprio di come abbiamo gestito tutto il codice devono tornare le dimensioni altrimenti non non vi funziona e qui generiamo una print che ci dice qual è la shape dell'oggetto che abbiamo appena generato ed è effettivamente vedete 100 virgola 1 ok abbiamo generato 100 punti tra 0 e 10 in un intervallo tra 0 e 10 dopodiché stampiamo di nuovo il valore del che avevamo ricavato qua sopra per semplicemente per averlo di nuovo sopra il grafico e qui sotto andiamo a fare un grafico in cui stampiamo la x versus quindi la y versus la x quindi di nuovo uno scatter plot vedete qui semplicemente gli dico che voglio che mi generi dei punti blu che sono dei cerchi ok e sono questi in blu che avete che lui ha generato qui sotto quindi questo è lo scatter plot fondamentalmente ok un altro modo per generare lo scatter plot quello che prima avevamo generato con la funzione che avevamo chiamato scatter ok lo posso generare anche con invocando semplicemente plot a cui passo il colore questa è la codifica del colore blu e passo il tipo di marker che è una e lui mi genera questi punti o una volta che ha generato quei punti noi cosa facciamo andiamo a prendere il nostro modello ok e qui c'è un comando plot in cui andiamo a passare come x quelle che abbiamo sono la nostra x di test sono tutti quei 100 punti tra 0 e 10 che abbiamo generato equispaziati e per ognuno di questi andiamo a vedere il nostro modello cosa ci dice qual è la risposta del modello la predizione del modello è chiaramente qualcosa che sarà questo cioè la risposta del modello sarà che cosa vi ricordo w star per x ok w star chiamiamolo di 1 quindi più w star di 0 ok questo è il bias il termine di bias questa è la feature touching weight feature touching weight ok e quindi qui stiamo costruendo l'equazione della retta y uguale a x più b in cui andiamo a mettere come x i valori di x che abbiamo generato che chiamiamo x di test e andiamo a mettere come pesi i pesi che abbiamo trovato nel nostro modello con le equazioni normali e il risultato lo andiamo a plottare in rosso mettiamo un'etichetta che è quella delle equazioni normali e il risultato vedete come abbiamo ottenuto questa retta rossa l'abbiamo ottenuta tramite il comando plot questi sono tutti i punti e il risultato dei 100 punti che io ho generato equispaziati tra 0 e 10 per ognuno di questi sono andato a vedere qual è il corrispondente valore e l'ho graficato nella retta rossa e questo è il fit migliore di quella distribuzione di punti ok quindi abbiamo visto come possiamo con le equazioni normali con NumPy andare a risolvere un problema di regressione lineare la cosa che vediamo adesso è come la stessa cosa possa essere fatta utilizzando una libreria che introduciamo adesso che useremo anche nelle prossime esercitazioni che si chiama Scikit-Learn Scikit-Learn è una libreria estremamente versatile che viene utilizzata per tantissimi tantissimi problemi di machine learning quindi per la costruzione di tanti modelli di machine learning che diciamo principalmente per quasi tutto quello che ha a che vedere con i modelli lineari si ferma al ai modelli in realtà c'è un supporto anche ai modelli non lineari quello che intendevo dire si ferma e non include il supporto tranne pochissime poco direi giusto qualcosa sulle reti neurali perché lì ci sono dei framework specializzati però solo per quello però tutto il resto ci sono un sacco di cose a vedere che la useremo oggi per la regressione poi per i classificatori lineari quindi regressione logistica support vector machines quindi diciamo la classificazione lineare e non solo perché le svm diciamo hanno anche la possibilità di di utilizzare con dei trucchi la la non linearità ma offre il supporto e lo vedremo anche quello per il non supervisionato quindi per esempio per il clustering riduzione della dimensionalità quindi diciamo è una libreria molto versatile e potente è una libreria open source ha diversi tra l'altro tool per fare il pre-processing dei dati la selezione la valutazione dei modelli insomma un sacco di utilità ci sono dentro quindi avremo modo di vederne alcuni alcuni alcuni aspetti nel corso delle esercitazioni queste le prossime e cominciamo a vedere un po' un po' di funzionalità già da oggi allora qui prima cella non facciamo niente di nuovo se non rigenerare la stessa lo stesso insieme di punti quindi cerchiamo di risolvere sempre lo stesso problema e lo stesso problema è vogliamo trovare il miglior fit di questa nuvola di punti ok? quindi sempre lo stesso problema e vediamo come lo risolviamo anziché scrivere noi le equazioni normali tramite la libreria e il funzionamento è molto semplice si fa l'import come per Numpy quindi prom sklearn che è la libreria scikit-learn linear model linear model è la sottolibreria che contiene i vari modelli lineari importiamo linear regression che è proprio il modulo che è deputato al calcolo della regressione lineare la prima cosa che facciamo è definiamo un oggetto che chiamiamo model tramite appunto la chiamata a linear regression quindi model è un modello della classe linear regression ok? quindi effettuiamo questa chiamata a linear regression che ci permette appunto di definire l'oggetto model e questo oggetto viene generato con il parametro fit intercept uguale true perché vogliamo anche il fitting del bias ovviamente noi questo del termine di bias ok dopodiché facciamo un controllo andiamo a vedere qual è la shape di x qual è la shape di y la modifichiamo aggiungendo come al solito un'ulteriore dimensione perché questi saranno 50 virgola e invece vogliamo che diventino 50 virgola 1 ve lo mando in esecuzione intanto vediamo l'output ecco vedete da 50 virgola 50 virgola nulla intendiamo ovviamente vogliamo generare dei vettori degli array che siano array numpy 50 virgola 1 dopodiché che cosa facciamo? abbiamo creato l'oggetto model l'oggetto model si porta dietro una serie di metodi tra cui il metodo fit allora il scikit-learn funziona in maniera molto semplice vedrete che c'è una una costante nel anche nella sintassi e poi anche nella semantica dei vari delle varie funzioni di scikit-learn e la costruzione del modello prevede che si vada a definire l'oggetto secondo una determinata classe che è la classe in questo caso linear regression poi questo si porta dietro dei metodi i metodi più utilizzati che utilizzeremo sono il metodo fit fit fa l'addestramento di quel modello sui sul dataset di addestramento e poi a questo seguirà vedrete il modello predict quindi definizione dell'oggetto poi fit e predict fit e predict fanno l'addestramento e la predizione allora vediamo come funzionano in questo caso per la regressione lineare noi passiamo al metodo fit due parametri ok che sono l'array numpy che contiene la x e l'array numpy che contiene la y ok la x dobbiamo dire vai a prendere tutti quei 50 punti e aggiungici un asse perché se no non funziona cioè lui come primo vuole un array 50,1 come primo parametro mentre per y va benissimo la shape il vettore diciamo colonna 50 virgola ok ci siamo fin qui questo è proprio come deriva dal da come sono state costruite le queste funzioni quindi il primo parametro che è la x deve essere un array numpy di dimensione 2 in questo caso e il secondo è la risposta che è sufficiente che sia un vettore di dimensione 50 quindi un vettore colonna quindi questo il primo parametro è un array numpy scusatemi siamo qui a model fit è un array numpy il secondo è un vettore numpy dopodiché rifacciamo quello che avevamo fatto prima costruiamo x test che sono quei prima avevamo fatto 100 punti quindi abbiamo messo 1000 era 0 e 10 andiamo a vedere qual è la la shape se ci aggiungiamo un un'ulteriore dimensione e quello che facciamo è invochiamo il metodo predict a cui passiamo un solo vettore che è il vettore di test sono questi 1000 punti qui con il comando new axis vi ricordo che gli aggiungiamo una dimensione cioè è un vettore che a questo punto è 1000 virgola 1 questo è il vettore che gli passiamo qua dentro come test poi y invece è un vettore 50 virgola e questo è un array x il primo parametro che gli passiamo di dimensione 50 virgola 1 ok questo è come va bene ok diciamo in notazione matematica si usano le parentesi quadre se voi andate a fare la shape vedete ve la restituisce tra parentesi tonde quindi dobbiamo scegliere se utilizzare la notazione matematica o quella di numpy diciamo che facciamo così così almeno ok lasciamo quella matematica che è più va bene più coerente quindi y test che cos'è sarà un vettore di 1000 punti uno per ogni valore della x secondo il modello di regressione lineare quindi all'interno che cosa fa questo codice questo codice numpy va a invocare questo metodo fit e il metodo fit va a implementare le equazioni normali oppure in realtà dentro c'è anche altri metodi perché può andare a lavorare anche con metodi di scesa del gradiente perché poi lavora anche con funzioni di costo differenti quindi diciamo poi lì dentro andando a vedere la guida del metodo fit della regressione lineare riuscireste a vedere che ci sono una serie di opzioni nel cui dettaglio non entriamo però ecco lì dentro viene implementato comunque il modello di regressione lineare viene risolto e addestrato e andiamo a vedere qual è il risultato il risultato lo andiamo a vedere tramite la funzione scatter con cui andiamo a plottare x test e y test vi ricordo che y test l'abbiamo ricavato in base al modello di cui abbiamo fatto il fitting ok e andiamo a vedere intanto il risultato il risultato del grafico è questa cosa qua che è esattamente quella che chiaramente ci aspettavamo è la stessa che abbiamo fatto prima però l'abbiamo ottenuta in maniera molto semplice tramite la libreria scikit-learn se voi andate a prendere model model ha quelli che vengono chiamati degli attributi allora model è un oggetto che noi abbiamo istanziato e che si porta dietro una serie di cose tra cui appunto un attributo che si chiama cof0 cof0 che cos'è? è il 2 ma il 2 è chiaramente il bias scusatemi non il bias è la pendenza la slope della retta mentre l'intercetta è il bias ok e li ritroviamo sono 2,02 e meno 4,99 vedete a meno dell'approssimazione numerica ritroviamo quel 2 e il meno 5 che sono la pendenza della retta e l'intercetta il modello è sempre lo stesso chiaramente lo ritroviamo sono domande? quindi l'attributo cof sarebbe il vettore dei pesi giusto? questo tutti e due sono il vettore dei pesi esattamente solo che il primo si il primo è solo il peso di bias esattamente il secondo il secondo il primo è il feature touching weight questo è il bias perché questa è il tercetta ok quindi qui avete invece il feature touching weight ok ok si poi se andate a vedere la funzione di libreria insomma dovreste riuscire a a trovare un po' di ulteriori dettagli anche qui il mio invito è un po' andare a curiosare andare a vedere come nella documentazione insomma quello che c'è che vi può essere utile per avere ulteriori dettagli io adesso vi faccio una panoramica per vedere come vengono quali sono i costrutti come vengono utilizzati nella loro versione diciamo di base per ottenere il risultato poi alcuni dettagli li potete li potete anche andare a vedere ci sono ci sono diverse cose che si potrebbero aggiungere ma ovviamente che per motivi di tempo non riusciamo a vedere invece se non avete altre domande mi piaceva andare avanti e farvi un ulteriore esempio su quello sempre di regressione lineare quello che abbiamo visto ora è un esempio ovviamente simulato sintetico abbiamo generato noi dei dati lungo quella retta adesso prendiamo un dataset reale che è un dataset molto utilizzato lo riuseremo anche quando facciamo l'esercitazione sulla classificazione è un classico diciamo dell'analisi statistica dei dati che è il cosiddetto dataset di Iris dove l'Iris è un fiore ok questo è un dataset che è stato studiato credo all'inizio del secolo scorso da uno statistico britannico se non ricordo male allora in questo dataset sono stati raccolti i dati relativi a tre a tre fiori sono tre varianti del fiore dell'iris sono rispettivamente iris setosa iris versicolor e iris virginica in particolare hanno preso 150 campioni di questi fiori divisi più o meno in maniera più o meno e qui diciamo bilanciata e di ognuno sono stati misurati la lunghezza del petalo e del sepalo il sepalo per chi non lo sapesse è quella parte del fiore che diciamo determina il calice cioè i vari sepali formano il calice del fiore che regge poi i petali ok quindi sono degli attributi fisici misurabili di queste piante di questi fiori ok siccome abbiamo detto lunghezza e larghezza di petalo e sepalo sono quattro attributi quindi sono quattro feature quindi quello che hanno fatto hanno preso 150 fiori di queste tre tipologie e ne hanno misurate la lunghezza di petalo e sepalo ok e poi questi sono stati chiaramente tradotti in un in un in un in un in un dataset digitale digitalizzati e messi in un array in un pi array a cui potete accedere direttamente da scikit-learn cioè scikit-learn vedrete adesso ve lo faccio vedere si porta dietro un po' di dataset di prova per per per imparare un po' a a lavorare con con il con con la libreria poi potete ovviamente mettere dentro anche i vostri dataset ma quelli sono quelli ovviamente di default che si porta dietro tra cui si porta dietro questo questo dei dataset di Iris ok allora qui oltre a questo vi faccio vedere un altro strumento di cui non avremo occasione di di vedere altre cose ma che mi sembra comunque non avremo tempo di entrare nel dettaglio però mi sembrava opportuno menzionarvelo perché viene molto utilizzato in ambito data science per l'analisi dei dati si chiama pandas ha tantissime funzionalità quindi anche qui ci si potrebbero spendere svariate lezioni non è l'obiettivo chiaramente questo però adesso giusto ve lo faccio vedere perché serve per organizzare i dati cioè si interfaccia bene per esempio a numpy perché permette di creare delle tabelle di andare a estrarre dei dati da queste tabelle in maniera abbastanza efficiente allora qui alla questa cella che cosa facciamo guardate vi faccio vedere semplicemente alcune non vi do proprio i dettagli riga per riga perché poi ripeto se avete qualche qualche dubbio magari potete chiaramente chiedere ci ritorniamo sopra però fate prima forse andare a vedere da soli alcuni alcuni dettagli però va bene questo è semplicemente un un settaggio della libreria seaborn che andiamo a utilizzare adesso cioè abbiamo fatto l'import di quella libreria serve per generare questo plot che andiamo a vedere adesso e questo plot prende come input una struttura dati che è il cosiddetto data frame che è una struttura dati propria di questa libreria che si chiama pandas ok quindi aggiungiamo un po' di cose per farvi vedere anche un'idea di cosa fanno questi framework però non sono strettamente necessarie quindi noi potremmo fare la regressione semplicemente senza utilizzare pandas senza utilizzare seaborn utilizzando semplicemente scikitler come abbiamo fatto fino adesso scikitler scusatemi pandas e seaborn servono per generare questi grafici che sono abbastanza carini che vi faccio vedere adesso e secondo me sono significativi perché vi fanno capire molto di come è strutturato un dataset e quindi mi sembra significativo farvelo vedere però ecco non entriamo nel dettaglio di tutto vi dico solamente che questa libreria la potete importare molto molto semplicemente in questo modo import pandas as pd quindi la chiameremo pd qui settiamo un po' di opzioni di visualizzazione cioè le tabelle che pandas gestisce le possiamo andare a visualizzare a monitor qui gli diciamo semplicemente che vogliamo al massimo 20 righe e 30 colonne il resto lui lo compatta metterà dei puntini per dire se mi chiedi di visualizzare più di 20 righe io te ne metto al massimo 20 e ti faccio ti dico che in mezzo ci è qualcos'altro l'ampiezza dello stesso delle finestre 100 cioè sono tutti dei valori per settare la visualizzazione quindi quando va a fare il display dei dati dopodiché importiamo scikit-learn l'abbiamo già fatto non ci sarebbe bisogno ma lo importiamo qui qui importiamo il modulo datasets e dal modulo datasets vedete importiamo loadiris loadiris è semplicemente il comando che vi genera poi l'oggetto iris che contiene tutti i dati che vi dicevo prima cioè è un array o meglio da lì possiamo estrarre un array di 150 punti ognuno con 4 feature infatti alla riga 16 e 17 vedete quello che facciamo noi accediamo all'oggetto iris e il campo data è esattamente un array numpy di 150 elementi ognuno dei quali ha 4 feature quindi questo è un array numpy 150,4 e con punto target noi accediamo a che cosa? a quello che ci possiamo aspettare cioè quello è un oggetto che contiene per ognuno di quei 150 fiori le 4 misurazioni e anche una classe cioè questo ci permette anche di risolvere un problema di classificazione se vogliamo noi adesso questo in realtà non lo useremo perché oggi parliamo di regressione ma ci torneremo sopra quando parliamo di classificazione perché y è un vettore 150 di 150 elementi ognuno dei quali ha una classe 0 1 o 2 e questa classe è rispettivamente che il fiore si tratti ci dice se il fiore si tratta di un fiore di iris virginica di iris versicolor o di iris setosa ok poi facciamo la print della shape di questi di questi oggetti e andiamo a vederlo mandiamo magari in esecuzione così intanto vediamo che cosa fa poi fa anche altre cose ma le vediamo dopo ok l'abbiamo mandato in esecuzione e vedete il risultato è qui ci fermiamo qua cioè fino adesso quello che abbiamo fatto è stampare la shape e vedete la shape è quella che vi dicevo stampiamo la shape di x che è 150,4 e la shape di y che è 150 quindi sono dei dati quadridimensionali abbiamo 4 feature abbiamo 150 punti e per ognuno dei punti sappiamo anche la classe quindi qual è il fiore questa cosa della classe in realtà non la usiamo perché oggi ci interessa fare la regressione la useremo quando faremo la classificazione perché se non ricordo male avevo preparato proprio un esempio su questo dataset sempre ci siamo fin qua cosa stiamo facendo adesso vi faccio vedere brevemente alcune funzionalità di pandas ma molto così giusto per farvi vedere che cosa può fare al volo crea queste tabelle queste che vengono chiamate data frame ne creiamo uno con il comando data frame a cui passiamo un primo parametro che è il nostro array numpy in cui ci sono i dati e un secondo parametro in cui definiamo le colonne le colonne vedete le chiamiamo noi come vogliamo sono delle stringhe che definiamo noi in questo caso sl sta per lunghezza del sepalo ampiezza del sepalo sepalo width lunghezza del petalo ampiezza del petalo petal width quindi noi associamo delle colonne a questi dati quindi sono quattro feature ognuna delle quali noi ci associamo un'etichetta e definiamo quello che in pandas viene chiamato un data frame questo data frame lo chiamiamo df dopodiché possiamo andare a definire in questo data frame delle label e queste label sono proprio i nomi l'oggetto iris si porta dietro dei nomi target che sono rispettivamente lo vedrete proprio iris setosa iris virginica eccetera eccetera se vado a fare la stampa vedete ottengo questo questa è la stampa del data frame pandas questo è un data frame vedete vi permette di costruire pandas questi oggetti che sono abbastanza comodi anche per da visualizzare quindi possono essere utili diciamo noi non lo useremo lo useremo solo oggi giusto per farvi vedere perché mi serve per utilizzare il plot che andiamo a vedere sotto però c'ha una serie di funzionalità che se uno deve lavorare con delle tabelle di dati ad esempio possono essere utili vedete vi fa visualizzare un certo numero di righe per ogni riga abbiamo definito noi degli header dell'intestazione di colonne e abbiamo definito delle label che sono prese da da questo oggetto iris cioè come codificato dentro scikit-learn c'ha anche le categorie dei nomi ok questo è target names se vi ricordo andiamo un po' più in su che noi possiamo accedere anche a target che invece se andiamo a stampare adesso ve lo faccio stampare target se io vado a stampare anche target oltre che questo ok iris target che sarebbe y è una cosa così è un array numpy vedete vedete che è un array con tutti 0, 1 e 2 cosa vuol dire che questi sono tutti i punti di iris adesso non mi ricordo se tu usa virginica e ci picchia qual è l'altro versicolor ecco questi sono tutti i punti gli 0 sono credo setosa poi gli 1 versicolor e il 2 virginica ok quindi è un modo per rappresentare questi dati altrimenti a noi basterebbe l'array numpy eh gli array numpy ok allora andiamo avanti ci siamo fin qui a cosa ci serve tutto questo tutto questo ci serve perché andiamo a utilizzare questi pair plots allora questi pair plots sono uno strumento utile di della libreria seaborne quindi sns noi l'abbiamo chiamata sns cioè seaborne che prendono come input un data frame pandas ok quindi per quello che abbiamo tirato in ballo pandas anche e sono molto utili come vi ho scritto qua per esplorare delle correlazioni quando avete dei dati su più dimensioni in questo caso abbiamo quattro dimensioni quindi eh quello che possiamo fare possiamo plottare tutte le coppie di dati tutte le feature una contro l'altra cioè andare a vedere ehm quanto vale una feature in funzione di un'altra feature e farlo a coppie chiaramente farlo a coppie significa fare avere una matrice di n per n meno 1 eh possibili coppie eh in realtà poi sarebbe n meno 1 fratto 2 perché sono sono simmetriche chiaramente eh però in realtà vedrete che è una matrice n per n meno 1 quindi in questo caso sarà una matrice che vedete ehm sarà di 12 eh di 12 riquadri lungo la eh lungo la diagonale adesso poi ve lo faccio vedere lungo la diagonale che cosa viene fuori lungo la diagonale ci sarà un qualcosa siccome è una feature contro se stessa in realtà vedrete che ci sarà la distribuzione delle tre feature ok quindi per default come vi ho scritto qui viene creata una griglia di assi in modo che ogni variabile numerica dei dati viene condivisa lungo l'asse y e ehm attraverso una singola riga e l'asse x attraverso una singola colonna mentre sulla diagonale verrà vedete plottata la distribuzione univariata che vi mostra la distribuzione cosiddetta marginale allora per secondo me capire bene bisogna mandarlo in esecuzione e cercare di vedere che cosa c'è e poi torniamo magari sopra questa definizione perché è molto più utile andare a vedere come opera ok questo questo questo oggetto allora per mandarlo in esecuzione molto semplice abbiamo questa funzione che si chiama perplot della nostra libreria seaborn che abbiamo importato prima il primo input è il data frame che abbiamo creato poi qui semplicemente gli andiamo a dire quali sono le variabili in gioco che sono le quattro variabili delle quattro feature di questo data frame quindi il campo colonne andiamo gli diciamo vai a prendere le colonne da 0 a 4 qui gli stiamo dicendo semplicemente la sfumatura cioè lui va definiamo una palette di colori per cui associamo all'etichetta setosa al verde al scusatemi al rosso all'etichetta versicolor il verde all'etichetta virginica il blu e lui utilizza le label quindi setosa versicolor e virginica per sfumare e vedrete i colori quindi associa ad ogni elemento di cui lui sale etichetta un colore che è quello rosso verde o blu e li utilizza vedrete anche sfumandoli dando delle opportune sfumature che sono queste che andrete a vedere dopodiché mandiamo in esecuzione il comando per plot e guardate che cosa fa allora lui genera una matrice vedete di 4x4 ok 4 colonne e 4 righe vedete se andiamo a vedere la prima riga come vi dicevo prima ha in comune che cosa il fatto che l'asse delle y è condiviso tra tutti questi grafici e l'asse delle y è la lunghezza del sepalo la ampiezza del sepalo per questa seconda riga la lunghezza del petalo per la terza riga e la ampiezza del petalo per l'ultima riga le colonne chiaramente condividono che cosa la lunghezza del sepalo la ampiezza del sepalo la lunghezza del petalo e l'ampiezza del petalo quindi questo significa che io se parto dalla prima riga e vado allora intanto vediamo cosa c'è sulla diagonale sulla diagonale come vi dicevo ovviamente ci dovrebbe essere una qui abbiamo la prima colonna è quella della lunghezza del sepalo ok vedete e qui ovviamente non ha non ha senso plottare una feature contro se stessa perché ovviamente non ci dà nessuna informazione quello che vengono plottati sono degli histogrammi che vi dicono come sono distribuite le le frequenze di occorrenza di di di questa dimensione quindi in particolare se io vado di questa feature se io vado a considerare la lunghezza del sepalo vedete vi dice che in blu e a questo è servito dire la sfumatura prendi l'etichetta vedete che vengono sfumate in blu in blu sono i fiori di iris virginica io gli ho detto e i fiori di iris virginica sono distribuiti in questo intervallo vedete di di larghezza della lunghezza del sepalo quelli in rosso che sono in parte sovrapposti ma hanno questa distribuzione di frequenze quelli verdi che sono relativi alla versicolo vedete sono tendenzialmente un po' più lunghi perché la media è un po' più alta e sono distribuiti in maniera leggermente diversa vedete che questo questo plot vi da vi da un contenuto informativo vi evidenzia in maniera visiva grafica quello che è il contenuto informativo degli histogrammi delle frequenze ma non solo qui abbiamo per ogni per ogni attributo per ogni feature i vari plot in questo caso la lunghezza del sepalo verso che viene messo in relazione a che cosa al secondo parametro che è la ampiezza se non sbaglio del sepalo esattamente quindi e qui vedete avete la palette di colori che di nuovo è rosso sono quelli del tipo setosa blu del tipo virginica verde del tipo versicolo e qui avete degli scatterplot per cui questo vi dice qual è la lunghezza del sepalo e l'ampiezza del sepalo di questo punto che è un esempio di fiore di tipo virginica e così via e la stessa cosa la potete ripetere mettendo in correlazione la lunghezza del sepalo con la lunghezza del petalo oppure la lunghezza del sepalo con l'ampiezza del petalo ok e la stessa cosa chiaramente ce l'avete sulle altre righe in cui avete vedete lungo la diagonale le distribuzioni di di frequenza di probabilità del quindi gli histogrammi relativi alle alle varie feature e e le altre cose vedete che quello che si può vedere già da questa analisi visiva visuale diciamo visiva del dataset si possono trarre diverse informazioni interessanti perché ad esempio qui si può vedere che se io guardo alla ampiezza del del petalo vedete che i tipi di fiori blu che sono i virgini che adesso non mi ricordo sono abbastanza distinguibili dai tipi di fiori a cui abbiamo associato il colore rosso questo significa che se voglio costruire un classificatore e vado a utilizzare solo la feature ampiezza del petalo ho buona probabilità di discriminare correttamente questa tipologia di fiori da questa ma ad esempio non queste due perché hanno dei valori soprapposti cioè ci sono tutta una serie di lunghezze del petalo per cui queste due tipologie di fiori una e due hanno sono fiori di tipo diverso ma che hanno la stessa lunghezza del petalo e più potete fare altre considerazioni anche guardando non solo le distribuzioni univariate ma anche ecco questo si vede bene anche qua qui si vede che questa tipologia di fiori è distinguibile abbastanza bene in base a ampiezza del sepalo e lunghezza del petalo e quindi diciamo è uno strumento abbastanza utile di esplorazione dei dati come lo utilizziamo questo strumento di esplorazione dei dati appunto è in una fase preliminare quando facciamo un'analisi del dataset può essere utile cercare di capire qualcosa di più del dataset è sempre anche questa è una fase preliminare molto importante di qualunque pipeline poi di machine learning ok quindi ve l'ho fatto vedere per questo quindi questo comando si chiama perplot della libreria seaborne il problema è che deve utilizzare dei data frame e non direttamente degli array quindi abbiamo utilizzato quindi abbiamo utilizzato anche pandas per creare questi data frame fine dell'escursione su seaborne e su pandas torniamo a noi cosa ci possiamo fare su questo proviamo a costruire una regressione una regressione in cui andiamo a vedere se riusciamo incrociando alcune feature a descrivere un'altra feature in funzione di altre cioè quello che facciamo è ripercorrere un po' e poi con questo concludiamo il discorso sulla regressione andando a utilizzare alcune dimensioni di quel dataset quel dataset vi ricordo è 150 per 4 e noi in quel dataset andiamo a selezionare una colonna che rappresenta per noi la x la variabile indipendente e poi andiamo a selezionare un'altra colonna che rappresenterà la y quindi vediamo se riusciamo a descrivere la lunghezza del petalo ad esempio rispetto adesso li andiamo a scrivere perché non me li ricordo quali sono così almeno ce lo manteniamo allora vediamo un po' la prima colonna allora slswplpw slsww adesso vi dico cosa andiamo a fare intanto rimportiamo il dataset così almeno siamo sicuri di lavorare sul dataset pulito oppure questa cella potrebbe stare in un altro notebook quindi va bene lo rimportiamo facciamo una stampa del tipo di dato e vedete che se andiamo a fare una stampa del tipo di dato lui ci dice sono cento scusatemi ok scusate non lo stampa non ah ecco è un è un array numpy ok viene stampato il dato che è un array numpy ok dopodiché vado a definire ho rifatto anche per comodità la stampa del data frame che lui ha conservato in memoria l'ho fatta semplicemente ecco perché io mi sono annotato qui che cosa rappresentano le quattro dimensioni qui ve l'ho fatto anche stampare così almeno sapete ce l'avete direttamente lì però anche qui non era strettamente necessario cioè il data frame lo possiamo anche buttare via a questo punto dopodiché impostiamo un identificativo della x e diciamo la x per noi è 2 2 vuol dire scusate vuol dire la lunghezza del petalo per noi la variabile indipendente è la lunghezza del petalo quello che vogliamo fare è andare a vedere se riusciamo a creare un regressore quindi a fare il fitting di un'altra tra le variabili e vedere se riusciamo a descriverla in funzione della lunghezza del petalo quindi andiamo a prendere ad esempio la colonna 1 e la colonna 3 la colonna 1 rappresenta la ampiezza del sepalo la colonna 3 la ampiezza del petalo e vogliamo vedere se riusciamo a descrivere questa oppure questa in funzione di questa quindi facciamo un ciclo for in cui la prima alla prima iterazione la y la variabile dipendente sarà la colonna 1 la ampiezza del sepalo alla seconda iterazione andiamo a prendere la colonna 3 come variabile dipendente scusatemi cioè la larghezza del petalo la variabile indipendente sarà fissa e sarà pl ok costruiamo il vettore x a partire da la ray numpy a iris data e gli andiamo a prendere gli diciamo prendi tutte le righe e prendi le colonne tra 2 e 3 cioè la colonna 2 cioè questa ok poi come y prendi tutte le righe e la colonna è alla prima iterazione la colonna 1 cioè questa alla seconda volta vai a prendere la colonna 3 cioè questa dopodiché invochiamo andiamo ad accedere alla classe linear regression e definiamo un oggetto che chiamiamo linreg questo oggetto linreg si porta dietro il suo metodo fit e diciamo vai a fare il fitting di x con y dopodiché andiamo a vedere che cosa che cosa che cosa abbiamo fatto una volta che abbiamo fatto il fitting generiamo dei punti che chiamiamo x s li generiamo vogliamo vedere l'oggetto geometrico che abbiamo creato con il nostro modello come facciamo allora prendiamo il valore minimo di x il valore massimo di x e in questo range andiamo a generare tutti i punti che ci stanno con passo 0,1 ok con il comando arrange ok questa è la x di test sarebbe ok dopodiché questo è un vettore che riarrangiamo in due dimensioni quindi sarà un vettore qui ci staranno un certo numero di punti quindi questo sarà un vettore con un certo numero di punti n virgola e questo diventerà n,1 ok y hat sarebbe la nostra previsione la nostra previsione è il metodo predict dell'oggetto linreg che abbiamo creato gli passiamo la x e lui ci dice qual è il valore corrispondente della y secondo il modello che lui ha addestrato e a quel punto andiamo a fare il plot di xs e y di y hat in funzione di xs sopra ci andiamo a fare anche lo scatter plot della x e della y che erano i punti originali e andiamo a etichettare questi plot con i nomi delle feature corrispondenti con il comando xlim e ylim settiamo il valore minimo e massimo degli assi rispettivamente con min e max e poi lo mandiamo in esecuzione con il comando show e il risultato è questa cosa qua quindi che cosa rappresenta questa retta vedete vi ho detto che tra il valore minimo e massimo dell'asse delle x io ho generato un certo numero di punti non mi ricordo quanti erano 100 mi sembra no non gli ho specificato quanti gli ho detto compasso 0.1 e lui me li ha generati per ognuno di quelli lui prima ha fatto il fitting del modello e questa è la retta che rappresenta il miglior fitting non è un qualcosa che ci dice molto perché perché la lunghezza del petalo e la ampiezza del sepalo non sono molto correlate tra di loro è un fitting che non ha molto senso ma se andiamo a vedere cosa è successo al secondo ciclo perché noi abbiamo fatto due cicli in cui nel secondo andavamo a vedere la l'ampiezza del petalo rispetto come è correlata rispetto alla lunghezza del petalo e chiaramente qui ci possiamo aspettare che in un fiore la lunghezza del petalo e la larghezza del petalo sono correlate tra di loro e vedete questa è la distribuzione di punti e questa volta il fitting è abbastanza significativo ok io direi che con questo finito il notebook e abbiamo terminato questa esercitazione riguardatelo se ci sono dei dubbi la prossima lezione o comunque quando anche diciamo il ricevimento in mail potete chiedere e e niente intanto per oggi non so se ci sono domande ecco se avete qualche qualche domanda qualche curiosità da casa anche e se no direi che intanto blocchiamo qui la registrazione va bene allora intanto che ci pensate andiamo a conti va bene allora intanto fermiamo la registrazione capitone potete