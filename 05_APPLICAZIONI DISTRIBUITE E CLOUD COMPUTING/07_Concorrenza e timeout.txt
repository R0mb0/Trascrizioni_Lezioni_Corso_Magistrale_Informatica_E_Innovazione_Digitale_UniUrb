salve ragazzi allora in questa lezione continuiamo a parlare di concorrenza essenzialmente parleremo di operazioni non bloccanti no come vi avevo detto la read è scusate la receive è un'operazione bloccante esiste un modo per farla non bloccante questo modo non è nient'altro che mettere un time out quindi di nuovo ricordatevi che la receive è di default bloccante e la send non si blocca mai quindi la send va a buon fine abbiamo visto l'altra lezione che inviare a un pid che è morto un attore che è morto va sempre a buon fine perché di nuovo noi non ci aspettiamo nel momento dell'invio non ci aspettiamo un hack di ricezione quindi questo vuol dire che in Erlang la send non è bloccante mentre la read è bloccante allora quindi cosa vuol dire questo? cosa vuol dire questo? questo vuol dire che come vedete dalla slide dall'esempio delle slide che il processo o l'attore l'attore prova block cioè l'attore che implementa o che esegue la funzione prova block non si sblocca sino che non riceve un messaggio particolare che contiene quell'atomo ping quindi cosa faccio questo esempio? questo esempio ora lo vediamo lo riscriviamo quindi touch onk2.erl open onk2.erl ricordatevi sempre che il modulo deve avere lo stesso nome del file altrimenti non funziona nulla quindi meno module onk2.erl salviamo allora qual'era l'idea? l'idea è questa che io faccio una funzione block block per dire che sicuramente questo che fa receive se riceve ping da ok possiamo far così audio format audio format and e punto e poi facciamo una funzione test no? quindi test allora nelle slide abbiamo visto c'è una cosa strana abbiamo visto esattamente questa roba qui questa è la spawn noi abbiamo visto che la spawn 3 questa è una spawn 3 no? perché prende tre elementi la spawn 3 prende il modulo allora questa è una macro questa è una macro quindi quando vedete qualcosa che inizia al punto di domanda quindi un po' tutto interrogativo maiuscolo vuol dire che è una macro che viene quindi una direttiva è un'altra direttiva al compilatore qui siamo veramente pigri non vogliamo mettere il modulo il nome del modulo diciamo al compilatore trovatelo da te quindi quello che facciamo qui è id uguale spawn ricordate la spawn 3 mettiamo già la virgola perché voglio fare altra roba di sotto modulo modulo block scusate e non prende parametri però ricordatevi che va sempre messa la lista vuota qualora prendesse un parametro tipo x qui dobbiamo indicare un elemento tipo pitto però ora non faccio però ora facciamo che sia bloccante senza scusate senza parametri quindi parametri anche se la funzione è void quindi non prende parametri deve sempre avere la lista la spawn la spawn esige la lista vuota pin poi cosa pitto cosa facciamo facciamo cioè facciamo nelle slide facevamo sta roba qui quindi allora qual è l'idea l'idea è questa che se noi vogliamo mandare n messaggi allo stesso allo stesso alla stessa allo stesso pid quello che possiamo fare è iterare quindi abbiamo visto che per iterare possiamo fare il for each e utilizzare una sequenza quindi essenzialmente questo stiamo facendo list for each ricordatevi che ricordatevi che tutte le vediamo un attimo ok for each ricordatevi che tutte le funzioni del no il package del modulo list prendono come ultimo parametro sempre la lista quindi io voglio qual è la lista la lista è list.sec da 1 a 10 questa roba qui e quello che voglio fare è la for each itera applica una funzione a ogni elemento della lista quindi qui mi sto creando una lista di 10 elementi ovvero dei primi 10 numeri naturali qui cosa voglio fare? voglio fare una funzione funzione lambda quindi fun che prende i quindi il mio iteratore end così evito di creare evito di scordarmi di chiudere la funzione quindi quello che fa è pid mandiamogli mandiamogli i quindi che stiamo mandando 1 2 3 4 5 fino a 10 e questo lo possiamo fare perché allora questa funzione questa è la funzione questa variabile non è legata qui dentro ma appartiene allo scopo allo scopo più in alto quindi essenzialmente lui quando noi eseguiremo questo comando lui a pid sostituirà quello della spawn quindi questo lo si può fare cosa faceva altro la slide ok allora mettiamo un po' di un po' di output io format process waiting for messages e gli diamo self in modo tale lo scriviamo anche qui per dire chi sta facendo cosa ora questo self questa è una cosa che spesso i vostri colleghi degli altri anni confondono questo self scusate si riferisce a chi sta eseguendo questa funzione ora siccome questa funzione la stiamo spawnando il self di questo è diverso dal self di questo quindi dovete iniziare pure a capire un po' questa roba qui url devo esportare qualcosa perché altrimenti abbiamo export ricordatevi che export prende una sequenza quindi una lista di test 0 e metto pure block di 0 e ponk2 ecco qui manca una virgola perché cosa è successo questo l'avevo scritto ho aggiunto del codice sopra e mi sono scordato di metterci la virgola ok quindi se io lancio test lì non ho list ponk2 test però vedete che il processo non è uscito il processo è ancora lì perché se fosse se adesse terminato avrebbe fatta questa roba qui allora ora per vedere effettivamente che lui è ancora bloccato dobbiamo mandargli un messaggio come facciamo sappiamo che questo è il suo pid quindi questo è un trucco pid uguale a pid di sta roba qui quindi mi ricostruisco il pid 95 e quindi a pid gli mando gli mando scusate gli mando ing e lui ora dovrebbe terminare visto? quindi lui è rimasto nonostante noi gli abbiamo mandato 10 messaggi quindi gli abbiamo mandato 10 messaggi 10 messaggi lui rimane in attesa fino a che non riceve quel messaggio che noi gli abbiamo detto e questo a volte è un po' è un po' controproducente perché potremmo avere un programma bloccato all'infinito perché? perché magari chi doveva mandargli il messaggio è morto no? quindi quello che fa Erlang siccome abbiamo detto che Erlang è utile per programmare programmi reattivi ma anche software real time quello che fa Erlang è metterci un timeout quindi quello che noi facciamo è questo receive quindi qui abbiamo tutti i pattern quello che facciamo è after t e ora voglio mettergli voglio che la block sia bloccante fino a un certo punto quindi la block prende un parametro quindi qui spono qui gli metto test di t e qui spono la roba con t quindi test di 1 quindi cosa gli sto imponendo? sto imponendo che lui deve aspettare t millisecondi quindi se dopo t millisecondi non ha ricevuto nessun messaggio che soddisfa i pattern di sopra allora va a io format ora ricordate fate attenzione a questa cosa questa è l'ultima clausola di receive quindi va bene non avere punta e virgola e anche questa è l'ultima anche questo non deve avere la virgola quindi vediamo se quello che ho detto è quindi rifacciamo l'esempio rifacciamo l'esempio e l'esempio è test 2 gli dico di aspettare un secondo facciamo 5 secondi così vediamo così vediamo un po' la vedete dopo 5 secondi lui è uscito lui è uscito perché non ha ricevuto nessun messaggio di ping se io in questo in questo frangente diciamo 10 secondi no 10 secondi sì gli faccio a pid di 0 106 vediamo se è più veloce lui o io gli mando più veloce lui mettiamo più tempo scusate ragazzi mettiamo più tempo 15 quindi a pid di a 0 108 0 gli mando gli mando ping è uscito prima perché io sono veramente lento a scrivere sta roba quindi quindi quindi facciamo l'ultima volta 20 secondi 20 secondi quindi 20.000 millisecondi 111 quindi è uscito prima del del time out e ora lui ha terminato quindi non è non c'è anche se aspettiamo 25 secondi non vedremo il messaggio di l'altro messaggio quello di uscita dopo il time out va bene allora quindi qual è la semantica dell'after la semantica dell'after è questa che lui Erlang inteso cioè l'attore aspetta quindi si blocca ed è aspetta dei messaggi che soddisfano i determinati pattern che abbiamo detti e se dopo n millisecondi non succede allora lui è libero di fare altro quindi è libero di fare altra roba qui c'è un errore perché questa espressione questo dovrebbe essere senza punto e virgola quindi state state attenti a questo allora uno potrebbe domandare qual è la semantica di after zero perché ovviamente Erlang allora vi anticipo che Erlang tutte le tutte le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le le non ricordo più però dovrebbe essere vediamo un attimo scusate vediamo un attimo se riesco a infinity atom infinity quindi infinity è infinity è l'atomo per per indicare bloccati all'infinito allora eravamo qui quindi cerchiamo di andare pian piano allora cos'è cos'è vediamo un attimo se lo compiliamo se ti piace infinity e quindi se esponiamo perché non c'è il test zero cosa stiamo facendo test con t ah vabbè possiamo possiamo passare infinity direttamente quindi vedete lui si blocca di nuovo indefinitivamente fino a che noi non gli mandiamo 126 non gli mandiamo il ping quindi infinity per lui anche se non mettiamo l'after quindi la receive bloccante lui la traduce in after infinity allora stavamo dicendo cosa succede se invece di mettere infinito mettiamo zero esattamente quello che uno si aspetta quindi vuol dire che se ci sono messaggi nella coda allora lui cerca di soddisfare il pattern altrimenti se la coda è vuota o se non c'è messaggi che soddisfano quel pattern quel pattern indicato dai vari pattern allora lui immediatamente non si blocca immediatamente fa l'after il fa qualcosa quindi essenzialmente la receive after zero si si usa per vedere se la coda non è vuota quindi se la mailbox di un attore non è vuota allora quindi uno potrebbe anche usare questo tipo di primitiva perché la receive after è una primitiva potentissima di Erlang la potrebbe utilizzare per implementare una slip ed effettivamente Erlang implementa la slip scusate la slip in questo modo quindi receive pattern nullo after t quindi essenzialmente il mio programma se io voglio implementare la slip slip di t secondi allora come implementata la slip è implementata come receive pattern nuoto after t ok ok and ok sì and perché deve chiudere ecco qua in questo modo si implementa Erlang implementa la slip quindi vedete che dalle primitive di concorrenza riusciamo a costruire primitive non di concorrenza quindi quindi slip di 1 quindi compiliamo effettivamente come dargli torto è slip non è slip quindi se io conc slip di 2 secondi lui aspetta e poi ritorna ok quindi questo modo il modo in cui Erlang implementa la timer la timer slip in Erlang è implementata essenzialmente in questo modo inoltre si può utilizzare l'after 0 per fare la flash la flash quindi per eliminare tutti i messaggi nella coda in tutti i messaggi che sono presenti nella coda li possiamo eliminare tutti insieme usando un'operazione di flash la flash l'abbiamo vista già essenzialmente questa la flash l'abbiamo vista già questo modo quindi cioè la flash questa è la flash che viene fatta sulla sulla console quindi sulla mailbox della console quindi io posso implementare come ho implementato questa posso implementare la mia flash flash chiamiamola mia flash altrimenti quindi my flash altrimenti potremmo avere no perché usiamo usiamo il il nome del modulo quindi per lui gli va bene quindi come si implementare la flash la flash vuol dire che deve leggere ogni messaggio quindi receive qualsiasi cosa che è presente nella coda faccio di nuovo flash e nel momento in cui non c'è nulla nella coda quindi after 0 after 0 ritorno ok and questo ecco in questo modo mi viene implementata la la flash l'esportiamo prima di tutto altrimenti flash che essenzialmente flash vuol dire tirare la catena come come si fa il flash del water flash 0 quindi proviamo a fare la flash della della console per far questo ci mandiamo un po' di messaggi prima quindi quello che faccio è list mi mando tipo 10 messaggi sulla coda quindi list lists 2.4 each questa è la mia lista il mio tiratore da 1 a 10 chiudo e quello che faccio è fun quindi cerco di stare attento end virgola self fun di i scusate send self mi mando i quindi se io faccio la flash ora la flash di sistema questo è quello che ottengo se io faccio in questo modo chiamo conc di flash e vado a rifare la flash quello che ottengo è che la lista e la la coda è vuota ovviamente c'è una differenza perché questa ce la mostra a video qui no però potremmo anche scrivere il scusate dove siamo scrivere il il scrivere a video il messaggio tipo qualcosa di questo tipo m io format virgola shell got p marren virgola m quindi se io compilo si compilo chiamo la flash la mia flash è praticamente uguale a chiamare mi rimando 10 messaggi è praticamente uguale a chiamare la flash di system ecco allora di nuovo cosa ci fa cosa ci fa capire questo after 0 after 0 ripeto vuol dire che se non ci sono se la coda è vuota o non ci sono nell'immediato messaggi che mi soddisfano i pattern allora posso fare altro quindi vuol dire che non mi blocco questo vuol dire l'after 0 quindi l'idea di base è questa che con l'after 0 uno può implementare dei messaggi con priorità esattamente quindi mettiamo caso che noi stiamo implementando un sistema IoT o un sistema software real time ovviamente qui stiamo parlando sempre di software real time non di hard non di hard real time quindi diciamo che c'è una precisione al millisecondo non non spacchiamo il capello cioè non stiamo usando un orologio atomico stiamo usando un orologio di sistema del computer quindi la precisione fino ai millisecondi o ai nanosecondi poi perde perciò si intende software real time allora quello che si fa è questo si mette in alto il messaggio il pattern con priorità più alta quindi io voglio ricevere un allarme di tipo 1 se ce l'ho nella coda devo subito gestirlo altrimenti do priorità all'allarme di tipo 2 o do priorità a qualsiasi altra roba quindi after 0 quindi se io quando incontro questa priority receive quindi quando quando faccio la mia receive la faccio in modo prioritario allora io prediligo prima i messaggi attenzione prediligo i messaggi presenti nella coda e non mi blocco perché uno potrebbe dire allora perché non mettiamo allarme 1 e poi di nuovo come chiusura no come chiusura come clausola allarme 2 no perché vuol dire che se non è presente allarme 1 o allarme 2 mi blocco quindi io voglio vedere nell'immediato se è già presente nella coda allarme 1 se c'è voglio gestirlo altrimenti do la priorità al fatto che ci sia allarme 2 sempre presente nella coda se ancora mi deve arrivare e se ancora mi deve arrivare roba allora faccio mi blocco mi blocco quindi receive qualsiasi cosa faccio tutt'altro ecco quindi questo è quello che dicevo nel commento questo è veramente diverso dal dire questa roba qui perché cosa vuol dire che se io faccio after 0 vuol dire che io do sempre la priorità allarme 1 quindi se c'è un messaggio allarme 2 non verrà mai gestito perché perché si blocca prima allora esaurita la parte di di receive after quello che rimane da capire un pochino è come usare i pid e i nomi registrati allora i pid abbiamo visto che sono una bella cosa però sono un po' complicati da capire speramente quando uno quando uno vuole mandarlo in giro quello che uno vorrebbe fare è implementare un sistema di dns un po' come si fa con gli ip e con i siti internet voi non usate l'ip del sito internet non usate il nome tipo google google poi il computer il browser farà un look up al dns e riceverà l'indirizzo fisico della macchina che risponde al nome google o le macchine o il cluster e l'ang fa una cosa simile e lo chiama nomi registrati quindi quello che uno fa è registrare usare questa direttiva in cui il pid viene registrato sotto un particolare nome ricordiamoci allora attenzione questo nome è un atomo registered ci dà la lista di tutti i pid registrati e poi si può fare where is name che essenzialmente gli diamo il nome registrato e ci restituisce il pid allora siccome la console è un attore qualsiasi cosa in Erlang è un attore se noi scriviamo direttamente registered vediamo che l'ecosistema ha già tanti nomi registrati e se io faccio where is troviamo uno più semplice vedete sono tutti atomi non c'è kernels app mi dà il pid di kernels app banalmente io posso mandare un messaggio a kernels app questi sono tutti i demoni o gli attori che stanno che convivono insieme alla shell anche questo ci sarebbe in mezzo a questo c'è anche il monitor della shell logger user file init logger perl prime loader kernel safe standard error è il file di error e così via allora voi mi direte a che serve questa roba qui allora io posso tornando all'esempio del tornando all'esempio del del fruit shop quindi se io ricordo bene fruit fruit noi abbiamo il server e il server lo chiamavamo attraverso il suo pid quello che posso fare è quello che posso fare è fare una funzione di init in cui gli do il nome quindi prendo un nome quella che quello allora vi ricordate che vi dicevo che questo è il loop del pattern però noi avevamo ho messo la parte di inizializzazione ecco guarda la stiamo dicendo la parte di inizializzazione mi fa register scusate facciamo facciamo le cose per grado quindi pid uguale si può fare direttamente però non voglio confondervi spawn di shop di module scusate module shop e questo prende una funzione che è populate scusate prende un parametro che è il nome populate e ritorniamo questa roba qui e questa roba la registriamo register allora vediamo la register cosa vuole register prende il nome quindi un atomo che gli sto dando il nome e il pid ovviamente uno può fare direttamente questa roba qui quindi uno può fare questa roba qui direttamente allora proviamo un attimo a vedere se questa roba funziona come l'ha chiamata throw it init n int is unused non l'ho esportata quindi questo è il pattern che noi utilizzeremo spesso per inizializzare inizializzare un server quindi ok quindi invece di chiamare la spawn da console quello che io faccio è chiamare init quindi throw it init e lo chiamo voglio registrare il server col nome server quindi se la register va a buon fine attenzione il register va a buon fine vuol dire che ha associato tipo un hash associato a un atomo un pid non vuol dire che quell'attore esiste perché se quell'attore crasha siccome la spawn ritorna sempre noi non ce ne accorgiamo poi avremo altri modi quindi quello che sto dicendo io che il server esiste no il server esiste c'è un'associazione server con un pid quindi se io faccio where is server questo è il pid originale del server per vedere se il server è veramente up and running quello che facciamo è ecco prima noi facevamo pid e mandavamo un messaggio ora invece di fare questa roba possiamo direttamente usare il nome registrato e come facevamo print no e è la stessa cosa di scrivere pid di 0 171 finito da 0 questa roba qui quindi essenzialmente Erlang vi dà a disposizione l'utilizzo di nomi mnemonici per dei pid ovviamente lui che fa runtime fa il look up di quel nome non è che c'è tutta questa scienza infusa è solo dello zucchero sintattico che vi viene dato così per facilitarvi quindi così ogni volta che inizializzate o lanciate il server lo chiamate sempre con lo stesso nome ad esempio sì qui è un altro esempio molto più banale io ho voluto completare l'esempio del server ecco questo è quello che vi dicevo allora non si può registrare due volte lo stesso nome quindi il nome è un hash quindi è un'associazione univoca tra un pid e un nome quindi non potete associare a un nome più pid quindi questo ve lo dovete ricordare è un altro un altro problema che noi non possiamo vedere con i se usiamo i pid direttamente allora se non usiamo i pid direttamente ogni send va a buon fine se usiamo i nomi registrati e mandiamo quindi registriamo un attore questo attore muore e mandiamo qualcosa utilizzando il suo pid il suo se mandiamo qualcosa utilizzando il suo pid non ci accorcemo se noi mandiamo qualcosa utilizzando il suo nome becchiamo un errore quindi ricordatevi sempre questa differenza quello che sto cercando di dire è questo che se io abbiamo ancora server se noi lo stoppiamo e poi gli mando di nuovo stop ecco quello che tengo perché non esiste più non esiste più quell'attore perché non esiste più perché poi il look up se noi facciamo il look up vero e proprio ecco qua quello che becchiamo è undefined quindi lui va a scrivere cioè interpreta l'espressione come undefined qualcosa e ci dice che e ci dà questo errore qui quindi state molto attenti a quando utilizzate sono intercambiabili ma non tanto perché col pid qualsiasi send va sempre a buon fine con i nomi registrati quindi se l'attore muore o l'attore termina quel nome viene come se venisse deallocato e quindi non esiste cioè per l'ecosistema di Erlang non ha nessun senso mandare un messaggio effettivamente ad un atomo questo l'abbiamo visto il where is ecco questo è un esempio in cui di nuovo usiamo la receive col tempo e quindi l'attore ha n millisecondi per ricevere pipo se non lo riceve termina in maniera decente quindi lo facciamo terminare con ok e se noi non gli invigliamo un messaggio entro tot secondi e se se gli invigliamo un messaggio usando il nome registrato dopo tot secondi quello che pecchiamo è un errore allora come vi dicevo i nomi registrati possono essere usati da chiunque quindi se io registro un nome in un pezzo di codice il pezzo di codice successivo può utilizzare quel può utilizzare quel quel nome registrato però bisogna stare attenti a quando un attore utilizza il nome registrato di un altro attore perché siccome in questo caso ad esempio quello che noi facciamo stiamo registrando sponiamo un attore e lo registriamo con il nome di primo e poi sponiamo un secondo attore che utilizza il nome del primo che si chiama primo cosa succede qui succede che siccome sono due attori che vanno in concorrenza potrebbe darsi che questo viene schedulato prima della prima della della creazione di quest'altro quindi potremo avere degli errori di concorrenza in cui noi utilizziamo un nome registrato che ancora deve essere registrato quindi dobbiamo stare molto attenti vedete che ora quando andiamo nella concorrenza bisogna gestire tutta una serie di errori che prima non avevamo allora un pattern molto un pattern molto bello e molto utilizzato è quello di creare cioè la spawn la spawn va sempre da un'altra parte quindi è un attore la console parliamo di console la console quando fa una spawn vuol dire che crea un handle per un altro attore quello che si fa è un trucco è quello che quando spawniamo qualcosa questo qualcosa si registra e noi ci possiamo invece di usare il pid che ci ritorna la spawn possiamo utilizzare direttamente il nome che noi abbiamo scelto è più facile a dirsi che a più facile a vederlo che a dirlo però essenzialmente quello che facciamo qui è betterreg ok torniamo indietro non concorrenza 2 quello che noi facciamo è questo betterreg ok no punto quello che noi facciamo è ci facciamo dare un nome quello che noi facciamo è vediamo un attimo registriamo noi stessi quindi register locale on surf ma quindi non c'è bisogno di questa roba qui ok spawn remoto con fun no scusate allora spawniamo la funzione che è si mette in attesa vediamo se era così no allora facciamo così che manda al locale si manda un app vuol dire che è attivo e poi si mette in attesa un messaggio ok virgola qui non mi interessa aglio format scriviamo tipo qualcosa il tipo resist end dobbiamo stare attenti ora a questa roba end chiudiamo virgola e questo spawn quindi register di remoto virgola sta roba qui allora locale cosa fa quindi questo è un attore che manda al locale un messaggio e poi si aspetta un messaggio quindi io che faccio io che sarei il locale faccio un receive app quindi quando ricevo un app quindi quando so per certo che l'attore remoto è in attesa quando gli mando al remoto pack quindi cerchiamo di fare io format io format hack e poi basta significa che basta così end quindi questa end è più della receive cerchiamo di esportarla quindi virgola debiter reg di zero sicuramente c'è qualche erroruccio come si c onc2 45 allora allora c'è qualche errore non gli piace end si mi sono scordato vedete mi sono scordato un'altra un'altra mi sono scordato un'altra parentesi quindi mi sono scordato quest'ultima parentesi che chiude è questa ok quindi chiamiamo conc2 di betterreg vedete se noi mettiamo se noi mettiamo se noi mettessimo qui un timer punto sleep di 10 secondi allora vediamo che questo il locale aspetta 10 secondi prima di ricevere il messaggio quindi vediamo un attimo cosa è successo ecco perché cosa è successo è successo questo che il nome ancora era registrato quindi il il nome locale era già registrato quindi lui cosa ha fatto ha cercato di registrare il nome locale ed è fallito quindi baddarg qui questo è un altro tipo di errore vediamo un attimo stiamo facendo un po' di casino timer punto sleep locale receive ok and and ancora allora facciamo così questo è tutto il problema di nomi quindi c c conk2 allora se noi ora lanciamo betterreg qual era il secondo errore il secondo errore è stato questo il secondo errore è stato che remoto esisteva remoto esisteva e quindi abbiamo registrato remoto un'altra volta ed è spaccato tutto quindi ora dovrebbe andare perché ho ammazzato l'ambiente rieseguiamo tutto quindi conk2 betterreg ecco perché non funziona perché sono 10 millisecondi quindi se io devo aspettare 10 secondi però ora abbiamo entrambi specialmente locale è registrato quindi cosa facciamo unregister unregister locale mi dovrebbe dare true ecco quindi abbiamo tolto dal registro locale che sarebbe la console se noi cerchiamo di togliere dal registro quindi cancellare ecco se cerchiamo di cancellare dal registro il nome remoto beccheremo un errore e un false ora non ricordo perché remoto ha finito ha finito quindi non esiste più quell'associazione se io facessi remoto vediamo un attimo ah me l'ha tolto comunque ecco qui allora ecco quindi aspettiamo un secondo non dieci secondi perché è mille millisecondi quindi un secondo aspettiamo un secondo e poi mandiamo l'hack ad app questo riceve l'hack quindi vuol dire che ora i due attori esistono ci sono mandati due messaggi in un handshake da lì in poi possono andare avanti questo è un pattern abbastanza comune quindi tornando a noi quello che si è fatto si è fatto questo che la cosa interessante è che possiamo abbattare bene possiamo far questo possiamo ora quando lo vedremo meglio nel distribuito possiamo mandare fare una spawn su un nodo remoto registrare un nome lì e da una macchina riferirci a quel nome in maniera del tutto trasparente va bene questo conclude la parte sulla la parte sulla concorrenza la prossima lezione parleremo un po' di vi sembra strano torneremo a parlare di sequenzialità quindi parleremo di delle strutture veramente importanti strutture dati quindi di tabelle ets e debts e poi vedremo come queste tabelle sono veramente potenti e riscriveremo il il fruity shop invece di utilizzare una lista utilizzeremo delle tabelle su cui è possibile fare un pochino di query poi banalmente vedremo molto più in là che queste tabelle si mappano uno a uno su delle tabelle di un database e quindi questo è quanto fate tutti gli esempi provate a giocare un po' con tutte queste primitive che vi ho dato e di nuovo se avete problemi mandatemi pure mandatemi pure un'email e Grazie.