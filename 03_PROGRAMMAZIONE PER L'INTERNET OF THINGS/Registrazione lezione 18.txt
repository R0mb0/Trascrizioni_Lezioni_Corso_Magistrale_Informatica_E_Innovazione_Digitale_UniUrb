eccoci qua allora oggi facciamo un'altra esercitazione con le sp però oggi ci concentriamo più sull'aspetto consumi energetici di sp nell'ottica di lavorare nella io con sistemi alimentati a batteria quindi abbiamo visto la programmazione io per connettersi ai vari tipi di server vari tipi di servizi eccetera ma abbiamo sempre dato che scontato che il nostro dispositivo fosse connesso a una fonte di energia praticamente illimitata ma momento in cui dovremo andare a lavorare con un sistema alimentato da batteria vedremo che sarà indispensabile usare qualche accorgimento altrimenti ci troveremo presto con la batteria scarica quindi il nostro dispositivo non funzionerà questa esercitazione chiaramente è targettata cioè è mirata direttamente al dispositivo sp quindi se cambiamo hardware chiaramente cambieremo anche informazioni e sistemi per gestire il power management oggi vediamo esattamente quello che possiamo fare con l'architettura sp allora per vedere cosa possiamo fare andiamo a a mostrare un po di documentazione su quelli che sono che sono i livelli di consumo energetico di questa piattaforma adesso la vado a trovare eccolo condivido le informazioni che vedete sono informazioni che trovate su qualsiasi sito dedicato un po' alla iot e per le forme sp e derivano dal deficit proprio del sistema del processore il sistema sp 8266 che quello su cui siamo concentrati adesso oltre al alla modalità active quindi dove tutto è acceso e in in esecuzione a tre stati di consumo di consumo energetico via via decrescente come vediamo da questa tabella abbiamo il lo stadio modem slip che l'unica cosa che va a spegnere è l'interfaccia wifi spegnendo l'interfaccia wifi quello che andiamo a fare è risparmiare una grande quantità di energia è chiaro che quando andiamo in modem slip non possiamo trasmettere quindi se la nostra applicazione periodicamente avrà bisogno di trasmettere un dato dovremo fare il refresh quindi riaccendere il nostro modem per poter comunicare tutto il resto rimane acceso rimane acceso la cpu le reti c e il consumo stimato in questo caso spegnendo il modem è di 15 mili ampere se lasciamo il modem acceso sapete quanto consuma sp consuma 130 140 mili ampere perché il wifi ragazzi è molto molto costoso dal punto di vista energetico quindi anche spegnere semplicemente il wifi è un grande battaglio passiamo da 130 150 15 il che non è per niente banale è normale che la scrittura del codice cambierà perché prima di dover fare una qualsiasi un invio di messaggi dovremo riaccendere il modem e quindi ma rinitualizzare la connessione via dicendo il secondo stadio che vediamo il light slip è ancora più bassa energia perché spegne anche la cpu cioè toglie il crocca la cpu quindi oltre a spegnere il modem toglie il crocca la cpu le reti c che è il real time clock interno rimane acceso ma la cpu va in uno stato di idol dove non cicla più e come vedete il consumo passa da 15 mili ampere a 0.4 mili ampere quindi un vantaggio enorme dobbiamo tenere presente che quando ci risveglieremo dal light slip ci vorrà un po di tempo perché dobbiamo riattivare il clock della cpu la cpu andrà a regime dopo un certo tempo diversi millisecondi una volta che la cpu è tornata a regime riaccenderemo magari il modem wifi se ci serve la comunicazione e quindi saremo pronti è chiaro che più andiamo in un stadio profondo meno consumiamo ma più è complicata anche la riaccensione perché se spegniamo solo il modem dovremo riaccendere il modem se togliamo anche il crocca la cpu dovremo prima rinitualizzare il clock aspettare che la cpu si stabilizzi e poi poterci lavorare ma il risparmio come potete immaginare è tantissimo l'ultimo il deep slip è lo stadio più di consumi energetico più profondo dove si consumano addirittura qualcosa come 20 micro ampere perché quasi spegne tutto non rimane nulla acceso se non il real time clock il real time clock che ha una sola capacità quella di che generano un intera quindi con il real time clock possiamo generare un intera per risvegliare la nostra la nostra cpu attenzione quando ci risvegliamo dalla modalità deep slip noi in realtà rifacciamo il boot riparte totalmente dal boot la nostra applicazione quindi capite stagli di addormentamento a consumo energetico diversi ma anche metodologie di programmazione diverse perché se mi risveglio col deep slip rifaccio il boot con light slip devo ciclare la cpu attende la stabilizzazione col modem slip devo semplicemente riaccendere il modem rifare la connessione wifi quindi dove in base allo strumento che andiamo a utilizzare il nostro codice naturalmente cambierà allora nelle esercitazioni di oggi useremo il deep slip cioè vediamo esattamente cosa può fare un sp e nel nella configurazione di slip cioè quando consuma praticamente 20 micro ampere e questo quando facciamo campagne di monitoraggio dove la grandessa da monitorare non varia molto rapidamente nel tempo se dobbiamo migliorare la temperatura una volta al minuto e già la volta al minuto è tanto e la temperatura non cambia se normalmente così rapidamente vuol dire che noi con il deep slip cosa facciamo dormiamo per quasi un minuto allo scadere del timer inter ci svegliamo rifacciamo il boot inizializziamo i sensori misuriamo la temperatura si connettiamo alla rete inviamo il pacchetto e poi andiamo a dormire per un altro minuto questo è ci porterà un risparmio energetico altissimo perché per un minuto non consumiamo quasi niente quando si riaccendiamo consumiamo diciamo fino a 130 140 quando accendiamo il modem però è per un istante molto molto ristretto però anche questo ci comporterà la scrittura del codice in un certo modo come si può usare il deep slip con le sp allora adesso vi faccio vedere il pin out quindi sp 82 66 pin out dovremmo vedere eccolo qua vediamo se ho trovato una pagina corretta sì questo qua questo è il nostro modulo che è l'esp 82 66 montato su quello che si chiama nude mcu cioè il development kit ma al di là di quello a noi ci interessa vedere il pin gpu 16 chiamato di zero c'è anche un etichetta wait vedete l'etichetta wait perché perché è l'unico pin in grado di svegliare la cpu con il real time plot cosa vuol dire il real time plot le reti cica è l'unica cosa che rimane accesa è connesso al pin di zero cioè al wake questo vuol dire che noi possiamo con la deep slip programmare un real time clock e digli fra 30 secondi fa 60 secondi genera un intera l'intera si avrà su il pin wake per poter far sì che il nostro sistema si risvegli però perché quello semplicemente è l real time clock che alza e abbassa il filo way ok per far sì che il nostro sistema si risveglie davvero dobbiamo collegare il pin wake con il pin reset che è il terzo in fondo rst vedete se noi colleghiamo il pin wake con il pin reset allo scadere del timer intera esatto wake genera un internet un segnale resetto risetta la cpu la cpu riparte allora questo collegamento però non può essere stabile non può essere stabile io non posso saldare il pin wake al pin reset perché ve lo spiego perché se io lo saldo non sono in grado più di programmare la mia cpu in fase di programmazione il programmatore di arduino quello di free rqs cosa fa invia un segnale di reset la cpu la manda in modalità programmazione e bisogna alzare il pin di reset e un altro pin contemporaneamente a quel punto la cpu va in modalità programmazione se voi avete cortocircuitato reset e wake non lo programmate più allora serve un sistema mobile infatti se vedete la scatolina che avete di fronte ha fatto l'ho fatta modificare da paolo abbiamo inserito un jumper vedete che c'è un jumperino lateralmente si può sfilare e rimettere perché perché nel momento della programmazione lo dovremo sfilare cioè dovremo togliere la connessione tra wake e reset altrimenti non riusciamo a programmare una volta che abbiamo programmato con il nostro firmware il la scatto e le sp allora richiudiamo il circuito a quel punto il nostro sp potrà andare a dormire e risvegliarsi ogni volta che vogliamo riprogrammare le sp dobbiamo togliere il jumper altrimenti non riusciamo a farlo a partire tra lupo la marcia quando il gioco quando il gioco con lei è laterale vedi questo cosino che ha messo paolo perché non l'ha fatto su tutti dove sta il gioco e quindi grazie a questo sistema questo è l'unico sistema per poter far sì che si autori svegli ok l'alternativa qual è noi possiamo anche mandare in deep sleep il nostro esp e svegliarlo con un segnale esterno ad esempio con un bottone va benissimo perché noi mettiamo un button che collega in qualsiasi segnale a reset quando premo e fa reset e riparte quindi è chiaro che noi dal deep sleep ci possiamo svegliare in due modi o in maniera temporizzata se ci vogliamo svegliare in maniera temporizzata dobbiamo collegare wake a reset se ci vogliamo svegliare in qualsiasi altro modo non temporizzato con un inter basta agire su reset e su reset possiamo agire in tanti modi vi dicevo con un pulsante oppure con un altro dispositivo che alza un pin e sveglia esp in tanti modi possiamo svegliare l'importante appunto che si agisca su reset e per fare il wake up temporizzato è proprio il pin wake l'unico che genera appunto questo segnale con real time block che può andare a fare questo bene e a a questo punto possiamo provare a gestire un esempio con il nostro esp in modalità io lancio la macchina virtuale e ci mettiamo nelle condizioni appunto di programmare il nostro esp io dovrei partire questo per la sua sponica ma non mi sembra che abbia intenzione di farlo e nós di Grazie. Allora, l'SP32 dal punto di vista del power management è addirittura uno stato in più. Il DeepSleep ce l'ha ma ce n'è ancora un altro in più. Sì, non è troppo compatibile, diciamo così. Allora, il principio di quello che stiamo vedendo funziona lo stesso, però in più c'è anche, come ci dicevo, degli stadi in più. Allora, colleghiamo questo. Ok. Allora, condivido. Perfetto. Sì, sì, scusa, usiamo Arduino. La cosa che non ho detto, Arduino ha finalmente messo a disposizione una primitiva di DeepSleep. Quindi prima c'era solo la delay, ma la delay era un ciclo attivo, ora c'è la DeepSleep. Non ha implementato anche la modem sleep e la light sleep, ma si è dedicato solo alla DeepSleep, però già è qualcosa. Allora, cosa facciamo come esperimento? Allora, come esperimento andiamo a prendere un codice che avevamo già fatto tempo fa e lo aggiorniamo. Quindi prendiamo il DHT11 in flutti di B, non so se lo trovate già nella macchina virtuale, questo non mi ricordo. Altrimenti lo andiamo a scaricare da Blended. Scarichiamolo da Blended più o meglio. Allora, andiamo su Blended. Blended. Login. Login. Allora, abbiamo esercitazione SP in flutti di B, Arduino. Questo prendiamo. Esercitazione SP più in flutti di B più Arduino Sketch. E scarichiamo quellino. DHT11 in flutti di B, I. e lo salviamo da qualche parte. Ok, Inino ce l'abbiamo. Quindi, doppio clic, lo apriamo. Cosa ti fa? Ah, ok. Non mi piace. Non mi piace. Non mi piace. Non mi piace. Ah. Non mi piace. Ok. Quindi aspetto che anche voi riusciate a scaricarlo. Dovete togliere il jumper, altrimenti non si programma. perché vi dicevo, durante la programmazione gli viene inviato un segnale di reset e gli si alza un altro pin. Ma se il reset è cortocircuitato con wake, non riesce a resettarlo, quindi non parte. Ok. Allora, vi ricordate questa esercitazione? La commento velocemente che facciamo tempo fa. Cosa faceva? Si collegava al network point wifi, si collegava al nostro server di influxdb, quello che abbiamo disposto noi, e andava a inviare periodicamente la temperatura e l'umidità prese dal sensore che si chiama DHT11, che è quello blu che è connesso alla vostra periferica. Allora, io intanto attivano anche questo. Esercitazioni, unirb IoT è attivo, a press point. Quindi, una volta che avete scaricato il codice, rispetto all'esercitazione precedente, dobbiamo modificare sicuramente il wifi SSID, che ne si chiamava così, quindi mettiamo esercitazioni con la E maiuscola, il wifi password, che è unirb IoT, senza 2021. Tutto minuscolo. Se l'hai fatto pari dai collegati? Invece la macchina host è connessa. Cosa dice? Niente. È un'altra macchina virtuale questa? No, no, non posso provare. Ah, beh, se no te lo... Se hai una pinna USB te lo do con USB. Possiamo spostare con la USB. No, no, ma... Si chiamava DHT11 underscore influxdb. Sì, perfetto, allora è quello, non devi scaricare niente. Quindi andiamo a modificare, come vedete, il wifi SSID, ci mettiamo esercitazioni con la E maiuscola, wifi password, unirb IoT, e poi sotto abbiamo le credenziali del server, quelle non vanno modificate, nel senso che il server è quello, l'organizzazione è unirb, il bucket è esercitazioni e il token fa benissimo, non è stato modificato nulla. Poi abbiamo il pin, è sempre il D5, dove è connesso il DHT11, questo quindi non lo modifichiamo. Anche il client Wi-Fi va benissimo. Lasciamo tutto uguale. Abbiamo queste due variabili globali, T e H. Il setup fa la connessione. Una volta connesso, predispone i tag, vi ricordate? Ecco, magari voi qui tag, io ho SP là tanti, voi cambiate il nome delle SP come host, anche l'aula, qui non è Turing, ma mettiamo... Lab... F fa la validazione e poi entra nel loop. Il loop cosa faceva? Leggeva i sensori, scriveva in inizio di B e andava a dormire con il delay per mille. Millisecondi, quindi per un secondo. Ok? Ok. Allora, che modifica dobbiamo fare? Allora, ricordiamoci che quando andiamo a dormire con Deep Sleep, spegniamo tutto, qualsiasi cosa, anche la RAM. Quando ci riaccendiamo, l'unico modo per riaccenderci dal Deep Sleep è il reboot. Essendo il reboot vuol dire che rinistiamo tutto da capo. Allora, intanto abbiamo un problema, non possiamo salvare, avere delle variabili che fra un boot e il successivo rimangono validate, quindi si riazzera tutto. Poi, quando si lavora con Deep Sleep, la funzione loop non viene più invocata. Quindi non possiamo scrivere niente dentro la loop. O meglio, è buona regola non scrivere niente. Quindi qua ci mettiamo un commento, non entriamo mai qua. Questo vuol dire che le tre righe le tagliamo, quindi readSensor, writeInfusDB e il delay, le tagliamo dalla loop e le mettiamo in setup. Cioè si fa tutto in setup. Inutile. È inutile, sì. Esatto, diventa un loop in quel senso lì. Quindi, alla fine di setup facciamo readSensor, poi facciamo write to InfusDB e chiaramente sostituiamo la nostra delay con la primitiva che ci mette a disposizione il buon... ...per entrare nel modo Deep Sleep. E si fa con ESP.DipSleep. Il timer viene specificato come argomento del Deep Sleep in microsecondi. Quindi se vogliamo fare 30 secondi, dobbiamo fare 30 milioni. Quindi possiamo scrivere come 30 e 6. 30 e 6 vuol dire appunto 30 secondi. 30 secondi di Deep Sleep. Possiamo anche scrivere 30 milioni, eh. Questa è una notazione esponenziale così, proprio semplice. Mettiamoci un commento. All'arrivo dell'interrupt si riparte dal reboot e quindi si riesegue tutta la funzione setup. Av smoothecolo, in째 video.... Ho ricreato tutto. Si riparte proprio da capo. Microsecondi micro... Micro secondi. Si. Si. Si... Sì, si, si, cancella tutto perché proprio lui si ributta e quindi... esatto proviamo a fare un compile andiamo a vedere potrebbe lamentarsi del fatto che le funzioni read sensor e write in flux di b non sono state dichiarate in cima ma è una macchina virtuale che hai fatto tu o è quella nostra vediamo come sta andando è forse come a ti manca qualcosa no aspetta perché sp 32 diciamo a tu stai lavorando con 32 ora faccio vedere tools allora board ecco qua dovresti avere node mcu 1.0 sp 12 e module c'è live a subord manager in modem c 1.0 e poi si va su sp 82 66 board deve essere selezionato nodem c 1.0 da me non ha dato errori no dicevo invece a te lorenzo stai usando questo computer qua? è probabile però perché le macchine virtuali non l'abbiamo mai usata magari quella lì e l'avevo congelata ad agosto quindi ancora non ci avevo messo le libri in più di più purtroppo siamo un po' capito in divenire allora l'avevo congelata d'estate ma non avevo ancora aggiunto quelle di prevedì ok quindi da me ha funzionato la compilazione esatto esatto quindi adesso la board è selezionata quella giusta vero? tanta mega? si va bene quindi quando fai compile ti dà? ti dà e quando fai? viap Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie a me adesso non mi apre la TTIP而已, no, bollito B0 perché... Riproviamo. il message lo vedo è connesso USB 0 poi lanciamo Arduino a volte si incanta eccolo qua allora vediamo se è giusto sì è plumo vediamo un po' se va stavolta vediamo un po' allora qui adesso dovrebbe essere attivo mi dice 0 connessi esercitazioni con la E maiuscola password uni IOT io ancora non sono riuscito a collettare ma cavolo forse non mi chiede era DHT11 andescore in frutti B proprio quello mi sa che una l'abbiamo bruciata si ho fatto più volte questa cosa qua ma dai devi lanciare Arduino con il sudo non mi chiede di message Linux lo vede bene dice ok connesso collegato sketch upload provo l'ultima non è la Word che va riavviata infatti no devo riavviarla spesso e volentieri avrete notato che le macchine virtuali se le congelate queste qui con VMware fanno casino io perché la congelo sempre non la spengo mai adesso la spengo e poi la rilancio questo non ho tanto più volte che quando parto da una macchina congelata spesso non do un pino o qualcosa o un lardo adesso ripartiamo da zero adesso ripartiamo da una macchina virtuale adesso ripartiamo da una macchina virtuale ancora non si è connesso nessuno dispositivi connessi zero esatto esatto riproviamo ok rilanciamo l'ardomino di prima gestione libreria vai faccio vedere manage libraries poi scrivi influsdb riprovo riprovo ok ok tu sei riuscito a fare l'applauso? non ti va continua a stampare i puntini è vero ma non so questa 6.0 di windows cosa sa gli tanto ha sti problemi attivo sullo smartphone che li funziona dai dimmi che ce la fai fare l'applude adesso se no allora commissione condivisione bene non è un bel segno sì sì oggi è la giornata degli errori no adesso sta caricando c'è anche un dispositivo connesso sì ma adesso ho messo lo smartphone Android della hotspot funziona invece il punto serve dopo che hai scritto esatto adesso una volta che hai scritto rimetti il ponte e fatto messo il ponte puoi fingere anche il reset e poi apriamo il serial monitor ecco da me ce l'ha fatta il risultato mi dice writing ok connesso di un'idea di un'idea di 34 adesso lui è andato a dormire tra 30 secondi dovrebbe rifare l'us vedete lì l'aria dovrebbe rifare l'us e poi visto ha avuto Grazie. Grazie. Grazie. Grazie. Esatto. Adesso proviamo a parlare di questo. Poi considerate che c'è anche un altro vantaggio questa politica che sembra un po' brutale, no? Perché noi buttiamo giù tutto e ripartiamo da zero. Ma sapete anche qual è il vantaggio che ha? Che ogni volta che tu devi mandare un campione in realtà fai tutta la procedura, quindi fai il reboot, ricerchi il wifi ti ricolleghi al wifi ti ricolleghi alla piattaforma e questo può sembrare un controsenso ma in realtà a volte quello succede è che tu fai la tua app ti colleghi al wifi poi per un certo lavoro mandi i pacchetti magari il wifi è caduto o fai il codice robusto che ogni volta che mandi il pacchetto prima fai il senso, c'è il wifi se non c'è rilanci la routine di connessione al wifi con lo scambio delle password eccetera però capite che questo qui viene in automatico nel senso che io sono sempre un run fresco ad ogni volta che devo mandare un campione si, fa la connessione prima quando la connessione è andata a montire quindi è abbastanza robusto ma dà una robustezza interiore questo riavviarsi in continuazione per questo dispositivo perché se qualcosa va male lui quantomeno al prossimo riavvio probabilmente potrebbe funzionare meglio anche dopo un po' di tempo adesso possiamo andare a vedere se su influxdb ci sono effettivamente i dati così come li abbiamo inviati vado a collegarmi al server in influxdb avevo pulito il pacchetto ieri sera quindi sul pacchetto esercitazioni se c'è qualcosa sono quelli che sono arrivati adesso studente e la passo sì sì, quello non è cambiato nulla vado in esplorazione esercitazioni monitor task vedete che c'è effettivamente temperatura e ho ben tre vedete piattaforme pari della tanzi e calipi submit studente e un URB 2021 i nostri dati stanno arrivando su influxdb una volta ogni 30 secondi certo perché io ne andiamo ogni 30 secondi però pensate se avete intenzione di fare un'applicazione con la batteria pensavo anche a cinti che vuol fare risparmi un'esagerazione in questo modo perché quando stai fermo non consumi niente poi è chiaro se hai bisogno di campionare velocissimamente non è questo il modo che fa per te però adesso vi faccio vedere ad esempio e e chi è pari della temperatura la sua sta aumentando di brutto si è arrivato 19 e ripartito da 18 6 un'altra cosa che non vedete che è importante se avete un ESP quando un sensore è embedded di tipo temperatura spegnere tutto fa sì che la vostra lettura di temperatura sia anche più corretta perché la vostra ESP si scalda se rimane con la CPU ciclata il modem acceso quindi avevamo visto l'altra volta con le Raspberry con le Raspberry addirittura sono molto potenti la temperatura del sensore è molto influenzata da quella Raspberry pensate di poter spegnere tutto per 10 minuti quando ti accendi la temperatura che misuri è davvero quella reale e poi vai subito a dormire anche questo aiuta notevolmente ad avere dei valori significa qui abbiamo Calisti anche lui che sta scaldando di brutto 24 e 4 allora invece vi faccio vedere ieri siccome volevo fare davvero una prova reale ho fatto questa cosa qui di là con Paolo se lo vado a prendere devo mettere la nuova condivisione vado a condividere il mio schermo perché ieri ho fatto una misura di consumo energetico proprio su questo task allora vado su didattica siccome nel laboratorio abbiamo degli amperometri digitali abbiamo dei volt adesso vi faccio vedere cosa ho ottenuto ieri con questo task lo stesso task questo qui di HT Influence DB l'ho fatto sia con la delay di 30 secondi che con la Deep Sleep per vedere la differenza di consumo energetico e ho fatto con MATLAB ho fatto un'immagine che adesso vi mostro non è vero non si vede non si vede non si vede non si vede non si vede non si vede oggi è la giornata non si vede di questi cosi? no non si vede dei peg bianco ieri c'era vabbè apriamo il fig di MATLAB solo che adesso deve partire MATLAB è 90 90 megabyte queste immagini perché c'è una valente campionato a un milione di punti al secondo potevo anche campionare un po' di meno però datemi il tempo di avviare MATLAB l'avevo fatta apposta in jpeg così dicevo la lancio subito ecco adesso ci vede allora è windows che fa questi problemi questo è il jpeg allora la curva blu è il consumo energetico con la delay quindi senza andare a dormire in deep sleep la curva rossa con il deep sleep vedete la differenza? è chiaro che il consumo energetico con la delay rimane sempre qua la base è questa tutti questi picchi alti qui non stiamo andando perché noi andiamo ogni 30 secondi sapete cosa sono quelli? sono i beacon mandati al wifi perché il wifi come protocollo prevede che periodicamente si mandino dei beacon per dire io ci sono io ci sono io ci sono vedete qui è un disastro anche i beacon sono fittissimi cioè qui la scala del tempo sotto è sono i secondi nei nostri 30 secondi vedete quante volte mando i beacon e quanti li mando quindi questo è tutto un consumo energetico non banale ma la cosa che mi interessa farvi vedere è la differenza tra la linea di base blu e la linea di base rossa lì dove va in sleep e l'altra cosa che possiamo vedere da questa figura intanto qui abbiamo power in millivatt vedete siamo a qualcosa come 25 millivatt nella fase di sleep allora prima vi ho fatto vedere un datasheet che diceva micro ampere perché diciamo millivatt tanto vabbè una è potenza e una è corrente ma in realtà il datasheet parlava del processore SP io ho misurato il consumo energetico di node MCU cioè di tutto di tutta questa scheda con il PCB dove sopra ci sono dei dispositivi passivi che qualcosa consumano se io spengo la CPU c'è comunque un consumo energetico della scheda node MCU per avere il consumo energetico pure bisogna prendere l'SP da solo quindi non node MCU ma ad esempio potete comprare solo il chip iniziale se mettete la batteria allora è chiaro che arrivate a questi livelli sì però su node MCU ci sono anche dei convertitori di tensione questi qualcosina quando gli dai corrente prendono ah sì esatto perché considerate poi qui ci potete collegare in node i sensori esterni e dei sensori esterni anche quelli hanno la logica digitale la puoi spegnere accendere la loro alimentazione ci sono dei sensori però che non si possono spegnere allora noi abbiamo comprato ad esempio dei sensori che misurano gli idrocarburi in combusti quelli non li puoi spegnere perché devono essere sempre alimentati poiché dentro hanno una sorta di fornace micro fornace nel senso che deve essere sempre a 100 gradi qualcosa del genere addirittura infatti quando tu lo compri ti dice il primo giorno risultati non sono validi nel senso che lui deve stare un giorno acceso per normalizzare insomma il suo sensing poi ti dice se lo spegni il primo dato valido dopo la prima giornata è dopo 15 minuti quindi vuol dire che tu devi accendere 15 minuti prima lo puoi spegnere se fai una misura al giorno o due misure al giorno lo accendi 15 minuti prima poi misuri ma questo è semplicemente dovuto alla caratteristica peculiare di quel sensore ma se misuri la temperatura come facciamo noi adesso va benissimo non è che devi in qualche modo avviare prima il sensore eccetera è perché dopo quando si resenta lui fa l'associazione il wifi e ci impiega del tempo poi hai visto lì abbiamo messo un ciclo dell'associazione certo certo parte o parte finita esatto infatti lo vediamo anche qua prima di spegnersi lui fa il boot prima di spegnersi passa parecchio tempo perché l'associazione il wifi si connette misura la temperatura e poi si spegne e infatti sono quasi 4 secondi anche qui nella traccia che ho fatto ieri non solo ci aspettiamo anche che in questa fase varie perché magari a un boot si agganza subito al wifi al boot successivo ci impiega di più quindi è abbastanza variabile quella zona però vedete rimanere sempre accesi è un consumo energetico davvero molto molto più alto se lavoriamo con le batterie questa modalità di programmazione con il deep sleep va tenuta in considerazione sicuramente perché ecco infatti adesso facciamo 5 minuti di pausa poi facciamo un altro piccolo esercizio perché se noi dovessimo portarci un valore tra un boot e il successivo come facciamo? lo possiamo salvare nella flash perché lui ha una flash adesso vedremo facciamo un piccolo esercizio dove andiamo a usare il deep sleep ma ogni volta che ci riaccendiamo andiamo a leggere un dato che abbiamo salvato nella memoria così che fosse un contatore che fosse una variabile di stato possiamo recuperarla ogni volta altrimenti così come abbiamo fatto adesso nudo e crudo ogni volta è tutto zero no? si si ti svegli fai un buff e poi quando il buffer è pieno poi quando il buffer è pieno ti colleghi e scarichi tutto è un'idea anche quella bene adesso allora facciamo una piccola eh sì sono 4 mega se non sbaglio quindi non è piccolissimo facciamo questo lo lascio qui così funziona il cappello cosa vuoi dire ci vogliamo di questi questi che è riuscito a passare il rischio di rischio e non fa pensare tutto e non fa pensare tutto e se ci sono più arrucchi di rischio da troppo solo possono essere grandi compositi da troppo di rischio di rischio e quindi danno un po' eh si hai un po' dentro lui non mi ricordo cosa aveva fatto comunque ha avuto problemi il grosso dei problemi è stato fare gli script praticamente per esempio Windows di eseguire le cose in un'altra ma quando non avete la cosa dicano però non non non non non non non non non non non non non non non non non non non non non non non non qui cosa parda le cose di l' FAE ilょ Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Per finalizzare. Sotto il testo. Sotto il testo. Sotto il testo. E vediamo se funziona. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Quindi diventa il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. Sotto il testo. con un alimentatore. Bene. di chiudiamo.