cloud perfetto la registrazione partita e di condividere lo schermo eccoci qua oggi iniziamo a vedere le tecniche di programmazione dei sistemi e cioè dei device edge nell'iott quindi ci chiediamo proprio come si programmano questi device e dal punto di vista progettuale adesso non è che in questo momento prendiamo un device e esploriamo come si programma quello no andiamo a vedere le tecniche di programmazione più diffuse nel mondo aiuti a livello edge allora dovrebbe essere partita la sito dovrebbe essere apposta i contagi quindi sono diverse tecniche di programmazione dei device a livello edge sono diverse anche perché dipendono anche dal da stazione e quella che è la più nota la più diffusa esser sicuramente la più semplice è quella che viene chiamata la struttura a super loop la struttura super lupo senza girare troppo intorno è quella struttura ma banale semplice che prevede la creazione di un software che sia in un grande loop ecco perché siamo super quindi come vediamo da questa da questa slide abbiamo a che fare con un main quindi il codice principale della nostra macchina e a un certo punto ci sarà un grande while 1 ad esempio c'è per tutta la vita di un inelda su un'operazione di una maia facciamo qualcosa perché è molto usato questo strumento perché questo strumento questo super loop è così diffuso allora intanto alla caratteristica di essere semplicissimo alla caratteristica di essere portabile su praticamente tutte le architetture perché qualsiasi servizio anche da più semplice al microcontrure o di sensibilità prevedono una sintassi while o una sintassi foro quindi in questo caso un while 1.000 come funziona funziona che il nostro programma chiaramente parte ci sarà sempre un routine di inizializzazione di qualcosa quindi identificata come x underscore init e questo x underscore init è appunto una funzione una routine che deve inizializzare dei parametri magari inizializzare i sensori nel nostro caso e predisporne il tutto affinché nel nostro super loop si possa eseguire il nostro task in questo caso il task è identificato dalla funzione x x è il nostro task che dobbiamo eseguire cosa può essere x facciamo in un device edge potrebbe essere contatto con il mio sensore leggo il valore di temperatura leggo il valore di unità posso fare una personifica posso fare una media mobile mobile magari come array polizializzato come x i salvo dentro questa array calcolo la media e poi faccio una send verso un qualsiasi server finita questa è finito il mio task vado in una stato che qui chiamo wait ad esempio wait 35 è un wait temporizzato cioè aspetto per 35 posso essere secondi minuti quello che volete il mio super loop è fatto così mi alterno in uno stato di esecuzione il task e poi attendo quando mi sveglio dall'attesa ripeto il task tutto qua la maggior parte dei dispositivi edge viene davvero programmato così banale sembra banale è banale ma viene davvero programmato così la maggior parte di questi è cioè la tecnica super loop sono tutt'altro che tecniche superate perché perché il super loop è semplicissimo no da scrivere se guardate qualsiasi codice embedded che trovate sulla rete molto probabilmente lavora con lui se avete esperienza di arduino lavorato con lui facile da gestire da mantenere efficiente certo non mi serve quasi nulla a livello auto cioè mi serve che la mia piattaforma abbia a disposizione una wait temporizzata e un'istruzione di cibo quindi effettivamente l'efficienza è altissima per non parlare di curve di apprendimento per scrivere il codice e come vi ho già detto per non parlare di portabilità perché il super loop io posso scrivere la riga di un paio in qualsiasi linguaggio che io posso utilizzare nelle mie piattaforme ha degli svantaggi certo che ha degli svantaggi adesso prima di parlare degli svantaggi vediamo che questa questo esempio che avevo fatto è un esempio banale di programmazione super loop anche per la sbri è un esempio per esempio fatto in parte dove questo è un esempio che avevo proprio testato nelle nostre nelle nostre sbri dove abbiamo un adc che si chiama mcp 308 ricordo che la per di paia non ha una dc in teo non ha un sistema per la conversione analogica digitale ma basta comprare un cibo anche esterno come in questo caso un cibo che costa 3 euro che si chiama mcp 308 ed è un cibo che permette su diversi canali di fare per il momento una volta digitale grazie alla diffusione di questo strumento esiste proprio una libreria python si chiama mcp 308 quindi adesso vediamola così poi quando faremo la prima esercitazione studieremo e vedremo proprio come si programma la raspberry pi in python ma in questo esercizio importiamo la libreria mcp 3008 e importiamo la libreria slip diciamo che ci serve cosa facciamo vabbè al di là di questa più distruzione che va a creare un'istanza di mcp 3008 sulla quale andiamo a scegliere il canale visto che invece che prima cosa un canale c nel caso scegliamo il canale lo zero perché perché allo zero abbiamo collegato qualcosa della nostra nel nostro shield della raspberry pi abbiamo collegato in particolare un lm 35 lm 35 è un sensore di temperatura che si basa essenzialmente su una resistenza interna è un termine resistore costa davvero pochi centesimi e di analogico dove abbiamo collegato abbiamo collegato il canale zero poi qua ci sono altre istruzioni di inizializzazione del canale dove andiamo a dire la massimo voltaggio di lettura e se il canale deve essere differenziale lo vedremo comunque nelle esercitazioni una volta che abbiamo creato questo oggetto mcp 3008 quindi questa è la fase diciamo così di inizializzazione delle forze inizializzazione delle forze inizializzazione del superlucro vedete in python un superlucro possiamo uspire qui a più per sempre cosa faccio leggo il valore dal mio oggetto mcp 3008 che è inizializzato e lo metto in una variabile temporanea poi faccio una print è digital stampo il contenuto di questa variabile ricordiamoci che lmcp 3008 è un analogico di scuola conversizione logico digitale ci ritorna già un valore digitale ma in testa di tensione la tensione che le ha i capi del suo conlettore quindi quello che stampiamo è il valore letto il valore letto poi lo trasformiamo in volt visto che la prima lettura è scalata sull'alimentazione 0 1 lo moltipliciamo per 3,3 che è la attenzione l'alimentazione del nostro circuito stampiamo il voltaggio e poi grazie al detasheet dell'lm35 saremo in grado di trasformare questo voltaggio in temperatura molto semplice perché basta da moltiplicare per cento quello che riteniamo è la temperatura di galite celsius e lo stampiamo con questa stringa e poi cosa facciamo? slip 10 slip 10 vuol dire che il nostro superluccio torna per 10 secondi quando si sveglia torna in guarda il trono ecco proprio il codice minimo di un superluccio che funziona benissimo che provvediamo? tutto bene dal nostro punto di vista è funzionale, facile da comprendere, temporizzato quindi noi ogni 10 secondi abbiamo una lettura la lettura in questo caso viene semplicemente stampata potremmo collegarsi ad un server per fare una push per inviare il nostro valore ma diciamo questo è effettivamente ciò che potremmo fare ed è davvero funzionale ma come scriviamo qua un grosso problema di tutti i tasti in superluccio è che la tempistica è non accurata perché non accurata? perché io posso avere una slip, una weight accurata quanto vuole dare la mia attività è davvero un grosso, una weight accurata quindi addirittura al micro secondi potremmo dire no? e quindi lei non sbaglia ma il problema è che il nostro task potrebbe avere durate variabili allora il task prima non mi vede durate variabili perché legge da una DC locale collegando i quadro C è difficile che una lettura successiva abbia dei tempi diversi da questo stesso ma se noi ci mettessimo anche l'invio del pacchetto verso un server allora questo potrebbe avere un diritto di qualche tempo questo cosa vuol dire? che il mio task qui potrebbe durare qualcosa di variabile se dura qualcosa di variabile io faccio una weight precisa quanto voglio in realtà il campione che leggo non lo leggo a distanza costante lo leggo a distanza che dipende dalla elementazione della realtà se mi va bene, probabilmente per l'85% delle mie applicazioni mi va benissimo ma se io volessi un timing accurato questo sicuramente non sarebbe un buon modo quindi sicuramente ci serve una weight e una slip molto accurata perché se anche la weight e la slip non fossero accurate allora avremo due problemi di accuratissima sia il task che ha durata variabile sia la weight e la slip che non sono accurata ma anche se la weight e la slip fossero accuratissime il task probabilmente potrebbe avere una durata variabile quindi il super loop genererebbe sicuramente un grosso svantaggio ma non è l'unico svantaggio perché l'altro svantaggio che facciamo individuale è sicuramente legato al consumo energetico molto di questo luogo perché è vero che spesso volentieri i super loop si usano in architetture di bassissimo livello l'architettura di bassissimo livello comunque quindi anche i microcontrollori hanno differenti sistemi di power panel cioè di sicuramente differenti livelli di consumo energetico con il super loop noi siamo up quando facciamo il task al 100% e poi ci affidiamo alla slip, alla weight cosa fa la slip? che livello di power panel usa? che livello di frequenza usa della CPU? ci da vantaggi a livello di consumo energetico? no, è molto semplice ma soffre di problemi di timing non è molto naturale e soffre di problemi di elevato consumo energetico una cosa che mi sono dimenticato di dirvi perché in questi dispositivi Edge si usa molto il super loop perché la maggior parte dei dispositivi non hanno un sistema operativo non guardiamo la sverra pari che c'è l'invisto parliamo di sistemi che non hanno un sistema operativo cioè sistemi molto piccoli non avendo un sistema operativo non hanno le sistemi che noi conosciamo non hanno dei sistemi operativi di alto livello che ci permettono di essere accurati di essere sincronizzati ci permettono di eseguire le tue tasking contemporane no, molti dispositivi non hanno minimamente un sistema operativo quindi siamo noi a scrivere il codice ed è il super loop che viene portato e viene molto utilizzato che è il modo più semplice di mantenere un'esecuzione sempre attiva e nel dispositivi Edge IoT è fondamentale che questo sia sempre attivo e che faccia di dare una misura in continua di un parametro quindi ricapitolando, super loop è usatissimo? sì, è usatissimo perché non esistono spesso i operativi sotto sul quale appoggiarsi ha problemi di tempistiche inaccurate e ha problemi di consumo energetico che può essere anche molto alto perché non si sfruttano tutti i sistemi diciamo così i livelli di funzionamento energetico delle varie CPU allora qual è una soluzione che si è utilizzata molto efficacemente ancora delle architetture senza sistema attivo quindi ripeto parliamo di architetture davvero molto semplici la nostra Raspberry Pi non avrebbe senso lavorarci in questo modo ma una soluzione che è low power quindi non consume energia come quella che abbiamo visto precedentemente e che è anche accurata dal punto di vista delle tempistiche è quella basata su un'intera sì, te la faccio adesso piano piano do la testata e la testata dovrebbe funzionare allora sappiamo che cos'è un intera che è un segnale a singolo e ha la caratteristica di sospendere la CPU da quello che stava facendo e fa saltare ad eseguire quella che si chiama la routine di gestione dell'intera ma non solo sospendere la CPU c'è un'altra caratteristica molto interessante che con l'intera è possibile fare un wake up from free tutti i continuano contro loro che hanno vari livelli di consumo energetico e di stadi di funzionamento hanno tutti stadi a bassissimo consumo che sono risferiabili con internet quindi se io mando tutto il contro loro che mi abbassissimo consumo vuol dire che il ciclo flash di cose del test è bloccato ci toglie addirittura corrente arrivano a consumare micro-batt proprio una cosa bassissima e da quello stato con un intera io li posso svegliare e ripristinare il ciclo flash di cose del test e svegliarli e diventare attivo quindi il fatto che l'intera possa in maniera sincrona svegliare da uno stato di bassissimo consumo energetico e essendo l'intera un segnale che può essere gestito con una precisione temporale altissima allora io posso fare che cosa utilizzare un timer timer è proprio un sistema che si dice che può essere preciso quando vogliamo anche di vibra contro noi normalmente c'è un oscillatore un quadro che addirittura un quadro permette di rendere stabilissimo l'oscillazione e quindi contare il tempo in maniera stabilissima e quindi sarà possibile con un timer che ha il suo interno a questo quarzo generare intera periodici e svegliare il microcontrollore che è dallo stato di addirittura più basso e quindi dove effettivamente non consuma nulla come si può usare questa copiata timer in più internet per generare un task più performante del superluc vediamo come si può fare allora il nostro non so cosa devo fare non colpisco dimmi forse il mio editore forse il mio editore ma è una pari che la prima non prende il gesto proviamo ma potrebbe essere allora io l'ho dato per il mio si si allora per fare 10 milioni che lavagna come funzionano i sistemi basati su internet task allora il nostro software ha di nuovo il main ha un init che è una funzione di visualizzazione proprio come prima e guardate bene non fa niente invoca no e invoca adesso proprio in modalità boia mondo non sape che ne voglio avere un video in tua tezza ma dove per te no no su quel simboletto di con la pelle ah si però che è un maremma eh non sape così di tutto tutto ogni volta che io mi scrivo un po' devo passare prima di là mi fa arrabbiare molto queste cose però allora vi dicevo che la slip in questo caso non è temporizzata vedete non c'è un argomento non è la slip in 35 ma in una slip in realtà è un dire invio al microcontrollore allo stadio di oggetto di basso consiglio per sempre ok quindi cosa fa il mio task dal punto di vista della scrittura è semplice c'è l'inizializzazione di qualcosa si si è praticamente ci alterna nello stato di penna che io vorrei mantenere allo stato di faccio come mi pare allora come funziona il sistema? allora la slip abbiamo detto manda la cpu nello stato più basso andiamo a vedere cosa fa l'init allora l'init che è questa funzione qua è una funzione che serve a settare il time limit cioè io ho bisogno di svegliarmi ogni x microsecondi x microsecondi e l'init fa proprio questo quello che vediamo qui è codice di basso livello legato chiaramente all'architettura con cui stiamo lavorando che è un microcontrollore non ci supermiamo su ogni riga di codici ma vedete qui viene settato un praticamente il quartzo al suo interno di 18 kHz noi dobbiamo vogliamo inizia 255 microsecondi e noi dobbiamo fare dei visori per far sì che praticamente si vada ad avere un segnale ogni volta che lo vogliamo noi non ogni 55 microsecondi quindi vi tralascio questo codice di inizializzazione ma questa questa init che viene eseguita una sola volta configura il timer interno microcontrollore per fornire un segnale in questo caso ogni 55 microsecondi in questo esempio quindi vogliamo un segnale periodico ogni 55 microsecondi benissimo e questo codice viene eseguito una volta sola quando il segnale arriva la mia cpu che era entrata in slip più profondo quindi viene fatto un webac e il wake up da un interapp fa sì che si esegua la routine di gestione dell'interapp che è questa altra funzione qua sopra, q1 interapp che viene eseguita in maniera larga cioè arriva a vita, ci fa il wake up da cpu che si esegna, gli viene data fornita e va subito e viene quella funzione del codice cosa ci mettiamo in quella funzione? il nostro task il nostro task va in quella funzione la vedete x che è il nostro task che fa quello che deve fare sta di dentro esattamente il idetto qui non si sanno di nu, perché la funzione finita e poi riconoscemo esatto, la funzione è ritorna, ecco chiaramente il task deve entrare in nu la funzione ritorna, quando ritorna la cpu automaticamente arriva nella modalità più bassa di consumo energetico al prossimo segnale, al prossimo 55 microsecondi si risveglia di nuovo, torna qua e riesegue il task, quindi il task viene eseguito ogni 55 microsecondi questo qui funziona se il task ha una durata costante oppure non supera quei 55 microsecondi ecco, non tanto costante, ma non supera, perché se è inferiore o comunque inferiore la tempistica è precisa, perché l'interapp arriva sempre 55 microsecondi è generato da questo timer, poi se tu qui ci impieghi 23 microsecondi, 18 l'esecuzione prossima c'è la sempre 55 a partire dalla precedente se si è in un'infinizione? in un'infinizione in un'attuale? no, in un sistema a singolo coro viene referito, quindi si sfalta il time ah, un'infinizione in un'infinizione ma non è che ci sono tutti 30 almeno esatto, se accettiamo un 3 di tutti i go, allora si ma in un'infinizione così ma si si fa delle 3 e poi anche ci si scopri perché poi due 3 che tendono a riaccedere la stessa risorsa esatto, possono andare in condito però non mi succede che io le dico che si può dire che tu arrivi intrapprecato no, in questa architettura no perché appunto è un'architettura banale senza sistema operativo quindi fino a quando questo intrapprecato non ritorna il prossimo intrapprecato non viene accendente si, quindi viene referito in quanto sull'interapp esatto, e l'altra cosa che dobbiamo ricordarci di fare questo è un accorgimento a basso livello per chi non ha lavorato con architetture a basso livello può essere una cosa strana ma è fare il clear dell'intra perché in realtà quando l'interapp viene ricepito è vero che si esegue una funzione ma fin tanto che non viene pulito il flag della funzione poi verrà convocata quindi cosa succede? se io sto eseguendo questa funzione questa funzione non ritorna è molto lunga nel frattempo arriva un interapp il flag mi viene riuscito a 1 e quindi appena ritorno a casa mi viene eseguito a 1 perché fin tanto che il flag è 1 non viene eseguito la regola qual'è? cercare di avere una tempistica se qui ci chiede 55 microsecondi per un esempio ci chiede un time limit a 10 secondi l'importante è che le totassi non ci chiedi mai più di 10 secondi per eseguire se manteniamo questo ragionamento lo tutto funziona e un codice così fatto è un codice classico che possiamo usare un microcontrollore a bassa energia e come abbiamo detto ci garantisce intanto che le tempistiche siano molto accurate vedete qua questo è proprio un esempio di eseguitore quindi facciamo finta che x duri più o meno 10 microsecondi quindi bene inferiore ai 35 che è il nostro timer inter anche se x una volta dura 10 una volta 12 una volta 22 dal punto di vista della tempistica come vedete qua non cambia nulla il timer viene generato sempre ogni 55 microsecondi questo è invariante proprio questi 55 microsecondi sono invarianti e x può anche leggermente variare vi dico leggermente perché non deve mai arrivare a 235 la durata di x ma la cosa che a noi interessa anche è che questa fase qua è una fase a bassissimo consumo energetico e noi possiamo risvegliarsi da quella fase solo grazie all'inter senza l'intera non ci riprenderemo quindi noi cosa possiamo fare possiamo mandare in slip più profondo possibile questo vuol dire che posso davvero consumare pochi micro watt e risvegliarli periodicamente per eseguire più tanti quindi al super loop ogni volta che è possibile conviene sostituire un sistema asintro sicuramente non solo per la tempistica la tempistica abbiamo detto vabbè se non è fondamentale della mia applicazione mantenere la tempistica costante passi ma per il consumo energetico conviene sempre lavorare così perché posso sfruttare gli addormentamenti più profondi anche i microcontrollori della serie arm sono in grado di andare a dormire anche i controllori che diciamo così che viaggiano normalmente a centinaia se non anche un gigaer sono in grado di andare a dormire e consumare davvero poco pochissimi micro watt e quindi conviene sempre usare in questo modo possibile comunque quando sono stanno dormendo qualcosa per per la prima volta che si deve essere si ma in grado di cese solo in real time clock che lavorano di quasi è quello che consuma di un prodotto il resto è il prospetto la RAM la RAM in realtà sarà ceduto ecco in realtà molti di la nostra parte dei controlli usano queste raro ferro magnetiche addirittura che non possono ricercare il contenuto quindi alla fine sono delle EEPRO si però non sono le architetture EEPRO quindi l'EPRO che per scrivere sono costose no? si si no soprattutto al numero di cicli vendettivi esatto quindi se no sono 300.000 sono delle RAM a tutti più effetti solo che rimangono nel contenuto quanto stacchi la corrente quanto meno stacchi la effetti è una RAM dinamica che è un piccolo magnetitramo se voi guardate anche gli MSP qui della Microsoft della testa sinistro i nuovi contenuti come noi c'hanno una RAM classica e in più sanno anche il programma che erano parte così ma vuoi dire i TASI che erano lì per i quando tu spegni le ricerche riparte adesso due tipi di varianti quelli che sto usando adesso per se dire e le scrivere le mani che ti ha e tu il programma di te puoi scelere dove caricare anche tutto il TASI se il piccolo si sta nella RAM quindi di solito sono metà metà dinamica che sta all'altra e non cancella la cosa bella è che non sono le eccombe le proprie quindi non devo fare la procedura di scrittura di cancellamento della cella ma è che non si fa chissà di cosa e l'auto altrimenti cosa è di riniti secondo me sono fantastici questi tipo con noi perché costa davvero poco ma il banale ci spende di ripartire non devi fare più a mano con una sorta di ibernazione quindi una volta si faceva l'internazione con gli MSP2486 si chiamavano eric che dovevi salvare il flash perché ci avevano RAM e flash eric tu quindi se volevi mandarlo a dormire allo stato più basso allora devi preoccupare questo lo salvo di questo lo salvo di ora se lo carichi in queste nuove RAM praticamente è perché la scuola e poi lo riacevi quindi vi dicevo questo è fondamentale per quanto riguarda il consumo energetico e sicuramente ci garantisce anche un timing molto molto più oppurato ecco qui va bene facciamo vedere il fatto che dicevo prima che x può variare quindi anche se x è variabile nella sua durata quello che succede è che comunque noi abbiamo sempre un timing preciso perché l'intera sta a partire sempre a 55 microsecondi questo è proprio il modulo indipendente da quello che sta facendo la CPU perché in realtà il clock manda un segnale e quindi a noi sinceramente non ci interessa questo spasamento e la cosa che facciamo a notare ecco in questo sistema dove il task dura 10 microsecondi e lo mandiamo a dormire per 35 abbiamo il 64 per cento del tempo passato in sleep mode e quindi passato a uno stato di consumo bassissimo e questo è un esempio che manda un segnale di 35 microsecondi se noi lavoriamo così con un device IoT che deve cambiare una volta al secondo e il task dura qualche millisecondo abbiamo il 99,9 per cento del tempo passato in T questo per noi è fondamentale per non consumare energia e magari anche per far sì che il sistema duri di più se avesse poi un sistema gestito con la batteria è questo è fondamentale qualche anno fa aveva fatto un'applicazione o meglio aveva creato un prototipo di sensore sottomarino che misurava le onde sono ore le registrava proprio e poi faceva un duodo del process perché praticamente con degli studiosi di scienze ambientali si andavano a cercare di trovare i segnali delle valene che parlavamo proprio di loro i device andavano da 35-40 metri soltanto e c'è stata la vostra e tu non potevi pensare della batteria che si è rimasta perché noi stavamo la barca mentre scavano dalle buone tra di su apriri per stare a 50 metri soltanto facciano delle guardie sui spese quindi la valente di più loro per esempio a 45 metri soltanto e allora la sfida era stata proprio quella di tenere la CPU più bassa possibile quando miglioravano fare niente noi cosa facciamo? campionavamo Claudio in finezza del temporale non è che campionavamo tutto il tempo quindi si dice che ogni ora campiono 5 minuti in questo modo tutto il resto del tempo doveva andare dal mese più possibile a uno stadio di consumo energetico più basso possibile e grazie a quello le batterie duravano 3 mesi quindi andare a ripescare questi agenti ogni 3 mesi e la cosa se devi ripescare un mese cambia totalmente anche il costo del progetto e alcuni di questi sono ancora in Sicilia sul papo ogni tanto li vanno a ripescare e vedete che ci stanno lavorando e funzionano e era tutto scritto in linguaggio C che era una ripetentura del Texas Instruments come libero controllore che poi aveva un DSP un board perché aveva la necessità di fare processi un board altrimenti cosa voleva dire? voleva dire che io dopo ripescavo questo oggetto c'aveva le SD sull'interno dovevo sbubinare tutto inizio di facciare processi un board e andavamo già a fleggare tutti i record che eravamo salvati grazie grazie perché io da qui non so per quale motivo ma come vedete non si vede allora l'ADC non è fisicamente collegato ai sensori della quali le devo convertire i valori giusto? è fisicamente collegato cioè l'ADC ha una porta digitale in questo caso nell'esempio di prima che è collegato alla Raspberry Pi no? abbiamo l'ADC l'MCP 3008 è collegato in quadro C quindi la porta digitale verso la Raspberry è digitale quindi quadro C dalla parte opposta ha diversi canali analogici sul quale collegare il PIN del sensore che voglio buttare quindi cosa succede? che lui automaticamente col campiona i valori dal sensore li digitalizza produce un valore numerico compreso fra 0 e 1 che poi deve essere scalato come avevo fatto vedere con la tensione dell'alimentazione che da noi era 3.3 quindi quando faremo l'esercitazione vedremo proprio la la i PIN come sono stati collegati alla Raspberry Pi nella nostra shield e proveremo ad usarla proprio in questo modo però sì è fisicamente collegato sia ai sensori volevo dire è collegato comunque ah ok non c'è il non sì confermo l'ADC è collegato fisicamente al sensore e fisicamente alla Raspberry Pi visto che è un dispositivo esterno alla Raspberry Pi collegato tramite il quadro G quindi invece poi una domanda che si fa poco come viene per esempio degli interatti come si porta il time che crea il timer e qui con te c'è un sistema operativo sotto magari sono delle azioni quindi qui non c'è serva nel caso non c'è ma c'è come c'è come hai visto in questo caso non c'è proprio il sistema operativo allora cosa si fa? si lavora con a livello bit bit proprio vedi queste sono le maschere cioè i comandi da dare al al timer interrupt cioè tu lo stai programmando il timer interrupt però vedi ma vedi interaggiamo direttamente poi ah sì sì sì perché questi valori queste qui sono delle maschere definite dal compilatore quindi quando tu compili qui vai a settare i bit esattamente nel registro del real time copy e lui ci troviamo in più modo e questo è offerto e allora quando tu compri un microcontrollore di massissimo livello ti offre che le siamo la tool chain cioè ti offre la libreria del compilatore ammettici usiamo un gcc modificato che è un gcc per il microcontrollore però viene offerto di solito dal produttore del cibo insomma quindi hai un data sheet e sai che per programmare il timer devi mandargli queste grandesse qua non è proprio di bassissimo livello però non è banale non c'è niente su un microcontrollore non c'è niente perché non c'è qualche sistema quindi non ci sono delle funzioni se non appunto queste queste maschere che ci permettono di iscriveri sui registri del microcontrollore e ci sono dei registri che sono quelli che si andano a programmare perché fai i registri per andare in lì è comodo si andano a programmare è comodo si andano a programmare esclusivamente in più complesso ma tu scriviti nella memoria e decisi quelle che dovevo facendo le monedì cambiavano che era esclusivamente ma il microcontrollore ma il microcontrollore funzionava benissimo un mega il microcontrollore di oggi sono molto comportabili nell'architetura dell'epoca e all'epoca quelle le architetture più evolute adesso non c'è più spartanile rispetto a prendere adesso sì i microcontrollori oggi sono così basso livello perché? perché non possono aspettare un sistema operativo complesso perché hanno poca ramp poca frequenza flash quindi poco c'è l'avvantaggio del codice però si usano per il loro vantaggio di essere il cabello del power e a basso costo cioè microcontrollore lo fai di 3 euro poi se lo compri a una unità se ne compri mille i costi sono davvero bassi ah no no ma che è che semplissima nel microcontrollore dei sensori sott'acqua eccetera eccetera invece il problema è che deve fare dell'elaborazione on board si l'idea di mettere un modulo wireless cioè per farlo comunicare in wifi è un qualcosa che non c'entra niente oppure può che la tenere un senso? non avrà senso perché ti sei a parare per 5 metri sott'acqua ti serve a mano troppo? perché ci vuole tanto di quell'energia per arrivare in cima esattamente è lo schermo della schermatura dell'app magari non ci metti una serie di hub nelle boe lo sai come comunicano? con un'idea sonora perché un'idea sonora in acqua piangono benissimo vanno al pericolo dell'aria fanno velocità ma non solo si risperdono poca energia e quindi tu riesci a rispedire lontano le informazioni senza consumare troppa energia cioè è molto meglio il l'idea sonora soltanto che non delle informazioni non delle informazioni però dopo non è così esatto tu consideri che questi sensori qua si mettevano in batterie e noi ne eravamo a 50 quindi andavano lì con una barca come il cellulare la giornata la giornata poi dopo 3 mesi ne deve ripescare la cosa che è importante era quando devi ripescare non togliere l'Sd che è processale sai quante ore gli altri ci sono ma ci sono cosa che non ho detto perché il campionato non vale la fatta perché quelle ballere avevano un campionato a 260 kg quindi i file venivano grandissimi cioè ci troviamo su prontati in C a bestia per il campionato dell'Aubi e l'Sd l'Sd doppie anche per fare una minoranza sai che no? la scheda è così lunga la scheda eh sì ma non lo rimasci è più piccolissimo noi la scheda è così lunga stava in un tubo d'acciaio spesso un centimetro per un pomeriggio eseguito con la pressione e non era una cosa banale ma nessuno ha pensato di questo sistema di ricarica delle montere di vena? ancora questo non si è scientifico è il fatto con il CNR della Sicilia perché in realtà non si è menuto di varie cioè se si riesce a andare tranquillamente questi estremi sono ancorati al frontale cadevano a livello giù si è leggermente inquinato comunque le corrette sì sono metà a mezzo due metri quindi basta anche sul movimento per generare tanto interologi e spiegare a parteciazzo ah che sono i miei vecchi questo io ci parlo questo studio non c'erano lavorare circa dieci anni fa e ancora dieci anni fa tutto era la bomba tutto il bambino per esempio perché comunque erano zone disagiate cioè andati nell'angolo non è che lo metti vicino alla costa quindi no era una cosa terribile dove venivano buttate queste cose quindi l'unico modo dalle sue suolo da l'unico ma no c'era un distanziatore che aveva una certa distanza per il suolo quindi non andava proprio non lo pavano che misuravano i baleni i delfini e addirittura c'era un studio che cercava di scattare dei suoni invece di invertebrati che comunque facevano delle dimazioni con carapace insomma ci sentivano anche quelli che stavano misurando anche quelli questi ricercatori del generale dopo io quella parte me ne sono fregato in senso che loro mi dava una specifica mi serve 260 kg mi serve salvare questo però la parte biologica animalesca diciamo così un pochino me la sono bypassata però era stata una sfida il consumo del zè per lì la sfida era un aggeggio che doveva davvero consumare un po' quindi abbiamo detto che grazie a questi sistemi basati su generazione asincrona di Interapp e praticamente utilizzo di di di di rutilizzo per contenere il nostro task limitiamo il consumo e rendiamo il timing davvero preciso facciamo una pausa e poi riprendiamo per la seconda parte ok? allora domani facciamo le nostre lezioni sono riuscito a tornare il lavoro e quindi noi abbiamo le azioni dalle 9 le 12 domani siamo in laboratorio con le rascerte se qualcuno ci vuol portare lo sgarri da casa perché no, puoi lavorare con la tua così ti mantieni quei paio qui dentro qui l'attacchi semplicemente allo schermo noi faremo così staccheremo la tastiera il mouse dell'academy da un tipo di concetto la stacchiamo alla tua quindi se invece di andare a trovare un documento porti la tua volta lo stesso cioè dopo lo shield usiamo il nostro così perché magari hai poi il file che scrivono insomma voi preferisci? ma non c'è l'altro che si trattiva il quiso, non cambia niente però come volete? mi sono piaciuto andare bene in due allora qui ne sono tre sono il bai perché secondo noi il robot non c'è un 5.12 giga di organica l'importante è che c'è il Python sopra no, non voglio andare a fare ci sono un cittadino mobile da... se volete usare quelle del laboratorio ce ne abbiamo... non tanto voi siete tre ma non è una persona in più ma non so se c'è c'è Paolo si ma come volete? dite c'è Paolo quindi si può sentire però direi dai va bene quindi domani riusciamo a fare il laboratorio bisogna in realtà di fare il laboratorio come? Paolo non credo che... no ma è quello che mi aiuta a battere del stessi a dire da parte di te lui che è insinito per la sperma a me sarete in uspiti ormai sette o tre anni fa lui si era costruito la stampante 3D che andava con l'ambulina e il coso che però non usava il filo quello normale non usava una plastilina perché non si poteva andare in giro ma c'era le sclusure che faceva uscire la plastica ma c'era usata in giro la plastica quindi non usava il filo di plastica che si scegliero ma non mi ha fatto vedere la nostra plastica e dopo è anche molto di meccanica se non lo vede non usava la plastica ora viene anche dalla parte meccanica bene, allora domani facciamo esercitazione iniziamo quindi con la primissima esercitazione per conoscere tutta la raffaia che vai e usare i sensori che abbiamo sia quelli analogici che quelli digitali in realtà abbiamo i shield perché non si vede con la sensore ma sono i sensori di temperatura della CPU interna quindi non ha nessun altro tipo di sensore però abbiamo questi shield che li posso applicare con Paolo che li possiamo incastrarle sopra che hanno sensore di luminosità, di temperatura, di cina ma anche io li devo comprare sì, allora domani usa quello che offre il convento diciamo così poi dopo bene allora andiamo avanti e abbiamo visto quindi la logistologia di programmazione Superloop abbiamo visto un'evoluzione della Superloop utilizzando la routine di gestione dell'Initra quindi la programmazione di un RTC che comunque è presente su tutte le macchine basate su microcontrollori ora vediamo invece il capitolo 3.2 dove si parla di architetture software basate su macchine allo stato finito quindi stiamo lavorando con un'architettura più complessa di quella Superloop anche più complessa di quella basata su un'architettura intrasincrona e normalmente le architetture basate su macchine allo stato finito sono architetture che provano a giudere con un'ordine un pochino più voluti più potenti non c'è ancora un sistema operativo quindi non è ancora paragonabile a quello che può essere Raspberry Pi ma ci parla di architettura e macchine stati finiti perché queste definiscono nella parte diciamo di programmazione un insieme di stati ecco perché si chiamano stato finito un set di possibili eventi che vedremo serviranno come input per la programmazione e un set di possibili azioni quindi di app del nostro sistema a completare il tutto abbiamo funzioni a completare il tutto abbiamo delle funzioni di transizione da uno stato all'altro cosa vuol dire? come sono fatte queste macchine? allora intanto parliamo di stati che per noi che vorremmo programmare poi questa macchina gli stati che cosa sono? non sono nient'altro che un set di possibili situazioni del nostro mega task quindi possibili condizioni ben distinte nel cui il nostro task si può trovare quindi a intervassi di complessi di una semplice lettura che se non solo avevano usato prima quindi il nostro task può essere suddiviso in possibili stati che identificano delle situazioni in cui si può trovare il nostro task e la cosa che caratterizza le macchine a stato finito è che in ogni istante la nostra macchina si può trovare in uno solo di questi task di questi stati proprio perché è un sistema finito che si alterna tra i vari stati e i stati sono mutuamente esclusivi per entrare in uno stato contemporaneamente all'ingresso in un altro così come l'urro dei stati deve essere per forza finito ecco perché si parla di macchine agli stati finiti abbiamo un set di stati che rappresentano quindi situazioni ben distinte in ogni istante la macchina può essere trovarsi in uno solo di questi e il numero degli stati non può essere infinito ma dal nostro punto di vista cosa vuol dire? vuol dire che una macchina in un stato finito può essere rappresentata con un diagramma fatto in questo modo cioè abbiamo gli stati che sono rappresentati come dei nodi gli eventi sono degli archi che ci permettono di triggerare il passaggio dall'altro l'evento di start che è l'evento iniziale e poi abbiamo l'evento di fine che è l'evento che identifica proprio l'uscita dallo stato della macchina quindi la macchina che si ferma in qualche modo ok? bene in questo caso cioè con la rappresentazione in macchina è stato finito diciamo rappresentare un numero qualsiasi di task cioè qualsiasi tipo di task in questo caso nell'esempio è il task che rappresenta questa slide è un task che vuole fare il parsing di una stringa dove vuole cercare un'occorrenza del doppio slash che è come vuol dire quindi è semplicemente un software che deve processare una stringa rappresentato con macchina stati finiti allora arriva la stringa quindi parte start e il primo nodo cerca la prima occorrenza dello slash se non la trova quindi no output rimane là se la trova passa alla seconda alla ricetta della seconda occorrenza se la trova esce quindi fa dann altrimenti ritorna nella nella primo stato questo è lo stato macchina finita quindi la prima occorrenza di carattere causa l'avanzamento della macchina vedete la prima occorrenza causa l'avanzamento della macchina al secondo stato quindi si passa al secondo stato quando nel secondo stato trova un'altra produco l'auto se non lo trovo invece torna avanti perché quello che sto cercando è quello che sto cercando è esattamente l'occorrenza di due caratteri consecutivi non è l'unico modo che scrive un parser chiaramente questo è un parser di una stringa che cerca certamente quel doppio carattere scritto grazie al era rappresentato in questo caso ma poi non abbiamo visto come scritto rappresentato in questo caso grazie a macchine che hanno sottofine questo è un task molto semplice e le macchine a stato finito vengono utilizzate in realtà proprio per gestire dei sistemi molto più complessi quando gli stag sono tanti gli eventi di trigger possono essere tanti allora le macchine a stato finito sono utili proprio per fare carezza e per dare in quel momento una rappresentazione rigorosa di quello che sta succedendo nell'esempio che riporta il libro di testo questo esempio che riporta del libro che consiglio poi vi dico di testo se avete visto che se volete lo trovate in libreria come prestito che era quello sul si chiama un interno sims concetti di esempio comunque il principale che metto questo esempio invece è un esempio più complesso perché fa vedere come ci può essere rappresentato in una macchina stati finiti il funzionamento del carrello di terrazzo di aereo dove abbiamo il carrello frontale e il carrello in quello posteriore sinistro e il posteriore destro dove questi carrelli sono gestiti idraulicamente da degli attuatori e sono governati da delle pompe in questo caso la pompa che la faccio sta facendo impazzire oggi in questo caso la pompa chiaramente può essere un off e l'altra cosa è che la pompa può avere una direzione up or down perché se spinge l'olio allora l'attuatore va in un verso se ritira l'olio l'attuatore va in un verso coppia quindi chiaramente il carrello si muove nel posto inverso e i carrelli hanno anche un sensore di pressione di peso per capire se l'aeroplano sta appoggiando il carrello perché non si non voglia mai che la pompa si è perdi più del carrello e l'aeroplano si è perdi più sopra quello che succede è chiaramente l'aeroplano precipiterebbe a terra nel senso ci schiaccerebbe sulla pista ecco questo è un pochino più complicato adesso il diagramma della macchina stati finiti che vediamo prima e il diagramma è costituito appunto dagli stati abbiamo carrello giù waiting for take off rising gear quindi il carrello che sale gear up lower in gear il carrello che si abbassa e vedete tutte le possibili transizioni allora al di là di quello che adesso non è che andiamo a esplorare la dinamica di questo sistema ma quello che vi faccio vedere è che è possibile rappresentare un sistema complesso con ormai stati finiti e da qui non da parte della rappresentazione scrivere il codice è una cosa abbastanza agevole perché una volta che tu avrai identificato il questa volta l'avevo preso è però ma remma di quella bulgara una volta che tu avrai identificato i vari stati e le varie transizioni è fatto il più ok ok è un'altra volta che mi ha portato il testo che non c'è un po' questo cosa è chi è non lo so adesso per la prossima mi documento se no la stacco è vero l'alternativa è il uso del portatile quindi mi portate nel quale proiettolo anche qui così però non c'è la pena no no la piegate quindi sì ma anche mi portate le touch quindi posso la pena di sopra quindi posso magari andare con quello questo è davvero tedioso ogni volta che faccio così mi salta la diapositiva adesso no cioè all'istrae tutti me prima di tutto ma anche voi comunque come si fa passa da da un diagramma come quello che abbiamo visto a l'implementazione beh l'implementazione come per i temi degli stati vengono enunciati proprio con dell'interazione quindi questa è una implementazione del linguaggio C che andiamo a vedere e per ogni per ogni stato c'è una una tabella poi che contiene in realtà un puntatore di una funzione quindi quando sei nello stato gear down raising gear gear up eccetera questi sono tutti impuntatori alle funzioni quindi una volta che avete riconosciuto i stati fate una funzione per il stato e quindi l'ingresso all'interno dello stato viene risolto con l'invocazione di una funzione quindi vedete la gear down ad esempio è una funzione che poi mi va a fare i suoi controlli chiaramente e a triggerare stati successivi quando si usano questi strumenti si usano appunto ma nel tasto di un'interazione complessa e vi ripeto non siamo ancora in presenza di un sistema carattico quindi le architetture è chiaro che io posso usare una macchina stati finiti anche all'interno della macchina evoluta quindi per provare sopra un sistema operativo come lì in succeda però stiamo parlando di microcontrollori più evoluti ma che ancora non hanno a che vedere il sistema operativo tant'è che c'è una varia funzione ma le macchine di questo tipo vengono proprio create e gestite per cercare di solo in maniera più precisa e corretta task abbastanza complessi ma nell'IoT cominciamo ad avere anche task abbastanza complesse allora prendiamo la prossima e la prossima lezione ci dice come possiamo programmare nell'IoT utilizzare utilizzando però dei sistemi operativi basati sulla programmazione dei eventi oppure i sistemi operativi ma questo però ci non è condiviso ancora scusate i sistemi operativi quindi questa di tipo realtà quindi stiamo andando verso sistemi davvero complessi perché stiamo parlando non più di programmazione o macchina è stato finito o la passione super gruppo o a inter ma stiamo parlando di sistemi basati sulla programmazione dei eventi dove non c'è un vero e proprio sistema operativo ma c'è un gestore degli eventi una sorta di prima posta del sistema operativo non è un vero sistema operativo ma è un gestore degli eventi che vi permetta di fare programmazione degli eventi per poi arrivare invece alla fine che sono i sistemi operativi real time che fortunatamente ne esistono varie tipologie dei microcontrollori nelle nostre architetture anche sistemi gratuiti open source e noi nel sistema vedremo proprio un sistema operativo open source real time per microcontrollori dopo aver provato a fare la programmazione la programmazione superlupo e a inter cosa vuol dire programmare gli eventi allora in generale programmare gli eventi vuol dire che l'evento è quel segnale che triggera un processo o meglio un task da eseguire e se vogliamo l'esempio della programmazione inter da sim però ricada un po' per la programmazione dei eventi solo inter e non solo c'è solo quello cioè il inter però ricada la programmazione dei eventi perché come vi ho visto prima periodicamente viene generato un inter che a tutti gli effetti è un evento e noi cosa facciamo nella routine di strada dell'intra che si dice ah non voglio in senso che è quella non possiamo modificare lì dentro ci scriviamo un task bene se noi portiamo al limite questa questa esperienza possiamo creare una programmazione un paradigma di programmazione basato sugli eventi dove ogni evento viene gestito scherzo degli eventi ogni evento triggia una funzione la quale può a sua volta consumare un dole evento generare un altro e quindi triggierà una funzione successiva è un po' come la programmazione è sicuramente fatto di dispositivi nuovi condotti è detto che a noi si basa molto c'è la mente studiando su inter l'inter in attore è un evento che viene scagulato con le variate con la sistema operativa e un inter ci fa tutto se io devo lanciare un'applicazione genera un evento che è un inter se l'applicazione deve contattare un sensore genera eventi cioè gli eventi in quel caso sono il trigger fondamentale di quello che serve per comunicare tra varie applicazioni ma anche lanciare l'applicazione quindi nella programmazione ad eventi il primo che abbiamo già visto è proprio un timer qui da prima nella programmazione 5 l'inter è proprio l'inter solo che invece ci hanno limitato a quel tipo di eventi dove abbiamo altri nel sistema invece propriamente detti di programmazione ad eventi gli eventi sono tanti altri anche la stessa ricezione di un pacchetto della rete ad eventi la ricezione di un messaggio su una porta di comunicazione che sia il quadro C che sia Ua che sia S.P.I. questo può essere il meglio molti sensori lavorano ad eventi ad esempio sensori digitali non siete voi interrogati alcuni lavorano con la parte con la l'altra perché sono loro che quando hanno qualcosa di pubblicare ma non però possono aspettare perché magari sono programmati e hanno già il concetto di scioglio quindi voi volete un evento di sensore digitale di unità solo se l'unità ci è sotto X lo programmate e sarà il sensore mandare un evento sul quadro C viene da sé che la pressione di un tasto sia sicuramente un evento asincrono che debba essere recepito in qualche modo e gli eventi poi possono essere messaggi definiti all'interno del nostro tasto per scambiare informazioni fra processi questo è proprio l'esempio di Android quando un app deve lanciare un activity genera un user defined per creare un nuovo activity che sovrappone a questo qual è un sistema operativo ad eventi molto diffuso per l'IT non ce l'avete mai sentito nominare con Tiki avete mai sentito nominare con Tiki con Tiki è davvero famoso perché è un sistema operativo ad eventi quindi lo chiamano un sistema operativo ma in realtà è uno scherzo per degli eventi perché non ha la francesa di essere un vero sistema operativo per gli eventi è uno scherzo per gli eventi che conosce delle librerie di gestione degli eventi stessi tutto funziona con un evento allora qual è il bello di tutti? da preamco da pubblico più ricci l'altra cosa bella è che c'è una comunità di sviluppatori sotto che ci lavora e quindi per le architetture quali attività un comportiero sarebbe il ritornale che spieghi per le attività e quindi èutoso è un aumento di 26930 si che è veroefese un monero di multitasking e l'assunzione di tanti eventi che ne erano lunghe in casa. E qui c'è un mega scheduler dentro di questi eventi, perché questo è un monero di multitasking. Considerate che è un sistema che lavora su architettura di un single core, un po' di sistema RAM, con i suoi real time and clock, eccetera. Però quello che va al suo interno, c'è una parte di cose, perché è perfetto che più G serve in giro, un mega scheduler con uno switch che arriva l'evento e lo spara, non è un'altra, ma immagino perché qui ce l'è capitato di una coda e la facciamo una processione. Non c'è una coda che non possiamo capire, ma non facciamo parte prima. Però dal punto di vista del programmatore, cosa vuol dire? Scrivere un programma per un nodo IoT con degli eventi. Chiaramente c'è un attimo una culpa di apprendimento per conti. Se vogliamo capire come si scrive un programma per conti, non è una cosa che faccio in un secondo, perché ha la sua terminologia. Allora, intanto, vedete, ci sono queste macro in linguaggio C, che sono le macro che conti ti fornisce per definire, ad esempio, un task. Un task che si definisce come macro process underscore thread. Questo è il task, quindi c'è tu. Intanto non posso strumentare sulla stessa macchina più di un task. Non c'è esecuzione parallela. Eh, siamo tranquilli. È tutta esecuzione dei venti. Se tu vuoi fare un task che legge la temperatura, ecco quello che facciamo. Process thread, che è una primitiva per definire il nostro task, che ha sempre eventi come argomento. Quello che vado a fare in questo caso è definire un timer interno, poi vediamo perché. Poi invoco process begin. Process begin vuol dire, ok, da qui in poi il processo è pronto. Perché prima di process begin ci va l'inizializzazione. Da un punto che scrivo prima di process begin, inizializzazione. Da process begin in giù, invece, è il corpo del nostro processo. E cosa vado a fare? Visto che voglio fare una sorta di super loop, senza usare un super loop reale, triggero un timer tra un secondo e invoco questa primitiva, i timer set, e clock second, vi dico appunto un secondo. Quindi questa primitiva mi farà partire un evento tra un secondo. Poi che cosa faccio? Nel mio super loop, vedete se è un white 1, ancora una volta, perché il mio task voglia che faccia sempre la stessa cosa. Ma, se guardate, il mio task fa semplicemente process wait event until, cioè, aspetta l'evento che ho triggerato prima. Quando arriva l'evento, si sblocca da qui e fa qualcosa. Adesso qui qualcosa non c'è nulla, non c'è nulla, non c'è nulla, c'è nulla. Resettare il timer così da far ripartire di nuovo un evento. Quindi io il timer lo configuro qua. Vado in process wait event until, quando mi sveglio qui in mezzo, io posso fare tutto quello che voglio, cioè, leggi di temperatura, mandare dati. E poi cosa faccio? Resetto il mio task. E così riparro la rango. La cosa bella del sistema di mancontichi è che io, appunto, ho questo processo che ha generato un evento in coda tra un secondo, ma ci possono essere tanti altri task che hanno aggiunto nella coda globale di tutti gli eventi. E lo scheduler gestisce automaticamente gli eventi inviando i task a registrare. Perché voi con process 3 in realtà quello che fate è registrare questo task nello scheduler. Il task produce un evento che va in coda. Quando sarà le due ore di quel evento questo task è arrivato. Non c'è mai, per non essere con il problema, i task sono messi in uno di seguito dall'altro, non sarebbe possibile altri eventi, non è un sistema operativo, non è un'architettura parallela. Se ci sono due eventi che accadono allo stesso istante, mettiamo in coda qui. In base alle società della cosa, finiamo la scelta più o meno che fa. Bisogna fare molta attenzione, lo dico, quando ci programma con un sistema operativo come questo dei venti, di non mandare mai in loop un task. Cioè qua dentro io non posso occupare la CPU al 100% con un loop, perché blocco tutto. e quindi non c'è modo di venirne fuori. In questo programma ci sono anche la settimana di prego. Esatto. Dico altre due cose e poi mi fermo oggi. Allora, col Tiki è un sistema operativo che proveremo anche ad utilizzare. S sistema operativo, si chiama sistema operativo, ma è in realtà un sistema di servizio. che ha sistemi a basse risorse, lavora su architetture da 2KW, quindi davvero piccole. 2KW diranno in un tic è installabile, tant'è che uno dei processori più diffusi è l'MSP430. tra i MSP430 vi parlo di sistema che lavora 6-Tiger, come frequenze 16-22, poi ci sono le versioni. E parliamo di memoria RAM che va dai 2KW ai 16KW, quindi sono davvero piccoli. Ma considerate che costano un po' più di euro. Poi va anche su processori più complessi come gli ARM, il M3 e il M4, quindi effettivamente è abbastanza versatile. E la cosa che ci può stupire leggermente è che è già compatibile con i PV6. Quindi in realtà avviate la possibilità di usare l'estensione appunto degli indirizzi per avere la connessione di uno di questi. Ecco l'efficio che lo vediamo, vediamo che ogni device può essere un prodotto di un PV6. E non è una cosa banale. Gestisce diversi protocolli di comunicazione uguale, adesso non sono il M4, non sarebbe più parlare, perché è un numero stumper per le reti multi-hoc. E comunque è un sistema operativo che vale la pena vedere. È un sistema operativo che grazie alla sua scheda dichiara multitasking, ma è un multitasking... Ovviamente abbiamo la possibilità di gestire una quota di eventi, quindi chiamare processi in tempi successivi, ma non c'è mai un contest switch for sale, cioè non c'è mai prelazione, perché non sarebbe altrimenti. Come vi dicevo prima, bisogna fare molta attenzione a far sì che nessun tasso vada più, ovviamente non riusciamo più da lì e si chiamano un'operazione. Quindi ogni processo deve volontariamente, come dicevo qua, rilasciare la CPU. Infatti fare questo process wait diventa antico, quindi rilasciare volontariamente la CPU, fino a quando non mi contatterei. Ok? Fino a quando non mi darai più l'evento. Però è un'architettura già molto interessante, molto bella, nonostante non sia ancora un sistema operativo. Questo lo vedremo anche nelle esercitazioni e se siete curiosi potete anche andare sul sito con tiki.org, e poi non si può ricordere, quando scaricarlo. C'è anche una macchina virtuale molto bella da scaricare che utilizza un simulatore. Quindi tu addirittura cosa puoi fare? Puoi usare contigli con il suo simulatore, che mi sembra si chiama Koja, che scripiggiava, che vi permette di caricare il codice di fonti che scritto in C in nodi virtuali e creare magari 10, 10, 30, sono i verifani che mandano un partito in un lato, cioè lavorano proprio come dei fonti, con il codice vero. Quindi in realtà il codice che tu puoi caricare con il portatore, lo puoi prima sperimentare con il simulatore, andando a creare un numero di nodi molto alto che comunicano di loro e lavorano tra di loro. E il simulatore è tutto gratuito, anche il simulatore vi dà poi anche informazioni prestazionali di consumo energetico, di cpu, di rete e di adicento. Perché il banco si disponibilizza un euro potrebbe essere una quantità di caccia? Non è ma niente, mi fa nel tema che è uno dei problemi grossi anche di questi dispositivi. Ma anche se c'è un log di ritorno come si fa con i cellulati? Dove? Sponso, non per fare nel tema, dove c'è un log di ritorno che io posso vedere sul mio computer? Allora, nei dispositivi che hanno sempre la comunicazione UAT, sia seriale, puoi collegarlo proprio all'importante. Per vedere il flusso di quello che sta facendo. Sì, ad esempio, ASP, 246, ASP 4030 della Texas, ma da tutti, la porta UAT. La porta UAT è la porta seriale. Quindi tu metti. Io dici posso fare il logo? Sì, sì. Però se tu puoi dire il logo della porta UAT, questa cosa qui, io lo metto, sta facendo questo, questo, questo, questo, e se è bloccato qui, allora, ti ascolto a tutti. Quello è più così, perché non avendo nessun tipo di audio, non lo so. Ma è che non si interrompe il processore, non si cdb e... Tutti hanno, quando vedo la stampa sulla porta UAT, qui basta che uno snisca sul tuo portabolo, e sincronisi sulla porta UAT, questo è il modo più semplice. Poi ci sono anche i sistemi di debugging, come dicevi tu, con GDB, che allora il mondo manda la CPU step by step che dà la possibilità di debaggare. Comunque è vero, il debugging di questi sistemi è una cosa da vero più complicata. Se volentieri non ti parte, non arriva neanche a iniziare la UAT, è semplicemente che ti dai corrente e adesso, e lì ci diventa un po' buon senso, capire che non è arrivata neanche a iniziare la UAT. Bene, terminiamo la registrazione. Sì.