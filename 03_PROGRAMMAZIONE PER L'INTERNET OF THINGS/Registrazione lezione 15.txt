eccoci allora l'ultima volta abbiamo parlato dei canali di comunicazione wireless di vicino dell'IoT ed eravamo arrivati a descrivere il concetto di SIXLOPAN, abbiamo parlato di questo di questo layer wireless che usa il protocollo 802 154 quindi il layer NEC tipo 802 154 su 802 154 abbiamo detto che è andato a creare quello che viene chiamato SIXLOPAN, non è nient'altro che l'estensione su 802 154 a indirizzo di 64 bits, questo per poter fare sì che ogni possibile nodo possa avere il suo indirizzo e possa essere raggiunto diciamo così remotamente in questa architettura ricordiamoci sempre che appunto nella IoT il numero di dispositivi è elevatissimo quindi è necessario come dicevamo questo aspetto poi siamo andati avanti e abbiamo visto un po' che il concetto di SIXLOPAN si basa comunque su delle sottorete che si vengono a creare gestite da quelli che sono i router edge e in realtà è il router edge vi dicevo che collega la sottorete SIXLOPAN con la vera e propria intame e il router edge fa davvero tante cose che questo router ricombatta gli indirizzi in modo tale da avere la possibilità di risparmiare bit per accedere alla sottorete che sicuramente non avrà una dimensione tale da usare indirizzi 64 bits quindi è vero che sono è un'estensione di tv6 ma è vero che il router il router fa tante cose ricordiamoci che nel 802 154 che è il layer MAC che viene usato in questi protocolli ci ricordiamo che cosa è che la dimensione del pacchetto è molto limitata quindi se sparassimo da 4 bits solo per il diritto probabilmente rimanebbero ben poco per il dato e sarebbe potremmo fare un elevato numero di frammentazione molto grande bene questi sono discorsi che facciamo una volta scorsa e iniziamo poi a parlare anche dello SIGBI lo SIGBI è un'area che usa comunque il layer fisico del 72 154 ma sopra questo layer fisico crea una propria rete fatta appunto di un protocollo di comunicazione che hanno la caratteristica intanto di non essere aperto lo SIGBI come dicevo non è aperto non è royalty free quindi se vogliamo creare una rete SIGBI dobbiamo in qualche modo pagarne le royalty comunque acquistare nella licenza e lo SIGBI è proprio dedicato ai sistemi che lavorano con batteria lo costo lo power e lo data rate cioè sono proprio i sensori ideali nella parte proprio edge che non conosciamo hanno la caratteristica di auto e configurazione quindi la rete SIGBI ha delle primitive per aggiungere nodi cercare nodi e anche SIGBI si basa comunque su la potenza del 154 e quindi è totalmente wireless e garantisce la possibilità di creare rete dinamiche auto aggreganti eccetera nel resto del corso noi non vedremo esempi tipo SIGBI proprio per il motivo che non descendo si chiamano le reti priori dico un po' contro la mia filosofia che è quella di cercare di utilizzare gli strumenti invece aperti allora lo SIGBI come un pochino il SIGSLOPAN che di base sotto il sito del 154 definisce intanto la necessità di avere un nodo coordinatore il nodo coordinatore è quel nodo che in qualche modo gestisce la connessione dei sottonodi dove i sottonodi sono effettivamente dei nodi che si connettono direttamente al coordinatore e poi abbiamo proprio gli edge device che sono le foglie e le foglie sono dei nodi assolutamente low power che hanno la caratteristica inoltre di stare per lo più spenti nel senso che sono dei nodi che si svegliano con la loro tempistica fanno sampling lo inviano ai router i quali poi inviano i dati secondo le politiche definite dal coordinatore è un'architettura come vedete che può dar luogo a reti tipo Stella, Mesh, Cluster è molto versatile e si basa su queste tipologie di nodi dal nostro punto di vista diciamo così per quanto riguarda l'IoT è importante sono gli end device che sono proprio quei device minimali che possono stare spenni perché dico possono stare spenni perché i router e il coordinatore non possono spennerti mai perché se viene a mancare un router e tutti gli end device che hanno l'ambito sono indipendenti di quel router poi non potranno più dialogare quindi è vero che questa architettura è un'architettura per device low power ma è anche vero che necessita di nodi sempre attivi quindi ripeto i coordinatori router non possono spennersi perché hanno un compito di gestire la connettività degli altri nodi quindi questa architettura non banale comunque ha delle caratteristiche peculiari che rendono la gestione non proprio semplice è vero che io posso creare una semplice rete con un solo coordinatore tutti gli end device si collegano al coordinatore e il coordinatore può essere la base station però diciamo uso un'architettura molto più semplice rispetto a quella che è la potenzialità di ZigBee bene dopo ZigBee cosa possiamo dire esistono altre tecnologie sempre wireless portate nell'ambito IoT esistono altre tecnologie che sono tecnologie non basate sulle arie pili non basate su quella che è appunto la plastica che è struttura in rete internet e queste le conosciamo già sono la Bluetooth che è un'altra tecnologia che lavora comunque nella frequenza 2214 ma ha una gestione point to point quindi con il Bluetooth come ci si collega a punto punto è caratterizzata da anche qui bande variabili non eccessivamente alte e sappiamo che esistono varie versioni anche di tecnologie Bluetooth parlando della low energy che garantisce un consumo energetico minimale per il device edge quindi colui che usa la comunicazione per arrivare verso il router e questo è ciò che usano il smartwatch con tapassi in casi di frequenziometri che praticamente sono in grado di rifarmiare una grande quantità di energia grazie a questo tipo di comunicazione nell'IoT si fa anche sempre riferimento alle tecnologie RFID RFID non generano una rete come sapete perché RFID sono sistemi di identificazione sono dei tag passivi quindi non hanno la capacità di trasferire informazioni se non l'identificativo e il sistema RFID nasce proprio per identificare un oggetto RFID è un tag passivo, ha la sua antenna, ha una piccolissima MCU l'antenna ha la duplice funzione di collezionare energia e inviare e eventualmente anche ricevere dati quindi l'antenna fa effettivamente due azioni i sistemi RFID dove li troviamo? sono tutti sistemi antitacccheggio che trovate nelle merci di un certo valore o anche nei negozi e questi sistemi antitacccheggio funzionano proprio in questo modo perché hanno una piccola MCU e attorno alla MCU c'è una grande antenna che normalmente è un'antenna che si trova a casa dell'inferno antitacccheggio oppure ecco anche i pass per la cosa per la, come si chiama, per la fluia, no? per le energetiche di risalita sono fatti in questo modo quindi quando voi vi avvicinate ad un lettore il lettore manda, invia, con tanta energia e una frequenza particolare, una frequenza di risonanza di questa antenna l'MCU fa il boot, accende, ritorna in lavoro energia e l'unica cosa che fa l'MCU è inviare un identificativo che è salvato all'interno del nostro processore quindi non sono vere e proprie tecnologie di comunicazione ma vengono comunque indicate nell'IoT perché molti dispositivi grazie a questo sistema possono indicare un tracciamento perché lo stesso oggetto se viene campionato durante la sua vita in momenti diversi e il reader ha informazione di localizzazione possa semplicemente seguire questo oggetto durante la sua vita e l'idea è di usare RFID ad esempio per il tracciamento dei prodotti alimentari per vedere il percorso che questi hanno fatto dall'atto della creazione della produzione fino a quando viene al consumatore quindi non è una vera e propria rete ma fanno parte dell'IoT comunque per questo motivo qua perché i veri nodi che forniscono informazioni sono i lettori ma i lettori si basano appunto su questa identificazione per ricostruire tutto il percorso fatto dall'oggetto durante la sua vita pensate mettere appunto un tag RFID su un prosciutto al momento in cui è stato lavorato al momento in cui passa tutto il supermercato eccetera siamo in grado di capire proprio da dove deriva quell'alimento e questi sistemi in realtà da tempo vengono molto utilizzati anche per il tracciamento degli animali sia per motivi scientifici spesso e volentieri ci sono queste campagne di monitoraggio che inseriscono dei chip all'interno del tessuto adiposo degli animali così che quando questo animale viene magari ritrovato ripescato con l'RFID lo si associa appunto sempre allo stesso esemplare anche qui per cercare di seguire il loro percorso e non è fantascienza ma ormai da anche qui da diversi anni anche negli animali domestici si usa RFID per tracciarli il famoso chip che posso mettere al gatto o al cane è un chip RFID nel senso che è totalmente passivo una volta che ho il lettore riesco a risalire il proprietario degli animali questo era per chiudere la carrellata di tecnologie e comunicazione wireless all'interno del mondo IoT ma adesso passiamo alla lezione successiva invece che ci permette di affrontare un altro argomento tipico del mondo IoT allora adesso passiamo a condividerlo la nuova lezione qua dove andiamo finalmente a vedere delle tecnologie di comunicazione quindi dei protocolli che prescindono dal livello fisico di comunicazione quindi possono essere utilizzati al di sopra di tutti i punti che abbiamo visto fino adesso ma che sono proprio tipici del mondo IoT sono dei protocolli che vedremo il cosiddetto constrained application protocol e il protocollo di messaggistica che si chiama NQTT probabilmente avete sentito perché è molto diffuso che sta per message queuing and telemeted transport quindi sono dei sistemi di comunicazione nati proprio per il mondo IoT questo vuol dire che noi ad esempio abbiamo fatto già esperimenti in IoT abbiamo fatto esperimenti in cui programmiamo un Raspberry programmiamo un SP e inviamo dati su un server che abbiamo sempre fino adesso utilizzato in FluxDB ma in FluxDB è a tutti gli effetti un server di alto livello in modo di ricevere informazioni tramite il classico protocollo di HTTP HTTP non è un protocollo nato per il mondo low power o low resources è un protocollo classico di trasporto nel mondo delle reti internet bene l'idea è ma si può ridurre qualcosa rispetto al proprio protocollo HTTP cioè se possiamo avere dei protocolli più leggeri e più versatili più semplici da utilizzare per dispositivi ancora più ridotti è chiaro che se avete a che fare con Raspberry Raspberry in tutti gli effetti è un single board computing cioè non freghiamo possiamo lavorare con HTTP abbiamo visto che anche con ESP per quanto sia un sistema ridotto l'ESP 8266 che è HTTP oppure l'SP 32 che è 32 bits addirittura 2 core hanno una capacità tale comunque di lavorare tranquillamente con il protocollo HTTP abbiamo visto che è agile inviare dati verso InfluxDB ma ulteriori sistemi ancora di più basso livello potrebbero in realtà e possono in realtà scontrarsi con la necessità di installare uno step di HTTP molto pesante e anche pubblicata la formattazione eccetera delle query e delle stringhe di invio allora sono nati questi protocolli molto più snelli che hanno proprio la caratteristica di lavorare con dispositivi dalle basse risorse quindi se avessimo anche un microcontrollore a 16 bit o a 8 bit potremmo addirittura lavorare con questi sistemi ricordiamoci che ESP abbiamo utilizzato è vero che è un dispositivo edge molto ridotto perché abbiamo una CPU singolo core o double core che lavora a qualche megahertz creata a 20-70 megahertz e abbiamo a disposizione circa 2 megabyte di memoria per il nostro applicativo per salvare l'intero firmware ma se la vostra applicazione dovesse diventare molto pesante probabilmente non riuscireste a installare l'intero firmware con tutto lo stack HTTP allora si può utilizzare un sistema ridotto come il constraint application protocol ecco che quindi dobbiamo aggiungere nel mondo nello stack appunto abbiamo visto questa pila di layer che danno luogo allo stack di comunicazione partendo dal fisico network protocol transport protocol abbiamo visto di CPU e di P ecco noi abbiamo lavorato con HTTP fino adesso all'interno delle nostre esercitazioni per Influ HTTP ma in realtà esistono questi nuovi protocolli il constrained application protocol il protocollo di messaggistica nato per la telemetria un altro protocollo di messaggistica nato per il monitoraggio sono tutti i protocolli tipici dell'IoT e adesso noi andiamo a vedere un pochino come funziona l'idea di questi protocolli è ripeto cercare di ridurre l'occupazione di memoria la necessità di avere dispositivi performanti per poterli attivare bene come lavorano questi sistemi di comunicazione? allora intanto l'idea è che questi sistemi e ciò che noi vogliamo trasferire siano informazioni piccole cioè di piccola quantità ma se pensiamo all'IoT quello che abbiamo fatto fino adesso noi abbiamo usato un protocollo HTTP performante grandissimo per inviare che cosa? un'informazione di temperatura la peggio informazione di temperatura e umidità temperatura e umidità e pressione ma sono tre float cioè stiamo inviando stiamo creando un pacchetto complicatissimo una stringa una query complicatissima verso il server HTTP ma il payload cioè il contenuto è davvero minimale allora si può fare qualcosa di meglio certo si può fare qualcosa di meglio e si possono usare appunto questi protocolli di scambio messaggistica questi protocolli hanno proprio il concetto che sono in grado di scambiare dati primitivi su appunto lo stack di rete in maniera molto molto più snella e oltre a fare questo definiscono anche dei paradigmi di networking generalmente diversi da quelli che vengono usati appunto nelle reti internet classiche ad esempio il protocollo publish and subscribe è un protocollo nato proprio nel mondo IoT poi si può utilizzare anche il cuore del mondo IoT ma diciamo nasce proprio per questo meccanismo che si mette in parallelo al classico protocollo di richiesta e risposta il classico protocollo è la macchina server il client invia una richiesta al server e il server soluce la risposta bene in alternativa possiamo usare anche il protocollo publish and subscribe che vedremo in questa lezione anche questi sistemi poi possono in qualche modo garantire una sicurezza quindi possono creare dati eccetera non necessariamente il fatto che questi protocolli siano leggeri implica una loro intrinseca in sicurezza ad esempio la possibilità di farviare dati in maniera criptata in realtà questo viene mantenuto e anche la possibilità di avere una comunicazione robusta in modo tale da dire ok il pacchetto deve essere garantito la sua consegna quindi anche in questo i protocolli lasciano la possibilità allora vediamo intanto il primo esempio il primo esempio del protocollo constrained application protocol quindi nasce proprio per i dispositivi con risorse computazionali ridotte è simile a http cioè in effetti si basa sull'architettura client server dove c'è una richiesta da parte del client verso il server il server fa una risposta quindi in questo caso è una versione condensata ridotta del protocollo http quindi definisce delle primitive diverse definisce dei metodi compatibili con lo stack http quindi qua diciamo abbiamo comunque i metodi get post put delete oltre ad altre possibili query e comunque lavora anche con le url quindi abbiamo molto simile al protocollo che abbiamo visto http abbiamo sempre l'identificazione di un server il client trigger la richiesta quindi la richiesta parte sempre dal client che effettua ad esempio una get di un parametro il server risponde con un valore quindi a tutti gli effetti abbiamo a che fare con un sistema simile a http ma simile ma non è http perché il pacchetto appunto è molto più semplice molto più leggero e questo sistema questo sistema questo protocollo possiamo considerarne il suo funzionamento suddiviso in due sottolayer il layer appunto che utilizza il classico paradigma client serve richiesta risposta che si basa su la tipologia di comunicazione con quella che viene chiamata restful dove praticamente viene passato lo stato del client, del server eccetera e l'implementazione invece di un paradigma basato su messaggi che è un paradigma totalmente diverso in questo caso quindi quando parliamo di protocollo COOP ecco possiamo lavorare effettivamente in questi due modi per quanto riguarda il metodo classico richiesta e risposta client server abbiamo come abbiamo già detto i metodi classici get, post, put, delete che sono sotto insieme di quelli possibili in http così come le risposte sono sotto insieme di quelli possibili http possiamo avere una risposta successo che vi ritorna il dato oppure client error, server error eccetera per quanto riguarda invece il sistema di messaggistica il protocollo COOP implementa come scritto qua quattro tipi di messaggi i messaggi possono essere taggati con il tag con che vuol dire confirmable non che vuol dire non confirmable cosa vuol dire un messaggio confirmable e non confirmable allora se io invio un messaggio confirmable vuol dire che mi aspetto nel conology quindi io mando il messaggio e il ricevente è costretto a mandare l'acknowledge questo per garantire l'obustezza della compilazione nel senso che se io ho inviato il messaggio e dentro un certo time non ricevo l'acknowledge di conferma allora so che quel messaggio è andato perso i messaggi non confirmable invece sono quei messaggi che non necessitano di acknowledge quindi l'inviante non si preoccupa della ricezione del messaggio da parte del ricevente e quindi a questo punto continua ad inviare informati dati la slide è un po tagliata ok mi dice che è tagliata non si vede l'ultima parte io perché lo sto progettando anche sulla lavagna lo sto vedendo la parte anche non acknowledge reset quindi ci vede fino al for type messages ma non vedete sotto confirmable ah ok non vedi confirmable non confirmable acknowledge reset allora provo a fare una cosa di questo tipo ecco la slide sarebbe questa adesso immagino che riusciate a vederla che non l'ho messa a schermo intero confermi pari che così riesci a vederla ok si vede tutto quindi lo tengo così dai non vado a tenerlo tutto schermo non so perché la tagli perché in realtà io la sto progettando anche nella lavagna qui in aula e vedo che si vedeva bene ok mi dispiace se non avete visto l'ultima riga ok comunque eravamo arrivati a parlare di questa parte qua quindi il fatto che il messaggio potesse essere di tipo confirmable o non confirmable quindi vuol dire semplicemente mi aspetto la cruda non me l'aspetto e le altre due tipologie di messaggi sono appunto l'acknowledge e il reset per resettare la comunicazione ma come funziona questo protocollo allora intanto è un protocollo di invio informazioni in maniera asincrona cosa vuol dire io faccio una richiesta mandando un messaggio e il client non è tenuto a rispondere in tempo reale cioè l'altro attore diciamo così in questo caso non andiamo a identificare client server l'altro attore non è tenuto a rispondere in tempo reale e quindi vediamo come questo protocollo può funzionare lavorando proprio con tempistiche non certe non note e addirittura non singole allora vediamo proprio l'esempio dove abbiamo due nodi uno che lo chiamiamo client e lo chiamiamo server il client inizia l'interazione con il server inviando un messaggio confirmable vedete con dove chiede un campo temperatura in un dato istante invia un messaggio confirmable il codice esedicimale è appunto 07 a 10 e fa la richiesta della temperatura il server in questo caso invia subito l'acknowledge dice ok io ho ricevuto la tua richiesta ma non sta mandando il dato non sta mandando il dato perché probabilmente il dato non è pronto e non è riuscito a leggerlo comunque ha fatto l'acknowledge della richiesta come dire ok io so che vuoi la temperatura ok tu hai chiesto un confirmable quindi io ti dico ho ricevuto il tuo messaggio ma non ti sto dando la temperatura passa del tempo e a un certo punto il nostro server di destra ha pronta la temperatura ha pronta la temperatura e la invia al client per soddisfare la richiesta che gli era stata fatta all'inizio bene il messaggio di tipo confirmable contiene la temperatura 22.5 gradi e al suo interno per poter far sì che il client correva questo messaggio con la richiesta che aveva fatto il client visto che è passato del tempo nel frattempo il client può aver interagito con altri server eccetera quello che va a ricopiare qua dentro è il token vedete il token 0x73 si trova sia sulla richiesta che sulla risposta questo token 0x73 quindi ci permette di associare semplicemente alla richiesta la risposta questo in un sistema in cui richieste e risposte avvengono in momenti diversi proprio perché non c'è il sincronismo in questo protocollo volutamente non c'è il sincronismo perché appunto i sistemi sono constrained quindi hanno poche risorse computazionali possono avere anche poca banda e quindi per esaudire una richiesta si possono impiegare del tempo non banale e quindi la necessità di ricorrelare la richiesta al messaggio avviene semplicemente riportando il token che era stato spedito con la richiesta all'interno del messaggio successivo la richiesta poteva essere stata fatta anche non confirmable in questo caso non ci sarebbe stato l'acknowledge ecco il fatto che un messaggio abbia come campo con quindi confirmable vuol dire che ci si aspetta immediatamente l'acknowledge se l'acknowledge non arriva il server o il client dipende da quali dei due abbia fatto la richiesta ripeterà dopo un certo tempo il messaggio fino a quando non riceverà l'acknowledge quindi la differenza tra confirmable e non confirmable è essenzialmente quella ma posso fare una richiesta gap per la temperatura sia di tipo confirmable che non confirmable è chiaro se voglio assolutamente la temperatura entro in un certo limite allora farò sicuramente una richiesta di tipo confirmable altrimenti potrebbe essere migliorata dal nostro server vedete com'è molto snello questo sistema perché ripeto serve per trasferire una bassa quantità di dati quindi ciò che viaggia all'interno del pacchetto è effettivamente un valore numerico ad esempio la temperatura e per rendere snello questo meccanismo il sistema di trasporto su cui si basa è UDP non si usa TCP perché come avete visto si cerca di dare robustezza attraverso questo meccanismo di messaggi confirmable o non confirmable ma la parte di trasporto che ci trova sotto rimane UDP per rendere più snella la comunicazione crediamo che UDP rende pacchetti più piccoli ed è sicuramente più snello UDP per sua natura non è reliable cioè non è robusto ma nel protocollo low-coop appunto c'è la possibilità a livello quindi di protocollo di più alto livello di inserire la possibilità di ricevere una cosa e di confermare i messaggi abbiamo detto che appunto è un sistema asincrono che passa del tempo passare del tempo anche tanto fra la richiesta e la risposta e questo ci garantisce di mantenere un leader molto molto piccolo e quindi lavorare con poca banda e con dispositivi molto ridotti garantisce un meccanismo di discovery per poter trovare all'interno della nostra rete un eventuale server di comunicazione e quindi diciamo rende molto completa la nostra architettura come fatto nel dettaglio un pacchetto di tipo coop scambio di messaggi allora un pacchetto a come vedete parte la versi due bit dedicata alla versione del protocollo ha ulteriori i secondi due bit che sono identificano il tipo di messaggio quindi confirmable non confirmable acknowledge or reset poi c'è abbiamo il codice che appunto è il metodo che potrebbe essere get put eccetera che abbiamo visto prima il messaggio vero e proprio il messaggio che il messaggio è il messaggio è il messaggio è il messaggio che il messaggio è il messaggio che era quella stringa diciamo così che serve a correlare la richiesta con la risposta visto che è assincrono e poi un payload qui dentro ci metteremo appunto la nostra temperatura ok se la richiesta era appunto una richiesta di temperatura questo protocollo offre poi anche il meccanismo che si chiama observe è un meccanismo un po particolare perché vuole in qualche modo emulare quello che vedremo nella seconda ora che è il protocollo mqtt che cosa vuol dire vuole emulare il protocollo mqtt perché vuole cercare di implementare il cosiddetto meccanismo publish and subscribe che vedremo dopo cosa fa questo observe in particolare essenzialmente il client fa una richiesta di tipo get come quella di prima get della temperatura verso un server il server aggiunge questo client tra la lista degli osservatori per la temperatura e ogni volta il server avrà un nuovo valore di nuovo valore di temperatura la notificherà a tutti gli osservatori è un meccanismo diciamo che simula in qualche modo il meccanismo publish and subscribe che abbiamo visto prima ma è molto più primitivo infatti questo si ottiene tra due punti uno client server e il client fa una richiesta di tipo get di un parametro al server e il server lavora come qualche modo broker nel senso che sarà lui a inviare messaggi nel momento in cui ci sarà un nuovo dato tutti i client che hanno fatto la richiesta di get su quel topic cioè su quel parametro sia temperatura o umidità eccetera poi reagire e reagire riusciranno in maniera sincrona questa volta l'aggiornamento del dato per il quale volevano fare osservazione non è molto usato vi dico la verità questo meccanismo osserva su pop perché a quel punto allora si preferisce utilizzare direttamente il protocollo mqtt che invece nasce proprio per uno scambio di messaggi basato su un sistema di sottoscrizione quindi proprio il vero e proprio paradigma pubblica di cansa scrive dove ci sono dei degli attori che pubblicano le informazioni e degli attori invece che si sottoscrivono per l'interesse da quell'informazione quindi l'idea dell'MGTT sarà proprio questa no ci sono alcuni attori che forniscono informazioni e da noi chi saranno questi attori saranno i nodi edge ad esempio che producono dato per hanno sensore della temperatura hanno sensore di umidità e via di tempo quindi hanno con la loro tempistica la capacità di produrre informazioni informazioni ricordiamoci sempre taggate no? che l'informazione sappiamo che cosa conterrà e questi sono chiamati i publisher cioè i pubblicatori produttori dell'informazione chi è interessato a ricevere informazioni di tipo temperatura diventa invece un subscriber cioè colui che dice io mi sottoscrivo per il servizio temperatura una volta che mi sono sottoscritto al servizio temperatura l'entità che si troverà al centro che si chiama broker in realtà smisterà tutti i messaggi ricevuti dai publisher i messaggi di tipo temperatura avranno spediti tutti a chi si è sottoscritto per la temperatura un attore potrà sottoscriversi per diversi topics e quindi ogni per ogni topic riceverà gli aggiornamenti ogni volta che questo potrebbero prodotti dai publisher lo vediamo nella seconda ora ed è un sistema molto utilizzato proprio nella IoT perché se pensate è un sistema davvero utilissimo nell'architettura IoT dove abbiamo degli attori che producono dati e altri invece che li vogliono leggere ma soprattutto dove abbiamo degli attori che i produttori che sono molto molto constrained come power come risorse mentre possiamo avere dei lettori invece molto potenti normalmente proprio così non i server piccolini sono i nostri edge che producono dati ma possono davvero fare poco dal punto di vista della potenza di calcolo mentre poi ci sono lettori che normalmente saranno dei desktop computer addirittura dei servizi in cloud che poi possono processare integrare ok se avete qualche domanda altrimenti facciamo 10 minuti di pausa e poi riprendiamo con la seconda parte della lezione dove parliamo del protocollo PQCT quindi mi state ok tutto chiaro mi state dicendo che le slide devo tenere così rifaccio la prova ma se io la metto tutto schermo così vi salta in questo modo non riuscite a leggere l'ultima riga taglio un pezzo in fondo ma si vede solito non c'è nulla ok il 10 si vede sotto il 10 non si vede ok quindi se nelle slide ho strato quel livello ho capito grazie non avevo mai fatto caso a questa cosa va bene comunque la possiamo tenere tranquillamente così visto che siete tutti davanti al pc e nessuno qui non ha la necessità di renderla a tutto schermo va bene ci vediamo fa 10 minuti a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo a dopo ecco scusate ma andato giù la 6.0 di URB qui nell'aula e non riuscivo più a fare a fare un'altra dei tre e non riuscivo più a fare ma una volta urb e nell'aula e non riuscivo più a collegarmi adesso ha fatto spot con lo smartphone casino cosa gli sia preso allora la registrazione è già partita che perfetto allora torniamo a condividere la 43 minis ok ci sono vediamo finché regge la connessività dello smartphone bene allora eravamo arrivati a anticipare proprio il funzionamento del protocollo mtt allora il protocollo mtt appunto è questo protocollo che nasce per esigenze di telemetria infatti nel nome si porta ancora dietro telemetri transport no è un sistema ricordiamo se la telemetria era quella per monitorare dispositivi remoti come vi dicevo nasce proprio nel 1999 per monitorare le condutture di petrolio pipeline questi questi sensori che andavano a monitorare il flusso all'interno delle condutture per far cercare di identificare eventuali perdite no c'era una mancanza di flusso da un punto all'altro dire che nel mezzo c'era in qualche modo una perdita e nasce quindi proprio in quel periodo la telemetria come sappiamo appunto ha la necessità di inviare dati ma di inviarle piccole in piccole quantità proprio come come fa la iot il concetto è proprio quello pochi dati magari con una certa periodicità ma distribuiti su un grande territorio quindi nasce proprio come un sistema machine to machine per la comunicazione è stato rilasciato royalty free come vedete nel 2010 quindi dal 2010 in poi chiunque lo può usare per dover pagare delle delle royalties la specifica attuale la 3.11 quella che viene usata c'è una sottospecifica dedicata alle sensor networks e ricordo che le sensor network sono parte della iot sono proprio delle reti di sensori che hanno la connessione non è stabile mi sentite sì spero di sì ok sono reti di sensori vi dicevo che ok perfetto grazie lorenzo sono reti di sensori che hanno la caratteristica di essere normalmente sul territorio diffuse e hanno la caratteristica di lavorare in molti o per raggiungere un sync dove il sit è il nodo che riceve informazioni le colleziona per poi mandarle eventualmente su cloud bene quindi è un sotto insieme della iot ecco che per questo sotto insieme c'è una specifica dedicata chiamata appunto mqtt sn sensor network ma come funziona qual è l'architettura del l'architettura è quella che vi dicevo prima del publisher and subscriber e publishing and subscriber che però deve essere gestito da un regista e questo regista si chiama il broker che sta al centro e il broker non può essere un device low power può essere device con strain normalmente il broker è un dispositivo efficiente tutti gli effetti normalmente il broker lo troviamo cloud il broker è essenzialmente un server anche come potenzialità di calcolo nulla dieta che anche a livello di router o di di fog network uno installi proprio broker mqtt perché poi vedremo il broker ha essenzialmente la funzionalità di interagire con i publisher e di ricevere dati dai publisher e ammettere il servizio di subscribing da parte di client che sono interessati interessati all'informazione come funziona i nostri nodi edge low power constrained eccetera sono dei publisher i publisher contattano il broker e gli dicono guarda io ti mando un'informazione di questo tipo e chi sarà interessato lo gestirai tu nel senso io non gestisco le richieste client io semplicemente sono un produttore di informazioni e ti ti mando tutte le informazioni le mando a lui questi possono essere tanti tutti i nostri dispositivi io ti mandano magari allo stesso broker uno manda temperatura uno manda l'uidità uno co2 con i loro tempi con i loro periodi se il dispositivo si rompe smette di inviare dati cioè non c'è controllo dell'architettura i dispositivi ci possono aggiungere nuovi dispositivi in qualsiasi momento i dispositivi inviano il dato taggandolo anche qua possono aggiungere come potremmo dire temperatura urbino la room potremmo dire stanza eccetera tutti questi dati quindi sono taggati e le mqt broker per ogni publisher in qualche modo va a generare un buffer allora il buffer in realtà il broker non è server come in qtb quindi non salva le informazioni non è che sale sulle tabelle e salva le serie emerite temporale no lui c'è un buffer che è di dimensioni limitate perché all'arrivo di subscriber che chiede essere la temperatura allora il broker prende questi dati e li invia a chi si è sottoscritto per quel tag quindi se due subscriber si sottoscrivono per temperatura urbino tutti e due riceveranno tutti i dati taggati con temperatura urbino il buffer interno è un buffer che serve solo perché andiamo a disaccoppiare la produzione del dato dal consumo e come vi dicevo la produzione del dato avviene con le tempistiche proprie dei dispositivi a io ti ognuno saprà la sua tempistica da codice e i subscriber chiedono la temperatura e la temperatura di via inviata appunto ogni qualvolta ci sarà un aggiornamento si mantiene appunto questo buffer per garantire questo disaccoppiamento ma il broker gestisce solamente questi aspetti non salva informazioni non le mantiene quindi se io volessi creare una struttura in cui i publisher sono i miei sensori a io ti e volessi però continuare a salvare ad esempio in un server tutte le informazioni taggate come temperatura urbino cosa dovrei fare fare farei un subscriber che è una macchina server il subscriber si registra per temperatura urbino riceve quindi tutti i dati temperatura urbino e poi lui salva potrebbe avere ad esempio un influx di b sopra e un subscriber potrà avere un'istanza di influx di b raccoglie tutte queste informazioni e le salva su influx di b il broker non è titolato a fare queste cose che fa solo da orchestratore della pubblicazione però vedete che è molto versatile questa architettura quindi io potrei avere un broker sul quale appoggiarmi uno di questi subscriber sai per sai in tutti i b raccoglie tutte le informazioni da questi nodi e man mano che un nuovo nodo arriva e dice anche io c'ho la temperatura urbino perfetto ma rivederà anche quel valore lì quindi c'è questa dinamicità perché la creazione o meglio la giunta di nuovi nodi in un broker è un messaggio di un vino rapido come è fatto il pacchetto all'interno del protocollo mqtt allora il protocollo mqtt andiamo subito a vedere che definisce 14 diversi comandi ma non tutte le versioni delle librerie mqtt magari le implementano tutte ad esempio possiamo avere una libreria su arduino che implementa solo un sottinsieme dei comandi quindi il sottinsieme diciamo minimale qual è il comando connect sono diventi diventi in rosso qui il comando publish per il nodo che vuole pubblicare un dato il comando subscribe per chiedere la sottoscrizione a un topics quindi a un tag di informazioni e poi eventualmente il disconnect per chiudere la connessione quindi diciamo sono questi sono i comandi minimali e noi potremmo effettivamente vedere che in dispositivi davvero low power questi comandi sono gli unici che sono spesso implementati per non appesantire ulteriormente poi altri altri comandi sono l'acknowledge sulla connessione l'acknowledge sulla pubblicazione quindi pubback vuol dire l'acknowledge sulla publishing quindi io pubblico e il broker mi può dare addirittura l'acknowledge sul fatto che ha pubblicato la release della publication sono diversi sono diversi ulteriori comandi perché perché MQTT definisce poi lo vedremo nelle altre slide definisce vari livelli di reliability cioè di robustezza il più semplice non ha bisogno di un'acknowledge fino ad arrivare invece ad un livello di reliability dove non solo con la consegna del pacchetto è garantita ma è garantito che il pacchetto viaggi in un'unica distanza cioè non si ricevano molti più pacchetti dello stesso tipo quindi vedremo che saranno effettivamente utili questi altri comandi per implementare queste versioni della rialli di reliability allora il pacchetto vedete molto semplice perché a parte il payload in fondo che contiene appunto il nostro dato temperatura eccetera abbiamo un header iniziale fisso questo header contiene come vedete il tipo di pacchetto che appunto vuol dire se è un pacchetto di connect, publish eccetera dichiara la size del payload quindi quanto mi devo aspettare come come dati in fondo definisce la qualità del servizio appunto la qualità del servizio era questa capacità di reliability che può essere di vario tipo e la zona variabile contiene tutte le tag che noi possiamo andare ad inserire come vi dicevo le informazioni possono essere il momento in cui le vado a pubblicare contenere diversi tag che adesso andiamo a vedere perché quei tag saranno utili per i subscriber per andare a dire io mi sottoscrivo appunto per la temperatura urbino e tutti i pubblica che tutti i pubblica che hanno pubblicato con il tag temperatura urbino allora arriveranno anche il mio subscriber questi tag vengono chiamati topic i topic sono appunto dei questi tag che sono proprio delle stringhe è un campo questo campo variabile che è sotto forma di stringhe e i topic possono essere diciamo così geratici vedete in questo caso io posso pubblicare con topic temperatura oppure con topic temperatura slash cucina topic temperatura cucina sensore 1 quindi essendo una stringhe di dimensione variabile è totalmente libero questo il modo di definire questi tag un po come abbiamo comunque visto anche sui sui db anche sui db facevamo i tag erano delle stringhe quindi anche qui bisogna fare attenzione a fare lo spell corretto perché no temperatura e temperatura è già sono due topic diversi quindi non avremo poi il risultato atteso grazie a questo sistema sarà possibile far sì che i sottoscrittori chiedendo al broker di accedere a queste informazioni possono fare dei filtri quindi possono dire io voglio temperatura temperatura è chiaro che se io mi fermo al primo livello temperatura temperatura ad esempio temperatura slash asterisco asterisco è il solito carattere jolly allora mi ritorno tutti i dati provenienti da tutti i publisher che hanno come topic temperatura quindi se c'è temperatura cucina mi arrivano se c'è temperatura salotto mi arrivano comunque e quindi io posso scegliere il modo di sottoscrivermi a questo servizio cosa ci sta sotto mqtt ci sta il protocollo tcp allora prima un protocollo coop invece usava udp e invece il protocollo mqtt usa direttamente tcp allora c'è una domanda di paride ma se chiedo c'è una domanda di pari che mi ritornano anche quelli che non cominciano con temperature esatto c'è anche questo aspetto qui se io chiedo un intermedio se io ho gli umiditi ma arriva anche gli umiditi la risposta è sì dicevamo che mqtt si basa sul protocollo tcp mentre mqtt per sensor network siccome deve essere più bello e il sensor network hanno effettivamente delle caratteristiche un po' peculiari usa udp l'altra cosa che fa per snellire ulteriormente mqtt sm è quello di rimuovere il concetto di topic sotto forma di stringa ma i topic sono identificati con dei numerici quindi anche qua sarà un pochino per rendere il pacchetto più stabile come sapete no le stringhe essere dimensioni variabili che danno luogo poi a pacchetti di dimensioni estremamente variabili perché se faccio un topic alzioni sottotopic invece qui ogni combinazione deve essere identificato con un id numerico essendo il nostro protocollo mqtt basato su tcp c'è proprio il concetto di connessione no apro la socket la connessione la connessione rimane attiva fino a quando io non faccio la disconnect e ricordate che c'era il tra i pacchetti vedete la disconnect quindi la connessione rimane attiva e è possibile quindi mantenere la connessione e testarla ad esempio con un sistema basato con polling inviando il messaggio ping request il messaggio ping request che semplicemente mantiene la connessione aperta e da la possibilità quindi di testare la connessione senza per evitare quindi possibili errori nelle fasi successive di invio dei messaggi come funziona normalmente questo questo sistema bisogna apposarsi su dei broker come avete capito noi abbiamo la nostra raspberry o il nostro sp che sarà sicuramente un publisher che è lui che produce informazioni abbiamo bisogno di basarsi su un broker il broker è come avete capito si trova in cloud lo possiamo installare sulla nostra macchina fog dove vogliamo e un broker il classico broker che si usa nella IoT per diversi motivi uno tra i quali che è open source si chiama Mosquito non so se l'avete mai sentito nominare questo è un broker che possiamo utilizzare anche come testing nel senso che in cloud c'è sono delle macchine Mosquito che sulle quali ti puoi registrare come publisher come subscriber sono macchine di testing quindi non garantiscono nessun livello di performance standard ma semplicemente puoi provare il funzionamento del protocollo MQTT non hai bisogno di comprare un server o installarti un server ma vai tranquillamente su il cloud di Mosquito e sai già che avrai delle possibilità chiaro non è un sistema per la produzione perché poi ti limiterà per fare dei test per rivolgersi a questo broker come indirizzo sia dal punto di vista del publisher che sono dei miei risp sia poi da un subscriber che potrebbe essere il vostro portatile andare a vedere i dati mentre arrivano salvare e fare quello che vogliamo lo stesso Mosquito si trova per tutte le piattaforme basate su Linux è facilissimo installarlo e addirittura esiste la versione del broker Mosquito su Raspberry quindi in realtà la Raspberry può diventare un nostro broker come sapete come sapere come sapete come sapete come sapete la Raspberry è un device molto particolare un Ao regeneration e ha la possibilità di avere un parto di tutti altri sensori ma può lavorare anche con un vero proprio computer visto che c'è un'installazione di Linux oppure e quindi possiamo ad esempio nelle nostre prove di laboratorio installare sulla Raspberry un broker e poi con gli SP collegati come publisher verso la nostra raspberry, la quale poi inoltrerà i messaggi a tutti i subscriber che registreremo. Viene da sé che qualsiasi macchina Linux possa diventare un broker della vostra risa. Però, vi ripeto, se vogliamo fare dei test rapidi di funzionamento di questo sistema, ci possiamo appoggiare ai broker pubblici della Moschito, liberi, che possiamo andare a utilizzare e contattare. E nelle nostre esercitazioni future faremo proprio questo. Faremo l'esercitazione in cui useremo il Moschito in cloud gratuito, invieremo pacchetti e chiaramente ci dovremo anche registrare per quei topic per poterli ricevere dall'altra parte. Poi però faremo anche un'esercitazione in cui installeremo il broker sulla Raspberry Pi e con gli ISP, manderemo informazioni e la Raspberry Pi e vedremo che sarà davvero molto senso. Questo per dirvi che cosa? Che sistemi, anche per il vostro progetto di esame, no? Fino adesso abbiamo lavorato su InplusDB. InplusDB ha una caratteristica molto tipica, non tipizzata, nel senso. InplusDB riceve valori di temperatura e obiettà sotto forma di serie temporali. Quindi InplusDB lavora benissimo con le serie temporali. Abbiamo visto che se il vostro progetto conterrà al suo interno l'analisi e il collezionamento di dati sotto forma di serie temporali, sicuramente InplusDB va benissimo. Per quanto potreste anche creare una cittura più complessa, come vi ho detto prima, dove avete i device edge che lavorano col protocollo InplusDB verso un broker, ad esempio una Raspberry, sulla quale potete installare appunto un mosfitto broker. Poi potreste creare una macchina server invece che ha l'installazione di InplusDB e diventa un subscriber e quindi riceve le informazioni dal broker. È un sistema più complesso, ma diciamo è semplicemente un sistema di testing per vedere tutte queste tecnologie insieme. Però ripeto, se dovete lavorare con i temporali nel vostro progetto, InplusDB oppure quel ThinkSpeak che vedremo nella prossima esertizzazione, sono i sistemi migliori. Ma non è detto che IoT debba per forza campionare serie temporali e non solo. IoT si basa, c'è una caratteristica fondamentale di IoT e anche l'attuazione. Quindi voi potreste dire ok, io faccio un sistema IoT che ha cinque relai al suo interno e dal mio ufficio voglio accendere, spegnere ognuno di questi cinque relai. Ok, allora questo è un classico esempio in cui possiamo usare MQTT. Perché installiamo un broker, il vostro ESP diventa un subscriber a questo punto, non un publisher, diventa un subscriber per un messaggio accendiluce, voi con il topic accendiluce, che a questo punto può essere nel vostro computer Linux, inviate un messaggio accendiluce on, tutti i subscriber ricevono quel messaggio e attivano il relato. Capite? Questo è un progetto diverso perché c'è dell'attuazione e l'attuazione si basa proprio su dei messaggi semplici. Il payload in questo caso sarà semplicemente on, off. Quindi luce, on, luce off. E tornando all'esempio commerciale che tutti noi conosciamo, abbiamo imparato a conoscere, ad esempio gli interruttori sono off, lavorano tutti col protocollo MQTT, perché alla fine accendi, spegni la luce, no? Sono dei messaggi banali, semplici, un payload ridottissimo, che dicono semplicemente accendi questo interruttore che attiva un relato. Ecco, per implementare un sistema di quel tipo si usa chiaramente un protocollo tipo MQTT, perché il tuo interruttore diventa un subscriber e qualsiasi altro strumento che sia Alexa o Google Home diventa un publisher, cioè invia un messaggio a MQTT al broker e hai registrato il tuo interruttore e l'interruttore fa on, off con una latenza, va bene, ci sta tutto, però diciamo lavora con questa architettura. Quindi le prossime esercitazioni teniamole ben presenti, perché visto che dovrete preparare il progetto da qui a breve, perché ci sono i giorni, sono a gennaio, ecco, avremo la possibilità di vedere come utilizzare un server alternativo a MQTTB che si chiama ThinkSpeak, che però ha delle caratteristiche simili a MQTTB, se non ulteriori caratteristiche perché può essere esso stesso un subscriber, scusate, un broker che è MQTTB. E quindi lo useremo nei due modi, sia alla InfluDB per campionare serie dati numeriche, alla capacità ThinkSpeak di produrre grafici forse ancora più potente di InfluDB perché ThinkSpeak al suo interno ha un motore MATLAB, quindi se conoscete la sintassi MATLAB potete proprio caricare su ThinkSpeak degli script MATLAB e processare i vostri dati con tutte le caratteristiche di MATLAB e in più ha la caratteristica di poter fungere da broker e quindi lavora anche in questo modo. ThinkSpeak lo vedremo a MQTTB, non è gratuito, nella versione gratuita di libita a quattro canali, questo vuol dire che nelle nostre prove non potremmo usare più di quattro dispositivi che inviano dati o che lavorano da publisher e subscriber altrimenti dovremmo comprarci la licenza, però lo vedremo che sarà comunque un sistema interessante. E nelle ultime esercitazioni vedremo addirittura Moschito che è un broker puro e quindi potete pensare di delftire la vostra casa domotica, la vostra automazione con i vostri dispositivi semplicemente inviando messaggi attraverso Moschito e attraverso qualsiasi dispositivo per accendere e spedere qualsiasi informazione. Esatto, bravo, pari, l'avevo detto ma anche If This Then That che è un servizio cloud secondo me interessantissimo, si basa proprio sul protocollo MQTT perché manda appunto questi messaggi, reagisce a degli eventi, come sapete If This Then That vuol dire se succede questo allora fai quest'altro. Quindi io posso dire ma se mi arriva una mail allora accendi la luce in camera semplicemente manda un messaggio MQTT verso un publisher, un subscriber che ho registrato e lui effettivamente effettua l'azione. E le cose che come sapete si possono connettere con If This Then That praticamente sono qualsiasi cosa, dagli smartphone agli assistenti vocali Google Home, Alexa, qualsiasi cosa diciamo ha il suo plugin per If This Then That, quindi è sicuramente un sistema molto molto bello e interessante da vedere. Ok, per non perderci troppo nelle chiacchiere, visto che manca poco tempo vorrei finire questa parte, andiamo a dire qual è appunto la qualità del servizio aperto da MQTT. Vi ho detto che se io posso utilizzare un sottinsieme minimale dei messaggi, dei comandi definiti di MQTT che sono questi rossi per avere il servizio minimo e il servizio minimo che ha solo connect, publish, subscribe e disconnect non ha nessuna qualità del servizio e quindi il servizio minimo con nessuna qualità del servizio è il best effort, cioè il livello zero. Questo che vedete qua, il livello zero è il file meglio che puoi ma io non ti chiedo sicuramente nessun tipo di qualità del servizio. Poi abbiamo delivery at last once che è il livello uno e delivery at last once, quello che dicevo è il più potente dal punto di vista della qualità del servizio. Ma vediamo qualcosina. Allora, come vi dicevo, il livello zero spara e dimentica, ti sarebbe, io ti mando un messaggio e non c'è nessuna garanzia. Se lo ricevi lo ricevi, se non lo ricevi ciccia e quindi questo segue il concetto. Quindi nessuna garanzia, non si urlano gli acknowledge, i messaggi non vengono salvati e ritrasmessi dal sender, quindi non c'è un tentativo di trasmissione e quindi l'unica robustezza è data dal fatto che sotto c'è il proprio quello che fa il livello uno, ma altrimenti il MQTT non fa nulla di più di quello che fa il livello uno. Cosa fa il livello 1? Usa dei messaggi, dei comandi in più che prima non avevamo, cioè del set minimo. Ad esempio l'acknowledge sulla publication, quindi il cliente, cioè il publisher invia un messaggio verso il broker e attende il messaggio di acknowledge sul publisher. Se il cliente riceve publish acknowledge, allora il cliente cancella il messaggio alla coda che ha al suo interno, mentre lui produce prima di fare publish, crea una coda. Facciamo tinta che abbia una tempistica che è preso ogni 10 secondi e lui deve accodare il messaggio, altrimenti li sovrastrideri. Se invece non ha ricevuto pubback, allora dopo un intervallo, un tempo restabilito, fa il send di nuovo del messaggio, ma vi aggiunge un flag che sta a dire che è un messaggio già inviato, cioè duplicato. Vedete, da flag lo mette a 1 e continua questa opzione di resend, quindi la invia in continuazione fino a quando finalmente lo riceve pubback. Quindi vedete, almeno un messaggio deve essere ricevuto dal ricevente perché il pubblico continuo ad inviarlo fino a quando riceve pubback. Ma ne possa aver inviato tantissimo. È molto più complesso invece il livello 2. Il livello 2, come vedete, usa ancora altri messaggi. Il pubblico quando deve inviare un messaggio, anche qui aspetta pubback, quindi l'acknowledge su la ricezione. Il ricevente invia questo acknowledge. A questo punto cosa succede? Che se l'acknowledge non viene ricevuto, il sender rinvia di nuovo come prima il messaggio con il flag d'app, l'application 71 e quando il sender riceve l'acknowledge, allora invia un messaggio di release sulla publication. Se il ricevente non riceve pub release, allora di nuovo invia pubreck che era precedente. Quindi tutte le fasi vengono, diciamo, in qualche modo, gli viene mandato un acknowledge. Quindi è molto pesante questo protocollo, però si continua fino a quando, non la faccio troppo lunga, fino a quando arriva il messaggio di publication complete. Publication complete vuol dire, guarda, ce l'abbiamo fatta, io ti voglio caricare il messaggio. Quindi prima ti mando un messaggio, ma ti mando la volontà di mandarti un messaggio. Tu mi rispondi che ci sei, a quel punto ti mando il messaggio, tu mi dici, ok, ho ricevuto il messaggio e solo alla fine, quando arriva da parte del receiver, l'invio di publication complete, se io lo ricevo, allora finalmente dichiariamo chiusa la transazione. E la transazione è molto pesante, vedete, ma ci permette di inviare esattamente un messaggio e di riceverlo. Questa è l'architettura più completa, come potete immaginare, perché volentieri nella IoT, nei divani, in sfoglia, ecco, molto minimali, viene un po' bypassata, ci si mantiene su livelli di qualità del servizio più bassi, ma senza pesentire troppo la comunicazione. La libreria su Arduino per SP usa il livello zero. Quindi in realtà, quando faremo un esempio di Arduino su SP con MQTT, vedremo che usa il livello zero, quindi molto più snello, anche perché appunto sarà poi, diciamo, cura del programmatore, magari inviare pacchetti o far rendere lui consapevole di quello che sta succedendo. Bene, volevo arrivare qui e ci sono arrivato, perfetto. Per oggi finiamo qua. Se avete qualche domanda, invece martedì faremo un'altra esercitazione dove useremo, come vi dicevo, la piattaforma ThinkSpeak, che sarà appunto, magari prima di martedì vi carico anche un piccolo istruzione, così vi potete preparare. Vabbè che basta creare un account gratuito su ThinkSpeak, ci vuole veramente poco. Però vi do qualche istruzione prima per il martedì, così martedì siamo già operativi. Ok? Benissimo. Allora vi saluto, grazie dell'attenzione e ci vediamo direttamente martedì. Saluto a tutti. Ciao ciao.