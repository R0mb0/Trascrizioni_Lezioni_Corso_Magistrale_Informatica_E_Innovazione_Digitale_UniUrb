Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Adesso dovrebbe sentirmi, Nicolò. Infatti. Chiedo scusa, ma abbiamo avuto un po' di problemi nel login in laboratorio. Quindi, in realtà, non abbiamo ancora fatto niente. Quindi, non si è perso assolutamente niente. Perché non siamo mai fatto niente. Non siamo ancora riusciti a fare. Oh, adesso vi fanno vedere finalmente… Se torno a vedere l'aligno, io volevo… Cioè, oggi volevo… Vorrei… La registrazione è attiva? Sì. Oggi vorrei parlarvi, quindi, di questa piattaforma che è l'ESP, che proveremo a programmare. Intanto oggi faremo una cosa molto semplice. Quindi, leggere dati da sensori, poco più. Poi più avanti vedremo anche di cosa è capace questa piattaforma. Adesso vi passo subito ad una slide che è quella relativa alla dotazione che abbiamo. che ho predisposto, come avrete notato, una macchina virtuale che trovate scaricabile all'interno di Blended Learning. Ho messo un link al download di questa macchina. Questa macchina non è nient'altro che una macchina che ho creato con VMware, ma è una macchina in cui ho un'installazione di Ubuntu, la 20A04, e su questa macchina, una volta che l'avete avviata, potete fare login con un nome utente IoT, tutto minuscolo, e password ESP, tutto minuscolo. Questa macchina ci servirà perché contiene già preinstallate tutte le tool chain, cioè tutti i tool di sviluppo per questa nuova architettura che oggi studieremo. Quindi, qui a casa, quindi con lei, potrebbe intanto, Nicolò, scaricare e preparare questa macchina e lanciarla, mentre io faccio vedere alcune slide. Per lanciarla, appunto, va benissimo VMware o virtualbox, e per fare login i parametri sono questi, IoT, il nome utente, e la password ESP. Adesso torniamo un po' indietro perché dobbiamo dire due parole prima di iniziare a lavorare su questa architettura che studieremo e con la quale andremo a lavorare. Questo è un nodo che vedete nella slide che voi qui in laboratorio avete nella scatolina bianca che apre di spot-tangolo, che è effettivamente un'architettura molto più low rispetto all'architettura che abbiamo usato fino adesso con la Raspberry Pi. Intanto qui non si parla di single-borne computing, ma si parla di un sistema microcontrollore. Infatti si parla di MCU, che sta con la microcontroller unit. Abbiamo una dotazione di questi ESP, in particolare l'ESP che abbiamo in dotazione noi è un 2286, che è un ESP, no scusate, un 8266, che è l'ESP single core ma già a 32 bits. Esiste la versione nuova che si chiama SP32 invece che è il doppio core, cambiano pochi euro dall'una all'altra perché in realtà è una piattaforma che comprata su Amazon il nodo single costerebbe 5 euro, quindi costa davvero poco. Cosa abbiamo qua dentro integrato? Cosa abbiamo una DC a 10 bits, quindi c'è un canale ADC, diversamente dalla Raspberry Pi, qui c'è già un convertitore analogico digitale. Quindi se volessimo campionare un sensore analogico, come abbiamo fatto con la Raspberry Pi, non dobbiamo comprarci un ADC esterno, come invece facciamo per la Raspberry che era l'MCP 3008. Qui non c'è bisogno perché ce n'è già uno interno. Qual è il problema, o meglio, qual è la limitazione di questo ADC? Che c'è un solo canale, quindi c'è un solo input, può leggere solo su un pin, però è già qualcosa. Leggiamo solo su un pin a 10 bit con frequenze di campionamento variabili, anche qui siamo attorno ai 300 KHz, quindi andiamo abbastanza veloce. Poi cosa abbiamo? Abbiamo diverse porte di tipo digitale, i quadro C, i quadro S, il full suite modulation, general purpose input output, SPI. Abbiamo quindi un insieme di pin un po' simile a quello della Raspberry Pi, perché anche qui abbiamo general purpose input output, più di quadro C, quadro S, SPI, la UART, che è la porta seriale, e quindi diciamo ha una dotazione ben completa. Si completa inoltre la dotazione con un'interfaccia wifi, vedete, come vi dicevo, queste architetture SP hanno sposato da subito l'utilizzo di una rete wifi, l'802.11, protocollo BCN, così da subito compatibile con le reti che troviamo in casa nostra, perché wifi praticamente ormai esiste ovunque. Oltre al wifi abbiamo anche una porta bluetooth, quindi in realtà abbiamo anche una connessione bluetooth interna. Abbiamo uno stack di protocollo TCPIP, quindi diciamo è abbastanza evoluto, anche a livello di rete, e poi abbiamo, vabbè, un supporto alla crittografia WPA, WPA2 per il wifi, e come capite è un'architettura molto versatile. E quello su cui si lavora è un sistema on-chip, quindi quando si parla di micocontrollore in realtà è un po' diminuire, sminuire l'architettura, perché questo 32 bit MCU in realtà è un sistema on-chip che contiene sullo stesso chip, come vedete, tutti i circuiti di comunicazione, antenne, wifi e bluetooth, la parte di CPU, la parte di RAM e tutte le interfacce di comunicazione digitale. Quindi, nonostante il prezzo di 5 euro, è davvero un sistema molto versatile. Come si può programmare questo attrezzo? Beh, le possibilità sono davvero tante. Sono davvero tante perché, essendo un ambiente molto molto diffuso, come potete immaginare, la maggior parte delle tool chain si sono rese portabili per questo documento, ci hanno cercato di produrre appunto la portabilità. Quindi abbiamo la possibilità di scrivere software in FreeRTOS, che è questo sistema operativo real-time per nodi IoT e vedremo anche questo. Abbiamo un linguaggio proprietario della piattaforma che si chiama NodeMCU, che è un linguaggio Lua, che però non useremo. Lo stesso Arduino ha dei plugin per compilare ed eseguire su questa piattaforma, quindi useremo anche, oggi useremo proprio la piattaforma Arduino per fare questo. una versione di Python che si chiama MicroPython e quello che useremo noi, che è l'SP OpenRTOS, quindi che è una versione aperta di FreeRTOS, che è tutto scritto in linguaggio C. Quindi noi faremo esperimenti con questa piattaforma sia su Arduino sia su OpenRTOS. Prima di andare avanti, quello che vedete di fronte a voi nella scatolina si chiama Development Kit. Perché? Perché in realtà il vero nodo è ancora più piccolo. Se guardate nella piattaforma che ci avete davanti, quello che ha gestito il vostro Paolo, che è in scatolato... Sì, perché non ce l'avete ancora. Scusate, prendete anche un cavo USB. Prendete anche un cavo USB. La piattaforma qui cosa vediamo qua sopra? Annota. Sì, adesso ti spiego anche perché. Vediamo che questa piattaforma è costituita da una base rettangolare che ha diversi pin, che adesso i pin escono all'interno della scatola, quindi non li vedete, ma dove sopra sono le saldature sotto finisce il pin. Ma in realtà il vostro vero nodo è questa robina qua. E' la seconda scheda che è stata saldata sopra, se la vedete. Quella che c'ha da una parte l'antennina. Vedete quel punto in giallo fatto con varie onde, questa parte qua. Questa è l'antenna. E la vostra piattaforma in realtà è questa. Questo è tutto il nostro sistema UnChip. E' lui che fa tutte queste cose. Il resto è una board di sviluppo che serve semplicemente ad ampliare i pin dati che sia più facile per fare i collegamenti. Ma se voi vedete è proprio una schedina che è stata saldata sopra un'altra schedina. Il vero sistema OnChip è quella schedina più piccola che trovate sopra. Cosa c'è nel development kit? C'è dei pulsanti. Vedete? Pulsante 1, pulsante 2. Il pulsante RST serve per fare il reset della macchina. Quindi se la macchina si impianta, si blocca, premete RST. Quello è un pulsante che semplicemente cortocircuita il pin di reset e fa fare il reboot alla CPU. Qualunque cosa la CPU stia facendo. Il pulsante flash invece è un pulsante, diciamo così, che può essere utilizzato per forzare la scrittura sulla memoria oppure può essere usato anche come classico pulsante di input. Poi cosa abbiamo? C'abbiamo un nuovo chip qua, il CP2102. Vedete qui questo quadratino piccolo che se lo guardate lo vedete meglio nella figura qua che sulla realtà perché la sigla non si riesce a leggere. Questo CP2102 non è nient'altro che è un convertitore tra il protocollo USB e il protocollo UART perché la CPU del nostro microcontrollore ha implementato il protocollo di comunicazione seriale UART, non il protocollo USB. Siccome l'estremo della nostra scheda è una porta USB, è chiaro che ci vuole un convertitore per far sì che il linguaggio di comunicazione del protocollo USB sia compatibile con il linguaggio UART della nostra macchina. Quindi questo primo chip quadratino del valore anche questo di pochi centesimi, mi sembra che costino questi convertitori una trentina di centesimi, fa la conversione del protocollo fra USB e UART così che io possa gestire la comunicazione su questo sistema con una semplice porta USB. Poi ci sono altre cosine condensatori e un chip che sta a parte centrale perché la non si vede il video che sto facendo. Oh, io ero attento che mi ha detto. Ah, ah, ah, stavo disegnando. No, stavo in un momento po' a fare la mia cattesia. Ma non c'è più connessione. Oh, madonna, oggi la cattata è di merda. Scusate. Questa non è più in connessione. Ok. Non c'è più in un'altra cosa. La rinunciazione è perché sono l'allogato anche da qua, quindi credo che me la mantenga questa. Questa parte qua che vi dicevo è la parte che interessa a te, ad esempio, perché questa parte che è quella che fa la conversione dai 5V ai 3V. Perché? Perché alla USB arrivano i 5V, quindi da sotto entrano i 5V. ma tutto il resto funziona 3V. Quindi in realtà abbiamo il convertitore di protocollo di comunicazione, che è questo CP2102, e poi abbiamo un circuito analogico che fa la conversione da 2V, che fa la conversione da 2V, che fa la conversione da 3V, che fa la conversione da 3V. Quindi, per alimentarla, perde un convertitore, se vogliamo usare una porta USB. Sì, sì. Sì, sì. Le fa vedere le piccoline. kleine invece. Per riflessioni da 3V.��. La suggerita di codedんなle di открывità, se c'è questa tecnologia siottete, il mondo è più conosco, di ciò che ciò è fatto che non lo guarda più, ma la cosa non vale la sua. In pratica, la vera realtà è che la loro maggiore è quella di connessurare la sua. Le loro nuove, grandi, così, si chiamano development kit, perché è più utile fare sviluppo, in quanto i PIN sono resi più grandi, sono resi più accessibili, quindi fatele fare alla famosa. In generale è questo il concetto. Bene, allora. Adesso ci chiediamo, vediamo velocemente come sono fatti i PIN. Vedete da questo schema, anche qui abbiamo PIN che svolgono pubbliche funzioni, abbiamo la funzione general part con input out, che fa semplicemente segnali digitali in input in out. Poi abbiamo la struttura, le porte miso-mosi e system clock che sono per la comunicazione SPI. adesso arrivo. Queste qua sono per la comunicazione SPI. abbiamo l'ADC, vedete, l'unico ADC che abbiamo è il canale a zero, il PIN a zero, il porto di blu, è l'unico PIN che vi dà la possibilità di leggere un valore analogico. abbiamo un'altra porta SPI anche di qua, miso-mosi. Vedete, l'alimentazione è 3V3, poi abbiamo ground e vedete qui c'è VIN, vedete questo VIN in fondo? se voi volete alimentare senza passare per la porta USB, VIN gli dovete dare 3V3 su quella porta, senza passare per la porta USB. lì lo puoi prendere tu perché viene dal convertitore. Esatto, questi 3V3 sia questo che questo che questo sono, diciamo così, out, sono di accesso a te per poterlo usare. Sì, il ground è comune a tutti e quindi con quello, basta che tu colleghi un ground VIN, gli dai 3V3 e lui al boot e rimane 3V3. Quindi se devi collegare una batteria, quello è il punto giusto. Ok? Da 3V3 la batteria, sì. Sì, sì, ce ne sono diverse. Bene, a questo punto diciamo che abbiamo un po' definito tutti i parametri, tutti i parametri e la struttura di questo sistema, possiamo provare ad andare avanti. VIN nella scheda di sviluppo è l'ultima vicino a un bulloncino in fondo. No, ma lo sai cosa devi fare? Devi prendere il datasheet della schedina piccola e lì li vedi tutti i PIN. Eh, ma forse non li hanno portati fuori tutti perché dipende dal development kit. Vedete, c'è il PIN reset. No, no, ci deve essere scritto proprio WIN, eh, se no va bene. VIN nella scheda di sviluppo è un po' di sviluppo. Va bene. Mi fa vedere? No, ci vado io, dai. No, tu ci vuoi fare un po' di sviluppo. Ci sono preoccupare, ci sono preoccupate. Però magari non abbiamo come un po' di sviluppo in questa situazione. Sono anche i problemi di sviluppo, e vai a cercare, non può cercare di sviluppo. VIN, che è a partire di voi. Sì, mi serve di sviluppo. Io non ho fatto la situazione. Io non ho fatto la situazione. E da lì non c'è messo, se ci metto la batteria, se ci metto la batteria, se ci metto la batteria, non ho fatto una cosa. No, perché in fase del molto compagno di compost, questi completitori sono qua, se mi scambio non hanno più la batteria, non ha senso. E quindi mi dai un'album di ponte per scrivere la terra in riscaldamento di lavoro, non è proprio quello che non ho fatto. Ma in quello che non ho fatto, non ho fatto scelta di andare dal passaggio. Quindi, parli che ti dimenticate senza farlo, prima di ricercare la proprietà su quello di cui, io ho messo a fare un po' di cui, come mi sono detto, mi vado a fare un video. Ora non si è rispondi, non mi sia apporto di video, e questo è il video. L'intervento è che vai a rilassare quei siti. lo visitano lì, lo trovi e li colleghi alla sua uscita che lui riesce a fare. Perché da un'altra parte, diciamo, la 5-9, e io non mi sono prevede, e la propria, non mi riescono a fare. E la propria, e la propria, e le mie connessioni. Questo è un'altra alternativa. però se tu c'è, guarda la fila, se c'è la fila che c'è, la fila che c'è sotto su internet, la trova un'auto, se c'è tutto quello. Prego. Ma se vuoi lo possiamo fare? Sì, è vero. La ricerca viene di là con Paolo, la facciamo al volo. Allora, adesso è ora di lanciare la nostra macchina. E come vi dicevo, la nostra macchina ha già preinstallato, la macchina è virtuale, ha preinstallato un po' di cose. Ha preinstallato l'ESP8266 RTOS, l'SDK, quello che vi dicevo. prego. E abbiamo anche preinstallato tutta la toolchain Arduino per poter eseguire le nostre... per compilare questa piattaforma. Quindi, ciò che andiamo a fare... Adesso io mi collego anche da qua. Direi che possiamo provare a saltare la pausa, perché visto che abbiamo partito in ritardo. Se volete fare un salto al bagno, come ha fatto lui adesso per 5 minuti, va bene. Intanto io preparo... preparo la macchina. Sì, ma infatti vi conviene alla fine. se non è possibile che vi fare la mano. No, ma poi se tutti... Io immagino tanto tutti se avete un portatile, no? Non è... Le prossime esercitazioni che faremo con l'SP addirittura, è probabile che non riuscendo a trovare il laboratorio sempre disponibile, lo possiamo fare anche nell'aula, perché se ognuno ha il suo portatile, questo aggezzo basta un cavo USB, cioè non è che ci serve come per la Raspberry Pi, ci serve un monitor, non ci serve una tastiera. In realtà ci basta un cavo USB per questo, per lavorarci. Quindi potremo farlo anche nell'aula Turing quando non abbiamo la disponibilità del laboratorio. Quindi vi esorterei a scaricare la macchina virtuale su un po' sopportabile, se avete appunto questa possibilità. Allora... Sì. Sì. Allora, io oggi sono... molto occupato, ma in realtà ci sono anche tutto il pomeriggio. Quindi non ci sono stato occupato? Sì. Sì. Allora, io oggi sono... molto occupato, ma in realtà ci sono anche tutto il pomeriggio. Ho un po' quindi di molto tempo stato occupato? Sì. Lui ha bisogno di molto... Ah, ok. No, va benissimo. Allora, sì, se è una questione di 15-20 minuti, sì. Più faccio fatica perché sono messo malissimo questi due o tre giorni, perché c'è un po' di procedure in corso che devo completare. Però... Vado a condividere questa storia qua. E questa è la nostra macchina virtuale. Ok. Quindi ciò che vado a fare adesso è il semplice login con la password SP. Questa è un'installazione di Ubuntu pura. Non c'è niente di diverso da una classica Ubuntu, se non il fatto è che ho installato, ho preinstallato queste toolchain. Allora, essendo una macchina virtuale, come potete immaginare, la macchina virtuale ha un accesso particolare all'hardware, ma noi dobbiamo accedere all'hardware. Perché quando adesso noi colleghiamo un KUSB al nostro computer e lo colleghiamo dall'altro lato al nostro dispositivo, il dispositivo intanto cosa fa? Ottiene subito alimentazione. Nel momento in cui ci collegate la USB, il dispositivo oltre ad alimentarsi fa il boot, fa tutte le cose che porta a coparo. E vedete che la macchina virtuale VMware mi fa subito una domanda. Mi dice, guarda che è stato collegato un chip che si chiama CP2102 USB to UART Bride Controller. Perché la macchina virtuale cosa vede? Vede il convertitore fra USB e UART. Proprio quel convertitore, quel piccolo chip. E si dice dove lo vuoi collegare? All'host device o lo vuoi collegare al guest device? All'host operating system o al guest operating system? Noi dobbiamo dire al guest perché dobbiamo accedere tramite Linux. Vedete quindi tra i dispositivi rimuovibili c'è silicon CP2102 USB to UART Bride Controller. Noi dobbiamo dire connettilo all'host. Connettilo scusate alla macchina virtuale, quindi disconnettilo dall'host. E a questo punto Linux prende il controllo di quella periferica. Linux macchina virtuale, altrimenti sarebbe stato sul sito operativo host che è Windows nel mio caso. Ok? Per vedere su VMware se è davvero avvenuta, tornate su device rimuovibili e vedete che stavolta silicon CP2102 è ceccato come connesso alla macchina virtuale. Lo vedete anche voi? Benissimo. Ecco, se magari collegate un development kit diverso, invece di apparire CP2102 può apparire un'altra sigla. Probabilmente nel tuo caso, se ci colleghi uno di quei piccolini lì, apparirà un'altra sigla perché è un altro convertitore, un altro modello. Ma sarà sempre un modello, quindi invece di apparire come CP2102 apparirà con la tua sigla. Perché ciò che vede non è il chip ESP ma vede il convertitore lì, ok? Vede il primo chip che è quello che convertirà il tuo protocollo. Benissimo. A questo punto ci siamo. Per lanciare una delle due tool chain o Free real time operating system oppure Arduino. Oggi facciamo la prova con Arduino che è un pochino più immediato, un pochino più diciamo user friendly. Sapete, la diffusione di Arduino è stata galattica grazie anche al fatto che è molto semplice. Free RTOS sarà un po' meno semplice, se lo teniamo per le prossime notizioni perché è tutto scritto in linguaggio C, si compila da linea di comando, con un make. Insomma è un pochino più, diciamo da smanettoni tra virgolette, cioè da operatori di programmazione a basso livello. Ma allora noi andiamo sui programmi di questa macchina virtuale e lanciamo Arduino, il nostro tool Arduino. Si mette un po' a fare il boot. È un ambiente di sviluppo molto complesso questo di Arduino, anche perché gestisce un'enormità di tipologie di Arduino. Allora, ci fa il boot con quello che si chiama uno sketch di Arduino già carico perché quando ho salvato la macchina virtuale facevo dei test, ma noi adesso non ci interessa perché noi facciamo uno nuovo. Quindi facciamo file, new e ci crea un nuovo sketch. L'avete fatto? Allora lo sketch precedente lo possiamo anche chiudere, possiamo cliccare sul tastino X dello sketch precedente perché ogni sketch appare in una finestra. Quindi scriviamo quello precedente che non ci interessa. Lasciamo aperto questo nuovo sketch al quale è stato dato un nome provvisorio. Forse dovrei aumentare un po' il volume. Vediamo come si fa. Tra le mille cose che sa fare. Si vede un po' meglio così? Sì, vero? Ok. Bene. Allora andiamo subito a un name as. Diamogli subito un nome questo sketch, non sketch nuovo eccetera. Lo salviamo nella direzione IoT Arduino, mi va benissimo, e chiamiamolo in questo caso LED, visto che questo primo esperimento sarà per far accendere il LED che Paolo ha collegato nella nostra piattaforma. Quindi definito LED, fate save e vedete che il nostro sketch cambia subito il nome. Allora, nella scatolina bianca che ha prodisposto Paolo c'è il kit di sviluppo, ecco una cosa ancora non l'ho detto. Oltre al kit di sviluppo che cosa c'è? C'è, come vedete, annegato nella plastica un tasto che si può premere, no? Questo tasto qui praticamente è un tasto di tipo push, quindi che servirà per ricevere un input. Abbiamo questo aggeggio azzurro con dei buchini, questo aggeggio azzurro con dei buchini è un sensore che ha già il suo convertitore digitale interno, lavora in quadro C e al suo interno c'è il sensore di temperatura e umidità. Il nostro modulo è un modo di HT11 che è un sensore più usato per fare queste cose. Poi c'è un legato, un LED, ne vediamo solo la testina rossa che esce fuori appena dalla scatola. E poi c'è un'altra di queste resistenze che cambiano al variare all' luminosità, come avevamo visto anche sulla Raspberry Pi. Questo è un sensore analogico che Paolo ha già connesso il pin analogico digitale del nostro sensore. Ma adesso noi cosa vogliamo fare? Dobbiamo far accendere e spegnere questo LED annegato dentro la nostra scatolina. Come facciamo? Allora intanto vedete che Arduino ha la sua sintassi particolare, nel senso che ogni sketch Arduino è fatto da due funzioni che poi verranno invocate autonomamente. La prima è la setup. La setup, come potete immaginare, è la funzione che viene invocata per inizializzare qualcosa. Cioè io devo inizializzare un sensore, inizializzare una connessione internet, tutto nella setup. E poi c'è una funzione void loop. Ecco, la loop, come potete immaginare, è invece la funzione che servirà per fare il super loop. Si basa su un'architettura di tipo super loop, Arduino. Quindi qua dentro ci scriveremo il nostro super loop, cioè il comportamento della nostra macchina, quello che deve fare. Allora, come ha connesso Paolo il LED? Perché dobbiamo sapere questo, altrimenti facciamo anche fatica a Paolo funzionare. Paolo ha connesso il LED al, mettiamo un commento, al pin D0. Il pin D0 è un pin che è un General Parkus Input Output, che dovremmo usare in versione Output. Poi su D0 c'è un filo che va a finire ad una resistenza, perché è una resistenza? C'è una resistenza solita, altrimenti il LED si brucia perché andrebbe in cortocircuito. Questa resistenza è da 220 ohm. E poi il filo incontra il nostro LED e da lì dove va va a un GND, a un ground. Di ground ce n'è più di uno, non so Paolo quale era sceso, ma è indifferente. L'importante è che sappiamo che il LED è stato collegato a D0. Quindi se voi vedete sul nostro development kit il D0 è il più in alto a destra, guardando la nostra macchina dal basso verso l'alto con in basso la connessione USB. Quindi il D0 è in alto a destra, lo vedete? Dentro Paolo ha saldato da sotto il filo e l'ha portato alla destinazione. La resistenza non la vediamo perché è tutto chiaramente. Adesso dobbiamo cercare di far funzionare questo sistema. Come? No, mi sono ancora credo. Dunque si devono a fare un'altra. Ma è stato forte, no? Paolo dai, come si mette. Allora, sì, la scatolina l'ha stampata Paolo con la sua stampante. Per immaginare, no? Con la sua stampante 3D ha fatto i nostri scatolini. Bene, allora andiamo a definire subito. Definisco un costante che rappresenta il mio led sul porta di zero. Quindi con il led che prende proprio la parola chiave di zero. Di zero chiaramente tutti i pin sono dichiarati nelle librerie di Arduino. Ok, cosa facciamo nella setup? La setup, come abbiamo detto, servirà ad inizializzare. Questo dobbiamo inizializzare. Inizializzo il pin su configurazione output. Perché questi pin sono general purpose input output. Quindi io dovrò dire, guarda che il D0 lo configuriamo in uscita. Per fare questo esiste pin mode, la funzione pin mode, che riceve prima di tutto l'intero che identifica il pin. E quindi noi l'abbiamo chiamato led che ha preso D0. E poi la parola chiave, in questo caso output, perché noi vogliamo configurarlo in uscita. Bene, ora cosa vado a fare? Configuro la periferica di output UART per scrivere sulla shell di Arduino. Cioè, questi dispositivi non hanno una stand, una periferica di output, non c'è un display, no? Come fatto? Non ha un sistema operativo all'interno. Se io volessi scrivere una riga di debug e vederla, come faccio? E intanto che il dispositivo è connesso alla mia macchina virtuale Linux tramite USB, posso dirgli le mie print, spediscile qua dentro e fai sì che Arduino le sniffi, cioè legga quello che viene fuori. Per fare questo bisogna configurare il protocollo UART. Il protocollo UART è anche detto protocollo seriale. Intanto in Arduino c'è proprio la classe serial, che vuol dire appunto l'oggetto seriale. Quindi diciamo BEGIN, cioè configurati parti, e il parametro che vuole BEGIN è la velocità di comunicazione. Qui possiamo scegliere il protocollo UART, può lavorare a diverse velocità di comunicazione. Usiamo la velocità maggiore possibile del protocollo UART che è 115, ho messo un in più, 115 e 200, quindi 115.200 bit per secondo. Si, però questa è la velocità più alta che esiste nel protocollo UART. Ma nel protocollo UART manderemo i caratteri, quindi sarà più... No, no, è in questo, perché ci sono le specie delle visioni. Adesso questa qui è una cosa preistorica, possiamo dire, no? Bene, a questo punto la porta seriale è stata configurata, il PIN è stato configurato, possiamo permetterci di entrare nel nostro super loop e accendere, magari spegnere il nostro LED. Quindi troviamo questa cosa. Nel nostro super loop andiamo a accendere, accendo il LED portando il PIN di 0 alto. L'idea è quella, no? I PIN general part così imputato possono essere alti o bassi. Alto accendere il LED, alto vuol dire che andrà 3,3, basso andrà a 0 e spegnere il LED. Come faccio? Digital, Bright, queste funzioni di Arduino sono di altissimo livello, come vedete. Quindi digital, Bright, vuole l'ID, l'intero che identifica il PIN. Noi l'abbiamo nominato LED, che sarebbe semplicemente D0. Senza scrivere ogni volta D0 sappiamo che per noi D0 è LED, l'abbiamo nominato così. Quindi Digital, Bright, LED, come alto. Quindi capite? Sono di altissimo livello queste librerie, perché Digital, Bright, alto accenderà il LED, perché porterà il PIN a 3,3. Se lo mando basso spegnerò il LED. Facciamo anche un po' di debug su seriale. Quindi una volta che abbiamo stato il LED, ci permettiamo di stampare su serial.println, l'oggetto serial una volta che è stato configurato, ha queste funzionalità di stampa, println e LED acceso. E si aspetta una stringa questo println, quindi possiamo dire LED acceso. Ora anche qua vado ad attendere per 500 secondi, altrimenti se lo spengo subito il LED di nuovo non lo vedrò, se non può brincare velocissimamente. Per attendere nel superlucco possiamo usare delay. Ricordiamoci che non c'è un sistema operativo qua sotto, quindi l'unico task che sta eseguendo è questo. La delay Arduino mi sembra di ricordare che ancora su questo processore lo tengo come delay attivo, quindi come uno spin lock. la CPU non va in risparmio energetico. Diversamente quando useremo FreeRTOS invece potremmo usare anche i stadi e tabasso costumino energetico. Quindi dopo la delay faccio la spengo il LED. Quindi vado a fare di nuovo DigitalWrite sempre su LED ma questa volta Low. Facciamo serial.println, poi stampiamo anche questo stato, diciamo LED spento. E di nuovo facciamo un bel delay di 500. Anche la fase, anche la fase vi dicevo di spegnimento deve stare a 500, supera un po' di tempo, altrimenti lo riaccendiamo subito. E questa funzione loop viene invocata automaticamente da Arduino all'infinito. È già un super loop, vedete? Non abbiamo necessità di fare un while qua dentro perché la funzione loop, come dice il suo nome, viene invocata in loop dal sistema, dalla libreria Arduino. Bene, a questo punto possiamo provare a vedere un tanto la compilazione, la compilazione e poi provare l'esecuzione e fare lo sniffing. Lo sniffing vuol dire poter leggere eventualmente anche nelle system outprintln. Allora, se andiamo su tool, abbiamo un po' di cose che possiamo fare. Allora, qui la piattaforma, vediamo se è scelta da quella giusta. Proviamo a fare verify compile, disconnete su sketch, verify compile, vediamo cosa fa. Avete trovato su sketch, verify compile, sto facendo la compilazione. Ancora da me, sta ruspando. Ha creato l'eseguibile, sketch uses 25% con la storia, massimo is, roba, roba, dubiuses, eccetera. Dove è adesso in tools? Andiamo a vedere. Tools. Ecco, esatto, perché c'è un sacco di roba. C'è board node mcu 1.0 sp, lo vedete, è giusta. La riconosciuta bene. Bene, ha funzionato anche voi il compile verify? Guarda, lo rifaccio, mi ha dato tutto a buon fine. No, no, no, non ti dici. Se si vedono, ho avuto un grande discorso e più inizio di roba, in me serve. Hai fatto qua un Steam Club di D0 maiuscum? No, però no. No, però forse non ha la piattaforma giusta, perché D0 è dichiarato la piattaforma. Vai un po' a vedere in tools? No, no, ma se si vedono, non è giusto. Quindi è checcato node mcu 1.0 sp 12.0. Bene vero... ... Emo? Service x2 Allora, verify è stata configurata, vedete, qui ci dà un po' di informazioni sull'eseguibile che ha prodotto, ci dice quanta occupa il flash, la sua dimensione, quanto occupa la sezione data, eccetera, cioè ti fa vedere il task, ricordiamoci che è tutto compilato in maniera statica. Quindi, allora, la memoria RAM dovrebbe essere 16K, se non ricordo male. Allora, adesso invece facciamo upload, vedete, dopo aver fatto la verifica, facciate upload, upload, attraverso la porta USB andrà a caricare l'eseguibile sul nostro sensore. Quindi facendo l'upload, vedete che, ecco, comincia a fare la connessione, vedete, writing, 7%, 15%, vi ha riconosciuto il MAC address della macchinina. Questa è una programmazione più a basso livello rispetto alla Raspberry Pi, dove subito eseguivamo, la Raspberry Pi aveva il suo sistema operativo, qui ricordiamoci che non c'è nulla. E vedete che adesso lampeggia il led rosso. Sì, lampeggia anche quello azzurro. E poi lampeggia negato, sembra, no? Sì, è il not. Quello azzurro lì bisogna vedere il... Ah, lo so io cos'è. Quello azzurro lì, esatto, identifica il seriale, cioè quando viene scritto sulla UART. Adesso però noi la UART non la vediamo, vedete, non è che vediamo le print, non stiamo vedendo nulla di tutto ciò. Perché noi abbiamo configurato il serial, ma adesso dobbiamo far sì che sulla nostra macchina qualcuno sia in ascolto sul protocollo UART. E quindi in Arduino, cioè questo tastino in alto con la lente, in alto a destra, lo vedete il tastino in alto a destra con la lente, e quel tastino lì, serial monitor, ci clicchiamo sopra, apre il serial monitor, vedete, e appaiono le stringhe, perché adesso abbiamo attivato un task, un processo sulla macchina Linux, che sta sniffando il protocollo UART sulla porta USB. Tutto ciò che passa sul protocollo UART a 152.200 bit al secondo viene trascritto su questa finestra. E questo è l'unico modo per debuggare un dispositivo come questo, che non ha un'interfaccia, non ha un monitor, non sapremo altrimenti come fare a capire cosa sta facendo. Grazie appunto al protocollo UART, che è automaticamente implementato nel sistema un chip, e viene tradotto da questo chip che fa il convertitore tra il protocollo USB e il protocollo UART. Questo CP21 è qualcosa. A un certo punto possiamo chiuderlo, questo smiffer, tanto quando abbiamo visto che il tutto funziona, e abbiamo capito che queste righe di codice vengono ripetute all'infinito. Ecco il concetto di superloop. Questo è un superloop implicito, nel senso che la funzione loop, non lasciamo noi invocarla in un while, viene invocata automaticamente in un while dalla libreria di Arduino. No, devi spendere. Provate a usare il tasto reset, vedete che sulla board c'è RST, c'è un tastino RST piccolissimo, se premete il tasto reset, vedete che si ferma un attimo questo ciclo di blinking, perché la CPU viene resettata e rifà il boot da capo. Vediamo se ce ne accorgiamo lanciando il serial monitor. facciamo il reset, vedete va in panne anche la seriale, quando fate il reset comincia a scrivere caratteri a caso, perché non si sincronizza subito alla velocità di 115.200, e quindi scrive un po' delle cose a caso, o meglio, vengono interpretate a caso. Ecco, come dice poi il led acceso. Bene, quel tasto reset che vi ho fatto usare è un tasto, si dice, proprio fisico, nel senso che va a cortocircuitare di default il pin RST su ground, e quindi la macchina quando la CPU trova questo cortocircuito, si riavvia, proprio in hardware, è un tasto di salvataggio, perché qualsiasi cosa succeda alla CPU col tasto reset riparte da zero. Bene. A questo punto direi di fare un'altra prova, questa volta invece, utilizzando, perché abbiamo nel tempo, utilizzando l'altro sensore che è il, utilizzando la fotoresistenza che abbiamo integrato sulla scatolina. Quindi andiamo a fare un nuovo sketch. Intanto, chiaramente, il nostro sensore, non c'è modo di fermare, lui continua a fare questa cosa qua. Cioè, lui, se lo vuoi fermare devi staccare la corrente. L'unico task che ha è quello, l'unico programma che c'è dentro è quello, lui l'unica cosa che farà è per sempre accendersi e spegnere. Quindi andiamo a fare un altro sketch. Quindi file new, ho creato un nuovo sketch, questo vecchio lo possiamo finalmente chiudere. Il nuovo sketch, facciamo subito, save as, e questo lo chiamiamo, dunque l'altro l'abbiamo chiamato LED, questo qui lo chiamiamo fotoresistenza. Fotoresistenza, perché qui andremo a misurare il valore di luminosità presente nella stanza, grazie a questo fotoresistenza. è lo stesso sensore che avevamo sulla A0. Allora, come Paolo ha collegato questo sensore? Perché è stata una scelta, veramente progettuale di Paolo, collegare questo sensore. Allora, intanto va per forza su A0, perché l'unico pin analogico, l'unico pin di Analog to Digital Conversion è l'A0. quindi il pin, il sensore è stato collegato così. Per farlo mettiamolo in verticale, che è meglio. Sta bene, troviamo V3.3 in cima, il filo poi va giù, da V3.3, va sul sensore, o meglio, mettiamo fotoresistenza, fotoresistenza, dalla fotoresistenza si scende, qui, in questo punto, si collega il pin a 0. sotto questo collegamento, c'è una bellissima R resistenza, di 500 omega, sotto ancora, c'è GND. Ecco come è fatto il circuito, per leggere la fotoresistenza. così. Allora, la fotoresistenza sta tra GND e 3,3 V, però abbiamo dovuto metterci anche una resistenza in serie da 500 Ohm, altrimenti, di nuovo, la fotoresistenza si bruta, perché non reagisce, ha una resistenza interna molto bassa, non reagirebbe il cortocircuito, tra i 3 GND. Benissimo. Cosa andiamo a calcolare, a misurare col pin a 0? Andiamo a misurare la tensione fra la fotoresistenza e la resistenza di 500 Ohm. La tensione che misuriamo lì sarà proporzionale, questo è un partitore resistivo, sarà proporzionale alla resistenza R e alla fotoresistenza. La resistenza R è costante, quindi se noi andiamo a misurare col pin 0 la tensione lì, in realtà misuriamo una tensione che sarà proporzionale alla resistenza variabile che varia in base alla luminosità. E quindi noi, leggendo quel valore di tensione, lo potremo rapportare alla resistenza della fotoresistenza, il quale sarà rapportabile alla luminosità, nel senso che ci sarà, appunto, una proporzionalità tra queste. Allora andiamo subito a dichiarare il solito const int fotores, fotores, fotores, lo chiamiamo, fotores, che sarà uguale a 0. Il nostro pin a 0 è dove la nostra fotoresistenza è stata collegata, o meglio, il pin sul quale noi andremo a calcolare la caduta di tensione. Poi definiamo anche il double foto value, ad esempio, di pre-dato 0.0, questa sarà la nostra variabile che ci servirà nelle letture. nel setup andiamo semplicemente a fare init di serial, perché poi il valore lo vogliamo stampare nella seriale, non abbiamo altro modo per poterlo poi vedere. Quindi serial begin e la velocità è sempre quella, 115, 800. L'ADC non c'è bisogno di inizializzarlo, perché quel pin a 0 fa solo quello, non è che ogni volta che scegli il pin quello non può fare altro, quindi non è che dobbiamo dire configura il pin a 0 in ADC, no, quello fa solo ADC, quindi non c'è addirittura bisogno di farlo. Nel nostro super loop andiamo a fare la lettura. Effetto la lettura da a 0. Come faccio? Il nostro foto value prenderà l'analog read su foto res proprio e sarebbe a 0. E analog read come potete immaginare dal nome è una lettura analogica, quindi praticamente legge dall'ADC. Adesso passiamo una serial.println dove andiamo a dire attenzione ai capi del foto res uguale e qui se non sbaglio posso usare un momento tensione ai capi della fotoresistenza uguale più se non sbaglio devo fare qualcosa tipo string di foto value oppure posso fare sistema outprintl e poi sottofare il sistema outprintl del nostro valore e poi facciamo un delay di 1000 secondi se non abbiamo sbagliato questo sistema dovrebbe funzionare quindi facciamo sketch verify and compile wow non gli è piaciuto questo string ah ho lasciato una parentesi sotto non ho richiuso l'ultima parentesi verify ok da me è andato bene è arrivato in fondo dice che questo sketch usa il 25% dello program store space global valuable uses 34% of dynamic memory ci da un po' di informazioni su no perché le librerie sono di alto livello ma sotto c'è tanta roba capito non puoi scrivere chissà cosa però considera che sono delle macchine foglia queste non stanno la foglia della IoT campionano in via non è che non fare cose poco non puoi fare un gran processing allora bene adesso facciamo l'upload la flash light 4 megabyte auto detect flash light 4 megabyte 1% 69 100% resetting ha risettato la CPU e la CPU visto così non fa niente perché non abbiamo usato un led niente però andiamo a fare a lanciare il serial monitor i valori vedete ci sono ci mettete la mano sopra effettivamente cambia quindi siamo in grado di leggere il valore poi quando vedremo nelle prossime esercitazioni come mandare magari da questo dispositivo un dato potremmo provare a mandarlo su InfluDB anche qui anche su Arduino c'è la libreria InfluDB per questo sistema possiamo mandare anche lì con il nostro token eccetera prima ci dobbiamo collegare questo abbiamo detto che c'è il wifi quindi ci servirà la procedura di collegamento a una rete wifi una volta collegata a una rete wifi con il token conoscendo il token collegarsi a InfluDB mandare delle informazioni lo useremo anche per sistemi di comunicazione più semplici di InfluDB lo useremo per fare il invio di messaggi con ad esempio il protocollo MTT quindi vedremo anche questi aspetti quant'è che possiamo trovare un valore per i micro in una sottile di mille mille sì abbiamo quanti millisecondi o uno sì sì se ci metti uno è un millisecondo la velocità massima che riesci a gestire sì sì diciamo che dipende dalla sua capacità del processore e che quante istruzioni puoi considerare che qui la cosa che porta via più tempo è la stampa sulla UART perché stampare di questi caratteri sulla UART si mette parecchio tempo quindi in realtà se il task di campionamento dura anche poco e tu stampi tutto sulla UART in realtà si impiega più tempo a stampare che a campionare ok oppure se hai uno schermetto di qualunque oppure se lo vuoi mandare attraverso un protocollo comunicazione tipo MQTT lui deve essere collegato al wifi poi mette un serverino che raccoglie i dati della Raspberry e la Raspberry poi fa i grafici lui conviene che mandi il pacchetto semplice più semplice possibile così va più veloce possibile se hai bisogno di una capacità di campionamento con tutto che un po' di elaborazione la puoi fare anche qua sopra cioè un buffer di 20-30 elementi o 50 elementi probabilmente riesci a mantenerlo quindi che non so se devi fare un buffer e sopra fare la detection di un evento particolare ce la fa come? no se devi fare un buffer in 100 dati dove devi tutti procedere esatto se abbiamo ancora un po' di tempo a questo punto io proverei il il bottone quindi facciamo un altro sketch quindi questo lo possiamo chiudere facciamo un file new sketch vediamo quello vecchio sì di energia pochissimo il problema è che devi studiare il modo di mantenere il low power della CPU quando non fa niente e in Arduino immagino che ci siano delle librerie aggiuntive per cercare di farlo perché questo void loop con delay in realtà esatto non si muoverebbe più ma anche il rischio è stato un po' che è una potenza una resistenza termica ma poi è stato un video di transistor perché la caratteristica cambia secondo la temperatura che gestisce la tensione cambia secondo la temperatura e qualcuno può svolgere la resistenza ti consuma però è fastidio l'ambientamento è una ragionazione devi capire che batteria riesci a trovare come capacità di quanto possa essere grande eccetera fatto quello cerchi di capire ma per capire lo tempo è anche misurare il consumo di questo dispositivo se lo porti qui da noi abbiamo sistemi per la misura del consumo energetico l'attacchi lì e vedi ognuno non credo che questi DHT non consumino su di una volta la serie Robles c'era già dovrei campionare a una frequenza abbastanza alta lì un po' di energia sì allora non credo che il consumo possa essere molto grande però lo puoi studiare lo puoi anche misurare una volta che l'hai fatto se lo porti qua lo misuriamo vediamo quanto consumo è la fase più complicata allora proviamo a fare invece questo sketch per il nostro pulsante quindi facciamo save as pulsante e il pulsante che Paolo ha collegato andiamo a vedere come lo ha collegato quindi vi faccio il disegnino cercando come prima non funziona più allora se abbiamo la 3v3 il filo che dà la 3v3 qua al mio pulsante il pulsante è normalmente aperto quando premo collega la 3v3 a quello che ci sta sotto quello che ci sta sotto è una resistenza che abbiamo messo ops che va indietro allora qui Paolo ci ha messo in realtà il D7 collegato questo K a D7 qua c'è invece una resistenza da 100k no 10k scusate 10k omega su ground quindi praticamente questa resistenza da 10k omega cosa fa? fa sì che sicuramente limita la corrente nel momento in cui il pulsante collega i 3v3 a ground per non porto circuitare la scheda ma funge anche da resistenza di pull down nel senso che quando il pulsante è aperto il K D7 grazie alla resistenza 10k va a 0 cioè viene portato forzato a stare a 0 omega non appena premiamo il pulsante la 3v3 si collega a ground tramite questo e il D7 diventa 3v3 sale immediatamente a 3v3 la corrente che passa è bastissima perché abbiamo 10k in in questo limita la corrente e riporta D7 a 3v3 quindi noi dobbiamo essere in grado di percepire questa variazione perché D7 è normalmente a 0 tenuto dalla di resistenza r su ground quando premiamo il tasto va a 3v3 perché il pulsante mi collega appunto a 3v3 la D7 bene cosa dobbiamo fare allora andiamo a dichiarare appunto la costante costante per il pin D7 quindi const in chiamiamolo button pin prende D7 ponte virgola poi definiamo l'int button state vitalizziamo a 0 questo ci servirà a capire se appunto lo stato è 0 1 cioè auto basso e poi iniziamo con la nostra setup anche qui facciamo la setup della serial serial begin 115 1200 e ora inizializziamo il pin digitalizzo pin d7 a pin pin mode abbiamo chiamato il button pin input questa volta dobbiamo usarlo come input nell'initializzazione non dobbiamo parlare altro cosa facciamo nel loop andiamo a ricevere il button state da digital read no digital read su button pin e poi facciamo un check controlliamo se il pin è auto o basso facciamo quello che viene chiamato un polling sul pin non lavoriamo con interrupt in questo caso lavoriamo con un polling che è chiaramente molto disperdioso dal punto di vista energetico però la libreria più standard è appunto una libreria basata sul polling che legge semplicemente il pin quindi facciamo il il nostro button è uguale uguale a auto allora vi posso fare una siria un print dove dico tasto premuto come sì anche print mi sembra ma qui però c'è un print line esatto funziona sia print che print line else siria to print l line in realtà scriviamo anche questo scriverà in continuazione io lo lascerei senza lenza altrimenti vediamo una valanga di print inutili e ci mettiamo qui qua un delay giusto per non fare un polling ogni microsecondo non direi 50 millisecondi così che noi ci veda quando cambia lo stato del print proviamo verify e compone la verifica è andata bene facciamo sketch uploadません io periodo ano o camgado che Ok, adesso proviamo a vedere se va avvenzando il nostro serial monitor. Ci serve qualcuno che vigni, quello che succede, e vedete che funziona. Tasto premuto, tasto premuto. Sì, anzi non è venuto male, ci taglia la luce. Vedete, è una piattaforma povera, addirittura non abbiamo usato l'Interat, quindi con questo ciclo in un delay di 50 millisecondi andiamo semplicemente a leggere il pin, app o da. Esiste la possibilità di usare gli Interat? Sì, esiste, che è una cosa più intelligente e la vedremo soprattutto quando useremo invece che il toolchain di Arduino, ma useremo invece FreeRTOS, vedremo che sarà molto più versatile e soprattutto non consumerebbe tanta energia come in questo caso. Diciamo che Arduino non è tanto ottimizzato per consumi energetici ed efficienza. è molto intuitivo, è facile come vedete buttare due tre righe di codice e far fare qualcosa a un dispositivo così particolare come questo, ma non è poi così ottimizzato dal punto di vista energetico. per quello che applicazioni, passatemi il termine, più serie usano sistemi operativi real-time come FreeRTOS piuttosto che usare lo schetto di Arduino. Per Arduino come dimostratore, come progettino demo, va sicuramente. E' nato proprio nella didattica, per far apprendere ai ragazzi. Per fare tempo e semplicemente salurare in modo di atto. Esatto. Bene, vogliamo aggiungere come dicevamo il LED, diciamo anche questo, quindi dichiariamo anche un const in LED che stava su D0. E utilizziamo anche il LED, così quando premiamo il tasto il LED si accenderà. quindi inizializzo il LED, quindi pin mode, pin mode di LED, un boot boot. andiamo nel nostro if, dopo aver scritto premuto, facciamo digital write su LED di AI. qui facciamo anche fare l'else stavolta. qui facciamo anche fare l'else stavolta. dove facciamo digital write su LED di AI. su LED su LED di AI. su LED di AI. così lo spegniamo, altrimenti rimane in partita. di button state. si. di button state, sì certo. lo tiriamo fuori da l'IF lo facciamo. mi sembra molto intelligente. quindi qua sotto facciamo digital write su LED di AI. quindi togliamo l'else e togliamo questa roba qua. effettivamente abbiamo lo stato del pin pulsante, quindi quando il pin va su accendiamo, quando il pin va su accendiamo. rifacciamo il verify, compile e upload e vediamo se cambia. sta andando, sta andando. sta acceso solo per quei istanti in cui teniamo premuto. il seriale è il nostro. però non è il seriale, perché quando abbiamo mostrato l'uso, la seriale è la strada. giusto, è giusto, è vero. infatti mi chiedevo quello, quando noi ti abbiamo premuto in realtà il seriale spara. il not del D0, probabilmente. è vero. no? è vero. è vero. sì, bisogna guardare nella specifica. non dettagli. funziona. bene. per oggi chiudiamo qua. adesso è la mia benzina. no? no, è vero, è vero. no, è vero. no, è vero. no, è vero. no, è vero. bene. allora, invece, la settimana prossima vedrete l'annuncio, ma martedì non c'è lezione, perché martedì sono in affarato con il primo anno, quattro ore. sì, la mia, scusate, la mia. la mia lezione martedì non c'è, però giovedì facciamo esercitazione, magari portate il portatile, perché non abbiamo l'aula, ma lavoriamo ancora con questo aggeggio qua, quindi possiamo andare tranquillamente lì. ecco, ricordatevi di mettere la macchina virtuale sul vostro portatile. ok? allora, io... mettiamola corrente. è grezzo così, questo. sì, però...