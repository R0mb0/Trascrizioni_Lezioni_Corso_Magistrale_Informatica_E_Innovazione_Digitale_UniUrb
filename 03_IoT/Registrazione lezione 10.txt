Iniziamo questo nuovo capitolo di teoria della programmazione IoT e oggi andremo a vedere quella che è la parte di comunicazione. Naturalmente parliamo di comunicazione a partire dagli strati più basi, quindi dal livello edge, verso quella che è la parte cloud. Come ci ricordiamo infatti siamo nella condizione in cui abbiamo i nostri dispositivi foglie che normalmente raccolgono dati e compiono delle azioni e questi avranno la necessità di comunicare per raggiungere cloud e per comunicare anche tra di loro in una sorta di connessione più a più più. Quindi facciamo un primo ripasso di quello che è la struttura della rete, la struttura layer, poi invece ci caliamo un pochino nel dettaglio in quello che è la struttura normalmente utilizzata nell'ambito IoT. Per quanto riguarda il concetto di network layers, noi sappiamo che la rete, l'internet e tutti i sistemi di connessione sono stati implementati, sono evoluti in realtà nel tempo, attraverso una struttura a strati ben definita. Questa struttura a strati rende particolarmente efficiente e versatile il sistema perché, come potete immaginare, ogni strato dialoga solo con uno strato più in basso e con uno strato più in alto e si limita quindi a definire delle funzionalità interne a questo strato che rendono il tutto ben classificabile, ben strutturato e soprattutto ben gestibile. e ogni layer, come vediamo, è totalmente indipendente dall'altro e normalmente è stato disegnato, progettato e implementato seguendo degli standard o comunque che poi sono diventati tali in modo tale da essere interoperabile e da garantire la comunicazione con tutti i livelli successivi. Bene, in questa slide vediamo un po' quello che è l'ecosistema della rete, dove sulla sinistra vediamo NostX che vuole comunicare con un NostY o meglio, un'applicazione che si trova sul computer X che in qualche modo vuole scambiare informazioni con un'applicazione che si trova sul computer Y. queste due applicazioni che risiedono su macchine diverse, come sappiamo, avranno la necessità di scambiare informazioni attraverso la rete. e la rete può essere di tutto, cioè sappiamo che l'internet ad esempio è definita come rete di reti, abbiamo tante tipologie di reti connesse tra di loro, tanti dispositivi di comunicazione, tante tecnologie per l'applicazione, ma a livello applicazione tutto questo sarà trasparente perché se vediamo un'applicazione che ha il suo protocollo di comunicazione definito all'interno dell'applicazione stessa, vorrà dialogare semplicemente con l'applicazione che riscede in Y, detto da noi fregandosi di tutto ciò che accade sotto. l'applicazione utilizzerà le primitive messe a disposizione ad esempio dal sistema operativo e a livello applicativo il programmatore non dovrà conoscere tutto ciò che accade sotto. Ma tutto ciò che accade sotto è più o meno complicato anche in base a come è fatta la rete sottostante. Vediamo che a livello applicazione il messaggio in realtà entrerà nel layer successivo che facciamo chiamare layer di trasporto, dal layer di trasporto scenderà ancora dal layer di rete, il layer IP, da questo si arriverà finalmente, perché in realtà è questo il layer che davvero attua la trasmissione fisica dei bit, che è il layer fisico o il link layer. Il layer fisico, come potete immaginare, all'interno di un sistema internet costituito proprio da reti di reti, può essere basato su tecnologie più svariate, possiamo avere comunicazione wired, ad esempio in una LAN, oppure wireless tipo wifi, oppure possiamo uscire dalla nostra rete LAN attraverso fibre, attraverso GSM, e quindi capite che il layer fisico è qualcosa sicuramente di basso livello, ma è qualcosa che davvero lavora trasferendo i dati, cioè alla fine i nostri bit. Ma quello che interessa vedere in questo sistema costituito da pre-layer è che l'applicazione dialoga semplicemente con l'applicazione, nel senso che comunque il protocollo di applicazione è tramite questo dialoga. Tutto il resto è offerto dallo stack di layer, di rete, quindi tutti gli strati di comunicazione messi a disposizione anche dal sistema operativo. Quello che accade nella parte a destra della slide è che il nostro dato, che chiaramente l'applicazione sull'host X vuole trasferire all'applicazione sull'host Y, e quindi vi rientriamo con data, subisce in qualche modo diverse trasformazioni per giungere all'host X, perché man mano che si attraversa ogni strato, la prassi qual è? Che al dato, che al nostro payload, venga aggiunto qualche cosa, che normalmente viene chiamato leader, leader è proprio del layer in cui stiamo lavorando. Quindi ad esempio a livello di trasporto viene aggiunto leader del protocollo di trasporto, che può essere TCP o UDP, e questo leader è essenzialmente una delle informazioni, che possono costituire tagli, indiritti, eccetera, che servono essenzialmente per gestire l'informazione e trasferirla all'interno del layer stesso. Quindi ciò che ad esempio a livello di trasporto è costituito da data più header, che noi chiamiamo appunto un pacchetto TCP, diventa a tutti gli effetti data per il layer successivo. Quindi la stessa quantità, la stessa informazione che da noi era costituita da data più header TCP diventerà data del layer successivo, ad esempio in questo caso network. A sua volta il layer network raggiungerà un nuovo header, e questo qui viene definito classicamente incapsulamento, cioè il pacchetto originale, il nostro dato originale viene incapsulato all'interno di una struttura che contiene il pacchetto più header, il quale viene di nuovo incapsulato una struttura che contiene l'intero pacchetto più header, e via dicendo, fino ad arrivare al frame, diciamo così, definitivo, che è quello che viene scambiato a livello fisico. È chiaro che questo sistema poi a ritroso, cioè inoltre che il pacchetto è arrivato a livello fisico e dal fisico risale verso l'applicazione, comporta un processo inverso. Quindi avviene lo spacchettamento, diciamo così, si rimuove prima al leader del fisico, si passa al network layer, si rimuove al leader IP, si passa al transport layer, si rimuove al leader del protocollo fino ad arrivare in cima. Ecco, questo meccanismo, come potete immaginare, comporta dell'overhead, comporta un overhead di quantità di interruzioni che vengono trasferite sulla rete, ma garantisce la correttezza della comunicazione e vedremo l'estradamento. Questo per dirvi che chiaramente il modello della nostra rete è tutt'altro che banale. Secondo, ecco la sintassi Osi del nostro modello, quindi della nostra rete, va a definire un layer di applicazione, che qua viene diviso dall'application, presentation, section, un layer di trasporto, un layer di internet o di rete, un layer link e un physical layer. Questi sono tutti appunto i layer che normalmente si trovano in una particolare infrastruttura di rete e come vedete l'ultima colonna in fondo a destra ci dice quali sono i dati sui quali ognuno di questi livelli lavora. Chiaramente l'applicazione lavora a livello data, cioè dato che effettivamente è puro e viene trasferito dall'applicazione sull'host X all'applicazione sull'host Y. A livello di trasporto questo dato viene incapsulato aggiungendo il concetto di datagramma, di segmento. Si parla di pacchetto a livello di internet, di frame a livello di layer link e di simboli e di nostri veri e propri bit a livello di link. Ma andiamo in ordine e ripassiamo, ripassiamo perché per molti di voi sicuramente che poi saranno note ma non ci fa male. Comunque, mi metteranno in ordine per vedere poi come matcha l'IoT su questa architettura. Quindi parliamo dal basso, partiamo proprio dal link fisico, quindi dal layer fisico e link e questo layer è il layer che ha a che fare proprio con la parte fisica del trasferimento dell'informazione. Quindi ha a che fare proprio con i connettori, i cavi. Se parliamo chiaramente di canali di comunicazione wireless avrà a che fare con le frequenze di comunicazione del segnale, con la potenza del segnale, con i canali. Quindi noi sapete che spesso la stessa comunicazione può venire su vari canali, sulla generazione dei simboli, cioè dei nostri ricerzioni, dei nostri bit e sulla sincronizzazione. Quindi ad esempio a questo livello si parla di protocolli di controllo d'accesso, ad esempio si parla di sistemi di sincronizzazione tra ricevitore e trasmettitore, se in caso possiamo le sistemi wireless, per poter definire come leggere, come scrivere i nostri bit. La struttura della nostra informazione qua viene scambiata, diciamo che viene superimposto, si dice, una struttura, un frame. Ad esempio questo frame conterrà delle informazioni, ad esempio il back address di sorgente e destinazione all'interno di una comunicazione singolo oltre, dove appunto c'è una comunicazione diretta per due dispositivi e queste informazioni sono quelle che vengono aggiunte, proprio il back address, che sarebbe l'indirizzo fisico. Che cosa fa essenzialmente questo link, oltre a risolvere i bit? Ecco, ad esempio deve gestire tutto l'arbitraggio del canale, quando parliamo di comunicazione fisica, sia che siamo su un canale wireless o un canale wireless, in realtà i dispositivi che stanno comunicando, condividendo lo stesso canale, dovranno ad esempio mettersi d'accordo su il momento, sulle tempistiche in cui i nostri dispositivi dovranno pubblicare. E quindi tipici di questi layer sono i cosiddetti algoritmi di arbitraggio, come il CSMA, che sicuramente avrete sentito dire, che è un algoritmo di carrier sensing multiple assets con collision avoidance. Che cos'è questo algoritmo? Se l'avete sentito nominare, è semplicemente la necessità di definire tra più utenti che devono utilizzare in un dato istante il canale di comunicazione che è unico, diciamo che ci siamo in wifi, stiamo lavorando sullo stesso canale di comunicazione, il sistema di arbitraggio prevede che ogni dispositivo che voglia inviare un'informazione, per prima cosa dovrà fare il sensing del canale per cercare di individuare sia il canale in quell'istante, è libero, è libero, quindi ecco che si parla di carrier sensing multiple assets, cioè ogni dispositivo prima di inviare farà il sensing del canale per un certo periodo, se trova il canale libero, non vede energia, quindi non vede il trasferimento di informazioni sul canale, allora potrà iniziare la comunicazione. Questi algoritmi sono tipici appunto di questo livello, dove semplicemente si potrà andare a mettere d'accordo chi riesce a utilizzare il canale in un dato istante. Poi c'è anche il problema dell'oste nascosto, certo, e c'è anche il problema sì che nel algoritmo CSMA, cioè io vado a fare il carrier sensing, ma l'oste nascosto è magari a una distanza tale che io non riesca a percepirlo, quindi secondo me il canale è libero, ma invio a un destinatario, invece il destinatario è più vicino all'oste che per me era nascosto, e lui in realtà lo sente e magari lui stava comunicando. Quindi è chiaro che in un sistema, ad esempio wireless, è un problema non banale risolvere anche questo aspetto qua. Bene. Bene. Salendo invece dal livello fisico, saliamo verso il livello chiamato appunto network o IP layer, e a questo livello l'integrazione che avviene è un'integrazione basata su la conoscenza dei singoli punti che comunicano. Ecco, una cosa che non ho detto, a livello fisico non si ha una conoscenza globale, cioè del tipo il dispositivo, l'ost X che vuole comunicare con l'ost Y, assolutamente la comunicazione è punto punto tra i vari dispositivi che troviamo nel percorso all'interno della nostra rete, tant'è che si riconoscono attraverso questo indirizzo fisico, questo make-up. Invece l'integrazione a livello network è basata sul concetto di indirizzo unico, questo qui è l'indirizzo vero dell'ost, non è l'indirizzo del dispositivo intermedio che noi troviamo durante la comunicazione, e è quello che viene chiamato normalmente IP. Sappiamo che esistono due sistemi per definire questi indirizzi unici, il PV4 chiamato il PV6, il PV4 quello basato su 32 bit, assegnati di diritti IP, e l'IPV6 quello, diciamo, aggiunto pochi anni fa, che va a estendere il numero di indirizzi disponibili, tant'è che usa 128 bit. Bene, e a questo livello quindi si va a fare quella che viene chiamata l'integrazione della comunicazione, cioè le varie reti in questo caso si integrano grazie al fatto che i nostri punti, gli end point, cioè i punti di comunicazione, quello che nella nostra slide era l'ost X e l'ost Y, vengono identificati esattamente con un indirizzo IP. Cosa si fa a questo livello, cioè in questo strato? A parte appunto il concetto di addressing che abbiamo appena visto, si parla di segmentazione e di routing. Che cosa vuol dire segmentazione e routing? Vuol dire che, come abbiamo detto, i nostri dispositivi, per essere raggiunti, avranno bisogno di un sistema di instradamento, a questo sistema di instradamento, appunto gli routing, che permette di decidere quale dispositivo intermedio attraversare per raggiungere i nostri end point. La segmentazione che cos'è? Sappiamo che, perché, ad esempio, o meglio, ogni protocollo di comunicazione avrà la sua caratteristica per quanto riguarda la quantità di dati trasferibili e la segmentazione va a fare proprio quella che è la suddivisione di pacchetti di grandi dimensioni e di dimensioni più piccole, che poi verranno di nuovo riassemblati alla ricezione. Qui c'è anche un problema che dobbiamo dichiarare, perché poi che si parla di routing, e routing non è una cosa statica, cioè non è che il percorso di trasferimento dati tra il dispositivo X e il dispositivo Y rimarrà costante, ma anzi varia dinamicamente, in base al carico, in base alla disponibilità dei nodi di comunicazione. Quello che viene è che i nostri pacchetti, che vengono inviati dall'ortizio all'ortizio, non possono percorrere strade diverse e quindi arrivare anche in tempi diversi al destinatario. Arrivare in tempi diversi vuol dire che l'ordine dei pacchetti può andare a mescolarsi. Quindi in realtà a livello di questo network, di questo layer, cioè il layer IP, bisogna non solo fare la segmentazione e la riformazione del grande pacchetto, ma bisogna anche riordinare i pacchetti, perché possono arrivare in tempi diversi, poiché ogni uno di questi può essere percorrata. E come potete immaginare, questo layer raggiungerà nel suo header, oltre ai diritti, anche informazioni di ordinamento dei pacchetti, cioè ogni pacchetto sarà numerato, così che a ricevente, se arriva per un pacchetto 28, nel pacchetto 32, allora li sappiamo ordinare in maniera di vero. Abbiamo un messaggio. E forse è quello di Calisti, che avevo già visto, ma rimane ancora visualizzato. Però io si l'ho visualizzato. che parlavo di lo nascosto, quando abbiamo introdotto il concetto di Canvia Sensing. Bene, se saliamo ancora, cioè dal layer IP, saliamo verso il layer applicazione, incontriamo il layer di trasporto. Il layer di trasporto che utilizza essenzialmente due protocolli, che sono i più conosciuti, il protocollo TCP, che sta per Transport Control Protocol, e UDP, User Data Non Protocol. E sono due protocolli, ormai storici, ma che ancora persistono, nel senso che non c'è ancora la necessità di sostituirli, perché effettivamente sono molto versatili, e dove non arriva uno, diciamo, superisce l'altro. sapete sicuramente qual è la differenza tra TCP e UDP, il TCP è, si dice, connection oriented, cioè genera appunto la commissione punto punto tramite le socket, e ha la caratteristica di essere sicuro, o meglio, nel senso che il dato viene garantito alla consegna del dato, perché? Perché in caso, appunto, il pacchetto non dovesse arrivare, si scatterà un time out, l'acknowledge non arriva, e quindi la sorgente è inviata, è invitata a ritrasmettere il pacchetto. Questa ritrasmissione vi garantirà, in una certa possibilità, il delivery del dato, ma come potete immaginare, introdurrà un certo delay, perché è chiaro che si basa sul time out di connessione, quindi il time out introdurrà sicuramente un delay, si basa sul fatto che ad ogni pacchetto torni indietro un messaggio che si è detto di acknowledge, e tutto questo sistema che vi permette di avere un protocollo reliable, quindi robusto, ma che introduce un delay, si sposa comunque, si sposa molto bene con alcune applicazioni, ma meno bene con altre. Ad esempio, un classico file transfer protocol, cioè un'applicazione FTP, giustamente user ATCP, perché quando trasferiscono un file da un server verso un client, il file non deve essere corrotto, non deve perdere pezzi, e la latenza in quel caso mi interessa poco. Se devo invece fare uno streaming di un voice over IP, cioè una comunicazione vocale, quella latenza potrebbe in realtà generare dei problemi, perché appunto mentre la persona parla, io la ricevo con una certa latenza e se ci pensiamo bene, a parte la latenza che ci dà un problema sicuramente iniziale, ma anche di interattività con la persona, vi è capitato di parlare ad esempio con un VoIP e avere una grande latenza, avrete visto che non è facile, non è bene. Ma se ci pensate, mentre le due persone che interlociscono parlano, non ha neanche molto senso ritrasmettere un pacchetto passato, FTP dice questo, io ti mando questo frame vocale nella cascata di frame che ti mando, questo l'hai perso, te lo ritrasmetto, ma ormai cosa te lo ritrasmetto a fare per io, io sto andando avanti, sto parlando di altro. È vero, non hai sentito quel piccolo frame, ma se lo ritrasmetto dopo tot milisecondi o quasi anche secondi, non ha più molto senso. Non avendo molto senso, allora, ad esempio, il VoIP, il VoIP over IP funzionerebbe meglio con l'UDP, dove voi sapete che l'UDP invece non è basato su un concetto di connessione e soprattutto non ha la ritrasmissione, cioè non ha l'acknowledge, quindi l'UDP spara il suo stream di pacchetti cercando di fare il suo meglio, se li ricevi, li ricevi, le codifici di quelli che ricevi, e che non le riceverai mai più. Però così la latenza viene abbattuta drasticamente. Quindi, vi dicevo, hanno ragione di esistere entrambi, ma la tecnica tuttora sono i più diffusi. Ad esempio, l'UDP, abbiamo detto, si usa molto bene per le pubblicazioni vocali, mentre ad esempio lo streaming video è basato su TCP. Introduce una latenza iniziale che viene compensata da un buffering e poi, diciamo, mentre fai streaming video, parti con la pubblicazione TCP e in questo caso la latenza iniziale un po' la compensi perché semplicemente tu assisti uno streaming video poco importa se c'è uno sfasamento in quella fase di produzione del video mentre tu ci si è visualizzato. Però, in questo caso, viene garantita la comunicazione. Vabbè, questo era semplicemente per riassumere le caratteristiche fondamentali di questi due protocolli di trasporto, il TCP di ripi, che sono i più diffusi. Se saliamo ancora sopra, quindi, dai due protocolli di trasporto andiamo a livello applicazione e qui abbiamo chiaramente un mare estesissimo di applicazioni perché ogni applicazione può definire il suo protocollo di riferimento informazioni. Tra queste, ricordiamo, le applicazioni che ormai sono standardizzate, nel senso che si sono affermate nell'ecosistema delle comunicazioni digitali e sono ormai diventate degli standard. Ma chiaramente quando nacquero non erano nate essenzialmente con l'idea di diventare degli standard. Quali citiamo? Vabbè, l'HTTP, l'Hyper Transfer Protocol, il protocollo per trasferimento delle mail, l'SMTP, l'altro particolo POP, l'FTP che abbiamo appena detto, il File Transfer Protocol e le Real Time Transfer Protocol che sono transport protocol. Sono appunto delle applicazioni standard ma nulla vieta che noi sopra questo layer facciamo la nostra applicazione che definisca un sistema per trasferire informazioni che lo potete definire anche voi scrivendo il software del server del client useranno lo strato successivo sottostante che è appunto lo strato di trasporto basandosi sul protocollo TCP o UDP. quindi queste sono le applicazioni chiaramente standard ma noi ne abbiamo un mare proprio perché queste sono generate insomma semplicemente lavorando sopra questa struttura. Questo per dirvi che cosa che la struttura è una struttura davvero versatile è una struttura che ormai persiste per decenni è una struttura che ben si sposa con quelle che sono le caratteristiche di differenza dei dispositivi fisici e di differenza delle applicazioni che invece si trovano ad alto livello. Cosa possiamo dire sulla struttura dell'IoT? C'è qualcosa da dire di particolare rispetto a quella che è la struttura classica di internet? Allora se partiamo di nuovo dal basso qui diciamo che a livello fisico abbiamo tante possibilità di concessione la primissima potrebbe essere la wired quindi la concessione su cavo tutta la comunicazione su rete cellulare quindi 3G 4G 5G le reti GSM iniziali sono tutte comunicazioni fisiche i protocolli della famiglia 802 1 802 3 che è appunto l'ethernet l'802 5 l'802 11 che è il wifi quello che tutti noi conosciamo grazie a inter wifi noi access point che abbiamo sono diffusissimi come vi dicevo l'altra volta nell'IoT molti dispositivi di IoT hanno sposato questa tecnologia di comunicazione nonostante sia esagerata per un dispositivo IoT perché chiaramente tutta la banda garantita del wifi non serve a un dispositivo IoT ma semplicemente è stata sposata questa tecnologia per la sua pervasività perché la troviamo in tutte le case una tecnologia più dedicata al mondo IoT era ed è 802 154 che è invece un sistema di connessione wireless low power low range quindi rispetto al wifi molta meno potenza in gioco molta meno energia comunicazioni con distanze più brevi quantità di dati trasferibili molto molto inferiore però dedicata a tutti i dispositivi dispositivi IoT in realtà nasce come sapete per quella che si chiamava personal area network cioè una rente personale dove si immaginava ancora è così si immaginava che vari dispositivi personali cioè che circondassero una persona potessero comunicare tra di loro a distanza di pochi centimetri o qualche metro questo era il progetto di personal area network poi è stato esteso tutte le wireless sensor network ad esempio lavorate lavorate in modo 12154 e come dicevo l'altra volta hanno attuato queste politiche di multi-hook per coprire anche distanze significative di centinaia se non anche chilometri grazie al fatto che nonostante appunto questo protocollo sia un low range facendo multi-hook e saltando da un dispositivo successivo per raggiungere il collettore si possono raggiungere diverse distanze si possono compiere diverse distanze sì esatto più vicino al wifi perché è molto simile al wifi però cala esatto sì non è previsto esatto e in più l'integrazione con l'IPV6 da tutto il logo quello che è chiamato il 6-low-bun che è praticamente l'802-214 con il layer IP attraverso il 128 bit sopra e questo ci dava la possibilità di indicizzare quindi di raggiungere ogni dispositivo personal personal area per cui l'area di contichi questo sistema operativo IoT ha fatto proprio la sua forza nell'integrazione spinta da subito già una decina di anni fa della tecnologia 6-low-bun all'interno dello stack di comunicazione basato su l'802-214 sì la differenza è essenzialmente quella se non ricordo male ad esempio la banda è sui 500 kb al secondo cioè l'802-214 si è davvero poco trasferiamo rispetto all'802-211 però pensate che per fare un invio di un pacchetto sul l'802-214 si spende qualcosa con 40 mA quindi a tre volte cioè è davvero poco se pensiamo quanto spende un access point invece per trasferire un dato dell'802-214 sapete che c'è una differenza pissare no scusate bene salendo cosa possiamo dire ecco possiamo dire che chiaramente si sfrutta la versione anche V6 come abbiamo già detto nel Sysco Pan a livello network quindi quando parliamo di questa enorme quantità di dispositivi nel mondo dell'IoT pensare appunto al fatto che serva un'estensione degli indirizzi P è una cosa banale perché visto il numero si usa comunque a livello di trasporto sia UDP che TCP a livello applicazione ecco ci sono quelli che sono dei protocolli dedicati ai dispositivi IoT degli edge device e su questi concentreremo le prossime lezioni di teoria perché ci interesserà ad esempio vedere come funzionano i protocolli co-op che non so se avete mai sentito nominare è un protocollo per scambio di messaggi per device constrained quindi sta per constrained protocol communication constrained vuol dire per i device che hanno effettivamente poca potenza poca energia poca banda qualcosa di molto simile è l'MTT probabilmente anche questo l'avete sentito nominare è di nuovo uno scambio di messaggi quindi sono protocolli che si basano su messaggistica e in questo caso si parla di message più quindi è un protocollo di messaggi su code che permette lo scambio di nuovo di informazioni piccolissime perché si parla di messaggi davvero di dimensioni ridotte ma in maniera molto vantaggiosa dal punto di vista di nuovo energetico della banda della latenza sono proprio protocolli dedicati al mondo IoT poi permangono i classici protocolli delle applicazioni HTTP SMTP eccetera però noi ci focalizzeremo un po' nelle prossime lezioni su questi protocolli tipici dell'IoT e nelle esercitazioni quando saremo un po' più avanti perché ancora dobbiamo finire la parte di ITB e quando andremo più avanti faremo esercitazioni sia Forest Berry Pie che è un SP 2286 per utilizzare proprio questi protocolli di comunicazione COOP e MBQTT e vedremo quanto tale è semplice inviare dei dati come ad esempio una misura di una temperatura se pensate la misura di una temperatura è un float che viene facilmente trasferito con questi protocolli quindi se abbiamo un sensore che deve mandare una volta al minuto un valore di temperatura non conviene lavorare con uno stack l'applicativo a livello HTTP eccetera ma conviene lavorare con uno sistema ecco vabbè a livello object e data models di nuovo dipende anche qui che livello di dispositivo abbiamo a che fare se considerate di poter lavorare ad esempio con una Raspberry chiaro che essendo a tutti gli effetti un single board computer lavorando su Linux ci possiamo permettere di tutto diversamente se abbiamo a che fare invece con un dispositivo povero 32 bit 16 bit come SP22 allora chiaramente dovremmo tagliare qualche cosa ecco quindi cominciamo a fare una carrellata abbastanza discorsiva di quelle che sono i sistemi wireless di comunicazione dell'IoT perché l'IoT come capite il cablato è un po' un controsenso avere un IoT cablato quindi in realtà il cavo sì lo possiamo usare di nuovo il Raspberry Pi la possiamo collegare al nostro router in maniera cablata però fondamentale nell'IoT è la comunicazione non cablata quindi wireless e cosa ci offre oggi il mondo IoT a livello di comunicazione wireless di nuovo abbiamo comunicazioni che vanno da un range veramente breve 6 lo panni prima il 8215 4 si parla appunto di qualcosa di poco più dei 10 metri o del Bluetooth oppure un raggio medio a circa un chilometro oppure raggio anche lungo più di qualche chilometro quindi abbiamo dei sistemi dedicati pensate anche ponti radio abbiamo la possibilità di raggiungere molte delle distanze molto molto alte e le caratteristiche di range di comunicazione poi in qualche modo influenzano anche sulla banda se abbiamo una comunicazione molto breve o molto lunga ci chiede chiaramente l'energia in gioco andrà ad impattare anche sulla banda di comunicazione sulla latenza sul gitt abbiamo detto sul consumo energetico sulle frequenze in uso se pensate le frequenze wireless non sono tutte aperte tutti gli stati c'è una legge che prevede che alcune frequenze possono essere usate da chiunque in maniera libera e altre invece devi ripagare per poter usare quelle frequenze quindi farà una differenza anche questo il wifi cade su una frequenza libera ecco di nuovo perché il wifi è diventato così diffuso magari altri sistemi lo sono meno perché per potervi lavorare sopra avresti dovuto pagare ecco vediamo questa prima della pausa ma è semplicemente un grafico che riporta il solito spettro e le frequenze abbiamo le frequenze basse le frequenze alte la radio inizia dai 30 kHz in su fino ad arrivare a 100 gigahertz dove abbiamo le frequenze estremamente alte e vedete mobile phone si trovano qua le tv e in base appunto a questa tabella ci sono le frequenze libere e le frequenze licenziate quindi come vi dicevo anche quando si sceglie una banda di frequenza per dispositivo IoT questo è fondamentale perché ecco le bande non licenziate cioè quelle distribuibili da tutti sono ben definite ad esempio la 2.4 gigahertz in tutto il mondo che quella usata dal wifi bluetooth 802 e 12.4 è libera in tutto il mondo poi ci sono altre frequenze 433 megach 68 eccetera e più si alza la frequenza e più possiamo dire una banda elevata più abbassa questo è un motivo fisico perché abbiamo comunque un clock di sincronizzazione più alto più basso e quindi la capacità di trasferire bit più rapida o meno rapida questo non vuol dire che la IoT non usi bande licenziate possiamo tranquillamente incontrare sistemi IoT che si basino su frequenze licenziate ma come potete immaginare avranno un mercato molto particolare sì poi abbiamo delle bande proprio proibite perché in questo caso non si può proprio trasmettere perché sono delle utilizzate dalle agenzie di sorveglianza non si possono fare bene direi che se avete domande facciamo una piccola di parola poi riprendiamo giusto questo non l'ho detto è vero che trasferisce i bit più velocemente però non riesce a girare gli ostacoli non riesce non riesce a superare il muro e quindi se pensate anche il 5G adesso è la rivoluzione si diffonderà ma il 5G la farebbe tantissima l'idea è che non irà a mettere tantissimi ripetitori perché non è che con un ripetitore copre una zona che bastano gli alberi non bloccarlo basta un muro un edificio e quindi non sarà sicuramente semplice bene allora interrompo mettiamo il paolo bene allora riprendiamo quindi stavamo parlando ho ripreso la registrazione stavamo parlando appunto di queste di queste frequenze wireless per comunicare quindi tra dispositivi e abbiamo detto che c'è questa grande distinzione fra le bande a pagamento e le bande invece libere e da questo ne deriva che appunto le tecnologie siano come vedete in questa slide un numero elevatissimo si parla appunto dei tecnologie cellulari quindi 2G 3G 4G eccetera dove hanno un range come vedete qua di diversi chilometri hanno un'alta energia di trasmissione ricezione un costo altrettanto alto anche dovuto dal fatto che bisogna stabilire i contratti per lavorare su queste frequenze poi invece passiamo al 102 154 invece che appunto è nella banda libera però vedete ha un data range di 250 kilobyte al secondo quindi lavoriamo ad una quantità di dati molto bassa che però per l'IoT si parla di un centinaio di metri ma abbiamo un low power consumption un low cost per questi motivi qua il bluetooth un Lora che invece è una tecnologia sempre low power ma long range quindi si parla di chilometri quindi due cinque chilometri con un data molto basso minore di 50 kilobyte però ecco anche questa tecnologia si è fatta abbastanza strada nel mondo dell'IoT proprio per queste caratteristiche di essere low power comunque anche un range molto elevato poi abbiamo il wifi 11f protocollo e abbiamo questo zigbee e zeta wave che sono sempre nella frequenza non licenziate 2.4 giga lo zigbee praticamente non so se avete mai sentito nominare è un protocollo che si basa su 802 15 4 quindi ha tutte le caratteristiche low power low data rate comunicazione attorno ai 100 metri anche se in realtà si lavorava con i 30 50 l'unica cosa è che lo zigbee è proprietario quindi è un protocollo non aperto per il quale bisogna pagare per l'implementante per l'usare però è stato ed è ancora abbastanza diffuso nell'ambito dell'IoT per la sua solidità e la sua diffusione nonostante rispetto all'802 15 4 che è la base questo sia pagamento ma andiamo per ordine parliamo di tecnologie cellulari quindi quello che noi usiamo negli smartphone nell'IoT vanno sicuramente bene per quale motivo perché per il fatto che siano connessioni ad alta distanza quindi sappiamo dispositivi IoT anche remoti dispersi anche in situazioni più o meno semplici o da raggiungere in realtà se utilizziamo tecnologie cellulari godiamo dell'infrastruttura diffusissima sul territorio quindi se vogliamo mettere un nodo di monitoraggio ad esempio sulle nidi delle aquile del furlo come ci arrivo là? ci metto una scheda di SM e ciò sicuramente è la copertura cellulare quindi capite posso fare un monitoraggio remoto e per questo sono sicuramente molto utilizzati di dispositivi spot un po' diffusi lunghe e posso godere del fatto che ho una grandissima un range di connettività molto lungo quindi posso trasferire dati a distanze molto elevate ma soprattutto ho un'infrastruttura diffusissima perché viene utilizzata dalla comunicazione personale attraverso gli smart una banda molto alta che per l'IoT diciamo non è così fondamentale ma i contro quali sono? che costa molto consuma tanta energia e chiaramente non è banale creare un dispositivo che possa lavorare su queste tecnologie il logra come vi dicevo è un'alternativa invece molto appetibile per l'IoT è ancora un long range quindi si parla anche qua di chilometri come vi dicevo prima e diversamente dalla comunicazione cellulare invece è un low power lavora nella banda non licenziata e l'unica cosa diciamo che dobbiamo considerare è che il data rate è molto basso però nell'ambito IoT l'ora si è effettivamente fatto si è fatto avanti proprio per questo motivo l'IoT non ci serve una banda alta IoT in posti remoti hanno bisogno di un lungo un range di comunicazione molto ampio ma possono godere di tutte le caratteristiche low power che l'ora offre e come vi scrivo qua l'ora ha generato una tecnologia chiamata l'ora van che è un protocollo aperto ci dà la possibilità quindi di utilizzare dispositivi di questo tipo e l'architettura prevista da questo sistema è costituita da i edge node che per noi sono i nostri dispositivi IoT dei gateway che fungono proprio da sincronizzatori e da rilancio di queste delle informazioni prese dagli edge node verso quello che è un network server principale che poi praticamente lavora su internet quindi utilizza protocolli TCP IP eccetera e ci permette di lavorare con l'application server quindi se uno volesse lavorare appunto con questo protocollo l'ora quello che deve fare appunto è installare questi gateway questi gateway fungono da rilancio appunto verso il mondo cloud verso il mondo internet ma fungono anche da gestori di comunicazione tra i nodi perché appunto i vari nodi la comunicheranno attraverso uno o più di questi gateway i quali poi sono in grado anche di rilanciare verso altri nodi quindi in realtà i gateway sono proprio dei concentratori e amministratori di comunicazione in questo sistema però ecco la cosa fondamentale è che tra il gateway e il nodo ci possono essere chilometri grazie a questa tecnologia che è aperto ed è low power praticamente quello che vi dicevo di qua la caratteristica di questo sistema è che ogni nodo lavora in singolo hop cioè non è possibile come vi dicevano 802.15.4 ad esempio nell'uvalo sensor network lavorare in multi hop cioè questa tecnologia nasce per fare la comunicazione punto punto dal nodo verso il gateway e viceversa quindi se un nodo volete comunicare con un altro nodo deve passare per il gateway per fare questa soli guadri di comunicazione quindi ricapitolando per i tratti di comunicazione lunga quindi long range abbiamo l'alternativa alla tecnologia cellulare abbiamo questa l'ora che è l'implementazione l'ora one e quella aperta cosa abbiamo invece nell'ambito del medium range cioè del range medio tra i 30 e i 50 metri sotto ai 100 diciamo così è il più diffuso il wifi che si basa sulla famiglia 802.11 che lavora sempre nella banda non licenziata dei 2.4 ai 5 e che lavora tipicamente sui 30 e 50 metri di distanza è chiaro che le caratteristiche dell'802.11 lo conosciamo bene perché ci va a questa diffusione pervasiva in tutte le nostre case grazie alla semplice connettività internet che si basa proprio su access point di questo tipo se scendiamo più in basso cioè nella short range il padrone diciamo così lo standard che si è affermato da anni è l'802.15.4 l'802.15.4 nasce proprio come uno standard per le wireless personal area nel mio avviso prima cioè questi dispositivi che circondano in qualche modo la persona e che sono in grado di comunicare tra di loro punto punto un multi-op si parla di un range massimo attorno ai 10 metri ma in realtà vengono sfruttati anche a 30 50 metri con delle estensioni di potenza ma la caratteristica di questo sistema non è tanto la copertura che quanto il fatto che è dedicato a sistemi low power e low cost low power e low cost basati su microcontrollori ecco vi ho detto tempo fa che qui in università insieme ad altri docenti ho sviluppato un sensore per wireless sensor network basato su 802.15.4 questo sensore che si chiamava virtual sense si basava su un microcontrollore della text instrument che si chiamava msp430 non so se avete mai sentito è una famiglia diffusissima è una famiglia storica di microcontrollori l'ultima versione di questo microcontrollore integrava perché ormai sono diciamo così di sistema in cilio non c'è solamente il microcontrollore integrava al costo di 4 dollari integrava l'MSU la 16 megler la RAM la flash la RAM quella che vi dicevo ferromagnetica in modo tale che non perdesse il contenuto e integrava direttamente il chip di gestione 802.15.4 con tutto il protocollo già implementato dentro l'unica cosa che devi fare per usare questo microcontrollore è metterlo su un PCB e definire un'antenna perché alla fine ti serve un'antenna e un circuito di alimentazione quindi pensate con 4 dollari cosa ci portiamo a casa un sistema che disegnata l'antenna o attaccato di un connettore e un circuito di alimentazione automaticamente vi permette di creare un sistema IoT che lavora con 802.15.4 quindi davvero è stata una rivoluzione per il mondo dei microcontrollori una rivoluzione che però l'ho detto a livello di mercato è stata un po' soppiantata invece da queste famiglie di microcontrollori ESP che vedremo anche nelle esercitazioni che hanno invece sposato direttamente il 802.11 cioè il wifi non per il fatto che siano migliori dal punto di vista energetico o dal punto di vista prestazionale ma essenzialmente per la diffusione del sistema wifi di connessione mentre qua se vuoi lavorare 802.15.4 e a un certo punto i tuoi nodi vogliono comunicare in internet ci serve un gateway ci serve qualcosa che riceva quindi quello che si chiamava all'epoca collettore che riceva le informazioni dai vari nodi le riorganizzi e le spari sul dispositivo che abbia accesso o il wifi o la rete cablata per arrivare a un server mentre con gli ESP tutto questo viene naturale perché sono automaticamente commessi al wifi è stato questo che fondamentalmente ha portato a una grande espansione dei secondi rispetto ai primi questi MSP430 si usano sicuramente nel personal area network cioè se vogliono un dispositivo tipo un contapassi dentro probabilmente ci sarà un MSP430 però ecco nella IoT hanno perso un po' di enfasi per questo motivo perché è un pochino più complicato lavorare in questo sistema poi se devo creare un sistema di monitoraggio infrastrutturale posso tranquillamente dare questo perché posso permettere di creare il mio gateway e il PNC poi nel collegio Raffaello avevamo fatto una rete di testi proprio 802 154 con questi virtual sense che avevo creato dove c'è ancora una scatolina quindi c'è ancora una scatolina attaccata dal muro con una piccola antena però sono stati dismessi non funziona lì dentro c'è un virtual sense che campionava la luta quantità di CO2 qua dentro campionato temperatura umidità la inviava in multi-hoc lungo la parete di fuori eccetera non altri fino ad un collettore che era costruzione alla porta il collettore era server Linux cioè un classico computer Linux che raccoglieva i dati poi gli sparava su internet cosa possiamo dire ecco di questa questa architettura 802 154 beh questa architettura a livello di MacLayer cosa ci garantisce ci garantisce ecco diversi diverse caratteristiche interessanti abbiamo il carrier sensing multiple access e collision avoidance che chiaramente gestisce il canale in questo caso proprio come nel wifi ha delle primitive per gestire la criptografia quindi non è una cosa così semplice delle liste di controllo d'accesso per garantire l'accesso ai nodi e soprattutto questo è fondamentale nell'IoT a questi sistemi di radio duty cycling il radio duty cycling che nasce proprio di MacLayer low power a cosa serve? serve a ridurre il consumo energetico se voi pensate un dispositivo wifi qual è il problema di un dispositivo o mezzo di un dispositivo wireless qual è il suo problema? il problema è che per ricevere informazioni deve in qualche modo stare attivo mentre se devo solo inviare io posso permettermi di accendere il sistema di traduzione solo al lato dell'invio ma se io ammetto di ricevere anche informazioni come faccio? Devo mantenere attivo il sistema facendo in qualche modo il sensing del canale ma se c'è qualcosa lo scarico e lì quello che si chiama l'idol listening è la parte più onerosa dal punto di vista energetico quella che mi ecco infatti lo spesso più dopo quella che mi porta via più energia perché l'idol listening vuol dire io se ho bisogno di ricevere un dato bisogna che faccia il sensing del canale per capire allora se sono una base station cosa me ne frega sono la forrente lì connessa se sono un sistema IoT basato su batteria l'idol listening è quello che mi abbatte la durata della batteria più di tutto perché il listening è comunque oneroso allora non è l'unico problema perché abbiamo il concetto di over hearing cioè cos'è il concetto di over hearing io faccio il sensing del canale e se in questo canale ci sono tanti dispositivi spesso e volentieri io mi trovo a ricevere pacchetti non per me o meglio a vedere passare pacchetti non per me vedo passare un pacchetto e come faccio a capire se è per me devo leggere leader quanto meno di testo di destinazione ma questo energeticamente costa anche leggere semplicemente il preambolo comunque la parte in Italia del pacchetto per capire se è per me costa del tempo costa dell'energia poi è vero che quando ho capito che non è per me posso spegnere il ricevittore per un certo periodo intanto adesso dopo ci saranno i dati del pacchetto quindi a me non fermano però comunque è un costo non banale l'ide listening vi dicevo è questa attesa di ricevere i pacchetti l'altro problema è il concetto di collisioni il concetto di non nascosto che diceva prima al nostro compagno cioè le collisioni nascono anche da questo io invio a un nodo intermedio a valle di questo se un altro nodo che sta inviando lui io quando faccio faccio il senso che non lo sento perché da metro è un po' lontano io invio a lui pensando che il canale sia libero ma anche quest'altro invia inviamo in due è chiaro che lì ci sono collusioni ci sono sistemi per risolvere le collisioni nel senso di pacchetto poi ci sono i codici di controllo per capire se è corrotto la politica se è corrotto lo butto via e magari richiedo una nuova trasmissione però capito dal punto di vista energetico tutto questo non è banale allora come si cerca di risolvere nell'IoT il problema di idle listening che è anche il primo problema che abbiamo elencato allora è essenzialmente il problema più oneroso nel punto di vista energetico e si sono diffuse da tempo due grandi soluzioni protocolli sincronizzati e protocolli non sincronizzati allora i protocolli sincronizzati se pensate sono molto semplici perché ogni nodo si deve svegliare secondo uno schedule c'è una tabella dice ok ti devi svegliare al tredicesimo millisecondo e fare senti del canale perché se qualcosa viene per te io so che la devo mandare in quell'istante ti svegli non c'è niente arrivi subito tu perché tanto tu sai che quella è la tua finestra la finestra del numero 5 è il 28esimo millisecondo dopo del numero 7 il 36esimo millisecondo dopo quindi ognuno di noi sa quando deve attivare il ricevitore magari una volta al minuto attiva il ricevitore esattamente in quell'istante perché chi vuole inviare a me sa che se vuole mandare un messaggio deve mandare in quell'istante e dal punto di vista implementativo il protocollo è banale qual è il problema però il problema è che tutti i nodi devono avere la nozione del tempo sincronizzata al millisecondo secondo di più questo è complicato perché è complicato perché o io ammetto che sul dispositivo low power ci sia un orologio molto preciso che però costa soldi perché oppure devo generare un sistema continuo meglio periodico di risincronizzazione degli orologi diciamo metto in un dispositivo un orologio che costa poco ma io gestore della rete periodicamente devo aggiornare gli orologi altrimenti questi vanno alla deriva e se perdono qualche millisecondo non ci capiamo più niente e questi protocolli sincronizzati vi dico da subito sono quelli un po' meno diffusi perché si basano proprio su un hardware dedicato quindi un orologio di sistema ben preciso oppure un grande overhead di risincronizzazione che hanno un overhead cosa vuol dire pensate se ogni minuto io devo risincronizzare gli orologi ho dieci dispositivi probabilmente io devo cominciare a mandare dieci messaggi broadcast a tutti per fare in modo che questi li ricevano dicendo l'ora è questa l'ora è questa devo fare saturando il canale e quindi sprecando tanta energia e sprecando diciamo così tempo e denaro l'alternativa qual è? l'alternativa sono dei protocolli asincroni invece che sono protocolli che dicono gli orologi fanno schifo quindi ogni dispositivo ha un orologio suo non sincronizzato con gli altri quindi può avere la necessità di fare un wake up inviare o ricevere in qualsiasi stante ci può risolvere con un protocollo il problema dell'i-del-listering vediamo che cosa si fa allora il concetto di radio duty cycling spero sia semplice da capire i sistemi radio duty cycling dicono per risparmiare energia non posso tenere il ricevitore sempre acceso lo devo spegnere e accendere periodicamente è chiaro che io più la fase di down è lunga e più energia risparmio soprattutto la fase di down considerate che i nostri microcontrollori possono sfruttare come dicevo l'altra volta stadi di consumo energetico davvero bassi perché lì possono proprio andare in ibernazione e risvegliarsi con un internet l'esempio di prima il radio duty cycling protocol sincrono se io ho un orologio perfettamente efficiente che non perde i millisecondi genero un internet ogni tot tempo ogni volta che io so che mi devo svegliare mi sveglio c'è il pacchetto no non c'è ma vado a dormire consumo pochissimo solo in quella fase ma purtroppo abbiamo detto nei dispositivi IoT spesso questo non c'è però il radio duty cycling è necessario per risparmiare l'energia infatti è uno dei meccanismi più usati per questo motivo chiaramente introduce anche una latenza nella trasmissione dei pacchetti ma ricordiamoci che siamo a livello IoT quindi non abbiamo la necessità di trasferire grandi quantità di dati come funzione di protocolli sincroni i protocolli sincroni hanno uno schermo completo diciamo ogni nodo sa quando si deve svegliare semplicemente si svegliano esattamente nel momento in cui il sender invierà il pacchetto perché è codificato nel protocollo all'x sesimo millisecondo io invierò tu in quel millisecondo ti devi svegliare se vuoi il pacchetto ti svegli il pacchetto c'è bene se non c'è lo spegni subito il recepitore hai consumato pochissimo e questi sistemi hanno quindi uno slip periodico non hanno un idle listening perché il listening è relativo solo al momento in cui probabilmente ci sarà un pacchetto se c'è questo idle listening è comunque molto molto breve protocolli più diffusi di questo tipo sono gli SMEC e il TMEK sono molto diffusi in letteratura se fate una ricerca su google le trovate x varianti sono davvero diffusissimi e questi protocolli SMEC e TMEK di nuovo li trovate già implementati in contichi io faccio molta pubblicità a questo contichi perché è il sistema vi dicevo open tutto scritto in linguaggio C diffusissimo sulla maggior parte dei microcontrollori di oggi lavora con 802 154 e ha già implementati tanti di questi protocolli ad esempio l'SMEC e il TMEK per funzionare dovete avere però un dispositivo con uno slovo di sistema che non va dalla deriva che è un slovo di sistema non banale sull'SP2286 questi protocolli non sono consigliati perché il loro l'osio che ha già l'SP interno invece ha una buona deriva e quindi non funzionerebbe qual è l'alternativa? i protocolli asincroni i protocolli asincroni più di cui sono il B-MEC e l'XMEC anche questi li trovate su contichi dove ogni nodo si sveglia per conto suo vedete il nodo N1 si è svegliato qua e va in listening il nodo N2 si è svegliato qua il nodo N3 si è sveglia qua e il sender potrebbe iniziare a inviare qui come facciamo a congiungare questa cosa visto che ognuno si sveglia per conto suo totalmente sincronizzato non è banale per poter lavorare questi sistemi si basano su tecnologie di carrier sensing e praticamente quello che vanno a fare è inviare quando si svegliano un short piccolo preambolo non inviano il dato inviano un piccolo preambolo ripetuto dicendo io ho bisogno di inviare e normalmente in questo preambolo ci scrivono l'indirizzo di destinazione cosa vuol dire io ho bisogno di inviare il nodo 5 e comincio a mandare questi piccoli glitch devo inviare il nodo 5 devo inviare il nodo 5 io che invio devo inviare il nodo 5 quando il nodo 5 si sveglierà probabilmente sentirà questa cosa appena il nodo 5 sente devo inviare il nodo 5 allora comincia a mettersi in ascolto per ricevere il pacchetto anche il nodo 6 si svende per i cavoli suoi se sente devo inviare il nodo 5 si spegne subito perché dice fra un po' arriverà il pacchetto per i nodo 5 se il nodo 7 si sveglia e non sente niente va subito di nuovo a dormire perché la politica è quella di dire se io devo inviare prima bisogna chiamarlo dei preamboli e questi preamboli sono ripetuti perché sono ripetuti perché devono coprire il tempo del sveglio io non saprò esattamente come sono sincronizzato con il ricevitore quindi se so che il ricevitore si sveglia ogni 500 di secondi io devo mandare questi preamboli per almeno 500 di secondi per poterlo beccare sveglio perché altrimenti ho la probabilità di non beccarlo mai sveglio quindi spostiamo un po' il consumo energetico sul trasmettitore perché il trasmettitore si fa carico di mandare questi preamboli per un tempo abbastanza lungo l'idea è appunto ogni nodo si sveglia ogni 500 di secondi e io devo coprire i 500 di secondi se voglio inviare con tutti questi preamboli e quello che succede ecco vedete qua questo è l'XMAC l'XMAC prevede che il sender cominci a martellare il canale con questi piccoli preamboli ripetuti invio invio invio nel preambolo cosa c'è? c'è l'indirizzo di destinazione il ricevitore che anche lui ha installato l'XMAC a un certo punto si sveglia ma si sveglia per i cavoli suoi lui si sveglia dove c'è questa freccia una volta che lui si sveglia si mette in ascolto per i preamboli tutti si mettono in ascolto per i preamboli quando intercetta questo preambolo qua perché lui si è svegliato nel preambolo trova il suo indirizzo manda subito un acknowledge al preambolo l'acknowledge viene ricevuto dal sender il sender smette di mandare preamboli perché dice ok il mio destinatario sveglio e mi ha detto che è pronto ricevere il dato e quindi cosa fa il sender manda il dato il dato viene ricevuto e poi si spegne sia il sender che il receiver si spegnono entrambi questo è ciò che accade fra proprio il nodo sender e il nodo receiver se ci fosse stato qua sotto un terzo nodo che anche lui ha percepito il preambolo ma l'ha percepito qua ma visto che non matcha l'indirizzo di destinazione con il proprio indirizzo ha spento subito il trasmettitore perché tanto dice presto ci sarà un pacchetto ma non è per me se il pacchetto invece ha come destinazione la tua o broadcast allora rimane acceso anche lui e comincia a ricevere il pacchetto quindi questo sistema è un sistema di appunto di flexi cioè dove il preambolo viene ripetuto tante volte che sposta un po' il consumo energetico sul trasmettitore perché il trasmettitore a questo punto mi consuma di più da una parte è anche giusto perché tutti i ricevitori si svediano periodicamente cercando il preambolo e poi vanno subito a dormire tu che devi trasmettere un dato solo nel momento in cui trasmetti consumerai un po' di più però appunto il consumo è tuo mentre tutti gli altri risparliano un sacco di energie e questo sistema funziona bene appunto se i preamboli sono brevi la parte di listening del ricevitore breve quindi lui ascolta questo preambolo appena lo trova va giù oppure rimane acceso e una normalmente nel preambolo ci sta all'inglese di destinazione ma una variante che è stata molto diffusa soprattutto in un protocollo un MEC che si chiama Contiki MEC perché è un protocollo proprio proprietario dei Contiki proprietario si fa per dire nel senso che è aperto anche quello ha fatto una piccola variante a questi protocolli basati sui preamboli perché invece di mandare il preambolo che contiene normalmente informazioni di destinatario siccome l'802.154 definisce il pacchetto molto piccolo sono 128 byte invece di inviare il preambolo e poi il pacchetto io mando tante volte il pacchetto così chi lo riceve lo becca subito non ha bisogno di questa seconda fase di send data e receive data esatto quindi mando subito il pacchetto chiacchieramente è leader è destinatario destinatario è dei pacchetti per me i preamboli sono i pacchetti quindi cosa succede? succede che chi si sveglia e fa listening legge vede questo pacchetto che è brevissimo quindi poco più di un preambolo legge il leader il destinatario se per sé lo prende manda l'acknowledge e si spegne se non è per sé si spegne immediatamente e quindi ha risparmiato ancora un po' di energia perché invece di fare preambolo preambolo preambolo ho ricevuto il preambolo allora dammi il dato ho consumato energia per ricevere il preambolo invece io mando subito il pacchetto ripetuto tante volte e io dico ho ricevuto il pacchetto ok io e te abbiamo chiuso spegniamo entrambi gli altri appena ricevono un pacchetto non per sé spegnono quindi ha avuto comunque un risparmio energetico nel quadrato e questi sistemi vi dicevo sono usadissimi nelle reti 802-154 perché spesso e volentieri questi dispositivi hanno una batteria o comunque hanno una fonte rinnovabile hanno energia contata e quindi questi sistemi di radio duty cycling sono effettivamente molto utili e versatili e come vi dicevo ai sistemi sincroni basati su un orologio che non abbia una deriva che non abbia un errore si preferiscono ai sistemi asincroni con questi accorgimenti di lanciare dei preamboli per far sì che effettivamente non necessiti un hardware dedicato su questi sistemi radio duty cycle 802-154 è nato ormai da tempo la lo pan cioè si definiscono qua sopra gli IP a 128 bit quindi come vi dicevo è possibile indicizzare ognuno di questi dispositivi della rete essendo 802-154 ci vuole un Google Gateway se lo voglio raggiungere da una rete di CPP ma da una rete di più alto livello però il Gateway ha la capacità di instradare i pacchetti quindi fa anche il routing su uno di questi dispositivi poi il Gateway fa anche di più se andiamo a vedere dal punto di vista tecnico perché se il Gateway fa Gateway verso 38 dispositivi non ha bisogno di usare indirizzi a 128 bit quindi in realtà fa una rimappatura di questi indirizzi quindi è vero che al Gateway arriverà una richiesta per indirizzo a 128 bit ma il Gateway fa una rimappatura tanto sa lui i nodi che si sono registrati sul Gateway quindi rimappa senza dover sovraccaricare la rete 12154 di tanti bit solo per il leader dell'indirizzo quindi il Gateway fa anche una rimappatura di questo tipo perché è improbabile che un Gateway abbia un numero elevato di dispositivi registrati di tipo 12154 vediamo cosa dicevo qua quindi va bene la stessa cosa è perfetto ecco infatti qua vedete questo è lo Stexis Lopan vedete qua sopra quando lo Stexis Lopan si appoggia su 128 bit 154 c'è un Adaptation Layer questo Adaptation Layer è quello che dicevo che fa anche rimappatura degli indirizzi perché tra questo e quello sotto c'è un Gateway cioè c'è un Gateway che riceve dei pacchetti da una rete internet le deve instradare verso una sottorete Six Lopan questo Adaptation Layer fa sia routing perché l'Auto 12154 può comunque essere multi-hawk ma soprattutto va a fare questo adattamento cioè riduzione del leader per mappare gli indirizzi a 128 bit su indirizzi chiaramente numericamente più corti perché tanto non abbiamo la necessità di indicitare tutti questi dispositivi all'interno di quella sottorete bene e qui ci sono un po' di altre informazioni che diciamo appunto questo Adaptation Layer fa appunto l'incapsulamento dei pacchetti vedete either and address compression c'è anche il concetto di compressione short addressing perché chiaramente come vi dicevo prima abbiamo dei nodi un numero di nodi ridotto farà sicuramente segmentazione e riassemblamento dei pacchetti perché 802 154 ha un panchetto di 128 bit quindi qualsiasi cosa arrivi di maggiore di 128 bit deve essere frammentato e poi ricostruito questo è il fuoco di bene e qua ecco c'è un esempio classico di una rete 6 lopan come vedete abbiamo i nostri nomi che si dicono 802 154 in finito di configurazione i pv6 abbiamo da qualche parte un gateway o router o edge chiamiamolo quando vogliamo che si connette poi invece alla vera rete internet e qua abbiamo tutto il routing per arrivare a destinazione abbiamo la compressione dei dati la frammentazione e il riassembramento abbiamo la rimappatura degli indirizzi quindi diciamo questo router qua fa davvero tanto questa era proprio la rete che noi usavamo mi dicevo qui nel collega Raffaello per misurare queste grandezze perché erano questi nodi che non lavoravano in syslopan non lavoravano semplicemente 802 154 avevamo un gateway che era un serverino Linux che poi mandava all'epoca i dati su Google Cloud per visualizzare e graficare in tempo reale il contenuto di CO2 umidità e temperatura quindi ciò che facevamo era proprio di questo tipo questo potrebbe essere anche il nostro progetto d'esame se volete usare VirtualSense vi posso dare una trentina di tutti VirtualSense che sono 2,15,4 e gateway può essere tranquillamente un Raspberry Pi e quindi lavorare in questo modo il VirtualSense vi dicevo che è il nostro nuovo programmabile sia in Java che contando con Tiki con tutte le primitive del sito operativo con Tiki che vi ricordo più che un sistema operativo è un framework ad eventi per la programmazione non è un vero proprio sistema operativo ma ha la possibilità di gestire anche una sorta di multitasking edulando eventi in maniera appropriata io finirei qua per oggi se avete qualche domanda altrimenti ci riaggiorniamo invece per martedì dove faremo un'altra esercitazione con Raspberry Pi SenseApp InfluDB però la differenza rispetto alla esercitazione che abbiamo fatto l'ultima volta in cui abbiamo usato le API Python di InfluDB vi ricordate che abbiamo portato tutte le librerie Python faremo invece un esercizio che alla fine il risultato sarà lo stesso ma non userà le librerie Python ma userà questo plugin Telegraph che vi ho detto che è il compagno cioè il compagno proprio di InfluDB plugin Telegraph che si trova per qualsiasi piattaforma quindi impareremo ad usare il plugin Telegraph senza dover scrivere in Python un codice dedicato a InfluDB nel senso che noi potremmo avere la necessità di campionare qualsiasi tipo di informazione proveniente da qualsiasi tipo di applicazione processo che gira sopra la Raspberry ma lo vogliamo spedire su InfluDB quindi senza usare il Python tra virgolette perché questo Telegraph è proprio la via preferita di InfluDB che è il plugin che si trova per tutte le architetture perfetto domanda sì disponibile bandwidth Sì. Ok. L'importante però deve... Sì. Certo. Però la portante deve avere una capacità di wake up del dispositivo. Esatto. Tipo... Sì. Una sorta di wake on land, insomma, o cosa del genere. Tu dici che... Sì, sì. Sì, sì. Hai perfettamente ragione e l'idea qual è di usare un sistema di wake up che il cui listening sia meno costoso del listening come i file, perché alla fine l'idea listening è quello, no? Dio. Salve. Sì. Sì. Sì. Sì. Sì. Sì. Forse c'è lui adesso. Sì, ho finito. Ecco, comunque... Ma mancano... Niente, niente. Sì. Hai completamente ragione, ti dicevo, tant'è che l'idea è quella di usare un canale di wake up il cui listening costoso. un po'. Perché alla fine tu hai bisogno di... Sì. Sì. Sì. Sì. Mi pare sempre... No, mi pare sempre di un apportante wireless. Va bene? Un apportante wireless che a un certo punto la invio... Sì. Sì, sì. Sì. Sì, sì. Esatto. Ti sto facendo questa risposta perché ho la cosa che ho fatto, ma non è un po' e poi non è un po' che ha un po' che ha un po' che ha un po' di usare un po' che ha un po' che ha un po' di usare un po' che ha un po'. Esatto. Adesso ti sto facendo questo risposto perché ho lavorato per tempo su questi aspetti e ad esempio a Bologna facevano proprio qualcosa di questo tipo, un ricevitore passivo di una frequenza wireless. Quando la frequenza arrivava andava a caricare un mini condensatore e faceva scattare un internet e si svegliava il sistema. Funzionava. Infatti ci parlava di listening o meglio di consumi di micro watt addirittura. per stare in history. Io avevo sperimentato invece con Bogliolo e gli altri un sistema totalmente passivo basato sugli ultrasuoni, quindi l'importante era l'ultrasuono. Quindi tu avevi un ricevitore di ultrasuoni totalmente passivo, anche questo sarebbe un rispondatore, quando entrava in risonanza si caricava il condensatore, quando il condensatore arrivava a un certo livello c'era un circuito di attivazione che faceva partire un intrap e nel processore ci svegliamo. E questo funzionava benissimo perché era totalmente passivo, dopo il trasuono c'era un problema della direzionalità, un pochino il problema dei disturbi, dell'intervento, però ci ho pubblicato qualche lavoro in questo modo, perché a quel punto tu dicevi io adesso devo trasmettere a te, ti bombardo l'ultrasuono prima e tu a un certo punto ti svegli, rimandi un messaggio di un back knowledge di resveglio e io a quel punto ti faccio il capo e tu rispetti. Questo funziona benissimo, sì, ti devo mandare un dato di ora, tu stai un'ora spento e non consumi niente, poi ti bombardo gli ultrasuoni, tu ti svegli, partire un messaggio e ti spegni. Funzionava. A Bologna i nostri colleghi in ingegneria invece hanno fatto questa cosa usando sempre una portante wifi, scusa la wireless con frequenza diversa da 8154, anche lì c'era un sistema che caricava il condensatore lentamente perché se la vuoi fare... Esatto, dovevi insomma creare... L'idea fondamentale è se è totalmente passivo il ricevitore è un buon vantaggio, perché dici appunto questi sistemi che sono qualcosa di energy scavenging, cioè cerco di acquisire l'energia dalla portante wireless e quando l'energia è tale da far scattare un circuito di boot, allora mi partiva l'intrunt e mi partiva il produttore. Se fai una cosa attiva è meno interessante, tu dici io trasmetto il processo di 154, ma ho anche un ricevitore a 33 MHz che consuma veramente poco, però è meno divertente. Cioè era meno interessante perché diceva comunque, se ne aveva acceso il ricevitore un po' consumo per questo, era consumo di meno però era più interessante all'epoca lavorare sulle cose totalmente passive. Si chiamavano sistemi di triggering, non per svegliare gli dispositivi. che si chiamavano sistemi di utilizzare un po' consumo per questo, è un po' consumo per questo.