non usiamo la piattaforma arduino oggi con SP ma usiamo il sistema operativo realtime ad eventi che è FreeRTOS quindi siamo un po' l'equivalente delle esercizioni che abbiamo fatto l'altra volta con arduino però lavoreremo con questa piattaforma la piattaforma la troviamo sempre installata all'interno della nostra macchina virtuale con un window che adesso io vado a lanciare si windows poi bmware e poi studente e prova con un diurgo 2021 entra prova studente e studente non mi ricordo mai se è ospite o studente quale di cui dovete lavorare? perché non ti faccio mai scuola? come è che lo faccio? no dovevi andare? qual è l'altro 5? è la ospite? no prova ospite un'unico 2021 è la aspa ospite ospite? grazie grazie grazie grazie grazie grazie non auto sta e buon lo allora studente la faccia del studente unico quindi fai tutto slash studenti in modo tale che sia locale punto backslash esatto la passo di questo qui è IoT sì perché l'IoT è il oh adesso ci siamo benissimo allora adesso quello che possiamo fare è collegare il sito appare la porta usb e poi fa sì che la macchina virtuale ecco lo colleghi sul IoT machine non sull'host deve essere utilizzato da dentro lì ok bene così ce l'abbiamo internamente collegato apriamo il terminale per vedere se Linux ha riconosciuto l'esp potete scrivere dmessage l'avete mai usato il comando dmessage per vedere il kernel che messaggio vi ha fornito sono i messaggi del kernel quindi dmessage fate invio mi fa vedere gli ultimi messaggi del kernel e vedete gli ultimi messaggi del kernel da me dice che c'è stato usb 2.2 new full speed USB device e alla fine dice prodotto cp2102 usb 2 watt bridge controller quindi ha riconosciuto il convertitore da usb a uatt che è il quindi da queste da queste scritte da capire che effettivamente è stato connesso e riconosciuto cp210x convertitore da usb 0 quindi su tt più cp0 abbiamo il nostro divagio ok allora andiamo a vedere come cosa abbiamo dentro questa piattaforma passando un ls abbiamo arduino che appunto contiene la piattaforma passando la volta del documenti da un ls abbiamo sp andiamo dentro che sp quindi la sp effettivamente contiene sp 8266 rt os sdk che praticamente è l'ambiente di sviluppo che contiene il sistema operativo real time appunto free rt os quindi andiamo a fare un altro cd dentro sp 62 66 eccetera e ora siamo nella rt diciamo così della piattaforma ma la piattaforma non ha un editor grafico è una piattaforma diciamo così molto di basso livello tutto il rt os scritto in linguaggio g è un po di asse quindi siamo in un sistema davvero performante quindi cambia un po il paradigma no in arduino diciamo più a livello di didattica di diciamo così di fare le cose veloci intuitive semplici almeno performanti questo in realtà è un vero e proprio sistema operativo dedicato a questi device e può sfruttare tutte le peculiarità di questi device è chiaro che se vi troverete mai a fare una spiegazione che dovrà andare in produzione normalmente ci usano questi strumenti non si usa arduino quindi la stessa diciamo ditta sonora che usa all'interno di tutti i suoi device ls qui quindi il 262 86 usa questa piattaforma al suo interno perché è una piattaforma molto più stabile molto più rigida e molto più facile da debaggare e da gestire arduino diciamo così è più rapido più immediato lo vedremo nel codice è diverso si lavora tutto da via di comando che si lavora con un editor di test per scrivere file riguardo c e due gvim o nano quello che preferite e poi la compilazione l'esecuzione eccetera si fa tutto col comando make un po come avviene tanto in tutte le architetture di basso livello allora cosa contiene questa questa ruta contiene degli script export install vedete e poi intiene delle directory examples che contiene degli esempi preformatati components che contiene le librerie dei componenti hardware che costituiscono questa piattaforma questa è la versione rtos già portata per esp8266 poi quando scaricate rtos chiaramente lo scaricate per la famiglia di dispositivi che avete in questo caso ho scaricato e installato esattamente solo rtos per esp8266 e poi abbiamo la directory tools che contiene il cross compilatore e il cross compilatore perché perché compileremo con un gcc ma produrremo codice per una piattaforma esp8266 quindi con le sue caratteristiche bene allora la prima cosa da fare per far sì che la piattaforma possa funzionare è lanciare lo script export.sh allora gli script sh sono scritto dash possono essere eseguiti in due modalità se lo eseguo semplicemente . slash export.sh questo script viene eseguito in un ambiente locale e l'ambiente una volta eseguito viene distrutto in realtà a noi lo script export.sh serve non tanto per fare delle operazioni attive ma semplicemente per settare le variabili di ambiente quindi non lo possiamo eseguire con . slash perché se lo eseguiamo con . slash apre un nuovo ambiente setta le variabili esce e quell'ambiente se ne va e quindi le variabili non rimangono settate nella scelta su cui stiamo lavorando ecco quindi che ci bisogna usare il comando source source vuol dire eseguiti lo script in questa shell e non chiuderla quindi vuol dire che l'effetto del comando source su export.sh farà sì che le variabili ambienti verranno settate in questa shell quindi questo lo dobbiamo fare vedete una volta che abbiamo scritto source export.sh allora vedete che la piattaforma comincia ad aggiungere le directory nel path vedete ummyut spcomponent eccetera e alla fine vi dice fatto you can now compile sp82 project adesso lo puoi compilare questo bisogna ricordarsi di farlo ogni volta insomma che si vogliono che ci fa lo in della piattaforma e si vuole lavorare con questo sistema quindi ciò che abbiamo fatto è appunto eseguire lo script con source non con . slash per avere l'effetto sulle variabili ambienti quindi ora la nostra piattaforma on-medion, la nostra SDK è pronta per compilare eventuali esempi eccetera allora cosa facciamo? andiamo da un'occhiata alla directory esempi quindi facciamo cd example e dentro facciamo ls ecco c'è parecchia roba perché ci sono common components, dht, get started, length and button, referral, protocol, proviso ci sono tutti esempi relativi a queste diciamo così prime informazioni ad esempio se noi andiamo su cd periferal e poi facciamo di nuovo ls dentro trovate delle sottotirette che contengono esempi ad esempio adc quindi adc per utilizzare adcdsp general parto gimpotout un esempio per general parto gimpotout un esempio per l'hardware timer per i quattro cd quadro s cioè tutte le periferiche esp hanno il proprio esempio quindi in base al task che dovete sviluppare andrete a scegliere magari un esempio di partenza per poi modificare non si parte mai da zero, no? deve scrivere il codice per queste arbitetture c'è la UART, la SPI OLED, SPI eccetera facciamo un passo indietro se andiamo su wifi ricordiamoci che è SPA, un chip wifi vedete facciamo un ls dentro ci sono diciamo diverse sottodirectorie che contengono diverse informazioni ci sono diversi esempi dedicati ad esempio a fare uno sniffer a fare il WPA2 Enterprise a fare lo scambio di password, PowerSafe che sono tanti esempi che potremmo utilizzare e andiamo anche in storage dentro storage vedete che abbiamo un file system, PIPs che viene gestito da questo esempio se andiamo su protocol protocolli sono tutti i protocolli di connessione vedete c'è la pratica Soccer, OpenSSL, MQTT che vedremo nelle proprie lezioni di teoria vedremo questi protocolli di scambio di messaggi Coop è un altro protocollo di scambio di messaggi sono tutti i protocolli dedicati alle piattaforme IoT molto diciamo così, Low Power, Low Resource e poi comunque c'è anche il protocollo HTTP sia server che Bryant ci sono già i tempi implementati quindi sarà facile volendo anche creare un server sotto il nostro ESP un server HTTP andando a vedere in qualche modo questi esempi noi adesso partiamo da zero quindi torniamo indietro andiamo su get started cd get started e facciamo ls e c'è solamente un progetto dentro get started che è il più semplice che ci possa immaginare Hello World quindi facciamo un altro cd su Hello World e facciamo ls allora intanto capiamo come fa un progetto in FreeCart.OS un progetto è una directory in questo caso il progetto è la directory Hello World che al suo interno contiene un po' di informazioni c'è un ritmi vabbè che è stato messo qui se ci facciamo un gvim di ritmi o un nano di ritmi ecco qui mi dice che questo è appunto il primo task più semplice che è un Hello World chiaramente il ritmi non è funzionante poi c'è sdconfig sdconfig bold che sono dei file di configurazione dellsdk siccome io questa piattaforma poi ho fatto dei test gli sdconfig sono già prodotti li andiamo a cancellare un attimo facciamo rm sdconfig perché voglio fare vedere come inizia da zero un progetto quindi facciamo la rimozione di sdconfig e sdconfig bold che è un progetto in realtà a parte ritmi che come potete immaginare è stato aggiunto per spiegazione in realtà un progetto vergine vuoto avrà solamente un make file andiamo a fare anche rm dcm make list che anche questo è un file prodotto durante la compilazione lo rimuoviamo facciamo anche un rm-rf di build che era directory build ecco come ci presenteremo un progetto vuoto appena creato un make file la directory main andiamo a vedere dentro la directory main cosa c'è dentro la directory main c'è il codice sorgente e infatti qua dentro ci deve essere un file.c anche qui rimuoviamoci make list un file.c in questo caso lworld main e ci deve essere un component .mk il component .mk è un file di make che serve a dire al compilatore guarda che hello world main deve essere compilato andiamo a vedere cosa c'è scritto dentro component .mk praticamente c'è scritto niente perché questa la sola presenza del file dentro la directory main serve a far capire allo script di make che questo file va compilato quindi in realtà qui dentro non c'è niente però il file ci deve essere altrimenti quel quale viene compilato ok quindi ricapitolando con un attimo faccio un deck allora un progetto real us si presenterà così si presenterà con una directory il nome della directory che potete scegliere voi qualsiasi nome vi piaccia in questo caso hello world il nome della directory dentro la directory ci deve essere un main file e una directory main la directory main deve contenere i file.c e un file component .mk ecco il progetto come deve essere fatto andiamo a vedere il make file cosa contiene il make file un'altra volta è un molto semplice perché contiene il project name anche questo lo potete scegliere voi e la riga di inclusione dei make file della piattaforma che non deve essere mai modificata l'unica cosa che potete modificare del mondo nome del progetto l'unica ok ma adesso se ci siete tutti si parla di tutti anche tu quindi adesso impariamo i comandi di questa piattaforma allora il comando classico make porterà alla compilazione del progetto quindi se siamo dentro la directory per il loro work scriviamo make invio parte la compilazione del progetto la compilazione del progetto che è più salto che banale perché ogni volta viene compilato non solo ehm ho ridotto ho ridotto come è stato un'altra parte si doveva partire da i detrografici ma è perché a me non è partito perché mi dice che sono poche colonne perché ho fatto un contro il meno scusate lo rifaccio deve partire l'editor grafico a voi è partito? non è parte un po' la cosa che è forse è una cosa si no aspettate io non capisco per me non sia partito da me vediamo cosa fa mi ha dato un errore prima perché non ho capito questo senso adesso lo facciamo un attimo arrivare in fondo allora l'editor grafico serve a creare quel file di config che vi ho fatto togliere che vi ho fatto cancellare prima quindi si creano solo la prima volta che uno esegue aspettate un attimo lo faccio arrivare in fondo e poi li ricancello eh sta compilando tutto il sistema operativo il sistema operativo è frigo è ogni volta lo ricompila tutto era nella direzione di qui in basso? ehm ehm io sono andata con me si ero già andata con me si ero già andata con me quindi quindi se non è un progetto nuovo deve compilare tutto il sistema operativo e poi alla fine compilerà il file unico nostro esatto esatto allora un attimo che rimuovo il di confidio faccio make clean ok adesso faccio make di nuovo e mi dovrei trovare e porca poi perché non mi fa l'atti scusate make clean rm cd con fig ok comunque vediamo un po' così no non è una cosa ecco vi dovete trovare questa condizione la prima volta che eseguite all'interno di un nuovo progetto bisogna configurare la piattaforma allora la piattaforma è tanta roba adesso esploriamo un po' cosa vuol dire configurare la piattaforma possiamo anche semplicemente dargli il default e questo è quello che faremo adesso in questo caso ma vi faccio vedere quante opzioni possiamo scegliere per questo sistema operativo allora qui vedete sono delle opzioni di primo livello sdk tool configuration l'upload configuration serial flasher config partition table compiler options c'è parecchia roba andiamo a vedere ad esempio sdk tool configuration vedete che è da selezionato select facciamo invio e qui ci dice semplicemente quale sono le il compiler tool chain e l'interprete python possiamo anche diciamo così selezionare la terza opzione ma non ci interessa facciamo edit poi andiamo su bootloader configuration anche qui il bootloader configuration ci dice il bootloader che cos'è è del micro codice che serve per fare il boot alla micro security di questo progetto qua e qui c'è selezionato bootloader init fpi flash cioè parte il bootloader leggendo la flash su cui sdk tool configuration lasciamolo invariato diciamo exit serial flasher config ci dice qual è la porta sul quale andrà ad utilizzare per fare il flashing della memoria e la default serial port è devc y usb0 va bene perché vi ricordate linux aveva detto che il reviter è stato caricato proprio su questa porta qua quindi non la andiamo a modificare ci sono altre opzioni di utilizzare un upload compresso la frequenza eccetera vedete c'è tanta roba che possiamo selezionare lasciamola tranquillamente in questo modo compiler option anche qua ci dice il livello di ottimizzazione del compilatore che può essere modificato component config e qui c'è davvero il mondo vedete con prezzi un pic c'è tantissima roba perché qua posso andare a scegliere se includere dei componenti predefiniti ad esempio il corpo è un protocollo di comunicazione basato sui messaggi per device constrained quindi device quando ha bassa energia bassa memoria se la vogliamo abilitare se vogliamo abilitare power management il wifi chi sono tutte le porte fisiche se ci clicchiamo sopra anche qua possiamo andare a dire di calibrare le nostre periferiche utilizzare power massimo per il wifi c'è tanta roba sono iniziatelo in exit vedete esp-hp client eccetera c'è tanta roba che potremmo chiaramente se avremo la necessità andare a modificare non facciamo niente di tutto questo quindi facciamo fare subito un exit da qui un altro exit un save scusate della directory root ok e poi exit a questo punto il menu config è stato creato l'abbiamo lasciato tutto di default non abbiamo avuto la necessità di modificare nulla ora che il menu config è stato creato parte la vera e propria compilazione quella che prima da me era già partita parte per andare a produrre un unico eseguibile perché viene da sé che in un sistema amc come questo la vostra applicazione sia staticamente linkata all'interno del sistema operativo quindi in realtà verrà prodotto un unico file eseguibile che si chiama immagine questa immagine contiene tutte le biblioteche operativo utilizzate più la vostra applicazione in un unico file che verrà flashato sopra il dispositivo il sistema operativo viene ricompilato solo la prima volta adesso se non facciamo un mail clean tutta questa procedura andrà molto più veloce le volte successive su questo progetto perché il sistema operativo vedete viene compilato una volta sola adesso sta andando avanti vedete che sta compilando tutte le estensioni del sistema operativo vedete il pubblico applicato ok e a questo punto è andato a molti vedete è arrivato in fondo non ha prodotto errori e a un certo punto dice to flash all build out run make flash perché adesso ha prodotto l'eseguibile nella direzione locale ora la dobbiamo caricare da sopra questo eseguibile e per caricare dobbiamo fare make flash quindi la seconda parola dopo make è flash per dire ok adesso che hai compilato flasha chiamiamo invio make flash contatta la porta dev ttysp0 e comincia a fare il flashing della memoria flash appunto del vostro dispositivo e vedete che inizia col writing e è arrivato in fondo è andato bene la flashing da me al certo punto dice ad resetting via rtsp quindi il sistema è stato resettato ok quindi se non è in dimensione ma possiamo sempre dire quanto quando si allora adesso dobbiamo vedere dove era si esatto e da consideriamo che però la flash non sbaglio il film e mega e qua sopra quindi c'è da bravo si dove si è arrivato allora dentro ci mandava rimorso e si deve di capo con fighe se di capo con piccola e poi che ruotidano no no ti dà l'errore della flash o nel make basta ma scusa hai fatto make o make flash e ti dà errore? no no ti dà l'errore della flash e ti dà il proprio non aspetta proprio da l'alberia che hai un lavoro che non mi vedete allora sei dentro il luogo prima ma dal prossimo di qua ah scusa tu sì ho capito cosa non hai fatto torna subito una prima directory ancora finita qua ancora su no che è delucernita no ascoltavo ma hai fatto il programma hai fatto source dello script install e export scusa quindi source partito export sh quello lì serve accettare tutte le varie di ambienti che serviranno al confilatore ok adesso puoi fare il link certo quindi torna dentro però non da qui no torna dentro la directory jump call e il get started come si chiama get started and the world adesso puoi fare il link ok qui puoi fare il link se è il link poi anche prendiamo il default ancora il adesso mi fa ok si si quando mi riguarda la reazione magari è più facile ma no no ma eri per strada quindi immagino che giù bene a questo punto che abbiamo fatto un link flash se è andato tutto a buon fine come da me e vi scrive hard resetting via rtsp il sistema è stato flashato e resettato quindi ha iniziato a fare il quando il il codice che abbiamo messo dentro ok adesso non sappiamo quella c'era del codice perché quello l'abbiamo visto ma come come si fa a catturare un eventuale output di questo sistema di muovo veicolato in arduino c'è lo smiffer della seriale e qui c'è qualcosa di equivalente andando a scrivere make monitor make monitor lancia uno smiffer della porta seriale sui terzi di sicurezza di zero monitor questo è un'altra parte di un'altra parte del palio si vedete ecco è partito il main monitor il main monitor vi fa vedere allora in bianco ciò che è la stampa usando la printf allora cosa fa questo questo script questo piccolo applicativo che poi andremo a vedere scrive allo word e poi scrive le caratteristiche aro a dite questo è un s più tanto 206 con un core wifi silicon revision 2 mega di external flash e poi dice restarting in countdown e dopo 10 secondi fai un reboot della piattaforma al boot della piattaforma appare invece queste scritte verdi le scritte verdi sono scritte il debatto del boot della piattaforma non è la nostra più tempo è il sistema operativo che sta facendo il boot vedete dice boot compile time parte la spi a 40 mega spi mode la splash eye eccetera e poi a un certo punto parte il task load it up from partition and offset eccetera nel senso che le vostre applicazioni sono caricate in cienci prima parte che un pratico e poi il video di unica applicazione che ha installato può essere qui anche a partire più di un'applicazione è un'altra quindi potete anche lasciare più di un'applicazione vi dice che questo ci fa un solo core è un wifi eccetera allora come si esce da questo monitor perché il il monitor sta ancora lavorando vedete blocca la mia la mia scena per riuscire del monitor dovete fare contro alt gr parentesi quadra chiusa contro alt gr parentesi quadra chiusa e l'unica combinazione di di tanti per riuscire da questo non fate contro al cast per qualcosa di vi ha funzionato a tutti questo è lo world allora adesso devo vedere il codice però di e lo world quindi a facciamo un cd nel pro me facciamo io uso di bin perché mi piace vuoi potete usare mano quello che volete di cv mello world c e apriamo il nostro e lo world allora vediamo se riesco ad aumentare il post se le font l world example va beh c'è la solita scritta in cima e andiamo a vedere che intanto questo è un cd è un po' è che non lavorando sempre linguaggi include stdo punto h include free rtos e rtos punto h che praticamente sono tutte le primi di alzio operativo poi c'è l'inclusione di task di free rtos e poi c'è l'inclusione del sp system spi play perché questo qui ci serve spi play ci serve per leggere le informazioni in questo applicativo stampa a monitor come sono fatte le applicazioni in free rtos il mail si chiama app main quindi questo app main è il nome del vero main ok non potete cambiare di nuovo altrimenti non viene riconosciuto come punto di lancio quindi la mail è il nostro punto di lancio che cosa facciamo qua dentro vedete printf hello world e poi c'è principi information che per stampare cip information ci fa riferimento alle librerie sp system punto h quindi c'è insomma diciamo questa questa struttura dati sp chip info descorti che viene visualizzata con sp chip info e l'invocazione del system code che essenzialmente va a leggere il chip e poi vedete che la printf va proprio a dire questa è un s più 32 66 con per cento di numero di corno perché il numero di corno andiamo a prendere dalla struttura dati chip underscore info course che è stata valorizzata dalla system code precedente poi la silicon revision cp info punto revision e poi andiamo a chiedere quanta memoria abbiamo come vedete memoria flash e la memoria flash l'andiamo ottenere con p flash get chip size fratto insomma questi due calcoletti perché la vogliamo in megabyte ok e poi inizia il countdown per riaffiare la piattaforma per i che va da 10 a 1 a 0 in meno meno restarti in per cento di seconde poi c'è questo punto task di lei il buccato di lei è un è molto più performante nella di lei che abbiamo visto in arduino perché un tasco di lei automaticamente riesce a mandare il sistema in power management ciò che arduino non faceva in realtà e vedete come sp restart la macchina quindi allo scadere di questi 10 secondi perché questo foro ciclato su mille millisecondi semplicemente attende 10 secondi e poi fa il ributso della piattaforma quindi è davvero davvero molto semplice è un c1 quindi possiamo usare tutta la printf tutto ciò che conosciamo di printf e facciamo tranquillamente veramente anche qua bisogna conoscere le librerie e questa disposizione dal free rtos però questo è c'è una pulva d'apprendimento iniziale non banale però vi dicevo se volete fare una produzione che non sia un semplice testing la maggior parte anche delle software usano queste architetture non usano tanto arduino perché queste hanno una maggior stabilità e una maggiore capacità di configurare il tipo di testo beh adesso che abbiamo visto come funziona questo main questa applicazione possiamo tranquillamente chiuderla e però ora provare a fare un'applicazione che vuol dire la piattaforma così come diciamo paolo la configurata quindi con l'esp con un led connesso un tasto e un php ok ora per fare questo andiamo su non andiamo ad uscita sporcare la piattaforma sp o 72 66 eccetera perché la piattaforma diciamo così la vogliamo lasciare in tonta ma noi possiamo dentro la diretta di xp creare una nostra diretta di con i nostri esempi ok quindi dentro direttore se qui facciamo mk di e facciamo esempi e esempi ai o di esempio io ti l'ho fatto dentro di rectori sb io posso creare progetti per questa piattaforma ovunque nel mio file system nel momento in cui ho fatto su del vostro dello scritto vi ricordate export punto sh perché a questo punto in questa shell io ho le variate di ambiente settate e quindi posso lavorare ovunque vado dentro esempi ai o di che vuota e adesso qui andiamo a fare una cosa abbastanza rapida che non scriviamo il codice da zero ma sulla piattaforma blend di di riservi ho caricato degli eventi quindi lo chiamo su blend di unibus riscarichiamo semplicemente poi magari passano delle modifiche non andiamo a scrivere da zero quindi blend di urb ad un'icop 이� d'amore prima aveva vogliamo 1 nella al accetto ok e siamo dentro però no adesso siamo dentro andiamo su IoT vedete che ieri ho creato la directory esercitazioni SP più FreeRTOS l'ultima directory che trovate nella parte iniziale del corso esercitazioni SP più FreeRTOS contiene delle sottidirettori vedete button e LED, HTRID e LUXRED andiamo a prendere la prima che è LUXRED che servirà a leggere il sensore di luce analogico, vedete che se vi ricordate che Paolo ha legato nella scatolina una fotoresistenza se vi ricordate che è stata messa lì questa fotoresistenza può essere letta attraverso l'ADC ok quindi scarichiamo tranquillamente questi tre file prima predisponiamo una directory che si chiamerà LUXRED dentro esempio i2d quindi è MAKKD LUXRED non red READ dove vuol dire leggi la luce da un cd qua dentro e qua dentro se andiamo a copiare i file che sono nella sottidiretoria LUXRED che sono il make file salva il LUXRED main c e compone il make up ok adesso mi li ha scaricati tutti una directory di default si chiama download li vado a beccare da qua che sono il make LUXRED con il make e compone un conto MK faccio un conto X da qui che li vado a incollare dentro home esp esempio IoT flux in red ok in realtà qua dentro devo creare un folder main mk di main dentro il folder main ci metto component quindi muovo component dentro main e muovo lux read dentro main e qua fuori rimane il make file quindi la directory che ho creato il suo esempio IoT che si chiama lux read contiene make file e contiene la directory main che a sua volta contiene component punto MK e lux read underscore main punto c avete capito che ho fatto è stato abbattato in confusionario adesso andiamo a vedere il make file un attimo divino make file e make file l'unica cosa che ho vado sono andato a personalizzare è il nome che ho dato lux read come scusa no no io ho scontato la cartella con il di con di due file esatto perfetto quindi qui il make file c'è andiamo dentro direttore i main e andiamo a vedere la lux quindi gb lux read main dot c questo è il nostro select font questo è il nostro mail questo non fa cosa io su gbim vai su edit l'ultima riga in fondo di edit essere font e poi qua c'è il cursore allora andiamo a vedere questo oggetto allora intanto questo questo esempio vuole accedere all'ADC e l'ADC è vincolante nel senso che gli ADC c'è un solo pin su SP non possiamo scegliere il pin dell'ADC perché è solo quello in realtà l'ADC che c'è su SP può funzionare in due modi uno come ADC analogico sul pin a zero che noi sappiamo essere attuale oppure può addirittura leggere la tensione interna della CPU se lo configuriamo in un altro modo perché questo può essere utile per valutare la carica della batteria se io voglio sapere il mio SP che ha limitato la batteria quando sta per determinare la batteria so che la batteria è 3 e 3 io periodicamente leggo con l'ADC non il pin esterno ma lo configuro per leggere la tensione d'alimentazione del processore e mi dice 3 e 2 3 e 1 quando arriva a 2 e 8 dico la batteria la ricambiava quindi posso usarlo anche in questa configurazione noi l'abbiamo già usato un'altra volta in configurazione ADC esterno quindi leggerà sul pin a zero si io ho fatto un gbim del main della directory il file che si trova dentro la directory main che si chiama luxread underscore main ok la luta che ha sì perché non c'era quindi dentro la directory main ci deve essere compone .mk è lux underscore read underscore main ok adesso vediamo questo file luxread main andiamo a commentarlo e cerchiamo di capire cosa sta facendo io l'ho modificato un po' sono partito sono partito dall'esempio ADC classico che legge l'ADC per andarlo diciamo così a modificare un po' per le nostre esigenze allora prima di tutto andiamo a vedere l'app main l'app main ricordiamoci il punto di lancio perché allora di sopra c'è un task lasciamolo un attimo da parte andiamo a dire l'app main allora il main è il punto di lancio del nostro applicazione cosa facciamo qua sopra allora l'app main normalmente si inizializzano i device è un po' come in arduino c'è la setup e l'up bene in app main si inizializzano i device e poi di solito siamo in un sistema operativo free siamo in un sistema operativo realtime normalmente si creano dei task non si fa tutto nell'app main prima abbiamo visto l'hello world che faceva tutto nell'app main ma proprio perché era l'hello world era la cosa più semplice da fare ma normalmente il main deve istanziare dei task e farli impazzire prima fa la configurazione e poi istanziare dei task quindi andiamo a vedere che cosa fa l'app main allora innanzitutto deve inizializzare l'adc allora questa lettereria che abbiamo importato in cima che è adc vediamo il po' è driver adc.h driver adc.h contiene appunto queste definizioni andiamo a definire una struttura adc underscore config underscore d che chiamiamo adcconfig perché adesso dobbiamo configurare l'adc per la lettura sul pin esterno perché vi dicevo c'è anche la possibilità di usare l'adc per leggere invece la tensione dell'alimentazione per leggere sul pin esterno dobbiamo dire adcconfig mode uguale adc read t out mode che vuol dire la tensione esterna cioè legge esternamente esternamente c'è solo un pin la zero quindi c'è configurata in questo modo la dc mette da zero quindi Paolo ha collegato a zero sulla resistenza sulla resistenza variabile che ci ha messo anche qui la resistenza in serie per il solito motivo per andare a limitare la corrente ma questo è lo schema sempre lo stesso poi dobbiamo dare un clock alla dc la dc è un modulo esterno rispetto alla mcu cioè che in realtà è un sistema chip quindi la mcu contiene la dc ma la dc non è il processore quindi il processore deve forzare un clock sulla dc e per forzare un clock si usa un divisore che cos'è un divisore? Nel sistema di microprocessore abbiamo un clock di base che è la frequenza di base e questa frequenza di base va data alle varie strutture attraverso un divisore la frequenza di base è 80 MHz la dc deve essere cloccata a 10 MHz e quindi è chiaro che il divisore vedete clock div deve essere 8 80 MHz fatto 8 da 10 tutte le periferiche tutti gli oggetti che ci sono dentro questo sistema un chip lavorano con un unico clock che è 80 MHz ma con gli occhi di divisori perché la dc non può gli dare 80 MHz perché è uno dei grandi di lavorare in quel modo e allora servono questi divisori e il divisore appunto andando a settare 8 visto che il clock di base è 80 MHz viene esattamente 10 MHz bene e poi abbiamo la vera e propria inizializzazione dell'adc adc init passando della struttura adc config che abbiamo predisposto sopra produce l'inistralizzazione dell'adc sp error check è una macro che semplicemente controlla il valore di ritorno di adc e se c'è un errore manda in panico proprio fa panic che vedrete evidentemente eventualmente fa un panic del kernel quindi si blocca tutto se tutto va bene cioè se sp error check è andato bene su adc allora si crea un task ecco vi dicevo il sistema operativo di questo tipo lavorano appunto con la creazione di un task abbiamo installizzato tutto crea un task i task si creano con questa funzione x task create x task create ha bisogno di un nome di una funzione che dovete aver deprito da qualche parte quindi in realtà un puntatore a funzione elux read task l'avevamo deprito in cima poi andiamo a vedere passatevi la funzione ha bisogno di una stringa che sia il nome simbolico di questa funzione poi ha bisogno della dimensione dello stack di questa funzione dimensione massima ci passiamo 1024 byte e poi altre informazioni dove quella che interessa è il 5 5 è la priorità del task addirittura su quindi i task possono avere priorità diverse quindi potete avere più task e schienularle con priorità diverse 5 è intermedia la priorità va da 0 a 9 5 è la priorità di più alta 0 è la più alta e 9 è la più bassa solo che avete un solo task quella che gli diamo però la funzione create task appunto vi permette di definire queste cose andiamo a vedere la nostra funzione in cima come cosa fa la funzione che quindi è davvero il nostro applicativo perché l'altra è solamente la parte di installizzazione allora abbiamo definito una static cross char che è praticamente una stringa statica perché in questo esempio si usa non solo la printf ma si usa la modalità di log e questo tag servirà per appendere la modalità di log essenzialmente una stringa che ci faccia riconoscere tra i vari log di sistema esattamente quello che stiamo scrivendo noi usiamo due modi per leggere la DC leggiamo un semplolo alla volta oppure usiamo la lettura di dettagli c-fast la lettura passere per leggere un certo numero di campioni tutti in una volta alla velocità massima che la DC è in grado di forno allora cosa abbiamo predisporto abbiamo predisporto un array di interi senza segno 16 bit che si chiama dc data non 100 più date 10 modifichiamolo aveva fatto 100 ma poi in realtà neanche 15 è inutile e una x che servirà come contatore di un ciclo quindi sono le nostre variabili locali un array di win 16 di 10 di 10 di e questa e poi vedete la lux read task è in while infinito allora qui il while va esplicitato nel senso che se il task deve essere infinito dovete esplicitarlo voi il loop altrimenti non è come in arduino che la funzione viene invocata lì quindi while 1 che cosa fa fin tanto che è in vita questo task allora la prima cosa che va a fare invoca adc read di un solo valore quindi adc read legge un solo valore e lo va a mettere in posizione 0 vedete di adc data e poi lo stampa perché fa lo stampa attraverso non la printf ma attraverso questo sistema di debug che è sp logi che ha bisogno di un tag iniziale e poi la sintassia è quella della printf quindi in realtà adc read per cento di eccetera di adc data punto 0 in posizione 0 e poi vedete annuncia che farà la lettura fast sp logi di nuovo questo è un sistema di debug adc read past e poi lancia la read past la read fast legge un numero di sample che voi passate come secondo argomento allora ha bisogno di un array di un puntatore ad array dove mettere i dati che gli diamo adc data il numero di campioni da leggere che è 10 e questo lo legge in un colpo solo dalla velocità massima poi il ciclo successivo for per x che va da 0 a 10 stampa adc data in posizione x quindi stampa il sample appena letti i 10 sample le stampa questa volta col printf letti alla velocità massima dell'adc perché adc rimpass chiede alla dc un numero di tempo alla velocità massima quando facciamo un super loop all'interno di free atos ci serve sempre inserire una mutast delay cioè ogni step del nostro loop deve dormire per un certo periodo di tempo questo addormentamento sfrutta il power management quindi è automatico se gli dati un task delay ad esempio di mille manda la cpu nell'ottato più profondo perché per mille per un secondo non deve fare niente quindi è fondamentale usare la boot task delay che serve proprio a bloccare questo task poi cosa faccio a creare diverse il task in eseguzione c'è solo lui manda la cpu al massimo del power management se ne fosse un altro chiaro che deve schedulare anche quello e la decisione di power management è una decisione globale per il task bene se vi sembra chiaro quello che vuol fare questo esempio proviamo a compilarle proviamo a eseguirlo la printf viene ridefinita nella toolchain e la manda nel dftt attraverso la comunicazione seriale proprio perché in questa toolchain tutte le printf sono ridefinite quindi in realtà invia caratteri nella seriale a 115.200 bits al secondo e via di ciasco quindi facciamo un save qui dentro ci hanno apporto torniamo un attimo su dove c'è il makefile facciamo un make dovrebbe ripartire ecco l'autoconfigurazione grafica perché è vuoto non c'è l'autoconfigurazione qui possiamo lasciare tutto di default per la save e poi non abbiamo necessità di modificare nulla rispetto al default che parte il nostro compilatore di nuovo ricombina tutto il sistema cooperativo questo è un nuovo progetto e deve crearsi tutta la directory build con tutti gli oggetti compilati per poter linkare alla vostra app se volete andare più veloce potrevate anche fare un make meno j4 che usa più processori non avete mai usato il make meno j perché ci sono più file nel switch fa dei task più separati in parallelo su di processoria qui se abbiamo più corso potremmo anche fare un make j qualcosa da più veloce arriva in fondo in teoria abbiamo una macchina con poco da moda che possiamo combinare su tutte le lezioni di schede anche operativo hai visto che c'è quel config iniziale e vi dice ok non mi serve il wifi non mi serve questo allora crea un config che ti esclude dal linking tutte quelle parti lì quindi non ne so questo perché vedevo passando le librerie di trip si si le compila tutte però questo dipende dal config che hai fatto prima bene la compilazione data buon fine ora facciamo fare il make flash il flash carica sul dispositivo che è piuttosto eseguibile e ora facciamo fare il make monitor e vedete lui sta già andando dice adc fast e vi stampa i 10 elementi se ci passiamo la mano sopra dovrebbe cambiare la luminosità infatti lui sta cambiando 24 questa è la light show 68 71 quindi è strano che è molto più veloce che il barbino come scusami è schietta da ruino si è molto più veloce molto più veloce si vediamo se ci punto la luce con la luce dello smartphone arriva a 400 mi sento mi sento mi sento il mio dito è il più permeabile della luce 20 ogni resistenza poi da qua ha un po' le sue caratteristiche vi faccio notare che le stringhe di debug appaiono in verde vedete quando uso splogy invece che printf quello è in verde questo è il mio debug mentre la printf stampa il bianco è solamente una distinzione alla fine lo standard output è sempre quello cioè è la seriale quindi non cambia però con splogy abbiamo anche intanto il tag int vuol dire information quindi non è un errore ma un'informazione il timestamp locale al boot quindi quanti millisecondi sono passati dal boot e poi il tag che abbiamo predisposto noi l'UX read e poi tutta la printf tutta la stringa di stampa vedete quindi adcread legge un sample e poi fa l'adcread pass che legge invece alla velocità massima sì quindi ogni mille millisecondi però ogni tanto ne salta uno ogni tanto fa un mille e due sì perché come puoi immaginare esatto poi c'è anche il fatto che lì è al millisecondo però dipende dal momento in cui parte quindi poi prossima l'intero più vicino perché la bootass di lei è molto precisa quindi si dice mille e mille si portano mille e mille si portano mille e mille si portano cioè lei non sgarra assolutamente sì l'adc l'invocazione a read fast in quello che ci ha passate anche qui per riuscire con gr parentesi quadra è una cosa strana quindi se abituati io quando l'alcanzo se le vuoi vuoi riavviare capite che è un ambiente un po' diverso lavorare così rispetto a lavorare su arduino capite anche perché arduino è così diffuso no? perché diventa anche per diciamo tra virgolette gli smanettoni lanci arduino due righe di codice è un fatto qui adesso vedremo questo è per quanto possa pare complesso questa lettura se la riusci è semplice perché è semplice? perché legge su quindi adesso andiamo a vedere invece come usare il tasto del led che ha messo Paolo e ci vedremo che è un pochino più complicato fare queste cose chiaramente anche qui scaricheremo un esempio adesso però se siete d'accordo facciamo 10 minuti in pausa io metto la mia la mia la mia disposizione in pausa e facciamo 10 minuti in parte in cui continuo a leggere la DC tanto abbiamo solo staccato il monitor ma lui la sua vita è quella non c'è stato per fare questo l'unico modo per interrompere è la energia si prende il 15 monito però no si quindi c'è la cartella numero progetto si deve contenere una main che contiene i C e compone tutto MK se non c'è compone MK non lo trova come file da tirare non lo trova come allora continuo a fare quando va non lo trova come ci farà un'altra quindi sono no il c樣e però questo va è l' executed un po il il dove c'è il... ... ... ... ... ... ... ... ... Nessun ho o del la No, le sue storie è minimo. La storia è una storia di fatto. Eh sì. Ma noi è praticamente forza e andiamo molto difficili. Secondo me è quello che... Cioè non devi fare magari come un certo gioco. E poi ci dà la fai dall'altra parte. E poi ci dà la fai dall'altra parte. Non magari la rafferri. Tu devi fare come se ti dà la rafferri. Ho pensato a fare la rafferri. Stavo pensando anche di... Cioè non è che la rafferri. Non può discernere che se ti dà la rafferri, non pare da lei. Non è che i campi di rafferri. No. Non è che la rafferri. Non è che la rafferri. e non è che quello che reclame. Quindi via e imparrete... No lo so... Dai, dai. Vado a prendere qualcosa. Good bene ci vediamo per il 56 udd. Cosa c'è? Con noi collezini, con kidnapped. Inutta distr rozi alle 20 se il relay... Non è come sola, se le costa in�bone a 500 sopra. la fine 15 cm almeno significa di più 24 le le le le se dei francotony che marco come con i bici in un隻 Gli ho provato, ti fa immediatamente. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Allora, adesso l'ho pronto alla PG. quindi torniamo a noi andiamo a rimettere la registrazione registrazione chiudo no lascia che cambiamo un po l'aria perché viene scusato prima di però di solito era scostato ok la registrazione è ok benissimo allora dunque dunque dunque torniamo a noi questo era l'esempio quindi abbiamo visto per leggere dalla dc adesso questo non possiamo chiudere tranquillamente andiamo nella nostra directory e creiamo di una nuova quindi siamo dentro gente di oltre a lux read facciamo mk dir di una nuova directory che ci chiamerà button and button and led sarà il nuovo progetto e sfrutterà il tasto e il led del nostro sp quindi andiamo dentro button and led e qui ci andiamo a scaricare il codice che trovate predisporto su blending della sottodiretto i button and led proprio quindi save component mk va bene un po le teme capa sempre quello da salatine e lista funzionale se non l'esistenza andiamo a prendere il download nei file un po le teme capa e basso il led e da fuori e li mettiamo dentro la nuova direttore bato nel led anche qui andiamo a fare una sottodirettore nei pdmk di mail dentro me ci andiamo a mettere il nostro compone mk e il nostro batto led example g e quindi ci troviamo nella condizione di prima che dentro la diretta il bar con elettore abbiamo dei file che una diretta di mail sempre la diretta di mail abbiamo compone un per me cappa e basso nel corredato ok come prima abbiamo scaricato da il nostro esempio abbiamo creato una nuova direttore del gp e dentro questo direttore abbiamo creato la direttore che contiene il nostro file c adesso andiamo a vedere il nostro file c quindi gbim di mail button led example.c adesso vedremo un pochino come fatto questo esempio che mente un pochino dice di tutto c'è te la pari con me tu non riesci a dare un libro non la riesce a usare ma che c'è 1700 no ma tu riesci a entrare? no no uno il passata allora andiamo a fare un piccolo riassunto vedete qui nel commento ho modificato anche il commento perché stiamo lavorando con questa piattaforma dove Paolo ha collegato il led al D0 il D0 attenzione perché la denominazione D0 del WIN è relativa alla macroschedina che si chiama LodeMCU ma in realtà dentro FreeRTOS ci lavora a basso livello con i PIN numerati del sistema CIP che è la parte più piccola quindi noi dobbiamo capire questo D0 a cosa corrisponde perché il D0, vi ripeto è quel PIN esterno macroscopico della schedona che si chiama LodeMCU ma Paolo ha collegato il led a D0 e il tasto a D7 allora per capire però come utilizzarli all'interno di FreeRTOS dobbiamo capire ma D0 in realtà chi è? che general parto G input out è? D7 che general parto G input out è? allora per fare questo l'unico modo che abbiamo è andare a cercare uno schematico che io ho prelisporto qui e lo vediamo subito lo schematico di NodeMCU NodeMCU è questa piattaformona grossa grossa per questa virgoletta è così grossa e vi fa vedere che D0 vedete è collegato a GPO16 il nome di D0 dal punto di vista del processore è GPO16 il nome di D7 dal punto di vista del processore è GPO13 e in FreeRTOS viene codificato il pin del processore poi indipendentemente da NodeMCU che si avete attaccato quindi noi dobbiamo praticamente sapere che il led è su GPO16 e il tasto è su GPO13 ecco quindi che se noi torniamo al nostro codice vi ho anche scritto vede GPO D0 è GPO16 D7 è GPO13 l'altra cosa che dobbiamo sapere è vabbè D0 è il pin che dovrà essere configurato in output che sarà connesso al led chiaramente Paolo avrà messo anche una resistenza intera per far sì che il led non si bruci o non si bruci la porta questo a noi lo diamo per assolato che Paolo l'abbia fatto dobbiamo ragionare sul D7 perché il D7 invece è un tasto che dovrà essere configurato in input dobbiamo sapere se Paolo ha fatto qualche circuito di contorno oppure no ecco Paolo ha collegato il D7 quando il tasto è normalmente aperto ha una resistenza di pull down cioè l'ha messo a ground con una resistenza grande benissimo avendolo messo a ground normalmente quando il tasto è aperto quel pin sarà a ground sarà a zero allora noi dovremo configurare appunto il pin sapendo che è tenuto basso per sempre fino a su e quando il tasto verrà premuto viene portato alto l'idea è quella quindi l'altro cavo del tasto Paolo l'ha collegato con UCC cioè con la resistenza di A3.3 non appena premete il tasto questo cavo il D7 va a finire A3.3 normalmente sta a zero e appena premete va A3.3 quindi noi dovremo configurare questo GPO13 in input pull down e con l'internet che verrà generato nel fronte di salita rising edge cioè nel momento in cui il pin passa da zero a 3.3 dovete segnalare l'internet ok benissimo andiamo a vedere come si fa ecco non è una cosa banale allora adesso che abbiamo capito come si chiamano i pin noi definiamo una costante GPO vabbè questo è il nome era nell'esempio era così pronis GPO output input output zero che per noi è il nostro output che in realtà è il 16 perché GPO16 corrisponde a D0 poi una maschera GPO auto pin select per capire appunto quando il pin è configurato alto o basso 1 ul vuol dire unsigned long long con tutti 0 e 1 alla destra quindi è un unsigned lo devo disegnare qua è un unsigned e unico long long vuol dire che sono 32 bit 16 64 scusate 64 bit tutti 0 l'ultimo quello meno significativo è 1 si specifica in questo modo U L oppure se io dico U L è un long perché è un unsigned long invece è un unsigned long long esatto poi abbiamo l'input che è il 13 il GPO 13 che è il nostro di 7 anche qua definiamo la maschera per l'input per capire che il pin è stato selezionato in select benissimo poi definiamo due eventi button pressed è la mask è la pressed mask anche qui attraverso il time e long e vabbè questa è la priorità dei task adesso lasciamola un attimo anche qui è stata definita prima ma lasciamola un attimo andiamo a vedere come funziona allora in questo esempio definiamo due task vedete che si lavora per task quindi la main farà la configurazione definiremo due task un task che legge dal pulsante che si chiama button read task e un task invece che modifica lo stato del led quindi avremo per la prima volta un'applicazione più complicata che conterrà sull'interno due task un po' come sono due press uno che legge lo stato del pulsante e uno invece che modifica lo stato del task ricordiamo che siamo sul sito operativo real time ad eventi quindi andiamo a capire come faranno i due task a scambiare delle informazioni e per farlo ci serve dichiarare delle delle code di eventi quindi queste code di eventi che sono xq handle event group handle vengono inizializzate anali vediamo come le andremo a utilizzare allora prima di tutto saltiamo la mente che c'è più semplice sto per dire vedete quanto codice dobbiamo scrivere in arduino in realtà tiriamo molto di meno però ricordiamoci sempre che questa è una piattaforma più stabile e sicuramente più matura allora definiamo una struttura per la configurazione della general parto di potato che si chiama la prima cosa disabilitiamo il gintra quindi questo serve a inizializzare la struttura quindi disabilitiamo il gintra poi settiamo il modo general parto input output out vedete in mode output perché dobbiamo settare prima di tutto il pin di output poi configuriamo la maschera dei pin perché a noi serve solo il gpo 16 e la gpo output pin cell ci mette il bit esattamente alla maschera per indicare che vogliamo configurare il gpo anche il gpo 16 è il output quindi disabilitiamo sia la pulldown che la pullout perché lui è in output deve essere pin in input e poi configuriamo il pin 16 invocando general parto di inputaggio il config sulla struttura che abbiamo predisposto questo primo step fatto da queste 5-6 righe mi va a configurare il pin 16 in output ora dobbiamo configurare il pin 13 in input quindi questa volta dobbiamo andare a configurare l'interapp vedete prima l'abbiamo disabilitato l'interapp sul pin 16 ora sul pin 13 l'interapp invece dovrà essere abilitato sul fronte di salita allora intraptype questa volta non è disable ma è general parto intra positive edge quando sale anche qui passiamo il gpo input pin select per dire qual è il pin che dovremo configurare che sarà il 13 questa volta il modo è di input non è di output questa volta andiamo anche a configurare la pulldown perché rivediamoci che Paolo l'ha messo su ground questo pin quindi non possiamo configurare la pull up altrimenti confligerebbero e poi andiamo a invocare di nuovo cpo config sulla struttura ecco che quest'altro ring hanno configurato il pin 13 vedete si configura un pin alla volta prima il pin di A poi il pin di A a questo punto ci serve creare una coda degli eventi dove andremo a mettere gli eventi per far comunicare i due task la coda in questo caso ci invoca xq create e semplicemente gli ci dà una dimensione come un buffer dove mettere gli eventi dove qualcuno gli scrive e qualcun altro gli legge viene creato un event group che conterrà i task che potranno accedere alla coda e poi ci parte finalmente ci parte con l'installazione del servizio general parto di input output anche qua normalmente non è attivo quindi una volta attivato il servizio ISR vuol dire che il general parto di input output viene monitorato e non è installato il servizio si dice anche quale sarà la funzione che reagirà agli interrupt sul pin di IO attraverso la funzione general parto input output envelope dove vado ad aggiungere sul pin di input una funzione che deve essere invocata nel momento in cui arriva un interrupt la funzione si chiamerà GPO ISR che la devo definire io per la nostra funzione quindi questa funzione qua che dovrò definire da qualche parte l'ho passata come handler dell'intera su unico pin di input questa funzione verrà invocata ogni volta che c'è un intera così come abbiamo definito il writing edge su quel pin ok e l'ultima operazione che fa la main sono sempre le stesse cioè creare i task in questo caso crea due task il led for the task e il button for the task un task leggerà il l'evento sul bottone e un task modificherà lo stato del led anche qua abbiamo dato due nomi abbiamo aumentato lo stack nel 2048 priorità 10 che è la priorità più bassa possibile ora adesso andiamo a vedere prima di tutto la funzione di handling dell'intera che cosa fa cioè la general parto di input output intra service routine handler ISR per intra service routine l'abbiamo definita in cima eccola qua static void intra service routine handler parameter che cosa fa ogni volta che viene questa viene invocata dall'intera hardware quindi quando c'è un'intera data questa funzione viene invocata che cosa fa dai parametri va ad ottenere gponam cioè il numero sulla general parto su quale è avvenuto l'intera e chiaramente sarà l'unico che abbiamo attivato quindi abbiamo attivato solo l'intera sul di 7 e che cosa fa manda un evento nella cosa vedete xq send from ISR gli manda un evento passandogli il numero della dp l'evento lo mette sulla coda general parto di event q le general parto di event q l'abbiamo definita sopra che è appunto una coda degli eventi quindi ogni volta che c'è un int cosa succede succede che viene estratto il numero della general parto e viene creato un evento della coda semplicemente la routine di gestione dell'intera fa questo prende l'evento e lo mette nella coda ok benissimo allora vediamo il task che legge lo stato del p che è button ring task che è subito sotto questi task vengono schedulati dallo sistema operativo e lo danni anche in parallelo allora questo task è in loop vedete foro punti virgola punti vengono schiene y loop e questo task per sempre rimane bloccato su xq receive intanto che non c'è un evento lui è bloccato lì su xq receive non appena arriva un'intera la routine di gestione inserisce un evento nella coda e xq receive lo sblocca perché ha ricevuto un evento ecco come funziona la parola per l'evento riceve un evento sull'evento ecco io adesso l'ho commentato ma questa riga serve semplicemente per stampare l'evento che è arrivato adesso lo lasciamo commentato altrimenti fa una valanda di altri e cosa fa se il livello della gpo il cui numero è riferito all'evento è uguale a 1 quindi se il bid è alto allora va a fare questa cosa qua mette nel xflag event group l'evento button press lo mette in quest'altra cosa ok e poi torna a dormire perché torna in cima su xq receive la xq lo blocca fin tanto che non arriverà un altro evento chiaro se torniamo a figiare arriveranno tanti eventi si sveglia la continuazione e metterà i suoi eventi nell'altra cosa andiamo a vedere che cosa fa l'ultimo tag che è il toggle dei led cioè quello che modificherà lo stato allora vabbè intanto qui definisce un toggle enable a zero anche lui è perso in un ciclo foro il piscito vedete per sempre va a cercare nella coda degli eventi xflags event group preleva l'event bit con la maschera button press se appunto l'end di event bit press da 1 allora vuol dire che è stato premuto è stato inserito un evento tipo press allora cambio semplicemente lo stato di toggle così se il led era acceso lo spegno se era spento lo accendo faccio una printf setting led to chiaramente intanto il toggle enable e la riga successiva mi va semplicemente a settare l'output level quindi general purpose imputato set level del mio pin di output a tablo enable quindi set zero lo metto a zero se uno lo so mi facendo la scena come? faccio il problema a settare ecco si ferma allora vi chiederete se di sopra è fermo su una coda che ha chiesto il evento perché ho bisogno di mettere un task delay qua? perché in realtà non ci sarebbe bisogno perché noi torneremo subito sopra che intanto la reazione si blocca sapete cosa serve con il task delay? serve far sì che per 250 minuti secondi non sia reattivo questo task e quindi se ci sono dei rimpalti sul task ricordati come si è rimandato bisogno di rimpalti lui lì ignora altrimenti cosa succede torno subito sopra e tutti gli eventi di riparto e gli imprende tu allora quello lì serve in qualche modo per settare il periodo di inerzia 250 minuti secondi con sarà sensibile ulteriori amici 50 abbiamo sì proviamo a compilarlo e vedere se funziona si così si si si si si si si si si si si si si se si quindi parte del servizio in un sale ed exit della parte grafica strano su comportamento che se vede in carattere troppo grandi non so partire il grafico ma crea comunque un file di dei volte che ti va avanti adesso compiliamo e bello porto la ventilazione di questo ambiente c'è tanta roba poi come diciamo se lo configurate in modo tale da non linkare tutti questi oggetti quindi vengono tutte linkate allora non sono convinto che la compilazione di compilare sicuramente tutti ma non sono convinto che si vede poi non vi faccio vedere come si fa per capire cosa l'isca è una cosa molto da me a passo livello ma mi piace di solito fare quella cosa dopo dalla ragazza e ora che hanno fatto me che è andata a punti ne possiamo fare direttamente il mail flash monitor perché siamo mail flash monitor in cascata parte anche il mondo si adicolo possiamo scrivere mail flash monitor e lui compila flash e parte in cascata di così dobbiamo rinvocare e partito benissimo adesso vediamo sempre mentre un tappo si cede qualcosa in dato vediamo che il medico finalmente switch a e credente che c'è tim leggi di rossi 255 quando l'accende è 255 quando lo spendi e che dico curioso sto letto devo guardare lo schematico che fa il mio il nostro del legno di paolo è il legno di paolo è bisogna guardare a schematica di modelli perché questa è la caratteristica di modelli per capire il niente perché è tutto è il nostro di zero comunque sembra funzionare venite se andate veloci da 250 milisecondi di non voglio usare i rimbalzi se volete provare a modificare che si smettete una breve abbiamo fatto questo contro la rizzeria invece che 250 50 milisecondi di energia vedrete che a volte a dire il bar potete fare dove il prezzo avendo modificato solo il paese non resta e continuare tutto la mara d'arma compito adesso che abbiamo messo 50 dovrebbe rimbalzare di più imbri il mi funziona 20 50 una volta solo 5 e adesso non ha fatto 3 con 10 peggiora si si con 10 peggiora diciamo che 250 è molto cautelativo allora adesso che abbiamo visto che il giusto funziona proviamo a andare un po' a vedere come si fa a capire cosa davvero c'è dentro il nostro eseguibile andate dentro build quindi fate cd build c'è un file map vedete un punto map che si chiama come il nome del vostro progetto button and led map e un file di testo vi fa vedere la mappatura del pathian work che avete creato e installato da dentro quindi passiamo gbim di button and led punto map è una roba che vi fa vedere tutto ciò che c'è come oggetti linkati c'è praticamente tutto quindi davvero caricato tutto linkati staticamente sì però noi abbiamo preso il menu conficchio di default quindi i menu conficchio probabilmente ci scarica il compilatore ecco vedete adesso questo l'ultima parte location il proprio symbol vedete sai c'è la test print time che deriva da quella libreria si trova in posizione a dimensione 0x4 e qui sicuramente ci sarà anche un altro task a un certo punto mi fa vedere proprio tutta la composizione della memoria vedete c'è il wifi effettivamente c'è tanta roba c'è la printf vedete la printf vi dice dove è localizzata perché è tutto statico quindi questa è una mappa del pia che poi viene caricato da dentro effettivamente vedete c'è wifi delete wifi stop wifi reset ci sono tutte queste funzioni che ovviamente non ci servono in questo momento però da qualche parte si deve essere più lonti task eh sì 112 11 crypto effettivamente sta caricato tutto ma questo vi dicevo dipende proprio da come avete abbiamo configurato il menu config che in realtà noi l'abbiamo in tutti i detti c'è tanta roba sì ei penso ti chiediamo di negare l'essere perché abbiamo una roba che è che90 non abbiamo dietro tutta Woo está tutta teso s dentro la vita scusami scusami non mi velo da porte è un pocito addirittura generazione gentle E' prima di quei ca... ...ma che cosaantenho una prova? E'le visto che questo vi pr Hoffa è un di 26 dopo 5 pochissà, davvero 4.40 kg? Infatti c'è una prova? Ho fatto una prova quando la cosa fa unשים in dt.. Se nesse spooky va e partecia a vedere un bambino, artificia? Infatti una prova poi non si allogcia di fabbricchia? Se nessuno vuole un hooked, un 27 poco fa insieme a me poter farlo finire camera su e e poi ha preromsica in debuffarlo finire ca... Poiombino... Live in place dicono che 단 2 paints Non si, non si preventa diere non piantati, fammi te��면 più diweek secondo me quello bene io direi che ricordate c'era anche l'opzione di ottimizzazione del compilatore anche quella che l'abbiamo lasciato su the bugger che lo riduce ancora di più ok direi che per oggi facciamo più della qua e quello che facciamo invece la prossima lezione che giovedì sarà teoria quindi riprendiamo farlo con in teoria avrete notato che facciamo molta molta pratica in questo corso però in maniera programmazione io ti non me la sentivo di fare troppa teoria mi sembra più corretto di metterci le mani tu ok benissimo grazie a tutti