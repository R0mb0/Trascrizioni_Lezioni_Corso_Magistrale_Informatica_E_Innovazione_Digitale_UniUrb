Bene, ok. Benissimo. La volta scorsa abbiamo parlato un po' di paradigmi di programmazione di questi sistemi IoT. Abbiamo visto in primis il paradigma super loop, che è quello più semplice, che abbiamo anche sperimentato nell'esercitazione per Raspberry Pi, dove in questo paradigma, vi ricordo, essenzialmente il sensore, o meglio, il device che deve fare per sempre la stessa cosa viene messo in un while true, dove c'è una fase attiva in cui si fa qualcosa, la fase invece passiva è quella di mettere la CPU in slip. Quindi ci ricordiamo che il super loop si basa appunto su un while true, con una fase attiva e una fase di slip temporizzato. E abbiamo detto che è molto semplice e portabile. Questo ci abbiamo visto. Abbiamo visto invece il sistema a programmazione di eventi. Sia di programmazione di eventi non l'abbiamo terminata tutta la parte. E abbiamo detto che è tipica di sistemi, o meglio, framework ad eventi, tra i quali abbiamo citato Contiki. Contiki è uno dei primi framework che nasce per la IoT. è nato prima di diversi sistemi operativi di realtà, in un'operazione è nato prima del mondo Arduino. Si è evoluto e ad oggi è ancora un sistema operativo. O meglio, non è un sistema operativo, è un framework ancora esistente, ben funzionante, ed è basato sulla programmazione ad eventi. Quindi, come vi dicevo la volta scorsa, ogni processo, ogni task che dobbiamo eseguire su queste macchine viene triggerato in qualche modo da un evento. E il framework, essenzialmente, che cos'è? È un gestore, uno scheduler, un dispatcher di eventi. E quello che abbiamo visto la volta scorsa è che proprio Contiki, che è uno di questi framework, io ormai lo dichiarerei storico, perché effettivamente è uno dei primi che nacque con l'idea IoT che supporta di più di 6, e si basa tutto sulla gestione N20. Come vedete sono state definite queste primitive per settare un evento temporizzato dopo X secondi, ad esempio, e i processi sono essenzialmente sempre in attesa di eventi. Quindi, come vedete qua, ricordiamoci, abbiamo questo process wait event until che blocca il processo in attesa dell'evento. Nel momento in cui l'evento si genera, il processo prende il controllo, quindi in realtà il dispatcher di questo sistema fornisce il controllo al processo, il processo esegue il suo codice, che sta tra process begin e process end, e poi ritorna normalmente in process wait event until. ecco qua viene definito un sistema operativo, ma in realtà non fornisce delle system code, non fornisce uno stato di software, di astrazione, tale da poter essere chiamato sistema operativo, ma è più, diciamo così, un framework basato su uno scheduler. La cosa interessante è che, come vi dicevo, vi dà la possibilità di lavorare su diverse piattaforme oggi ben diffuse, e addirittura con piattaforme che hanno meno di 10 KB di RAM, sono davvero molto facili da utilizzare. La cosa che non vi ho detto è tutto scritto in linguaggio C, quindi i vostri task devono essere scritto in linguaggio C. Abbiamo detto poi che lo scheduler degli eventi di questo sistema si dice essere cooperativo, cosa vuol dire che lo scheduler è cooperativo? Vuol dire che non esiste la preemption. Bene, se vi ricordate dalla triennale, quando avete studiato sistemi operativi, che la preemption è proprio quel concetto che ci permette di sospendere un processo contro la sua volontà. cioè ci permette di forzare l'interruzione del ciclo, specie di codendezza di belle istruzioni del processo per provare con la mia proprietà di una persona. Bene, uno scheduler, si dice cooperativo, se non ha la preemption. Perché si dice cooperativo? Perché è necessario che il programmatore faccia attenzione a rilasciare periodicamente la CPU. Perché se noi rilasciamo periodicamente la CPU, quello che succede è che non essendoci la preemption, non essendoci un vero sistema operativo, l'unico task in esecuzione sarà quello che stiamo eseguendo e che non rilasciamo lontanemente la CPU. Cosa vuol dire? che non possiamo fare un buy-in-do e mettersi nelle istruzioni che non prevedono in quantità un'attesa di un evento. Perché se non prevedo l'attesa dell'evento, perché tutti gli vengono seguiti alla velocità della luce, cioè alla massima velocità della CPU, non c'è preemption e tutto si pianterà. Quindi uno scheduler cooperativo vuol dire che sono i processi che devono cooperare tra loro per rilasciare la CPU periodicamente così che questi possano deseguire. Questo se vogliamo è l'unico punto debole di Contini. Perché se utilizzato in maniera impropria diventa così impossibile lavorare. Però facciamo un attimo un incinio di Contini. E' vero che è un preemption tra IoT. Ma normalmente su un nodo IoT a scrivere applicazione task è un programma di solito. Non è che sono un'applicazione non divise come un sistema general purpose, non è che come un sistema operativo general purpose siamo nella condizione di dover fronteggiare diversi task, diversi processi scritti da utenti differenti e potenzialmente anche malevoli. Qui di solito siete sempre voi a scrivere i codici. quindi almeno gli errori, la cooperatività è molto facile ottenere. Bene, quando parliamo di spaccini degli eventi su Contini, diciamo che esistono due tipi di eventi. Eventi asincroni e eventi asincroni. Gli eventi asincroni sono messi in una coda e vengono gestiti, quindi notificati dal scheduler, dal dispatcher, essenzialmente nell'ordine, come ho scritto qua, a un drawing, cioè nell'ordine first in, first out, quindi una coda a un ordine e questi eventi asincroni vengono schedulati in maniera circolare e mandati in esecuzione sui vari tassi. Gli eventi, come vi dicevo, possono essere unicast o broadcast, diversamente invece esistono eventi sincroni, sono quegli eventi che vengono schedulati immediatamente. Qual è un esempio di un evento sincrono? Un evento sincrono, ad esempio, è un panchetto che si usa in una casa wireless. Quindi parliamo di nodi sensori, piano, normalmente, un sistema di comunicazione o Wi-Fi, oppure 1215-4, bene, siccome siamo in un sistema di eventi, un panchetto ricevuto dall'avestezio è un panchetto generamente di tipo sincrono, cioè viene immediatamente schedulato e forwardato, diciamo così, al task che era in attesa di quell'evento. Gli eventi asincroni, come ad esempio i timer, l'ultima, ogni task o schedulato timer, è una cosa che vuole essere stato in un'attesa. Quali sono i vantaggi di un sistema come questo? I vantaggi sono, inizialmente, la precisione temporale di tutto ciò che stiamo facendo. I eventi sono generati da un real-time clock, un real-time clock che è normalmente molto preciso, che avrà il suo oscillatore al guazzo, quindi sarà in grado di scambiare, è molto oscurato. E quindi tutto ciò che noi siamo in grado di fare lo facciamo con una tempistica davvero utile, davvero precisa. Ricordiamoci un'altra cosa. Anche in questo caso, generare un evento è un po' come la strategia dell'Interact. Se la mia fase attiva del sensore ha una durata variabile, a me non interessa, perché io la prima cosa che faccio quando prendo il CPU è schedulare un prossimo evento per 5 secondi, mi metto a fare la mia fase attiva, se la fase attiva dura una volta 3 secondi, una volta 2, una volta 1, non mi interessa, perché l'evento, lo che ho schedulato all'inizio, arriverà esattamente dopo i secondi dallo scheduler, dalla richiesta. Quindi, diciamo, la precisione è forte e non abbiamo anche più problemi di deriva dovuti alle fasi attive che possono essere varianti. Nel caso di Contichi, poi, abbiamo una specie di multitasking, non è anche di multitasking, ma siamo in un sistema a gestione di eventi, spesso e volentieri con un solo core, senza preemption, quindi tirare il raffiero multitasking, in realtà, e lasciare il fatto che lo scheduler gestisca gli eventi di tutti i processi che volontariamente hanno arrivato a quella ciclina. Però, si parla, guardare, si parla effettivamente di un sistema multitasking non reale, però vi permette effettivamente di lasciare la CPU a vari task periodicamente, quindi dare un po' l'idea del multitasking. L'altra cosa davvero vantaggiosa di Contichi è che può sfruttare tutti i start di power management dentro il controllo virtuale. Perché? Perché pensate, quelle primitive way, event and till possono essere complicate quando volete, nel senso che io dentro la way, event and till ci posso effettivamente non posso interagire effettivamente con il mio power management e in base anche semplicemente alla durata del prossimo evento lo scheduler sa quanto arriverà il prossimo evento guardando semplicemente la coda di tutti gli direi che si è segnato se nota che il prossimo evento legge per 10 secondi può pensare di mandare la seconda di un masso stata possibile per i prossimi secondi. Se invece il prossimo evento arriverà tra 500 mili secondi non conviene buttare la CPU nello stato più basso perché come sapete puoi risvegliarsi negli stati più bassi un po' a domani anche in azione e il trade off è sempre quello la CPU hanno vari stati energetici più lo stato energetico è profondo e più tempo e quindi energia ci vuole ripegare la CPU perché pensate lo stato energetico più profondo è quello in cui spengo tutto e rimane solo la realtà in clock spengo la RAM spengo la CPU quando arriva il real time clock però devo cominciare a rialimentare la RAM risincronizzarla perché la RAM è dinamica rialimentare la CPU far sì che la frequenza salga fino a livello stabile e tutto questo comporta il tempo in cui la sua rialimazione non funziona e il tempo uguale a energia quindi quando si lavora col power management c'è sempre un trade off tra quanto profondo è il power management e quanta energia e tempo serve nel risvegliare quindi diciamo che contichi per questo è in grado di sfruttare al massimo questi stati se viene lanciato un evento mentre la CPU sta già eseguendo del codice come si gestisce il tutto lo scheduler allora se io scherlo quindi chiedo un prossimo evento e l'evento arriva mentre la CPU sta già eseguendo quindi sta lavorando su un altro evento essendo un sistema senza prelazione essendo un sistema singolo core singolo task l'unica cosa che fa contichi è aspettare che il primo task rilascia la CPU non appena questa task è lasciato la CPU va a schedulare i prossimi eventi che ci sono nella coda degli eventi chiunque genere di un evento lo inserisce nella coda dello scheduler quindi lo scheduler sa l'elento degli eventi sa l'ordine di attrazione di questi eventi e se un evento come dicevo deve scattare quando la CPU sta già eseguendo un task ancora eseguendo un task viene semplicemente preferito per il tuo stato di attrazione eventi ecco eventi sincroni come l'arrivo di un pacco su un partito sono comunque indeferiti se la CPU è attiva perché in questo caso c'è quella che io vedete qui io do la CPU al task fino a quando lui non la rilascia non ci possiamo fare niente capito e questo vuol dire uno scheduler cooperativo che bisogna fare attenzione cioè il programmatore qui deve fare attenzione a scrivere il codice in maniera intelligente facendo sì che la fase attiva non sia troppo pesante perché questo rende potenzialmente deferibile a tanti eventi perché quando fai la fase attiva ci stai per esempio 10 secondi quindi quindi il post-power è finora fine quindi sì la risposta è quella anche se il elemento è sincrono non ci posso fare niente perché non c'è predazione immagino che nel sistema ci sia un ma in configurazione che dice quando è il tempo in giga quindi quindi da un determinato processore a portare a punto a punto a punto che lui possa scegliere perché c'è la idea esatto ma pensate che se voi guardate il repository di continuiti le grandissime le grandissime le grandissime perché la cosa bella di continuiti è che è stato portato su tantissime piattaforme che la gente non parla di basso livello quindi da SP quindi anche il suo controllore SGP anche 8P ci sono quindi sono davvero tante le piattaforme e ogni piattaforma le cime le caratterie con le alternative implementate le lecce e una di queste è abitante le condizioni e tutto se è un'oper che se volete trovato scaricate siete protoginati di compilare per gli scorsi domani se facessi con una piattaforma nostra potremmo pubblicare ecco mi lanci proprio una pallola che ti rimbalzo anche con orgoglio perché io ho lavorato più di sei forse quasi dieci anni di continuiti insieme alla mia faccia che è lungo perché abbiamo fatto la nostra versione di un nodo se è usato per un wireless sensor network quindi all'epoca non esisteva l'idea di IOP wireless sensor network che era qualcosa di quasi niente di male per una cosa particolare cioè erano delle reti di sensore low power che si potevano eseguire sui territori e ognuno compiava con un teore di cambiamento di qualsiasi grazie e la cosa interessante è che per arrivare al punto di raccolta che è un base day siccome la i nodi a perlopower si devono fare per tutti ognuno vicino e vicino alla non vicina che c'erano e l'intelligenza di tratta di questi strumenti era basata su algoritmi di stravaglimento come arrivare più facilmente a cui si viene a colta e consumere il tetto perché questi rigetti erano alimentati o dal premele solari o dal terreno bene le cose abbiamo fatto abbiamo preso consigli visto che è aperto abbiamo anche fatto la pezza formato abbiamo creato il nostro nodo con contiti però abbiamo fatto di più il diritto è fatto il netta forma dentro contiti ci sei fatto di quelli per incivito che l'armo aveva fatto il detto e l'hai compilato ma abbiamo fatto qualcosa di più infatti questo nodo si chiamava virtual sens era un nodo sensore virtual perché su contiti abbiamo messo una macchina che parezzava questa è una cosa innovativa dell'epoca formidabile perché contiti è un sistema operativo o meglio un framework scritto in C che va bene per il nodi sensore low power quindi gestiva low power gestiva poca ram noi sopra questo ci abbiamo formato il port in una macchina che è con le l'arte sui carici che non era un'altra che non dì che era un per il porto così low quindi il problema è la particolare si può tirare parecchie come una macchina virtuale e la macchina virtuale che eseguiva quando dice no quindi il nostro ruolo si chiamano più per il senso e possiamo scrivere quattici in java quattici in java poi il cross compilato trasformato in vai con interpretato da quella macchina virtuale che avevamo messo di sopra e continui a quel punto eseguivano addirittura il multitasking in quel caso era un multitasking reale o meglio il multitasking java tutti i parametri reali in java venivano bloccati dallo stand di c'era il processo così era sempre attivo diciamo così prima quando i task java era attivo e faceva prezzo di questi task java di conti e mentre eseguiva decideva ok come era eseguito per top e adesso eseguito dei task java quando nessun task java era attivo lo racconti di mandarsi più negli stadi di parola ma di negli altri profondi e addirittura avevano sperimentato anche dibernazione perché in una rete sensore facile di dire di poi di un parato di cinque minuti quindi cosa facevo in quei cinque minuti se l'ultimo evento schedulato era a cinque minuti si dibernava da di quindi si copiava all'epoca MSP430 non aveva lo schiarante non ma niente si copiava tutto il posto della ram nella flash e poi si spegneva tutto arrivava lì si rispegnava ci andava nella flash e rimanero un caso da lì era uno strumento molto carino che adesso purtroppo l'ho dismesso dismesso per vari motivi nel senso che come potete immaginare per mantenere questa forma aggiornata ci vuole dare una forza loro due delle persone che lavoravano con me ma per loro hanno fatto un lavoro altra università non rimasto io e se dovessi gestire gli aggiornamenti perché continui di per fare la situazione e di fare la tua parte di sopra tutte le per librerie e adeguati gli aggiornamenti ogni volta che usciva un aggiornamento di contichi per stare al pari ci voleva un mese da solo non sarà mai quindi diciamo così l'ho dovuto dismettere però se volete lo faccio vedere perché funziona aveva tutto il suo framework di sviluppo su Eclipse scrivevi codice Eclipse in java c'era tutta la tool chain con la scompilazione e arrivare a produrre un file eseguibile per la macchina virtuale che si dava sopra il nodo lo caricavi sulla porta la porta seriale e lui partiva e grande lavoro su questi strumenti che abbiamo fatto come vi dicevo era legato ai protocolli di installamento perché nel più banale il protocollo di installamento quale può essere faccio un percorso più breve ma il numero di o minore quale il numero di o stimore cosa vuol dire arrivare in un'argenza minore al collettore ma voi vedete anche che spavano le energie perché ogni rilancio comunque consuma energia ma purtroppo se voi ci pensate su una rete guarda se ne mette batteria e di risposta perché il percorso minore è sempre quello io mi trovo dopo tre mesi di funzionamento che sul percorso minore le batterie mi puoi fare scarica perché sono me che lavorano più sono quelli che rilanciano rilanciano rilanciano e quindi dopo tre mesi lavorare con funzionamento allora l'idea non è che la luciamo il percorso minore ricercando a dire io ho il senso il paceo cioè il senso della batteria io so come ha il 21 io 34 ho il 24 ho già quello che si si bilanzava in qualche modo che era tutto dinamico si bilanzava la consuma la tre mesi come l'albore che c'è un gran mucle che per interno scrivere sempre lo stesso in realtà si con i dati secondo lui in modo che non si consumi sempre sempre al stesso centro quello è quando non sono più di sst lavoratore ma poi la cosa si complicava delle varie ascensioni deletto perché magari se avevi 59 di prima tesorale fotocarti 30 con la parte via 18 pannelli solari l'altro collegato alla rete il di di di di di poi non solo abbiamo anche fatto dei lavori su quella che è chiamata computazione opportunistica o opportunistiche computetiche cosa è la computazione opportunistica fare le cose quando ripare quando fare fai infatti tutto quello di quei quale dal punto di vista noto quando hai energia un valore solare per tutto 60 energie allora comincio a lavorare faccio tutto quello che posso fare quindi computazione opportunistica vuol dire appunto in base a qualche parametro andare a fare le cose in un momento in cui puoi fare i nostri sogni avevano il mio parametro diverso diciamo di pannelli solari uno c'ha l'ombra l'un l'altro in quel momento lui può fare niente poi il sole si scuola e lui può essere molto attivo quindi la computazione opportunistica è una qualcosa di così diciamo c'è tutto un gran mondo nelle wireless sensor network che oggi viene tra l'IoT perché oggi l'IoT ha anche in sé le wireless sensor network diciamo le wireless sensor network sono essenzialmente il precursore dell'IoT non si parlava di perché due erano dedicati solo a fare un buon coraggio e le vignie abilizzate in questo modo e poi si sono estesi fino ad arrivare quello che oggi è il concetto di IoT però tutto ciò che noi vediamo in qualche modo all'interno dell'IoT è nato che si è evoluto a partire dall'euale sensor network se vogliamo l'aspetto che all'euale sensor network manca dell'IoT è tutta la parte cloud lì non c'è che la parola di attuazione nel senso che le wireless sensor network nascevano come reti private produttore di vino piantava modi sensori dei filari delle collettore di raccolta e i dati rimanevano locali a lui non c'era la necessità di contare il cloud di processare o di rifare operazione semplicemente a lui serviva capire beh è ora di ammazzare è ora di dare questa sostanza anche il cloud non era così come adesso è così approfabile da tutti all'epoca non si aveva servito c'era le ricevi confronti comparazioni o sharing dei dati da nessuna parte però ecco tutto ciò che abbiamo visto qua in qualche modo nasce nelle wireless sensor network e vi dicevo contichi che era appunto questa piattaforma che ho usato da tempo e oggi è andata molto nella direzione dell'IoT tra te che se guardate sul sito web sull'home page di contichi si parla di iper-inforzi se non esiste non so come se quali sono gli svantaggi della programmazione ad eventi ad esempio con contichi intanto rispetto a un super loop sicuramente il contichi è un contesto serve una curva dall'apprendimento di chiare e tos perché passare dalla classica programmazione super loop in linguaggio C o in linguaggio Python adattarsi al framework degli eventi sicuramente non sempre senza che ogni strema può essere la tattità senza il strema da tutto modo e quindi la complessità iniziale questa curva di apprendimento iniziale è sicuramente uno scoglio e come abbiamo detto l'altro svantaggio è investire i processi in maniera cooperativa massima attenzione a creare un'obiettica di far più pesanti perché come dicevo prima di tempo e quindi anche l'entai di può essere più preciso perché poi si è chissero a differire gli eventi cioè posticiparli ma nonostante questo è un approccio come vi dicevo molto usato nei device negli edge device come i sensori appunto aiutti bene passando all'ultimo dei delle nozioni di realtà che hanno la programmazione dei device edge ma erano anche di sistemi operativi davvero questa volta questo si parla davvero di operating system non di framework di tipo realtime e questo come vi dicevo nella macchina virtuale linux che ho fornito non so se avete provato a speritarla l'ho messo su blended in realtà su blended ho messo il link a google drive visto che sono diversi giga la potete scaricare potete lanciarla con virtualizzatore dentro c'è tutta la tool chain cioè tutti i sistemi di sviluppo per lavorare con un sistema operativo realtà lowpower che è free rtos quello che chiamo noi si chiama proprio free rtos che è un sistema operativo molto molto molto che vi da la possibilità di scrivere programmi per le di multi taschi davvero esistono relazione anche qui la curva d'apprendimento non sarà banale perché bisognerà comunque iniziare a capire come si lavora però una volta partiti sarà molto facile e anche rtos o meglio free rtos è un sistema operativo che è stato portato su un'enorme quantità di device quindi noi lo useremo sulle piattaforme sp2286 o sp32 e esiste proprio la libreria riporti su questi nodi quindi sarà davvero facile vedremo una volta stata la toolchain compilare codice e scrivere appunto le routine non è proprio un Linux perché è un motivo molto molto più semplice però parte da l'idea parte da l'idea è un sistema in real time quindi è proprio stato come vedete qua disegnato per per embedding system però diciamo così ha la caratteristica di lavorare con quelle che si chiamano le deadline time crick quindi in realtà le time crick è la città quindi qua quello che fai è il file è il file ma non fa il tempo è necessario di time precise per usurare altre cose esatto è la grande quindi se tu puoi davvero misurare tot millisecondi tot microsecondi con questo lo puoi fare infatti la differenza fondamentale tra i general purpose e real time sta proprio lì nel senso che la gestione del tempo è davvero precisa e meticolosa e praticamente il concetto real time è proprio quello nel senso che io chiedo il sistema operativo di fare una cosa entro con una data deadline e il sistema operativo riesce a farlo da fare e questo non è banale perché se pensate al sistema operativo general purpose normale le deadline sono vincolanti no perché chiaramente dipende il numero di processi che ho nella reddiffuse e nella cosa dei processi pronti il sistema operativo ha il suo algoritmo di scanning e quindi la servizio non guarda ma io posso fare tutto perché in realtà mi danno la garanzia di fare una cosa entro in tempo stabilito io ho messo un esempio come pensate un airbag che deve essere sicuramente aperto all'interno di un intervallo funzionale se lo apro prima lo apro dopo succede di tutto se lo apro troppo presto mi si sgonfia prima se è necessario se lo apro dopo ormai ho dato la testata quindi non è molto utile quindi le caratteristiche di un sistema real time che risponde immediatamente questo vuol dire che l'intera sarà la possibilità di eseguire un intera così che i task possono essere completati all'interno quindi un dilay che è ben definito e le sisteme operative real time si trovano dove? con tutte le gestioni che le macchine adesso bisogna di parlare di un aereo chiaro un aereo tutta la componentistica elettronica dell'aereo che è un aereo di un aereo è più semplice pensare di eseguire una reazione su un attuatore ma pensiamo a una cosa più semplice pensiamo a una macchina a controllo numerico che gestiscono delle prese e delle punte potrà fare un modulo rafforabile è lì la criticità del tempo per il fatto che il prodotto deve essere fatto in un certo stato ma non posso spostare esattamente nel tempo giusto sia per motivi di efficienza non è che deve andare veloce perché è il cuore denaro sia per motivi di correttezza e quindi di adesione aggivite e queste macchine c'è la bbs che produce macchine di questo tipo per la lavorazione del legno sono macchine complicatissime alla fine ci sono imperativi che si danno sotto sono tosti davvero si troveranno sei anni ma anche ma anche sono tosti davvero tosti ogni ma poi hanno delle specifiche adesso ma le macchine raccogliono numeriche diciamo che no un dicimo di millimetri di percezione che devono garantire i bracci robotici quelli che possono fare le pavole quindi inizialdo un modulo anche quello che è per un esperimento in ripetizione hanno mi pare un centesimo o un millesimo di millimetro in ripetizione che tendono la stessa operazione devono portare il suo posto è una cosa davvero spaventosa una precisione che devono raggiungere sia precisione appunto di posizionamento ma anche di di pericolosità come tempo esattamente se la rimane una curva del legno nel ferro non è giusto e non gli si incaspe con qualche pezzo è quello che è economico non è come un aereo che puoi schiantarti a terra però è una punta critica per funzionare deve funzionare così e questi sistemi sono dei sistemi davvero complessi che ci basano appunto su schede di tipo real time e i sistemi operativi real time come avevo già detto magari nel corso di schede operativi possono essere due tipi soft real time o hard real time quando parliamo di sistema operativo real time soft diciamo che le deadline cioè questi tempi predefiniti possono anche essere occasionativi per non è tanto di ma che è perché basta una volta e spaccola una se l'attuatore parte dopo spacco qualche strumento però se facciamo ad esempio riferimento a sistemi operativi real time soft di tipo multimediale come sappiamo salta una della e magari sento un glitch nell'audio nel modo da svolgo non c'è nulla di catastrofico questi vengono anche chiamati best effort system cioè sistemi che fanno del loro meglio ma non per forza sono davvero di real time hard e va bene a parte multimedia la telecomunicazione cellulare i servizi web computer games anche nei giochi il gioco va a scatto non sono conveni però non succede nulla invece gli hard real time sono quei sistemi operativi che invece hanno a che fare con le deadline in maniera critica che non possono essere proprio perse queste deadline e quindi devo evitare quello che può essere catastrofico quindi il problema di questi sistemi qual è che non è banale produrre un sistema tipo come questo deve essere deve avere un controllo anche formale una verifica formale non banale e la scrittura di codice non è molto semplice solo perché come dicevo prima la curva di apprendimento si fa abbastanza complessa gli esempi sono quelli di prima insomma allora perché usiamo sistemi operativi real time li usiamo essenzialmente perché vogliamo non tanto necessariamente rispettare le deadline che potrebbero essere catastrofiche facciamo un sistema IoT che vuole misurare grandezze quali minutemperature la vibrazione eccetera non sempre è così time critical il punto esatto una volta si è prima devi controllare particolari ambienti e allora è da sbignare che da real time per iot ma i sistemi operativi real time per IoT vengono usati anche perché garantiscono avere un buon timing ma hanno una buona capacità di essere modulari di essere mantenibili di essere robusti questo non è ma l'unice di essere operativo rende che cosa rende la mia applicazione magari priva di errori priva di crash per anni ma IoT deve lavorare per anni il problema è la caratteristica di IoT qual è? quella di stare acceso while true di solito fanno questo se non è magari importante esattamente la te che mi mi giuro è importante che io mi perdano cioè sono deciso di misurare più per me è il problema se un giorno il sistema è il progetto perché è un'altra cosa è questo è diverso ok e quindi si ricordano questi sistemi per la loro robustezza anche per la modularità portabilità via e via dicendo poi come in tutti i sistemi operativi il riutilizzo del codice è fondamentale è fondamentale poter fare dei test questo però diciamo che qualcosa che al di là del fatto che il sistema sia real time si giustifica col fatto che il sistema sia ben diffuso diciamo comunità dietro e free air tos quello che useremo noi è nato già diversi anni fa ora c'è specialità su dispositivi IoT attuali ma è un sistema effettivamente molto molto ben ben diffuso abbiamo ancora un po' di minuti vi dicevo oggi devo andare via prima per quella cosa non facciamo la pausa e vediamo un sistema operativo real time generico quindi abbiamo parlo di free air di OS quali algoritmi di scheduling utilizza per affrontare il problema appunto delle deadline sono degli algoritmi di scheduling che magari non abbiamo visto nei sistemi di general parlo nonostante round robin abbiamo sicuramente un monotra perché vi ricordate che chi ha seguito il corso con me abbiamo sempre detto che l'algoritmo round robin veniva gestito ad esempio viene utilizzato ad esempio in Linux per gestire i sistemi operativi sotto i task sotto real time e quindi è normale che noi ce lo ritroviamo tra gli algoritmi propri di scheda nel sistema operativo real time l'abbiamo già visto in Linux il priority scheduling e il clock riding scheduling invece li vediamo li vediamo ancora vediamo il primo uno scheduling basato sul clock non c'è il sistema operativo dell'albato l'albato abbiamo visto diversi scheduler first in first out oppure short and zone first ma non non avremmo mai parlato di clock schede di cos'è un clock schede è essenzialmente è un sistema in cui ogni task viene schedulato basandosi su degli internet quindi quindi non abbiamo il concetto di dare un task e scegliere un task in base al suo comportamento precedente per esempio short and jump first andavamo a dire bene le task normalmente usano il CPU per un tanto tempo per noi questo è il suo lavoro futuro probabilmente però qui andiamo semplicemente a utilizzare un sistema di internet che vi permetta di conoscere cioè fa sì che il nostro sistema conosca esattamente quando ogni processo dovrà rilasciare il CPU quindi non è un vero proprio timer internet è in maniera adattiva e lo scheduler potrà con un overhead minimo decidere istante per istante che mandare in esecuzione e tarare il timer entra quindi la differenza rispetto alla prelazione è quale è la prelazione noi sappiamo che il timer è periodico 50 secondi o 50 secondi lo scheduler prendeva il controllo e valutava la decisione nei sistemi operativi in realtà in quanto lo scheduler è di questo tipo invece adorino un processo di assegnare un internet programmato che è tu partirai di determinare il board tu partirai di determinare in base alle primitive che utilizziamo quando definiamo il nostro tasco è un sistema complesso questo qua ma è un sistema ancora una volta che comporta un apprendimento del programmatore ma rende le cose davvero deterministiche perché perché in un'unità inizia questo e in un momento l'auto inizia in un futuro dopo in un futuro in un futuro in un futuro eccetera eccetera ok quindi definisco che l'unità si è inizia a finire ed è il senore perché io mi garantisce di generare un'unità esattamente quanto lui deve finire e ripartire se il tasco si può tutto ah no tu non vuoi che mi chiedi a fare il programmatore effetto magari io se non hai finito rifare il pubblico il pubblico ma poi quella è la tua cosa però deve si può finire il processo e dice adesso ce l'altro che deve fare se da un questo a quel futuro è che lo parla del processo prima del processo poi esiste no lui gli diamo questa cosa si la verità è che il tuo piano ti insprimerò in questi commenti però non esiste così così almeno se non ce la fai il problema è tuo però io ho promesso e nel mio momento avrei lanciato i ci sono due degli x e si basa proprio una sorta di promessa all'unità si viene messo in etichetta il programmatore è una etichetta e il problema è di immaginare che il sistema operativo di il line che può spiegare un numero di caso in un gen 4 se comincia a fare due delle promesse poi in fase è difficile no praticamente il numero di task utilizzati è ridotto ma parliamo di operative in realtà dedicati a fare qualcosa no non è un sistema operativo generico quindi come in un nodo IoT quanto saranno mai tasse ma di ma di ma di ma di st però diciamo con un sistema così manteniamo anche davvero basso l'overredo di scheduling se vi ricordate del corso di sistema operativi gli altri pubblicani erano banali sceglie il migliore di stanno qui non è la scelta da qua c'è sa tutto più e quando lo schermo deve definire chi è in prescrizione perché si adatta ai l'animo il processo quando vede che la decisione è davvero banale più complicato magari se vogliamo per il programmatore il round droving invece viene usato come vi dicevo con soddisfazione nei sistemi operativi soft orientali se vi ricordate le caratteristiche di round droving qual è che nel processo di rinunere la cura la tipo il punto di rinunere il processo di che è il corpo le gestisce tutti in ordine fico assegnando un quanto di tempo che è costante a tutti rilassi cosa comunque va a fare la tassa se rilasci la situ dentro il quanto di tempo va bene lo successivo della ordine se tu non rispetti il quanto di tempo interrompo quindi vuol dire che più usi quanto che o usane di meno certo finisci prima quando ti interrompo passo al secondo secondo la stessa cosa se rilascia il tempo qui quando arrivo l'ultimo ritorno al primo ecco perché si chiama round perché è circolare ed è totalmente democratico certo ognuno al massimo prendo quanto spesa il vantaggio dell'economo di ricordato è che io posso conoscere il tempo massimo d'attesa prima che prenda più perché se io ho quattro processi lo definito quanto di tempo vale 10 millisecondi ogni processo prima di ricevere la stessa al massimo lo prenderà prima perché ci sono quattro processi due minuti quello è tempo massimo poi se la dobbiamo uscire più prima è un vantaggio conoscere il tempo massimo perché se io so che devo processare un pre ogni 100 di secondi posso subito sapere se la farò non se la farò dipende da quanto dire dal numero di tasche se ci sono pochi tasche qualche tempo breve faccio il punto al massimo per 60 minuti a me serve di 700 match perfetto c'è anche un bel un bel vantaggio quindi dico perfetto va benissimo invece il contrario troppo tasche qualche punto non posso eseguire non riuscirò a garantire la realtà di sbaglio scrivere e mi prende un lupo non do niente perché tanto che intervoto se la pregge tu anche se fai un vuoi uno niente da fare però quello che è un vantaggio diventa anche un svantaggio perché conoscere il tempo massimo vuol dire semplicemente moltiplicare il numero di 4 di tasche meno 1 per punto per 4 tempo ma se il numero di tasche diventa grande tant'è che non possiamo pensare di usarlo per schedulare tutti i taschi di un generale parlo anche se vedete un quadro di 20 millisecondi troppo piccolo poi se vedete 20 millisecondi ci avete 100 tasche 100 per 20 ogni 2000 secondi sono due secondi è impensabile che un tasche aspetta due secondi non solo nel sistema real time ma in qualunque sistema se pensate anche a GVIM voi pigiate i tasti e aspetta due secondi per farvi l'eco del tasto sulla tastiera buttate via tutto ecco ti sei perso un pezzo no il quanto di tempo in realtà lo setta il sistema operativo nei sistemi a schermo di round ottimo è un predefinito che per avere una responsabilità maggiore quanto il tempo deve essere basso considerate che nelle piattaforme di oggi non si può scendere sotto i 30 millisecondi a quanto di tempo perché se tutto lo avremo il quanto di tempo c'è la valutazione dello schermo del cambio di contro che sospenda il primo anche il secondo 30 secondi in termini computazionali non è stato 30 secondi è tantissimo perché una seguita lavorata circa su parte di parte di parte di tutti i conti che sarà se sei conti più prossimi conviene fare su esatto però non posso scendere di 30 secondi perché ovviamente vuol dire che ad ogni quanto di tempo poi spreco 5 milisecondi per fare la notazione per la percentuale con i raccogli dei dati esatto e quindi diciamo è questo il concetto non si lascia al programmatore la possibilità di settare il quanto di tempo ma è il sistema operativo che di default ha questa definizione sistema operativi più responsive hanno quanti di tempo più brevi sistema operativi meno responsi più dedicati agli task CPU bound hanno quanti di tempo più ampi però su pre-trail non è possibile scegliere qual è il problema ulteriore di round robin che per come è fatto questo algoritmo non contempla priorità diverse e precedenti cioè se io ho 5 taz per lui sono uguali non è possibile per lui dire ok questo taz vale lì e quindi ci dà l'altra di altro l'idea che è una del di circolare democratico quanto di tempo quale più e come potete immaginare gli scheduling per priorità sono quei classici scheduling che definiscono la priorità netto medica e in base a questo valore della priorità lo schedule viene assignato cioè assignato ai vari successi e normalmente abbiamo due tipi di schedule di priorità statiche dinamiche statiche che sono di quindi rimane così oppure dinamica è il sistema operativo che modifica quanti quali di priorità come sappiamo gli schedule di priorità sono molto pericolosi quindi voglio dire che possono produrre starvation cioè può accadere che c'è un task che è arrivato a un livello di priorità molto bassa lui non prende mai il più perché tutti i casi devono aprire il punto di quindi in realtà devo dire la verità non sono molti usati nei sentimenti in realtà per essere bassi perché sono un po' problematici da quel punto di vista bene finiamo la lezione di oggi semplicemente presentando quelli che sono i sistemi real-time per IoT open source nel senso che ci concentriamo un po' su questi e ce ne sono diversi noi studieremo come si scrive codice in free RTOS e faremo proprio in seguito le associazioni con ESP2286 su free RTOS ma come noi ci sono diversi dai nomi più variegati per IoT Apache ARM questo anche è molto utilizzato soprattutto nei web device dei dispositivi indossabili basati su ARM e poi ce ne sono diversi noi faremo riferimento a free RTOS che è proprio un sistema di questi che ci dà la possibilità di scrivere codice su sistema di realtà e una piattaforma in mente come appunto ESP2286 adesso devo proprio interrompere però mi dispiace ma mi hanno incastrato come vi dicevo al Carrier Day quindi per oggi finiamo qua ah invece no noi ci rivediamo martedì dico bene tuning aspettIO