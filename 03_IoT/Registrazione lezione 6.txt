Bene, ok. Ecco, grazie. Iniziamo con la primissima esercitazione su Raspberry Pi, che voi dovreste avere funzionale, è già partita la vostra, siete riusciti a collegarla, vedete lo schermo? Perfetto, benissimo. E iniziamo quindi a vedere come poter gestire sensori e attuatori con questo dispositivo. Ecco. Allora, prima di usarla, diciamo qualcosa come è fatta questa Raspberry, come vediamo nella slide. Intanto vi ho già detto che prende il nome di single board computing, quindi fa parte di quelle famiglie di dispositivi che vengono detti a tutti gli effetti computer, quindi computer inteso proprio come un personal computer. E l'altra parola che viene usata di solito è single board. Perché? Perché è un pezzo unico. Diversamente dai computer desktop e computer portatili, dove abbiamo scheda madre, memoria RAM, CPU, periferiche, connesse, intercambiabili, sostituibili. Quindi qua non è così perché la nostra Raspberry, come vedete, è un pezzo solo, un pezzo unico. E oltre ad avere tutte le caratteristiche di un normale personal computer, quindi porte USB, vedete in questo caso abbiamo quattro, sto descrivendola al modello 3, Raspberry Pi serie 3 e modello B, che è quello che sappiamo noi. Oltre ad avere porte USB dove connettere le periferiche di input output, porte LAN dove connettere la rete e porta HDMI per lo schermo, la cosa che ci interessa è che diversamente da un qualsiasi personal computer abbiamo questo slot qua, questo pin extended general purpose input output, che ha ben 40 pin. Questa è la caratteristica fondamentale di questo single board computing, che diversamente da un normale computer desktop ci interessa, perché qua su questi pin noi ci possiamo collegare sensori e attuatori, e quindi diventa sicuramente un dispositivo usabile all'edge dell'IoT, quindi alla parte edge. Cosa abbiamo poi interessante? Abbiamo on board una scheda Bluetooth, una scheda Wi-Fi, quindi ci possiamo collegare tranquillamente in Wi-Fi o in Bluetooth, in questo caso parliamo di una CPU che lavora a circa 1.2 GHz, abbiamo un gigabyte di RAM, e quindi abbiamo effettivamente un sistema che per noi diventa importante. Vi ho già detto che la Raspberry la possiamo usare sia all'edge come sensore, quindi come sistema di sensing e attuazione, ma essendo a tutti gli effetti un computer con un'istanza di Linux, lo possiamo anche usare al foggo oppure in cloud. Noi per oggi la useremo come dispositivo edge. Vediamo questa general purpose input output, che è quella che ci interessa come è fatta e cosa contiene. Allora i pin sono 40, sono numerati da 1 a 40, e in questa prima diapositiva sono identificati anche con dei colori. Allora i pin di alimentazione sono rossi, e notiamo subito che abbiamo il pin numero 1 che fornisce 3.3V, il pin 17 che fornisce 3.3V, ma abbiamo anche il pin 2 e il 4 che invece forniscono 5V, quindi abbiamo una duplice alimentazione sulla Raspberry Pi. Questo vuol dire che ciò che colleghiamo alla Raspberry Pi potrebbe avere necessità di essere alimentato a 3 a 3 o a 5. Dove le prende la Raspberry Pi queste alimentazioni? Ricordiamoci che viene alimentata da un normale caricabatteria, ad esempio di un telefono, e quindi fornisce esattamente 5V. Per ottenere la 3 a 3 c'è un regolatore di tensione, effettivamente che da 5 a 5 porta a 3 a 3. Gli altri pin fondamentali sono i ground, il GND, quindi la massa. Vedete ce ne sono diversi sparsi all'interno del nostro pettine, così che noi li si possa utilizzare più agevolmente. Sì, certo. Allora la General Park è rimasta. Quindi è compatibile a ritroso, quindi in realtà ciò che facciamo per la 3 funziona anche sulla 4. Cosa sono questi pin General Park? Abbiamo capito le alimentazioni e i ground che sono classici, quindi forniamo tensione e l'altro è la massa. Cosa fanno gli altri pin? Ora gli altri pin sono suddivisi in diverse tipologie. Si parla di General Park, Input Output classici, GPO, ad esempio, ecco, se guardiamo il pin 2931 qua, sono dei puri GPO. General Park, Input Output. Cosa vuol dire? Vuol dire che sono dei pin generici che possono lavorare sia in input che in output. Generici, cosa vuol dire? Sono digitali, chiaramente. Quindi sono in grado, se invece usiamo in output, possono produrre 0 o 3,3 volt. 3,3 volt corrisponde al bit 1, 0 corrisponde al bit 0. E in input sono in grado di reagire a un segnale imposto dall'esterno. Ma la maggior parte dei pin non fanno solo General Park, Input Output. Infatti vedete che il pin 3 e il pin 5 sono sì GPO2 e GPO3, quindi sono ancora General Park, ma dalla parte opposta si è anche identificato che fanno i quadro C data e i quadro C clock. Cosa vuol dire? Vuol dire che il pin 3 e il pin 5 possono essere utilizzati diversamente dalla semplice General Park, Input Output, possono essere utilizzati direttamente per codificare il protocollo in quadro C. E cos'è il protocollo in quadro C? È un protocollo di comunicazione seriale, digitale, che molti dei sensori digitali che acquistiamo già implementano al loro interno. Quindi cosa vuol dire? Se ho un sensore digitale che lavora col protocollo in quadro C, mi conviene collegarlo al General Park 2 e 3, quindi al pin 3 e 5, perché fungono anche dai quadro C data ai quadro C clock. Questo vuol dire che agevolmente io implementerò il protocollo in quadro C, perché si è già implementato in hardware su quei pin. Quindi mi basterà usare una libreria Python, ad esempio, che pilota il modulo in quadro C e comunicare in maniera molto molto semplice con un dispositivo in quadro C. Quindi ogni volta che io compro un sensore in quadro C, la domanda che mi faccio è dove lo collego? Lo collego nel 3 e nel 5, perché nel 3 e nel 5 sono uno data e uno clock. Il protocollo in quadro C è un protocollo seriale, si dice anche single wire perché in realtà il dato passa solo su un filo, l'altro è il sincronizzatore, vedete, il clock, l'orologo. Cosa abbiamo ancora di interessante? Vedete, questi pin marroni sono segnati come SPIO. Questo è un altro protocollo di comunicazione, un altro protocollo digitale. Ci sono altri sensori che non lavorano in quadro C, ma lavorano in SPO. E quindi in questo modo, se abbiamo comprato di questi sensori, lo colleghiamo là. Il protocollo è un po' più complicato, non è un single wire, perché c'è, come vedete, c'è il clock, ancora, poi c'è MOSI, MISO, Cipenable, Cipenable 0, Cipenable 1, sono un altro protocollo più complicato rispetto ai quadro C, ma è un protocollo standard. L'altra cosa interessante è che noi non dobbiamo studiare il protocollo, perché queste porte già in hardware sanno eseguire questo protocollo. Quindi l'importante è che noi colleghiamo bene i fili. Quindi se abbiamo comprato un sensore che lavora in SPA, allora andiamo a vedere il datasheet, lui avrà un pin di clock, chiaramente lo attacchiamo al clock, ci avrà un pin MISO, un pin MOSI, e poi il Cipenable, ecco che lo colleghiamo lì. Collegato in Python, di nuovo, potremo accedere direttamente a quel sensore in maniera molto molto semplice, senza preoccuparsi del protocollo. Quali altri protocolli sono implementati? UART, che è l'Universal Receiver and Transmitter seriale, quindi è proprio la porta seriale questa. La UART è la porta seriale. Il pin 810 insieme lavorano in transmission e reception della seriale. E quindi la porta seriale può essere collegata facilmente a questo pin qua. Poi abbiamo il pin 18, il pin 12 GPO 18. Aspettate che cancello. Non so come si fa. Non c'è la vista. Ah, qui appare sotto, guarda qui. Bene, il pin 18, come vedete, implementa anche un altro protocollo, che si chiama Fools Width Modulation. L'abbiamo visto nella teoria, cioè è uno di quei pin ancora digitali, che però è possibile gestire generando un'onda quadra, dove questo onda quadra, siamo in grado di variare la dimensione della parte ON rispetto alla parte OFF, per dare tutta una serie di valori medi da 0 a 3,3V. Quindi quel pin, che è un Pulse Width Modulation, ci dà quella possibilità. Ce ne sono altri. Vedete, c'è anche il GPO 12, che funge, che lavora in questo modo, il 13. Ce ne sono diversi. Poi ci sono pin EPROM, come potete immaginare, dove svolgono il protocollo EPROM per collegare una memoria esterna. E diciamo... Quale, scusami? Nella slide precedente? Ah, Do Not Connect. Vedi, è vero? L'ho scaricato dal sito ufficiale. Sì, no, probabilmente è per collegare a me o per collegare a me o per collegare a me o per programare. Sì, esatto. Potrebbe essere per quel motivo lì. Comunque, questo vi dice che questa Raspberry, appunto, con i suoi 40 pin di General Park, in realtà fa tante cose, non è solo un General Park, perché come vedete implementa il protocollo in quadro C, il protocollo SPI, il protocollo UART, il protocollo E2S, cioè, in realtà, sono tutti protocolli standard che hanno il vantaggio di essere già implementati in hardware, e quindi, se noi compriamo un sensore qualsiasi, legiamo del data sheet, legiamo quale di questi protocolli è compatibile, lo colleghiamo direttamente ai pin che fanno questo. Quindi, capite, questo qui ci rende la Raspberry uno strumento davvero performante. Ma adesso facciamo proprio il primissimo esercizio dove vogliamo, banalmente, fare, accendere un LED, quindi blinking LED. Prima di passare, switchare sulla Raspberry, fare l'esercizio, Allora, intanto lavoreremo in Python, quindi questo è chiaro. Prima di fare direttamente l'esercizio, guardiamo un pochino come il LED è stato collegato nello shield che vi è stato offerto, perché lo shield che avete sopra è una schedina che abbiamo fatto insieme io e Paolo, in realtà Paolo l'ha progettata, l'ha saldata. Questa schedina fa sì che ci sia già un LED di colore rosso, che vedete, sulla scheda, che è stato collegato da qualche parte nei nostri pin. Allora, vedete il circuito? È quello che viene evidenziato qua, nella parte bassa della diapositiva. È stato scelto di collegare il pin al GPO4, e da qui fate poter capirlo perché, guardando lo shield... Ah, ma se la cava bene. GPO4, chiaramente dalla parte opposta in ground, è stato messo in serie con il LED una resistenza R8 che abbiamo scelto di 220 ohm. Perché serve una resistenza? Perché se noi colleghiamo un LED direttamente a 3V3 e ground, non limitiamo minimamente la corrente, il LED ha una resistenza interna bassissima, passa a una valanga di corrente e il LED si bruca. In realtà, o si brucia il LED o si brucia la porta General Park o Zinput Out, perché la Raspberry Pi non è uno strumento che ha al suo interno circuiti di protezione evoluti. Le porte di General Park o Zinput Out funzionano proprio come delle porte di Input e di Out, ma sono limitate in quantità di corrente che riescono a derogare. Quindi bisogna anche fare un po' di attenzione a non strapassarle queste porte, perché è facile bruciare il modulo General Park o Zinput Out. Quindi, se ci mettete un LED, ci vuole sempre in serie una resistenza. Chiaramente, la resistenza cosa sta a fare lì? Limita la corrente. Quindi, limita la corrente che passa nel circuito. Più è alta la resistenza e meno intensa sarà la luce prodotta dal LED. Viceversa, più è bassa la resistenza e, al contrario, più alta sarà la luminosità prodotta. Bene. A questo punto, switchiamo. Io switcho. Voi, con chiusare la Raspberry, io switcho con la mia condivisione, vado a condividere lo schermo della Raspberry, che è questo qua, per iniziare, eccoci qua, per iniziare a programmare. per iniziare a programmare con il tool di programmazione. Quindi andate sul menu in alto a sinistra, dove c'è la fragolina, c'è programmazione. io sto condividendo la mia istanza. E c'è il tool che si chiama Tony Python. Voi vedete che è Tony Python? non so se quando parte, adesso provo anche io da qua. Perché io in pausa la condivisione della schermo? Riprendi condivisione. Voi vedevate ancora lì qualcosa? Andate in pausa. Ok. Lanciamo Tony Python. Mette un po'. Ricordiamoci che siamo su un device embedded. Ecco. Questa è l'interfaccia di dell'altù di sviluppo Python per la nostra Raspberry. Ok. Allora, qui vabbè, è partito già con qualcosa. Chiudiamolo pure questo. Anche da voi è partito con un file. Partiamo con un file nuovo. Allora, intanto da remoto chiediamo chi c'è. Scusami, faccio un attimo uno stop per vedere. Da remoto ci abbiamo. solo Nicolò. Quindi mi chiedo, Nicolò, lei riesce a lavorare con una Raspberry? Si sta seguendo? Può scrivere sulla chat se non ha il microfono. Sì, sì, ho la Raspberry. Perfetto. Quindi, allora, anche se fosse una versione diversa dalla nostra, comunque il tool che stiamo usando lo troverà. Bene. Giusto, lui non ha la Shield perché non ha fatto il prestito. Vi seguo perché non ho ancora assemblato di Shield. Certo, certo. Come sa, lo possiamo prestare quelli dell'università se riesce a fare un salto da queste parti e possiamo darle già uno Shield di questi. lo schema lo schema lo facciamo dare da Paolo. Smaletto volentieri con elettronica. Benissimo. Ok, allora, torniamo a noi. A questo punto siamo nel nostro ID che si chiama Tony, niente di particolarmente strambalato, facciamo New. New ci produce direttamente un file che chiama Untitled subito. Io clicco su Save subito così mi forza a dargli un nome. Possiamo scegliere dove salvarlo. Vabbè, io salvo dentro esempi Raspberry Pi. il nome lo possiamo chiamare LED, non che esiste già nella mia directory, quindi lo chiamiamo LED Lampeggiato. Punto PY. Così gli assegna direttamente il nome. Ok? Benissimo. Quindi iniziamo subito con le direttive di import per importare le librerie che vogliamo usare. Allora, librerie Python per Raspberry Pi ce ne sono migliaia a valanghe. Quella che abbiamo scelto di usare è una delle tante. Mi è sembrata subito molto versatile, quindi ho scelto questa, ma non è l'unica. Quindi from general purpose input output zero, questo è così il nome della libreria, general purpose input output zero, quindi dp0. Se aumento il font forse vedete meglio voi? Vedete lo stesso? Perfetto. Quindi from gpo general purpose input output zero andiamo a fare import della classe led. La classe led è una classe già predisposta che ci permette di gestire un pin come led. Poi cosa andiamo ad aggiungere? from time che è la libreria di timing visto che lavoreremo con un super loop ci servirà una slip quindi from time andiamo a fare la import di slip. in realtà non ci servono altre librerie per il momento visto che questo sarà proprio un hello world iniziale dove andiamo ad accendere e a spegnere un led. Quindi iniziamo con un piccolo commento quindi inizio del programma facciamo una print di una stringa quindi hello world la print della raspberry stamperà quindi nella shell e la shell in python quando la lancieremo è questa stessa vedete sotto c'è la pistola destrina qui bene a questo punto cosa possiamo fare andiamo a creare quindi creo un'istanza della classe led perché mi servirà appunto gestire un oggetto che chiamerò quindi stanza che chiamo led prende led e il costruttore della classe led s'aspetta il numero del general parco input out sul quale il led è connesso paolo l'ha connesso al general purpose input out 4 quindi qua gli diamo led 4 in questo modo si crea un'istanza della classe led sul general purpose input out 4 e ora la possiamo usare scusami non lo devi smontare devi smontare lo shield perché guardi il circuito sotto lo smonti sotto guardi i fili come li ha fatti passare e un filo andrà una parte andrà sulla resistenza dalla resistenza poi andrà alla 233 scusa andrà al general parco input out numero 4 esatto ah poi vedi la resistenza è già connessa direttamente sul pin quindi lo vedi vedi sul sul pettine che praticamente è connessa al 1 2 3 4 partendo da qua lo vedi no tentativi mai nel senso che allora tentativi allora intanto l'idea cos'è che tu o compri una shield che ha una documentazione o te lo fai se te lo fai sei tu che scegli esattamente dove collegare i fili con cosa se lo compri ti prendi una documentazione in questo caso l'ha fatto Paolo la documentazione non c'è nel senso che in realtà lo schematico quello che ho fatto vedere prima se volete ve lo ricondivido un attimo lo schematico ecco ecco lo schematico che Paolo ha prodotto è questo che mi fa vedere effettivamente che se il fatto che si fa il fatto la l'intento è passata se ti compri lo schemi sembra che la documentazione è molto più esplicativa se lo fai da solo non hai problemi che sanno in palmerina andare a tentativi non non è una forma che è intelligente però in questo caso basta chiedere a Paolo uno schema generale di tutto perché qui ha fatto il suo schema ha fatto vedere lo schema di come è collegato il led ma c'è tanta altra roba sopra lo schemi ok ripristiniamo questa qua benissimo ottimo allora abbiamo detto che abbiamo già creato l'istanza del led ora proviamo ad usarla quindi facciamo una print dove dico led on quindi lo vado ad accendere e per accenderlo davvero grazie alla libreria led basta fare led.on questa tonda chiusa tonda dove on appunto è una funzione un metodo della classe led led minuscolo è la nostra istanza in questo caso il led quando eseguiremo si accenderà si accenderà perché il general purpose input output è stato configurato in output visto che è un pin general purpose input output può essere configurato sia in input che in output l'istanza quando crei l'istanza della classe led automaticamente viene configurato in output quindi è pronto a produrre un segnale in uscita quando in poco on praticamente produce 3,3 volte cioè l'uscita alta bene adesso cosa voglio fare lo voglio spegnere se io facessi subito off è talmente rapida la procedura accensione spegnimento che non vedo niente quindi mi viene incontro la wait che abbiamo inserito prima faccio una slip di due secondi per vedere i due acceso altrimenti non vedrei niente quindi faccio slip l'argomento è già espresso in secondi quindi faccio slip 2 e slip 2 mi sospende la CPU in realtà questa è una sospensione attiva quindi non vado in un sistema in low power quindi la CPU in realtà rimane alto poi consideriamo che la Raspberry Pi c'è tante altre cose che sta facendo nel frattempo quindi e dopo spengo il led qui print led off chiudo la tonda e poi faccio led punto off quello che mi aspetto è proprio l'accensione spegnimento del led adesso vediamo se funziona vediamo se funziona prima di andare avanti e fare un super loop qui abbiamo creato un task che inizia e subito termine perché accende il led e lo spegne facciamo un save e poi facciamo un run premendo sul tasto run viene interpretato questo linguaggio ricordiamoci che Python è un linguaggio interpretato non c'è la compilazione quindi lo lanciamo vediamo se il led si accende e sta rimando a due secondi accese poi si spegne nel frattempo nella shell di output abbiamo visto tutte le stringhe che abbiamo stampato con print quindi c'è hello world led on led on lo vedete bene il task termina immediatamente perché come vedete non è in un while non abbiamo fatto un super loop ancora quindi in realtà il led si accende e si spegne una volta sola adesso aggiungiamo invece la parte che chiamiamo appunto super loop che abbiamo visto ieri super loop è un altro commento faccio lampeggiare il led a velocità costante questo è quello che voglio fare con il mio super loop while true due punti vado a capo e mantengo l'indentazione ricordiamoci che in python l'indentazione non è solo visiva ma è funzionale quindi while true faccio led punto on lo accendo faccio slip di un secondo led punto off e di nuovo slip di un secondo se mi dimentico le slip anche qua vado alla velocità della luce a un off non vedo niente il led rimane sempre a tempo questo è un vero e proprio super loop l'app non terminerà mai quando la lanceremo questo task non terminerà mai sì sì questo adesso abbiamo messo il secondo secco ma proviamo a vedere se funziona save run prima il suo task di due secondi poi è entrato in uno stato appunto lampeggiante ok ok si funziona ecco se vogliamo bloccare il task dobbiamo premere stop perché adesso questa volta il task è in task infinito premendo su stop si blocca il led rimane in uno stato ultimo in cui abbiamo bloccato perché un'altra cosa che non vi ho detto i pin general park o simpot out mantengono lo stato ultimo che gli abbiamo imposto quindi se noi terminiamo l'applicazione con un pin alto lui rimane alto se terminiamo l'applicazione con un pin basso lui rimane basso la raspberry non li resetta dopo che il task termina o li risettate voi in maniera forzosa oppure la raspberry li lascia nell'ultimo stato in cui erano rimasti quindi a volte mi potrà accadere che l'applicazione termina vedete il led che è rimasto acceso cosa è successo? perché la raspberry lascia l'ultimo comando quindi il pin rimane come tale dipende dove lo fermi esatto bene a questo punto proviamo allora visto che il pin che Paolo ha usato arrivo condivido questo visto che il pin che Paolo ha usato per gestire il nostro led è anche un pin che ha la capacità di pulse modulation come dicevamo questo pin ora proviamo ad usarlo come avevamo detto generando un'onda quadra questa onda quadra ci permetterà quindi di variare il rapporto on off dell'onda quindi la parte alta con la parte bassa e noi quello che vedremo sarà un led che sarà acceso a intensità variabile ok ricordiamoci è comunque un pin digitale non è analogico quindi noi non siamo in grado non abbiamo un DAC non siamo in grado di produrre un'uscita a 1,5 volt costanti ma possiamo ingannare in qualche modo il led usando un full speed modulation dove gli diciamo guarda genera un'onda che metà del tempo è on metà del tempo è off semplicemente il led è come se ricevesse in media una tensione che non è 3,3 ma è la metà di 3,3 perché per metà tempo è on e metà tempo è off giocando sui due rapporti on e off quindi siamo in grado di cambiare l'indirizzazione del led allora io qua in chat non vedo niente mi dice che sono gli investanti ah ok perché questo è un altro account ok va bene io qua li vedo tutti i led perfetto non capivo perché là invece si possono diventare bene quindi dobbiamo non dobbiamo modificare niente dal punto di start perché il led è già connesso all'interno del pin 4 è connesso col pin 4 che ha anche funzioni di full with modulation come la gestiamo torno a condividere la raspberry e facciamo questo nuovo esempio quindi chiudiamo led lampeggiante ne facciamo uno nuovo questo nuovo lo possiamo chiamare faccio anche qui save così mi dà la possibilità di mettere un nome a questo file e lo chiamiamo pool with modulation led quindi p pool with modulation led punto python ok anche qua iniziamo con le direttive di import quindi la libreria che usiamo è sempre general part in to go zero quindi from gpo zero vado a fare l'import di pool with modulation led tutto maiuscolo che è il nome della classe che vogliamo usare e anche qua prendiamo il timing quindi from time facciamo di nuovo la import di slip ok ora creo la classe pool suite modulation led sul pin 4 il pin 4 il gpo 4 che è lo stesso dove il led è già connesso vi dicevo perché ha anche la duplice funzionalità virgola setto la frequenza dell'onda a 500 ero questo è un parametro che io posso scegliere nella libreria pool with modulation led quindi quello che la mia istanza la chiamo piled piled prende un ritmo di led aperta la tonda primo parametro è il numero della general parcus imputatum quindi 4 virgola il secondo parametro è appunto la dichiarazione di frequenza quindi frequency uguale a 500 questi sono semplicemente i parametri della nostra libreria pool with modulation led questa è l'onda quadra quindi l'onda quadra va a 500 ero come il 4 del general parco imputato il primo argomento è il pin e il secondo è la frequenza a questo punto mettiamo un commento provo a variare la luminosità luminosità del led all'interno di un ciclo così parte da magari luminosità bassa fino ad arrivare luminosità massima e quello che mi aspetto è di vedere il il pin il led che cresca di luminosità quindi while true due punti quindi while true è perché uso sempre la tecnica super loop scusate quindi facciamo di nuovo un commento super loop quindi while true per sempre che cosa faccio voglio fare degli step di aumento della luminosità e per fare questo faccio un ciclo for per una variabile val che è in range non so se avete mai usato la sintassi del python per fare un ciclo for in questo modo comunque la variabile val va da 0 a 101 101 non compreso quindi da 0 a 100 due punti la nostra class la nostra istanza che è piled punto velu piled punto velu gli posso dare i valori completi tra 0 e 1 0 luminosità minima 1 luminosità massima e gli assegno val moltiplicato per 0 punto 0 1 quando val vale 100 moltiplicato per 0 0 1 vale 1 quindi alla fine del ciclo gli ho dato massimo però in questo modo faccio 100 step a partire da 0 0 0 0 1 0 2 0 3 fino a arrivare a 1 per ogni step però ci faccio anche una slip altrimenti di nuovo questo ciclo me lo risolve in un batter d'occhio e io non vedo più niente quindi faccio slip 0 punto 0 1 secondi in un secondo fa tutto il giro ok e alla fine del ciclo però quindi fuori dal for voglio fare p led punto value lo rinizio a 0 così riparto tutte le volte perché allora il i pull suite modulation led gli puoi dare valori fra 0 e 1 ok noi abbiamo fatto 100 step perché se tu vedi la variabile val va da 0 a 101 non compreso quindi da 0 a 100 facciamo 100 step e ogni step dormiamo un centesimo di secondo ok torna proviamo a vedere se funziona devo stare più avanti scusa così ecco io il python lo odio per questi motivi purtroppo proviamo un po' a vedere cosa succede diciamo run e vediamo il led da me si vede abbastanza bene che parte basso va un pochino più alto quindi abbiamo ottenuto qualcosa di simile analogico con un pin digitale vedete che il led si abbassa e poi si rialza si abbassa e poi si alza si quando lo spegnete dovrebbe rimanere in uno stato vediamo un po' esatto quando lo spegni rimane possiamo provare a vedere cosa cambia se abbassiamo la frequenza dell'onda proviamo a mettere 50 invece che 500 quindi nella creazione della classe invece che 500 mettiamo 50 e vediamo se cambia qualcosa ancora 50 hertz non ci accorgiamo di niente sinceramente perché poi come dicevo dipende anche dall'inerzia del led se mettiamo 5 hertz ecco 5 hertz vedete come sbarella lì si vede davvero che gli step cioè l'onda quadra in realtà non la risolve più come una media ma la risolve un po' esatto esatto noi non senti che se vediamo 1000 di red si anche 1000 non so fino a quanto vada la frequenza di questi pull suite modulation ma chiaramente più la frequenza è alta e migliore dovrebbe essere lo smooth quindi la parte dinamica che vediamo bene come? lo smooth si anche l'occhio è vero che abbiamo un'inerzia nostra interna allora il pin 12 se non è configurabile come pull suite modulation ti dà un errore la libreria sicuro ma i danni no nel senso no no i danni li puoi fare lo sai come con i circuiti quando crei il circuito poi dicevo prima stare attenti fare cortocircuiti non mettere resistenze quindi chiedere troppa corrente alle porte quelli possono essere danni ma via sotto abbiamo scelti perché in base al led la caratteristica della sua resistenza interna 3,3 volt abbiamo detto per avere una corrente che dall'interno del led deve stare su 3 4 5 mA abbiamo regolato la resistenza ci sa da data sheet che un led normale come questi va sui 5 massimo 10 mA se ne dai di più un casotto si non sbagli si esatto però ecco l'idea è proprio quella lavori con il data sheet dici si si lavori con il data sheet c'è scritta la corrente massima che ti fa passare lì dentro e tu la regola esatto sai che c'hai 3,3 e dici che è il limito a con quella da resistenza ok metto in ok dicevo abbiamo terminato l'esercizio con pulse with modulation per gestire il led in maniera quasi analogica e adesso facciamo quindi un nuovo esercizio quindi switcho di nuovo sulle slide le slide queste qui esatto e adesso invece proviamo a gestire il general purpose input output in input non in output perché nell'esercizio attuale abbiamo fatto sempre usato il general purpose in output per accendere un led ora invece li usiamo in input andando a recepire una pressione sul tasto allora per recepire una pressione sul tasto andiamo a vedere come può essere fatto il circuito perché chiaramente dobbiamo collegare un pulsante e cercare da questo di ricevere il segnale allora sposto un attimo scusate questo perché altrimenti ecco no faccio un attimo così no no torno torno è perché ho dovuto modificare un attimo la slide perché sovrapponeva un pezzo di circuito quindi non si vedeva adesso turno ecco ho dovuto spostare la finestrina del codice altrimenti ci sovrapponeva con un po' del circuito non capivamo sì ho visto che ci ha consigliato una documentazione sul pin out l'ha messa nella chat allora vi dicevo come cercare di reagire alla pressione di un tasto l'idea è mettere un tasto un tasto di tipo push quindi non un interruttore stabile uno switch ma è un tasto push che fin tanto che tieni premuto con il dito chiude il circuito appena lasci il circuito si riapre allora questo è un classico tasto di tipo push e lo vediamo rappresentato qui nella slide da questo simbolo normalmente è aperto il collegamento quindi se io non premo il collegamento è aperto come faccio il collegamento per poter recepire la pressione di un tasto allora intanto devo scegliere anche qui un pin di general purpose input output abbiamo scelto insieme a Paolo GPO21 che vedete qua nella slide il GPO21 è collegato tramite il pulsante al ground in realtà esistono due modi per lavorare con i pulsanti pulsanti collegati al ground o collegati a 3V3 dal nostro punto di vista è identico bisogna però configurare i pin in un certo modo perché perché affinché la CPU si accorga dell'arrivo di un segnale su un pin general purpose input output si deve essere un cambiamento di stato cioè il pin può essere normalmente alto quindi sta sempre a 3V3 e la CPU si accorge quando diventa 0 ok come faccio a portare un pin che sta a 3,3 volte 0 lo collego alla massa quindi quando io premo il tasto il circuito si chiude il mio pin 21 che era impostato alto arriva a 0 ecco che la CPU si accorge del segnale riceve un interrupt quale potrebbe essere l'alternativa perché funzionerebbe identicamente se io ti messi il pin normalmente a 0 e quando premo il portante lo porto in alto lo collego a 3V3 funzionerebbe allo stesso modo e la CPU salve no sono io che ho rubato l'aula per un'ora quindi Ferretti lo trova nella Turing da prima da giù sì niente no mi dispiace che ho fatto questo sopruzzo dicevo quindi il pin il segnale la CPU lo può ricevere sia se il pin passa da alto a basso sia se passa da basso a alto è una nostra scelta come operare proprio perché i pin sono configurabili sia per essere normalmente alti o normalmente bassi ok noi abbiamo scelto di tenere il pin normalmente alto e quando premiamo il pulsante il pin viene contocircuitato sulla massa e quindi va a zero esatto se voglio fare il contrario devo tenere normalmente il pin basso il filo del tasto lo collego al 3v3 quando premo mi va alto ok la Raspberry ci permette di fare questo come tutti i microcontrollori ci permettono di gestire segnali in input cambiamenti di stato da basso a alto e da alto a basso come si fa a tenere un pin normalmente alto o normalmente basso esistono delle resistenze interne al pin già presenti dentro la Raspberry che si chiamano resistenze di pull up o pull down che essenzialmente sono delle resistenze attivabili via software che la resistenza cosiddetta di pull up va verso 3v3 quindi mantiene la tensione del pin a 3v3 se abilito quella il mio pin rimane alto perché la resistenza di pull up è collegata fra 3v3 e il pin e quindi il pin normalmente è alto se io invece abilito la resistenza di pull down interna disabilito quella di pull up e abilito automaticamente una resistenza che va da massa al nostro pin che abbiamo scelto quindi sarebbe questo il circuito se io faccio il mio pin il mio filo che scelgo se abilito la resistenza di pull up questa resistenza che abilito via software è collegata a 3.3v e quindi questo filo qui diventa 3.3v ok questa resistenza di pull up che è presente internamente ai pin è una resistenza molto alta quindi fa passare pochissima corrente se al pin non c'è attaccato niente il pin lo leggete a 3.3v di tensione perché questa resistenza fa passare una minima corrente e qui ho la stessa tensione che c'è di qua praticamente se però io qui attacco un ground il ground assorbe tantissimo qui passa poca corrente e la tensione qui va a zero quindi la resistenza di pull up praticamente non incide sul cambiamento di stato ma incide sullo stato a riposo perché è molto grande come resistenza se invece io voglio mantenere un pin normalmente basso la resistenza di pull down a questo punto quindi disabilito la resistenza di pull up abilito la resistenza di pull down che però va verso ground è sempre una resistenza molto grande che è nel pin normalmente a zero se applico una tensione a quel pin il pin però viene immediatamente portato alto perché quella resistenza non ha la capacità di far passare tanta corrente per tenere ancora basso il pin non so se mi sono spiegato queste resistenze di pull up e di pull down sono comprese dentro il pin non dobbiamo mettere noi nel circuito noi li dobbiamo solo abilitare come si abilitano vedete adesso faremo questo esercizio vedete qui questa sintassi noi andiamo a creare una classe button che è una classe di libreria sul pin 21 e diciamo pull up uguale a true cioè gli diciamo attiva la resistenza di pull up interna attivandola vuol dire che quel pin se è libero quindi se non gli si attacca niente sta a 3,3 perché è collegato a questa resistenza attivabile via software molto grande che lo cortocircuita con 3v3 quindi lui rimane a 3v3 fin tanto che è libero però se io ci applico un ground lui si abbassa perché quella resistenza è talmente grande che non riesce a sopperire alla corrente che viene assorbita da ground ok io qui potremmo scrivere anche pull up falls se metto pull up falls mando la resistenza al contrario ok poi c'è un altro parametro che adesso andremo a vedere che si chiama Bonstine che dice praticamente è una soglia chiamata di isteresi sulla variazione di stato del mio pulsante perché mi serve una soglia di isteresi perché il contatto del mio pulsante può avvenire in maniera non istantanea anche sporca allora io non voglio che ogni volta che premo il pulsante se il contatto è un po' sporco io in realtà reagisca a 5 eventi 6 eventi allora ci metto una resistenza di isteresi per dire dopo il primo evento stai 0.1 secondi sordo quindi vuol dire che se il contatto continua a sporcarsi tu dopo che hai ricevuto il primo evento in realtà stai sordo per 0.1 secondi e questo è importante si usa proprio perché la pressione di un tasto a mano così può generare delle oscillazioni di rimbalzi anche addirittura quindi il contatto si chiude velocemente e quindi genererebbe tanti eventi ma io ne voglio beccare uno solo ok quindi grazie a questo parametro di rimbalzo cioè un tempo in cui il mio CPU rimane sorda all'evento una volta ricevuto l'evento per 0.1 secondi altri eventi non vengono processati su quel PIN e questo mi permette di avere una reazione al PIN molto più pulita non so se mi sono spiegato adesso proviamo a vedere questa questa funzionalità quindi proviamo a gestire questo PIN sì perché ripeto il nostro processore riesce subito a una versione di stato da basso da alto verso basso ma se il mio contatto è un po' sporco e quindi non è decisa l'on off del pulsante cosa succede? che lui reagisce e poi magari c'è di nuovo un cambio reagisce reagisce reagisce e io ho premuto una volta il tasto ma in realtà la mia CPU mi dice hai premuto 4 volte la volta dopo hai premuto 3 hai premuto 2 capite? rimane un sistema sporco allora mettendoci questa soglia di isteresi che è configurabile come tempo in cui dopo il primo evento ricevuto stai sordo in questo caso stai sordo per 0.1 tutto ciò che di sporco rimane subito dopo viene ignorato poi quando scade il time out 0.1 di nuovo torna la possibilità è chiaro che se il tasto è fatto per essere premuto a mano non è che 0.1 non ci danneggia chiaramente il tempo perché non è che possiamo premere il tasto così rapidamente semplicemente ci toglie una sporchizia sul segnale quindi esatto si metteva il circuito adesso lo puoi fare via software così quindi diventa anche molto più semplice allora torniamo alla nostra raspberry facciamo di nuovo un new new file andiamo subito a dare un nome lo posso chiamare bottone python e bottone punto python andiamo anche qui a usare rom general purpose input output 0 io uso con soddisfazione questa libreria però diciamo non è l'ultima da general purpose input output 0 andiamo a fare l'import di button la classe button che ci serve ah non ci serve però importiamo no facciamo import scusate di signal questo serve per mettere in pausa l'applicazione così che non termini immediatamente ho visto che spesso viene usata nelle applicazioni per raspberry per mettere in pausa l'applicazione vediamo come funziona quindi facciamo import di signal ok cosa ci serve allora ci serve definire definisco una callback vedete cosa si intende per callback si intende una funzione che viene chiamata in risposta in risposta a qualche evento e noi quindi definiremo una funzione che sarà chiamata in risposta alla pressione del nostro tasto quindi quando si preme il tasto questa funzione viene eseguita e lì ci potete mettere tutto il codice che volete alla fine perché voi avete definito una funzione complessa quanto volete che verrà invocata ogni volta che il tasto verrà premuto quindi definiamo questa funzione di callback def la chiamiamo pressive due punti e poi la implementiamo cosa fa questa funzione niente facciamo una print ci basta una print che ci dice bottone premuto per noi la funzione sarà banale l'unica cosa che farà farà una stampa questa è la callback che abbiamo definito adesso dobbiamo capire come associare la callback a una pressione del tasto perché la callback è semplice va bene però dobbiamo associarla alla pressione del tasto quindi per prima cosa creo una classe come un'istanza dell'asse button sul general purpose imputato 21 che è appunto il pin sul quale Paolo ha connesso la nostra in questo caso abilito la resistenza abilito la resistenza di pull up e definisco un definisco un'esteresi di rimbalto di 0.1 secondi questi sono i parametri che abbiamo scelto di utilizzare quindi button prende button il il general purpose imputato è il 21 pull up diventa true e definiamo l'isteresi come bonus time 0.1 questa è l'inizializzazione dell'istanza button così come c'eravamo proposti bene adesso però non abbiamo ancora associato l'azione cioè la nostra callback all'azione di pressione del nostro tasto il tasto è pronto è configurato quindi il pin general purpose input 21 è stato configurato in input ricordiamo che può essere input in questo caso è stato configurato in input è stata attivata la resistenza di pull up quindi il pin è salito già a 3,3 volte ed è stato messo un filtro di estersi a 0,1 secondi quindi adesso appena questo pin viene portato a 0 in qualche modo la CPU reagisce però dobbiamo associare quindi devo associare la pressione del tasto al alla callback da me definita l'ho definita sopra ma ora la devo associare molto facile perché basta dire button che è appunto la mia istanza punto when underscore pressed gli assegno il nome della mia funzione che è pressed la funzione definita in cima si chiama pressed e assegno a when underscore pressed di button pressed molto semplice e poi qui mettiamo blocco il programma per non farlo terminale e spesso si usa appunto questa libreria signal punto pause pausa sì dimmi tu sì sì ma allora queste libreria hanno tutta una documentazione sì sì io vi dico se voi andate se scrivete sì se voi scrivete su google general purpose input to zero classe button c'è tutta la documentazione possibile immaginata c'è una valanga di informazioni considerate che questa è davvero molto diffusa la gp0 che sto usando io non è l'unica è anche eh se guardate su internet c'è un sacco di roba sì sì ti suggerisce tutto ma sono comodissimi qui bisogna un po' rendarsi quando si lavora con il sistema embedded è un pochino più ah certo aspetti il completamento poi spesso provi cosa farà questo metodo bene adesso possiamo vedere se funziona facciamo un save facciamo un run l'app non dovrebbe terminare adesso andiamo a vedere se quando premo il tasto che è questo che ho fatto qua dice bottone premuto sì sta funzionando sì se vogliamo possiamo far accendere il led sì se vogliamo nella funzione pressed possiamo scrivere no possiamo scrivere qualcosa nella funzione pressed tipo accendi il led sta funzionando come vedete la funzione l'invocazione pause di signal non fa mai terminare l'applicazione quindi app non termina più e dobbiamo fare top se la vogliamo abbattere no gli puoi dare una sola funzione una sola callback sì all'interno della callback dopo quello è una funzione degli effetti puoi invocare altre funzione puoi fare tutto quello che vuoi però la callback è unica e se proviamo a cambiare il bounce time mettere 0 1 mettiamo 0 0 1 mi aspetto che il segnale sia molto più sporco nel senso che quando io premo una volta ma magari lo vedo anche apparire no non si è sempre abbastanza pulito mi sa rimane abbastanza pulito ah no ecco infatti adesso se non premete in maniera decisa mandate giù piano piano ecco me ne ha fatti tre di stampe io l'ho abbassato tantissimo se non premio in maniera decisa eh sì hai fatto le ciro vedete il bounce time serve proprio per quello per individuare una pressione piuttosto che n lo rimettiamo a 0 1 e qui anche se vado giù poco deciso in realtà con 0 1 mi devo fare un'idea di domenica poi sì se noi facessimo come suggeriva un vostro compagno possiamo anche fare from general panel così input output 0 facciamo l'import di led lo devi tenere premuto 8 secondi abbiamo fatto l'import di led dopo aver creato un button andiamo anche a creare un oggetto led quindi led prende led su general purpose 4 facciamo la prova così nella death preced facciamo led on sì mi sembra di sì però anche dobbiamo guardare la documentazione perché non me lo ricordo led tu che c'hai la documentazione vedi un po' se c'è modo di sapere se è già acceso spento possiamo gestirlo noi con una variabile e ogni volta generare lo stato ecco però ecco banalmente posso fare led punto on quindi if led punto is is con l'et così l'et if if se se non si facciamo led toggle se è spento lo accende se è acceso lo spegne quindi invece di fare qualcosa qua possiamo fare no così dovrebbe funzionare vediamo un po' se è vero save run messaggio così funziona perché led toggle cambia lo stato se è acceso lo spegne se è spento lo accende sì a me funziona quindi se il led è acceso lo spegne se il led è spento lo accende sì però abbiamo creato una sorta di di relay bistabile nel senso che non sarebbe questo panale un relay che praticamente tu accendi e poi senza dargli più impulso rimane acceso lo spegni senza dargli più impulso rimane spegne una sorta di relay bistabile con due spati stabili o ne ho sì o meglio se il bounce time invece che 0-1 lo metti 0-0-1 e non sei deciso nella pressione del tasto vedrai che gli eventi ne vengono recepiti più di uno quello serve proprio a filtrare eventi spuri diciamo così che non sono voluti e comunque se date un'occhiata come diceva il vostro compagno alle librerie vedete che ci sono tanti altri parametri che possiamo specificare sia nei sistemi il pull up dei bottoni che non nella libreria led e quindi gli dice anche no ma infatti è davvero semplice creare appunto gestire led con queste librerie python che per fortuna sono di altissimo livello quindi vanno benissimo per chi produce scrive codice proprio per un device IoT noi non è che vogliamo scendere nel dettaglio della programmazione del device noi vogliamo produrre qualcosa che ci sia utile per raccogliere informazioni per fare attuazione eccetera direi che per oggi possiamo finire qui la prossima volta che sarà di nuovo martedì martedì faremo ancora l'esercitazione su Raspberry Pi perché proveremo martedì proveremo a leggere sensori analogici visto che la nostra Raspberry Pi come vedete sullo shield c'è anche un integrato quel chip lungo con tutti i piedini quello è un integrato è l'MCP 3008 l'MCP 3008 che è un ADC esterno perché l'ADC la nostra Raspberry non ce l'ha ok l'ADC serve per campionare un segnale analogico al nostro chip ADC è collegato sia un sensore di temperatura che è uno di quei cipettini neri con tre pin che vedete sopra che si chiama LM35 che è un sensore analogico di temperatura e sia una fotoresistenza invece che vedete vicino quella cosina bianca con una serpentina sopra sembra che abbia un disegnino a serpente bene quella è una fotoresistenza è una resistenza che cambia la sua resistenza interna in base alla luce che la colpisce vedremo i circuiti analogici che abbiamo gestito e vedremo anche come campionare con l'ADC su questo pin l'ultima cosa che vedremo se fate caso nella scilla a un certo punto c'è un morsetto blu con due con due viti lo vedete quel morsetto blu quel morsetto blu diciamo così vi servirà a collegare un carico ad alto consumo io vi ho detto che le periferiche le porte general purpose input output non sono fatte per produrre tanta corrente quindi fin tanto che con una general purpose ci voglio accendere un led va bene ci voglio accendere un buzzer per fare un blip va bene se io ci volessi accendere una ventola o ci volessi accendere un motorino qualsiasi passo passo la porta general purpose non funziona più potrei bruciarla proprio perché lei è limitata a pochi milliamper allora cosa abbiamo fatto abbiamo fatto un circuito con un transistor che vi spiegano la volta prossima così il transistor prende la potenza direttamente dall'alimentazione e con il general purpose inputato semplicemente accendiamo chiudiamo chiudiamo chiudiamo il transistor ma la corrente non la produce il general purpose ma la passa direttamente dall'alimentazione attraverso il transistor esatto allora cosa vuol dire su questa su questa presa dove ci sono le vitine lì ci possiamo attaccare un carico ad alto consumo perché l'energia la prende direttamente dall'alimentatore non la prende più dal general purpose input output ok adesso qui apriamo le viti e ci mettiamo i fili di un la posizione delle ventole prendiamo una ventola per una e vediamo che riusciamo ad accendere una ventola se noi collegassimo la ventola direttamente dal general purpose input output la corrente non sarebbe sufficiente ah beh ci puoi mettere tanti transistor questo è un transistor unico ma ci sono chip integrati con 20-30 transistor hanno tante porte e a ogni porta ci colleghi una ventola diversa oddio se l'alimentatore è qualche ampere insomma l'alimentatore bisogna potenziare dopo quel punto anche l'alimentatore che l'alimentatore della raspberry è un potentissimo sì sì passa nella shield e prende la corrente direttamente dall'alimentatore quindi devi avere poi un alimentatore dimensionato questo è un alimentatore che verso fino a una ventola un motorino li regge dopo ci mettiamo sopra qualcosa di troppo forte però ecco con quel circuito con un transistor in realtà tu puoi accenderti anche una stufetta con la raspberry perché se hai potenziato bene l'alimentazione ci metti no per fare quello ti conviene usare dei relais piuttosto che dei transistor il transistor è a costo molto basso però è meglio usare un relais perché il relais poi esatto il relais è un contatto pulito invece il transistor non è un contatto pulitissimo perché qualcosa non passa sempre invece con il relais esatto poi dopo c'è una sua resistenza interna invece il relais è perfetto perché è meccanico tutti gli interruttori sono off sono fatti con il relais non so se se li avete in casa quando li attivi senti clac clac e il clac è perché il relais ha appunto una massa che ti sposta che va a fare contatto quindi se avete un carico un carico serve un relais un relais che vi dà un contatto pulito qui per fare un esempio senza andare a montare un relais su ogni cosa abbiamo messo un transistor che va benissimo per il nostro esempio per carichi abbastanza bassi i transistor va bene ok io direi che oggi possiamo terminare qua quindi sospendo o meglio interrompo la registrazione quindi per fare vi