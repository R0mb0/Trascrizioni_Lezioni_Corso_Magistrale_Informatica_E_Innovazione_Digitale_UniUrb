Ok. Dunque, riprendiamo un attimo le fila di quanto è ben discusso la settimana scorsa, in cui vi ho prima introdotto il concetto di età e del dirigente, poi dopo, nella seconda lezione, abbiamo iniziato a capire quali sono i primi algoritmi che vedremo in questo insegnamento che andremo a imbeddare, a mettere dentro il nostro argentino intelligente perché, dato un certo obiettivo che gli viene fornito, ci fornisca la soluzione. Abbiamo introdotto così problemi di ricerca, che sono quei problemi che forniscono come tipo di soluzione e un insieme di azioni da svolgere per raggiungere l'obiettivo. Dopodiché vi ho sostanzialmente spiegato in che modo possiamo definire un problema di ricerca e su questo abbiamo dedicato abbastanza tempo, perché la descrizione del problema di ricerca è in realtà il punto di partenza per tutto quello che viene ora, come successivo argomento, in cui a partire dalla definizione del problema noi dobbiamo trovare questa soluzione, quindi questo insieme di azioni che svolge per raggiungere l'obiettivo facendo una ricerca su quello che è lo spazio degli stati, che abbiamo presentato come l'insieme degli stati che descrivono il problema, ovvero in cui il mondo su cui ci stiamo muovendo, noi argentini, agiamo, si può trovare. Ok? Io poi, nei due gruppi di ricerca, abbiamo tradotto un momento di lavoro molto chiave, che è la strategia di ricerca, ovvero la strategia secondo la quale una volta che abbiamo definito l'albero di ricerca o il grasso di ricerca che abbiamo spiegato la volta scorsa la distorenza, in un caso abbiamo un memoria degli stati già visitato, in un caso non la deniamo, questa valoria, e dobbiamo capire nel nostro albero di ricerca, abbiamo disegnato un insieme di, abbiamo fatto diversi esempi, e posso ripetere, qual è il nodo da espandere ad ogni interazione. Ok? E quindi oggi cominciamo a ragionare un pochino meglio su questa cosa, assumendo di aver chiaro che cosa sono i problemi di ricerca, e tutti vedete questi elementi chiave che sono appunto il concetto di espansione di uno stato, di un nodo, il concetto di albero di ricerca, il concetto di nodi foglia, e il concetto di frontiera. Ok? Allora, la volta scorsa ce l'avamo fermati qua, sostanzialmente, in cui abbiamo detto va bene, abbiamo descritto bene il nostro problema, abbiamo capito cosa è l'albero di ricerca, abbiamo capito in che modo si differenzia dal grafo di ricerca, e adesso cerchiamo di proporre una prima strategia di ricerca. E ci eravamo fermati qua, con questo pseudocodice, che come vedete è abbastanza ricco e complesso, e quindi mi sembrava opportuno discutere e affrontare una relazione a parte. Allora, questo è un algoritmo che vuole, in un momento, essere il più generalista possibile. In realtà vedremo, tra un attimo, in alcune delle migliori istituzioni che si propone questo tipo di problemi di ricerca. Problemi di ricerca che noi definiamo generalmente, problemi di ricerca in cui possiamo, guardate qua, definire, oltre al problema, un qualcosa che vedete qua essere un certo F, un F che è una funzione, una funzione che in qualche modo mi dà una misura della bontà del nodo in cui mi trovo. Allora, non vi voglio dire nulla di più. Prendete quell'F come una misura della bontà del nodo in cui mi trovo nella ricerca, nell'albero, quindi ogni albero di ricerca, e il nodo che sto visitando in quel momento, che ho espanso e che sto analizzando in quel momento. Perché non vi voglio dire nulla di più? Perché a quell'F vedremo, dalla lezione di oggi, quella di domani, che può essere calcolato in diversi modi. Quindi sarà proprio quell'F che in qualche modo distingue, per esempio, tra ricerca informata e ricerca non informata, eccetera. Ne parleremo comunque. Per il momento sui anni, quell'F è una funzione che in ogni nodo, quindi un F di N, dove è nel nodo, mi restituisce un numero, vi direi reale, non necessariamente deve essere un numero intero, un numero reale in quale dice quanto è buono per noi. È proprio questo valore qui, che mi restituisce con la funzione di F di N, che io posso utilizzare per ordinare chi dà il più buono al meno buono. Può dare una semantica a questo concetto di buono, che appunto per il momento volutamente rimango generale. Vediamo un attimo però dove viene utilizzata quella F e perché potrebbe essere importante e soprattutto perché questa ricerca si chiama Best First. Sottolineo, gli algoritmi di ricerca di base si differenzieranno, per risottolineo per cercare di sedimentare questo aspetto, per la scelta del nodo da espandere. Quindi tutto il resto rimane uguale. Tutto quello che si sentite la settimana scorsa è condiviso da tutti questi algoritmi che vedremo in questa settimana. Quello che cambia è la comprensione appunto di quali sono gli elementi che ci portano a definire il nodo successivo da espandere. Quindi guardiamo brevemente questo algoritmo che quindi si prende in ingresso il problema, l'abbiamo descritto la settimana scorsa, quindi uno stato iniziale, uno stato obiettivo, un insieme di stati che appunto descrivono lo stato del mondo e come questi stati sono tra loro collegati. Vi ricordo il grafo degli stati, ovvero noi a priori sappiamo nella descrizione del problema che da uno stato possiamo, per esempio da questo stato qui, possiamo finire a seconda dell'azione che svolgiamo o nello stato a fianco, questo qui, se andassi a destra, o rimanere lì, oppure finire in questo stato giusto. Quindi noi sappiamo per ogni stato quali sono le azioni che posso svolgere e quali sono gli stati in cui finisco se eseguo una di queste azioni che posso svolgere. Quindi, dato il problema, dove è? Scusate. Dato il problema e data questa F, partiamo. Il primo nodo sappiamo, ve lo ricordo, che è sempre lo stato iniziale, quindi il nodo più in alto dell'albero di ricerca è sempre lo stato iniziale. E introduciamo il concetto di frontiera, quindi questa struttura dati, quindi inizializziamo una struttura dati che è una coda con priorità. E guardate qui, sottolineo questo punto qui, ordinata in funzione di F. Quindi F la utilizzo per ordinare i nodi all'interno di questa frontiera. Quindi ho una struttura dati che conterrà dei nodi che sono non più first in, first out, come abbiamo discusso l'altra volta, come vi ho detto, oppure la first out, sono grandissimi, che quei nodi nella frontiera li posso ordinare in modo svariato. Se li ordino sulla base di F, ottengo una frontiera ordinata. Ovviamente, nella fase di inizializzazione, dentro questa frontiera, io ci metto solo il nodo di campena creata che non è iniziale, che rappresenta lo stato iniziale. In questo tipo di ricerca, guardate bene, c'è un'altra struttura dati fondamentale, che è la struttura dati che viene qui chiamata RICD. In quella struttura dati andrò a mettere, è un, la posso rappresentare con una table, una recap table, va bene, in cui andrò a mettere tutti i nodi che ho già visitato. Questo l'abbiamo introdotto la settimana scorsa e vi ricordate perché lo facciamo? Perché creiamo quella struttura dati? Per evitare il loop. Tutto quello che abbiamo visto è inutile che lo rivisichiamo, è inutile che stiamo lì a muoverci ciclicamente attraversando degli stati che abbiamo già visto. O sono una soluzione oppure no. Ok. In questo caso, ci sarà sempre, anche in questo caso, in fase di inizializzazione, un solo nodo che è ovviamente quello che corrisponde allo stato iniziale. Benissimo. Allora, l'algoritmo procede in questo modo. Finché la frontiera non è vuota, che cosa faccio? Dalla frontiera prendo il primo nodo che a questo punto abbiamo visto che per come sono stati ordinati i nodi nella frontiera è il migliore usando la metrica F. Quindi per quella che è l'euristica, la funzione F, quel nodo lì è il migliore. Lo espando. Cosa vuol dire espandere il nodo? Scusate, prima di espanderlo verifico se è un nodo che, scusate, uno stato che quel nodo rappresenta è lo stato obiettivo. Se fosse lo stato obiettivo lo restituisco. E quindi sostanzialmente termino la ricerca. Nel caso in cui non lo sia lo espando. Che cosa vuol dire? Che per quel nodo vado a vedere quelli che sono possibili stati che posso raggiungere da lì. Ok? Ciascuno di questi nodi, guardate un attimo l'algoritmo perché qui c'è un elemento importante. Allora, prendo i figli di questo nodo. Ok? I figli, ripeto, sono gli stati che da lì posso raggiungere effettuando le varie azioni che sono consentite e che trovo nella descrizione del problema. Quindi nel mio problema nella descrizione ho il modello delle transizioni e vedo quali sono le azioni che posso fare da questo stato qui le azioni e in conseguenza ho le informazioni sugli stati che raggiungo. Benissimo. Allora, li prendono alla volta questi stati figli. se S è già stato è uno stato che ho già visitato e che me lo dice vado a vedere la struttura dati ricide e li ho memorizzato tutti quelli che sono gli stati che ho già visitato. Se l'ho già visitato come vi abbiamo detto un attimo fa non lo vado a rivedere perché è più difficile rivederlo l'ho già visitato non mi serve. Ok? Quindi se non è tra gli stati visitati oppure e questo è un punto cruciale perché è una cosa nuova di scelare più o meno in qualche modo all'imagine di sucrose questa è una cosa nuova ovvero faccio questa misura qua per quel figlio computo il costo del percorso Pat Cost è dato ve lo ricordate anche questo un po' al mio visto ma ve lo rifaccio migliere per esempio la puntiato allora dopo accendo la telecamera così vedete questo che sto facendo supponiamo che S1 è lo stato che non si faccia il figlio così riuscite a seguirmi meglio ok allora assumiamo che S1 sia il nodo che trovo come primo nodo della mia frontiera ovvero quella che al momento ha il posto alla funzione di questa funzione che misura la quantità di quel nodo sto cercando di essere guarda perché vedremo come la funzione evolve nelle settimane e gli daremo sempre dei nomi diversi specifici a seconda del problema però abbiamo capito che è una misura di qualità potrebbe essere una funzione costo che vogliamo minimizzare potrebbe essere una funzione euristica che vogliamo massimizzare capiremo benissimo S1 è quello che soddisfa quel criterio lì per cui lo proviamo ad espandere e vediamo che subito come primo stato nell'espandere potrebbe essere successo S3 allora abbiamo detto che la prima cosa che faccio è andare a vedere se S3 è già stato visitato non lo è è possibile quindi benissimo ci interessa la seconda cosa che faccio è misurare il percorso di questo il per posto per raggiungere questo stato quel child.pack pack posto cosa vuol dire che misuro quanto mi costa arrivare qui da chi non dovevo iniziare a stare partendo e quindi qui il pack post è dato da che cosa da C1 più C3 ok quindi da tutti i costi delle azioni che ho eseguito per poter in tutto il percorso appunto per poter raggiungere dal nodo iniziale il nodo affinché mi trovo adesso lo stato che mi trovo adesso ok allora perché ci sto guardando perché come vedete quello che poi faccio è fare un confronto tra questo costo qui ok e il costo che ha il percorso il costo che ha il percorso per raggiungere lo stesso nodo S3 ok per raggiungere lo stesso nodo S3 assolutamente che sia nella frontiera perché faccio questa che sia nella scusate una struttura dati reached perché faccio questa cosa dobbiamo capire il senso di quella di quella seconda verifica quindi se non c'è va bene ma potrebbe anche esserci oppure io faccio una verifica giuntiva esattamente ovvero io potrei averci S3 nella frontiera non è questo il caso esatto non è la frontiera del reached ok la lista dei nodi già visitati potrei avercelo però potrebbe anche essere che io quel nodo S3 l'ho raggiunto per un percorso molto più costoso e non dico lungo appositamente molto più costoso e allora ok l'hai visto ma forse quel percorso più costoso mi conviene dimenticare mi viene invece tenendo tra genomore di questo nuovo percorso che scopro essere più conveniente chiamiamolo così più buono più conveniente va bene ok quindi se sono in una questione o non l'ho visitato oppure lo sto raggiungendo ora da un percorso più conveniente ok scrivetelo e memorizzatevela così allora lo visito completamente cosa vuol dire visitarlo completamente vuol dire che per quello stato mi crevo un nodo nel mio albero di ricerca e aggiungerò col stato nel quel nuovo nel ricordato nella differenza tra stato in oro lo aggiungerò nella struttura dati ricide e lo aggiungerò nella fruttura per il carico prego prego si allora sicuramente viene la verifica del costo la verifica del costo devo far comunque assolutamente per i figli la devo far comunque perché anche se sono stati raggiunti potrei appunto raggiungerli per un percorso più conveniente esattamente a quel punto non vedete che sono un percorso dimentico quello passato ok sulla funzione expand non aggiungo altro perché l'abbiamo già discusa una volta scorsa questa vi sottolineo solo per ricordarvelo che effettivamente guardate qui c'è quello che vi dicevo voce un attimo fa il costo che è ciò che viene associato a ciascuna e una delle proprietà dei nodi il nodo è una struttura adatti un po' più ricca non è solo lo Stato contiene tante informazioni tra cui chi è il padre chi sono i figli quindi dei puntatori diciamo così al padre nell'albero di ricerca o nel grafo di ricerca in questo caso è un grafo perché ha quella famosa struttura adatti e il puntatore ai figli e un valore che corrisponde al costo del percorso fino a quel punto chiaramente quel valore in questo caso una volta che ho espanso un nodo va tornato per si prende il costo dello Stato padre del nodo padre e a quello lì si aggiunge il costo dell'azione che il nodo padre mi ha portato al nodo figlio ok è questo qua quindi il costo di quest'azione qua che da S mi porta in S' per effetto di quell'azione lì ok quindi che cosa vi sto dicendo rispetto alla guarda scorsa vi sto dicendo che potrebbe darsi il caso che per scegliere quali nodi espandere io posso voler introdurre questo concetto di funzione che quantifica e quantifica la volontà di un nodo ok e sulla base di quel valore lì effetto la mia scelta di quale nodo espandere il fatto che si chiami best first credo non a questo punto vi stupisca quindi quale spando il migliore il primo migliore ok quindi qui ho riferito due cose nuove quale spando il concetto di migliore di funzione costo di funzione che mi qualifica la bontà di un nodo e un'altra cosa ovvero il fatto che a quel punto diventa importante memorizzare quanto che è costata fare per un percorso alternativo rispetto al percorso che è già memorizzato nella struttura da diritto questo è importante perché appunto da questo concetto di best first noi vogliamo memorizzare sempre il percorso migliore questo è fondamentale perché guardate un attimo nella slide successiva cosa vi racconto allora quando noi dobbiamo scegliere quale strategia di ricerca a questo punto utilizzare il nostro problema io ve ne presenterò guardate solo oggi ho in mente se riesco di presentarvene una due tre quattro solo oggi con domani ve ne presento almeno altre due tre già cominciano ad essere allora qualcuna di queste scelte è vincolata dal tipo di problema e tra un attimo vi introdurrò al primo gruppo di problemi che sono i problemi non informati poi domani parleremo di problemi informati questo in qualche modo ci obbliga a scegliere tra alcune strategie piuttosto che altre ma non è l'unica regolamento di scelta che abbiamo perché quando noi descriviamo la strategia di ricerca possiamo valutare in base diverse sapete che è ovvero innanzitutto la completezza questo cercate di memorizzarlo perché è una cosa che ci porteremo dietro che è la completezza ovvero la completezza risponde alla domanda questo algoritmo mi fornisce una soluzione se ovviamente il problema ha una soluzione questa è una cosa che ci porteremo dietro molto perché interverrà quando parleremo di algoritmi di inferenza hanno i problemi di logica ok quindi questo algoritmo è completo ha la proprietà di essere completo sì no sì se fornisce sicuramente anche il percento quindi il 100% mi fornisce una soluzione chiaramente ripeto se questo esiste in maniera duale alla completezza spesso ci si porta dietro un concetto di ultima notte perché se cominciate a digerire un pochino questi grafi e il fatto che a ciascun nodo è associato anche un costo una soluzione qualità eccetera eccetera capirete velocemente il fatto che potresti trovare una soluzione ma non è detto che questa sia ottima nel momento in cui io vi introduco questa F e ve l'ho introdotto un attimo fa che mi qualifica una soluzione che mi dice quanto è buono un nodo va da sé che mi porto dietro quindi il fatto che alcune soluzioni possono essere meglio degli altri e sottolineo il fatto che questo concetto di meglio non è sempre lo stesso meglio potrebbe essere il meno costoso meglio potrebbe essere quello che mi fa guadagnare di più meglio potrebbe dipende da quell'è felice ok ecco sicuramente capo la soluzione costo minimo costo minimo già in grado il concetto di costo diciamo in generale la funzione è ottima per quelli che sono i miei obiettivi punto di domanda troverò questa soluzione ottima cioè l'insieme la sequenza di azioni che mi fa arrivare l'obiettivo guadagnando il più possibile spendendo il meno possibile ok questo concetto di ottimità ecco nel mondo della ricerca informatica poi intervengono degli altri elementi che quelli invece non sono di natura diciamo così associata alla qualità della soluzione che trovo ma di natura computazionale compiero quanto non si vuole una soluzione io ho fatto un albero con un branching factor questo la prima volta come lo dica a me ce l'abbiamo sotto e quindi c'è la vediamo lì però insomma iniziamo a con questi nomi il branching factor è il numero di figli che ciascun nodo ha ok assumiamo essere costante questi alberi quindi il branching factor vedete eventualmente potrebbe essere il massimo quindi tutti noi abbiamo lo stesso numero di figli in questo caso noi per esempio possiamo fare un alberi in cui c'è un alberi due figli ok quello che è il branching factor è il nuovo quello che abbiamo fatto un esempio ok immaginate un problema molto più con un descritto con un grafico di listarvi molto un branching factor molto alto eccetera eccetera fare queste operazioni di ricerca in qualche modo come vi ti diceva assoluti nella definizione di valutazione nella valutazione rivolta della funzione cost nella valutazione rivolta di qual è andato ad espandere nel fatto di mantenere in memoria già abbiamo due strutture datiche sono la frontiera e i nodi raggiunti insomma potrebbe avere una certa complessità sia di tempo che di spazio di tempo associato ovviamente a quanti nodi devo generare ed espandere e di spazio associato a quanti nodi sono costretti a memorizzare per il tipo di strategia di ricerca che sceglo per poter effettivamente alla fine del processo di ricerca fornire la sua produzione ok adesso discuteremo ovviamente sui vari esempi però ve lo sottolineo perché vi sia chiaro quando arriveremo con i vari tipi di ricerca per male di queste cose qua allora vedrete che per la time and space complexity ciò che va a fondamentale sono proprio quei valori sotto ovvero il massimo branching factor per quale motivo è facile che il tempo e la complessità e la complessità in tempo e spazio di questi algoritmi in qualche modo sia proporzionale al branching factor questo è abbastanza ragionevole tanto il branching factor tanto è più preoccupabile che sono tanti nodi che mi devo memorizzare e che per espandere tutti mi ci vogliono più questo discorso generale però mi sembra ragionabile la stessa cosa sulla possibilità se la soluzione è ottima si trova una profondità in quest'albero di ricerca superiore è evidente che mi ci è voluto un po' di più per arrivarci ed è evidente che ho dovuto memorizzare tutto quello che è là sopra in qualche modo vedremo in che modo ci sono insomma delle soluzioni diverse che riescono ad ottimizzare un po' questa cosa però sicuramente ha un impatto sulla complessità in spazio e tempo dell'algoritmo così come chiaramente la profondità massima ok tenete presente questi BDM perché ci ritroveremo tra un attimo come parametri che utilizzeremo per portare la complessità dei vari algoritmi che vediamo ok allora io passo al prossimo blocco di slide in cui iniziamo a discutere delle prime strategie di ricerca non informata per problemi di ricerca non informata se delle domande ben vengano eccoci qua allora il primo insieme di algoritmi che discutiamo un pochino più in dettaglio sono questi problemi che vengono definiti non informati quindi strategia di ricerca non informata e vediamo di capire che cosa significa non informato in questo contesto allora guardo un attimo a casa non vedo domande spero che riusciate a seguirmi ho cambiato blocco di slide ok allora vediamo la definizione allora questo problema mi ha definito queste strategie di ricerca vengono definite non informate o blind blind è interessante blind è seco perché non ho altre informazioni oltre a quelle che mi fornisce nella definizione del problema e noi nella definizione del problema abbiamo visto se vogliamo riprenderlo ve le riporto qua un attimo così almeno ecco qua guardate quello che mi interessa sottolineare in questo in questo in questo slide in cui riporto tutti gli elementi che vanno definiti quando si descrive un problema di ricerca che su ogni azione che vado a svolgere l'unica informazione che ho è quanto mi costa com'è allora ho il mio spazio degli stati per ciascun stato so quali azioni che si svolge e ho un modello di transizione che mi dice da quello stato svolgendo l'azione qual è lo stato che finisco inoltre per quell'azione lì ho anche il costo stop ok quindi voi immaginate che il problema di ricerca blind è un informato fa riferimento a un problema di ricerca di questo tipo in cui io l'unica informazione che ho è il costo speso per svolgere quell'azione allora perché viene definito blind e ve lo spiego subito e provo a farvi vediamo se ho qualche esempio qui carino allora guardate qui c'è una cosa interessante ovvero poi ci arriviamo a peralegria però mi interessa farvelo vedere subito per farvi capire in che cosa consiste questo essere blind molti dei primi problemi che vediamo oggi sono a costo diciamo sono quei problemi che utilizziamo quelle strategie scusate che usiamo quando il costo di un'azione è uniforme su tutto il problema ed è tipicamente ombra non è questo il caso perché invece in questo caso il costo è associato al chilometraggio più o meno adesso lo interpretiamo così tra una centella e l'altra ok allora il problema che avevamo visto l'altro giorno era definito in questi termini parto da rad devo arrivare a bucarest allora io posso per esempio supponiamoci trovarmi qui a Fagaras o trovarmi qui a pitesti allora quando vi dico che il problema di ricerca è blind quello che intendo è questo se sono a Fagaras o a pitesti io l'unica informazione che ho è quanto mi è costato arrivare lì quindi se sono a Fagaras ho speso 140 più 99 se sono a pitesti ho speso 140 più 80 più 97 che informazione mi manca perché viene definita blind perché io non so quanto sono distante dall'obiettivo ovvero ho computato grazie a cosa? a questa a questo path cost ho computato per quei due nodi Fagaras e pitesti ho computato quanto mi è costato arrivare fino a lì avete visto quindi il path cost cosa vuol dire? tutti i nodi che ho attraversato ciascuno hanno un suo posto l'azione per arrivare a quel nodo li ho sommate tutte e quando sono a Fagaras o a pitesti ho la memoria di quanto ho speso per arrivare fino a lì in nessun modo so però che se fossi a pitesti devo fare solo 100 più per arrivare ad assinazione se sono a Fagaras devo fare 200 questo ha un bel impatto se ci pensate perché di fatto forse diciamo così se fossi qua valuterei se mi conviene andare avanti o meno chiaramente a quel punto sarebbe più conveniente quantomeno voi vedremo in che modo viene utilizzata questa informazione chiaramente se lo scopro solo quando sono qui è già tardi però diciamo quando sono a Sibiu che mi trovo di fronte a un incrocio libero punto scegliere se andare a destra o a sinistra di fatto potrebbe essere come scelta potrebbe essere fatta sulla base dell'informazione di quanto mi manca che è quella che peraltro noi tipicamente usiamo ok ma se questa è un'informazione che io non ho come faccio punto di domanda ok quindi vi ho fatto questo esempio perché è veramente esemplificativo sulle strade lo sappiamo perfettamente che è uno dei criteri per cui decidiamo di percorrere una strada piuttosto che un'altra il chilometraggio e la distanza dalla meta ok però ancora non siamo lì non siamo ancora capaci per gli algoritmi che vediamo oggi di sfruttare questa informazione quindi questi algoritmi di ricerca vengono chiamati strategie di ricerca vengono chiamate non informate perché usano solo informazione disponibile nella definizione del problema e quindi nello specifico il costo delle azioni generano dei successori come abbiamo visto e distinguono tra quelli che sono dei successori che sono degli stati vuole oppure non sono degli stati vuole non utilizzano la conoscenza dei dominio questo vuol dire che io non utilizzo le informazioni su la mia mappa del mondo di Normania in quell'esempio e quanto ciascuna città di Stadale non hanno informazioni su quanto è vicino allo stato obiettivo sono dei problemi di ricerca esaustiva allora oggi vi faccio vedere nell'ordine il Brad First che si chiama ricerca in ampiezza viene tradotto in italiano Depth First ricerca in profondità il Depth Limited Search che è una evoluzione sia il Depth che l'iterative della ricerca in profondità vi spiegherò perché dobbiamo evolvere in qualche modo dalla versione base e poi vedremo la ricerca costo uniforme ok i primi 4 che ho citato che però non sono nell'ordine in cui sono scritti qua quindi anche essa e le ragazze di la ricerca in quantità partono dal presupposto che le azioni abbiano costo uniforme a 1 ok quindi tutte le azioni hanno costo 1 è il problema della spira polvere non so se vi ricordate ma nella spira polvere le azioni possibili da 4 a destra a sinistra pulisci tutte le azioni hanno costo 1 ok quindi si parte un po' dal presupposto che le azioni abbiano costo tutte lo stesso costo e il costo sia 1 e la ricerca costo uniforme invece vedremo che può tenere appunto anche di un costo di azioni diverse posto diverse operazioni diverse allora l'algoritmo di ricerca in ampiazza è molto semplice e se vogliamo vabbè lo sottolineiamo sia qui che nell'immagine successiva utilizza presupposto ripeto costo pari a 1 o comunque lo stesso costo guardate scritto mi spiego meglio lo possiamo usare comunque non è sbagliato usarlo anche in altri casi ma adesso scopriremo come funziona a sé usarelo garantisce ottimale la soluzione solo se le azioni hanno lo stesso costo ok quindi così spreco esattamente esattamente quindi ripeto quello che ha detto ancora meglio tutti i passi devono avere il stesso costo perché l'algoritmo si è più male adesso capiamo come funziona la strategia capiamo anche perché questo capita però è abbastanza intuitivo allora qui come vedete rispetto a quello che abbiamo visto un attimo fa quello che cambia qui innanzitutto il problema non ha una F in ingresso quindi si perde un po' questo concetto di funzione che mi qualifica un nodo la puntata di una soluzione e la frontiera è una frontiera FIFO quindi la cambia se l'altro giorno è interessato quindi il primo nodo che viene impitato dentro è quello anche che è il primo ad essere espansio ok allora la frontiera quindi è una coda ordinata quando faccio il pop mi prendo sul primo per ciascun figlio lo espando se prendo lo stato se lo stato è uno stato gol quindi obiettivo lo restituisco altrimenti se non è già stato raggiunto per evitare i famosi loop allora lo aggiungo sia alla frontiera che di RID ok vediamolo di qua perché da quell'immagine lì è insomma tutto molto ovvero partiamo dal nostro meraviglioso nodo di partenza stato iniziale che ha e lo espandiamo nei suoi due nodi figli b e c questo sostanzialmente lo dobbiamo fare sempre quella primo step è costante più o meno forse adesso no è vero non sarà così però lo espandiamo nei suoi due nodi figli in questo caso quindi breccia in fattore 2 quale espando a questo punto tra b e c punto di 90 abbiamo detto first in first out espanderò quello a sinistra b ok b lo espando nei suoi due nodi figli d e d ho quindi una frontiera adesso e sono al terzo step frontiera che è composta da tutti i nodi che sono al momento foglie di questo problema e sono d e e c frontiera ok d e e c quale espando adesso quello più a sinistra no perché non espando il d abbiamo detto first in first out tra d e e c quello che è stato inserito prima è chiaramente nella frontiera chiaramente c perché è stato inserito qua d e d sono stati inseriti dopo espando quindi c che produrrà i due figli f e g eccetera eccetera ok allora la cosa interessante come vedete qua è che prima di espandarlo questo nodo figlio che sia b che sia c che sia b qui o che sia c qua o che sia d qua che cosa vado a fare vado a verificare se è o meno uno stato obiettivo che dovesse essere quel stato obiettivo lo restituisco e nel restituire quel nodo restituisco anche nella definizione di nodo tutto il percorso che lo ha portato fino a lì e quindi cosa riscrivo la soluzione del problema cioè le azioni che ho svolto per raggiungere quel nodo allora volevo un attimo farvi vedere una cosa vabbè ci guardiamo dopo su questo ok allora vediamo un attimo adesso mi viene non ho molto altro da dirvi questa ricerca in ampiezza lo vedete diciamo dal grafico perché quindi si procede tipicamente ad espandere nodi poiché vengono espansi nell'ordine che vengono inseriti ad espandere diciamo in orizzontale poi si passa al livello sotto livello inferiore e si espande tutti tutti i nodi allo stesso livello e poi di nuovo ok quindi ampiezza perché prima di decidere espandere i nodi a livello inferiore quindi con un D uguale a D più 1 ok a livello inferiore sono sicure di aver espanso tutti quelli sopra ok allora è completo sì una soluzione la dico assicuramente che a forza gli spando è un problema di voi se esiste no io gli spando se c'è una strada che nel mio problema di ricerca dove il quadro interno è un modello di transizioni effettivamente è strutturato in modo tale che esiste un'azione che ricorderà lo stato obiettivo sicuramente ci arrivo perché a forza di espandere i nodi prima o poi arriverò anche quello che è stato obiettivo benissimo ok è ottimale e qui bisogna fare una domanda vi dicevo è ottimale solo esclusivamente se il posto è 1 non è ottimale in generale perché lo fate a portare allora in questo esempio cosa vedete perché gli stati sono tutti diversi allora intragionateci un attimo io vi costruisco un albero di ricerca in cui la soluzione potrebbe non essere ottimale o quantomeno insomma adesso ve lo faccio vedere perché non è ottimale lo studio di un'entanto se ripeto sottolineo il posto viene in generale il posto viene in generale non è un criterio di selezione nell'espansione però quindi formula lo so che c'era in testa un prova a formularla perché è così però prova a formularlo bene perché è ancora normale in generale allora vi faccio due situazioni che suonano allora aspettate ok ci sono guardate un attimo questo è proprio corretto tutto è perfetto allora G era stato gol ok G era stato gol e riapro un attimo la telecamera se le ragazze cadono non riescono a seguirci questo è un albero che mi sono costruita adesso per fare se la vuoi ragionare per quale motivo questo è ottimo se il posto è lo stesso allora definisco il problema come mi pare ma nel definire chi è fatto benissimo allora assumiamo che il costo sia uguale per tutte le azioni noi che cosa facciamo spandiamo spandiamo abbiamo visto l'ordine esattamente identico quello che abbiamo visto un attimo fa quindi non mi sto a ripetere arrivo qua come avete visto prima a questo punto io faccio la verifica se quello è un attimo si lo è e si restituisco la soluzione cosa vuol dire che qua non ce ne vedo mai se quello è costumiforme mettiamo uno per semplicità l'ho raggiunta sicuramente con il percorso più breve perché qua questo qua non arriverà mai a spandare qui già restituisco questo che mi porterebbe comunque a una soluzione ma questa soluzione è più lunga perché costa tre non la vedo neanche e va bene quindi so che con uno con il costumiforme ripeto il fatto di sempre uno ma in realtà qui l'idea è che sia chiaramente lo stesso valore che sia uno dieci non è costumiforme ok non è costumiforme e invece in questo caso assumiamo che costano tutte una tranne quella che danno a portatisi che come avevo fatto prima costa dieci benissimo allora io qui per l'algoritmo di ricerca che sto utilizzando adesso restituirei questa soluzione che costa undici per vendermi completamente questa soluzione che costa invece tre ok questo cosa implica che siccome noi tipicamente è evidente che qualunque strategia andremo a scegliere è perché vorremmo trovare la soluzione ottima tipicamente non è difficile perché vogliamo trovare una soluzione subottima è facile che sceglieremo questo tipo di soluzione se e solo se siamo in una situazione come richiedi per requisito rispetto a questo vincolo di avere costo uguale per ogni azione e guardiamo invece sulla complessità computazionale perché questo algoritmo oltre ad avere una questione appunto all'ottima età che è vincolato a cose delle azioni potrebbe essere anche un pochino impegnativo a livello computazionale allora sul tempo come vedete è uno grande tb all'antico quindi è proporzionale al branch infatti ovviamente e non sono dipende chiaramente da quanto è profonda la ricerca quindi quanto varrà ovvero appunto la profondità massima la profondità a cui arrivo ok quindi è uno grande lì e questo credo sia maggiore e più sensibile e non credo vi crei problemi che ha problemi il tempo è proporzionale a quanti nodi espanto quanti sono i nodi più espanso sono b e la t come vedete scusate sono di più 1 più b più b al quadrato più b al cubo eccetera eccetera e quindi saranno grazie di più ecco il problema che ha il spazio corrisponde esattamente alla complessità in tempo perché perché come vedete lì per come è diventato un algoritmo io per trovare la soluzione del problema devo tenere forza per realizzarci tutto perché devo tenere l'intraccio di tutto perché allora vediamo se riesco a farvi se non vi viene intuitivo capire questa cosa farvi l'evento che vi aiuta a capirlo e va beh non è particolarmente difficile anche assumendo che siano tutte allo stesso posto è chiaro che io a priori non so dove le soluzioni e non posso sapere quando lo troverò lo stato obiettivo quindi se lo stato obiettivo è qui oppure è qua per esempio implica io non posso sapere implica che per forza io questa parte qua sopra la devo tenere tutta viva perché se qua benissimo restituirò questo percorso se qua devo restituire questo ma io quello che ho usato ok benissimo quindi questo ci porta purtroppo a dover tenere in memoria tutti i nodi che abbiamo espanso questo potrebbe essere molto costoso adesso noi eh sono disfunzioni che forse stavano molto in piedi al tempo in cui avevamo sistemi la potenza computazionale non era particolarmente e la capacità di storia storia genera come quelli di anni di odierne però dobbiamo anche fare lo sforzo di metterci nell'ottica di aver di fronte dei problemi molto complessi quando questo problema qua adesso non analogo ma simile lo affronteremo per esempio per il gioco degli scatti ci troviamo di fronte un branching factor mi ricordo la memoria di 40 una profondità dell'albero che non credo non mi ricordo sto continuando dalla memoria o emetto il 100 ma provate a fare quel lavoro lì con un branching factor di 40 e una profondità di 100 che rendete conto cosa può implicare in termini di storage ok non tanto neanche forse di tempo di computazione perché però sicuramente soprattutto se per esempio quello è un gioco non possiamo neanche aspettare quattro ore per sapere qual è la prossima mossa da fare ok dubbi su questo vediamo il prossimo allora questo diciamo così prova non dico risolvere le problematiche però anzi ne puoi provare le problematiche però in qualche modo sicuramente ne risolve una e credo che senza che ve lo spiego lo vedete anche solo guardando sulla destra il grafo ad occhio qual è la tematica che può risolvere questo alberto tra quelle che ti ho citato adesso quello della memoria già si vede ad occhio senza che vi ho dato una semantica sulla colorazione di quei nodi ma è abbastanza ragionevole interpretarla come quali sono i nodi che ho quali sono i nodi delle riscritture date si vede che sono tutte di meno allora qui che cosa succede come vi dicevo un attimo fa parto dal mio nodo stato iniziale lo espando nei figli che lo sto facendo quindi questo lo dicevamo già prima ed è sostanzialmente un passaggio obbligato a questo punto una volta che ho espanso A in B a C devo capire qual è il prossimo nodo da espandere strategia di ricerca che mi dice qual è il prossimo nodo da espandere sfrutta un ordinamento per quella struttura dati qual è la struttura dati la frontiera che è diverso dal fifo ma è nifo quindi la sting first out quindi non prendo il nodo C come ho fatto prima ma vado sotto ovvero espando il nodo a sinistra e così vado avanti ok vado avanti espandendo sempre l'ultimo espanso fino a quando quando mi fermo in questa profonda in questo andare in profondità secondo voi intuitivamente quando mi fermo quindi andare in profondità potrebbe voler dire che sono qua potrebbe voler dire fare questo eh tante volte quando mi fermo ho due opzioni o si raggiunge il gol ottimo per forza quindi a forza di andare in giù in profondità ho trovato un gol oppure si raggiunge una foglia come la definisci la foglia però è una foglia dell'albero perché è una foglia perché nella transizione nello spazio degli stati viene la definizione del calma qui ci arriviamo qui ci arriviamo sul discorso partiamo facciamo una discutiamo una cosa per volta sicuramente un nodo può essere una foglia o perché è uno stato obiettivo oppure perché non ci sono nella definizione del problema transizioni ammesse da quello stato no? e vediamo per esempio arrivo qua potrebbe essere adesso qui in realtà è bidirezionale ma supponendo la definizione di questo problema è bidirezionale ma supponendo che non lo sia arrivo qua non c'è sono in un una strada senza uscita ok? e lì mi fermo ok però mi è stato citato una cosa interessante ovvero scusa prima finisco di descrivere chiaramente una volta che ho raggiunto il nodo figlio il nodo state foglia un nodo che non ha successori e non è il nodo goal che cosa vado ad espandere mi sposto sulla destra e quindi spando in questo caso E vedete spando E poi dopo lo spando in G e K eccetera eccetera quindi in ampiazza mi sposto solo quando in profondità ho raggiunto un nodo foglia ok? allora si presentano a questo punto un po' di discussioni che meritano una bella diciamo così ragionata che sono sempre collegati al problema dell'ottimalità al problema della complessità allora trovo una soluzione provate a rispondere un attimo trovo una soluzione non vi faccio vedere altro ragioniamo insieme cerchiamo di capire se questo è un problema la strategia di ricerca così definita per come è stata definita ora con te o meno certo non faccio ancora la cosa che ripeti cosa hai detto tu? per come è stato definito il problema non è sempre così ma potrebbe esserci un insieme di transizioni che portano a dei cicli all'interno dell'albero degli stati dello spazio degli stati del grafo degli stati ok? guardate ve lo faccio vedere qua giù nel problema che abbiamo discusso la settimana scorsa così spero che sia più semplice da capire questo noi abbiamo guardato questo problema dell'aspirapolvere e avevamo visto che anche se questi due stati di fatto sono dei perfetti stati obiettivi no? no qui diciamo che mi termino assumendo che sia stato obiettivo quindi torno qua sopra in questo stato qua per esempio non è uno stato obiettivo quindi non termino per quel motivo lì però pare che io possa continuare a svolgere questa azione di left no? un autoanello quindi di continuare ad andare a sinistra e quindi ma sono già a sinistra e quindi mi lupo lì e questa è una delle ipotesi potrebbe esserci un'altra ipotesi che siccome queste azioni sono tutte ammesse vado a destra e poi ritorno a sinistra vado a destra e poi ritorno a sinistra questi sono i cicli di cui stiamo facendo riferimento allora una soluzione a questo problema è quella di sviluppare non un albero di ricerca come vedete qua ma un grafico di ricerca ovvero ricordo il fatto che appunto io tengo in memoria la memoria dei nodi espansi e a quel punto in qualche modo se ho già visitato un nodo evito di rispanderlo ok? quindi faccio un check per evitare di espandere repeated state quindi di di espandere stati già visitati e quando qui quindi vi si dice che il problema di ricerca non è completo si fa proprio riferimento a questa cosa qua ovvero sarebbe completo se io evito di infilarmi in the loop che chiaramente qui sono a me possibili per questo tipo di ricerca e nel caso in cui invece io riesco a gestire questa cosa prima o poi una soluzione è una troppo ok? quindi completo potrebbe esserlo è ottimo o non è ottimo? la risposta ce l'abbiamo già qua no non è ottimo perché non lo è? l'abbiamo visto prima e ve lo rifaccio è ottimo non è ottimo no non è ottimo perché non lo è? andiamo ricordando qua ne facciamo lo stesso identico grafo di prima che prima avevamo affermato per la ricerca in ampiezza e sarebbe ottimo adesso sì ok sono ancora in posto uniforme quindi qui è ancora più complicata la situazione non ho quel vincolo del posto il posto è uniforme però per come definito questo problema di ricerca io spando A in B e C e spando B in D e D questa parte qua dell'albero non l'ho ancora visitata a questo punto espando D e trovo G G è un sottobiettivo se restituisco qual è il costo? ok senza sapere che su G ci sarei arrivato anche nel branch a destra e con un costo inferiore che sarebbe stato più alto ok detto questo detto questo questo è un algoritmo che però porta diversi contatti delle contestità importazionali guardate innanzitutto la profondità vabbè complessità computazionale di darmi in spazio non tanto di tempo perché a quel punto come abbiamo visto qui posso una porta che ho visitato fino alla foglia di un branch cioè questo qua sinistra e lì non ho trovato degli stati obiettivi che in cambio non mi serve tenerlo in memoria tanto lo so che lì è una strada che non porterà una soluzione quindi se io fino alla prova supponiamo che questo si dividi un H per esempio un H che fosse stato un nodo semplice è un diretta in traccia di questo però tranquillamente in dettaglio perché tanto qua non ci sarà mai una soluzione che possono andare a destra e così le spaccolano in spazio e spazio appunto di di memoria di storage di questi nodi ok quanto invece al fatto di visitarle attenzione quello potrebbe essere complesso perché noi in termini di tempo non abbiamo nessun controllo su quanto questa cosa va giù anche sul metodo di non aver cicli perché se ho cicli ripeto la questione è sostanzialmente non risolvibile a meno di come produrre appunto il concetto di nodi spazi e già spazi però ecco anche sul metodo di non aver cicli qual è la profondità di un branch non è assolutamente di una sì un branch non è assolutamente sotto il nostro controllo effettivamente potrebbe essere molto superiore alla profondità a cui si trova la soluzione che ho dato il D quindi se io ho la soluzione qui ma intanto mi sono visitata questo branch fino alla fine ho speso un bel po' molto di più di quello che avrei speso se fosse una pena insomma non è banale no? perché vedete da una parte mi richiede quanto mi richiede molta molta spesa oltre al fatto che non mi restituisce una soluzione ottima qui sottolineo questa cosa qua ovvero che assumiamo che lo spazio di ricerca sia finito ragazzi perché se ci mettiamo nel mondo e lo spazio di ricerca è infinito auguri perché insomma quel punto è chiaro che con una profondità andando in profondità così effettivamente rischio di non convergere mai benissimo dati questi problemi di questo algoritmo che in parte ci piaccia in parte non ci piaccia per quello che ci siamo detti e guardate scusate la sottolina un quanto vi ho già detto anche in questo esempio qua in questo esempio la cosa è ancora più antipatica questo è l'esempio dell'esplorazione della mappa della Romania vi dicevo gli spostamenti da una città all'altra al di là del costo che è diverso sono bidirezionali chiaramente quindi è facile infilarsi in dei cicli in un esempio del genere da Rad vado a Sibiu da Sibiu torno a Darad da Rad vado a Sibiu e poi ritorno a Darad ok quindi è quello che vedete in questo esempio qua ok e con Depth First se facessi come dice il collega qua in aula avrei questo problema chiaro che se invece Rad io l'ho memorizzato nel mio expanded node nella RIC che vi ricorderete di prima delle publie su radati beh l'ho già raggiunto il costo addirittura in questo caso sarebbe superiore perché chiaramente vediamo lo rifaccio qua ah per esempio arriva in A A l'ho già visitato va bene ma non mi basta mi controllo mi serve anche di capire quanto mi è costato facciamo attiva no A per proposito 0 B l'ho già visitato ma non mi basta quel controllo mi serve anche verificare quanto mi è mostrato visitare a B prima per c'è il sugiore prima mi era costato 1 adesso mi costo 4 quindi stop questo è proprio un sostanzio senza speranza ok allora vi faccio vedere tra un attimo delle evoluzioni di questo algoritmo in profondità perché insomma è volto in modo interessante con delle soluzioni che provano a risolvere un po' i problemi che vi ho citato ma prima vi voglio far vedere queste immagini che è molto carine secondo me perché in qualche modo è più cattiva soprattutto forse rimane un pochino anche graficamente nella memoria e di che cosa e in che modo si differenzia come vedete è uno spazio degli stati un pochino più complesso con tutte le nostre transizioni ci sono dei nodi per esempio questo nodo A allora si parte da S si deve arrivare a G stato iniziale è stato obiettivo ci sono dei nodi per esempio il nodo A che come dicevamo prima sono dei nodi in cui a quanto pare non è possibile svolgere alcune azioni perché abbiamo delle azioni entranti ma nulla che esce quindi in questo modello delle transizioni abbiamo dei nodi figli che peraltro appunto uno è A un altro è Q e troviamo esattamente come vedete qua negli alberi di ricerca troviamo esattamente come figli scusate come foglie di questa porzione di spazio visitato fatemi vedere se qui riesco a farvi vedere attraverso questo albero anche il fatto sì credo sia un esempio utile a tanti livelli e assumiamo che sia questo 1 ogni azione effettivamente noi qui raggiungiamo l'obiettivo G lo raggiungiamo in 1, 2, 3, 4, 5 passi l'obiettivo G c'era anche di qua di qua lo avremmo raggiunto in 1, 2, 3, 4 passi quindi avremmo speso di meno se fossimo andati là come vedete la ricerca in ampiezza che è quella che avete a destra sullo stesso identico problema riesce a raggiungere l'obiettivo G con soluzione ottima come ci siamo detti prima fornendo una soluzione ottima come abbiamo detto prima però si deve tenere memoria di tutta sta roba qua sopra ok avete delle domande qui o a casa? no allora vediamo un pochino la ricerca in profondità è stata evoluta si è evoluta in due diciamo passaggi successivi tengo questa immagine come sfondo per spiegarveli perché è un po' più semplice con l'esempio ovvero la primissima versione la primissima evoluzione per evitare principalmente vi direi il problema della complicità in tempo più che quello ancora della soluzione ottima ma sicuramente agevola la rende probabile detto meglio il fatto di trovare una soluzione ottima e ha proposto di insomma come prima evoluzione è stato proposto di limitare il massimo livello di profondità dell'albero quindi viene introdotto un nuovo parametro un parametro L che è definito vabbè limit ok che corrisponde al massimo livello di profondità a cui l'albero quantità cosa vuol dire che questo aiuta anche evitare loop tra le altre cose e di gestire eventualmente anche spazi infiniti tra l'altro cosa vuol dire che se io metto L uguale 5 se io metto L dalle 5 quando sono arrivato a questo stato qua anche se è questo noto anche se questo potenzialmente può avere dei figli ed è stato l'ultimo ad essere inserito nella mia frontiera quindi potenzialmente sarebbe quello di poter espandere e riaccendo un attimo la telecamera quindi quando sono qui quando sono qui invece di andare avanti con le espansioni poiché ho raggiunto questo L uguale 5 che avevo utilizzato come garanzo di massima profondità raggiungibile non proseguono la ricerca in profondità ma mi sposto in una ricerca di dire campietta anche se significa spostarsi con il padere e procedere allo stesso modo di nuovo limitandosi a E per quella 5 allora senza che guardo le soluzioni a lei che è il problema di sta roba no le soluzioni sono le slide senza che vado avanti con le slide la completezza questo non mi dà nessuna benzia di trovare una soluzione potrebbe essere più probabile che dicevo prima se sono problemi piccoli con pochi stati e poche transizioni ma potrebbe in realtà essere assolutamente impossibile trovare una soluzione profondita 5 la soluzione può essere profondita L più 1 L più 2 L più n di fatto sicuramente non ho alcuna grazia di competenza quindi come si va di domenica la soluzione quindi finale che è stata proposta che è effettivamente forse una soluzione piuttosto efficace e vi direi è tra quelle più riconosciute in questo in questo contesto dove rimaniamo ancora a problemi con costi uniformi altrimenti ci crolla un po' tutto e è quello di vengono chiamati Trated Limited Search Depth First Search Depth Limited Search iterato potere L non è un valore costante questo parametro di profondita massima non è un valore costante ma è un valore che posso modificare quindi inizialmente lo inizializzo per esempio a 1 ok quindi stabilisco che è questa la profondità massima come voglio fermare se vi trovo una soluzione bene altrimenti procedo con una certitudine però ponendo L uguale a 2 e poi se non trovo una soluzione pongo L uguale a 3 e così via in questo modo continuo diciamo si trasforma è una sorta di ibrido tra ricerca in profondità e ricerca in ampiezza che in qualche modo mi aiuta a risolvere i problemi della ricerca in ampiezza soprattutto per quanto riguarda la complessità in memoria e spazio ma allo stesso tempo mi garantisce la completezza ok va bene guardate qua che vi stavo raccontando ok questi sono nodi di cui mi dimentico questi nodi neri sono nodi che io posso togliere dalla mia riaffi di qui togliere spazio in spazio quindi L uguale a 0 ovviamente difficilmente una soluzione limiti uguale a 1 visito di 1 di figli eccetera eccetera quindi faccio una ricerca in profondità ad ogni interazione modificando il valore di quell'infer associato alla profondità massima raggiungibile ok allora io ho un altro algoritmo da presentarvi che è diciamo così l'ultimo algoritmo quanto riguarda le ricerche non informate siamo perfettamente nei tempi e insomma quindi mi va molto bene però ecco prima di andare avanti vi lascerò un attimo parola non avete dubbi tutto è abbastanza chiaro allora questo qui quello che vi sto presentando oggi è potenzialmente uno dei primi problemi del genere è il primo esergetico dell'esame in cui tipicamente come ricorderete io vi do questo grafo che descrive il problema e le transizioni associate ricorderete a ciascuna transizione ricordate? forse no forse ce l'abbiamo ecco associato a ciascuna transizione voi avete anche il costo quindi in questo caso non è un costo uniforme come vedete ok quindi già forse è un problema un po' più complesso di quelli che abbiamo visto qui c'è un'altra informazione che è quella che vedete nel quadretto sopra allo stato e quella è un'informazione a cui domani darò un significato per il momento noi abbiamo solo l'informazione sul costo dell'azione che per andare da AB posso svolgere quindi in quel caso mi costa 12 nell'esercizio io tipicamente vi chiedo anche guardate qua vi chiedo anche cioè vi esplicito qual è l'algoritmo di ricerca che voi usiate per risolvere questo problema quindi qual è la strategia che dovete usare chiaramente se una ricerca è informata o non informata cambiano gli algoritmi che possiamo usare quindi questo algoritmo a stare ancora non l'abbiamo visto lo vedremo domani perché è una delle soluzioni per le ricerche informate però insomma potrebbe essere che vi fornisco un problema non informato quindi dovete togliere tutti questi riquadretti qua sopra oppure scusate potrei anche lasciarveli ma dirvi sotto questo lo sottolineo perché leggete bene quello che c'è scritto sotto perché io ve lo dico esplicitamente qual è l'algoritmo che dovete usare magari lì vi dico si applichi una ricerca in ampiezza per risolvere questo problema fornisce la soluzione ottima no lo sappiamo già che muro fa in questo caso ok sappiamo no no perché come vedete i costi sono diversi e attenzione un'altra cosa c'è un punto vediamo se siete attenti a tutte le cose che sto cercando di enfatizzare in questi giorni perché non non siate distratti o quantomeno non abbiate dubbi il giorno dell'esame cosa c'è scritto lì una cosa fondamentale cambia il risultato quello detto ieri cioè ieri la volta scorsa non solo abbiamo visto adesso che è un problema enorme sul come i migliori non ti aiutano se te ne ho già visitati io potrei anche fare non lo farei però potrei anche dire che si applici poi la ricerca a stare su alberi in grafica e poi da soli dovreste ricordarvi che la research non tiene traccia la draft search tiene traccia questo l'abbiamo messo la settimana scorsa però ecco volendo essere un pochino più insomma venire di incontro lo si esplicita l'importante è che voi lo leggete perché sennò mi date la soluzione sbagliata perché ripeto sono due cose un portogonale uno è se decido o meno di tener traccia e uno è quale nodo decido di espandere sulla base di quale algoritmo di quale priorità che sia la prima messa inserita nella frontiera che sia l'ultima inserita come abbiamo visto nel depth che sia la migliore come vediamo nel best ok allora andiamo a vedere l'ultimo allora nell'ultimo algoritmo che è questo allora finalmente si introduce questo si sfrutta questo concetto di funzione di valutazione del noto diceva quindi questo best first in letteratura sicuramente l'avrete incontrato anche con la definizione di Dijkstra probabilmente una delle strutture dati che ha fatto questo esame in passato sicuramente l'ha incontrato ok quindi qui cambia un pochino la configurazione della diciamo così della priorità che do ai nodi da espandere sulla base non più della priorità dell'ordine di inserimento nella frontiera ma del valore di questa funzione di valutazione di ciascun nodo di questa fdn che è una funzione di valutazione del nodo fdn con l'idea appunto che andrò ad espandere non il nodo che ho inserito per primo quello che ho inserito per ultimo ma quello che è funzione di valutazione più alta allora la prima versione di questo concetto di funzione di valutazione migliore guardate lì è associata in realtà alla funzione costo ok e io voglio minimizzare quindi come prima versione di questo algoritmo best first che abbiamo introdotto prima introduciamo l'algoritmo di Dynesna che viene nel mondo della ricerca chiamato algoritmo a costo uniforme quindi quella di valutazione corrisponde al costo del percorso per raggiungere il nodo M e definisco algoritmo di ricerca costo uniforme nel mondo delle AI perché come vedete la ricerca appunto la faccio procedendo per aree le chiamo così che sono qui colorate con appunto colori diversi aree che hanno un costo uniforme o quasi se vogliamo all'interno di un settore engine ok il grafo degli stati è sempre lo stesso quindi il problema di ricerca è quello che abbiamo visto prima dove per prima intendo qua però effettivamente c'è un'arco quindi c'è un'azione non è associato un costo perché abbiamo detto che questi li usiamo se il costo è lo stesso altrimenti siamo già a priori sappiamo che abbiamo dei problemi sicuramente associati all'ottimalità della soluzione ecco quindi in questa versione aggiuntiva un pochino più stesa ad ogni relazione come vedete è associato un costo che è il valore rosso che trovate sull'arco ok quindi io da S so che posso andare in tre nodi S allo stato iniziale posso andare in tre nodi che sono D E e P se vado in D spendo tre se vado in P spendo uno se vado in spendo nove ok poi espanderò quindi tra questi tre non guardate la soluzione perché in realtà non c'è un ordine di espansione quindi io parto da S lo espando secondo le solite regole però quando vado a costruire la mia frontiera scusate guardo in chat che forse c'è una domanda ah ok cosa è successo continuate a non vederle perché io le sto condividendo però per ora era era un pdf quindi ce l'avevo qua mi dite se vedete le slide perché sono tecnicamente in condivisione quindi se non le vedete quello che posso fare è interrompere un attimo e ricondividere condividere ok vabbè spero che vediate adesso non mi date feedback ma assumo che vediate ok ok quindi parto da S espandono i figli D e P quali espando dopo? espando P perché? perché la F di N su P che abbiamo detto è questo il tipo di problemi il costo uniforme è il costo per raggiungere P è 1 e quindi nella mia frontiera i nodi sono stati ordinati secondo appunto il valore di F di N quindi del costo P lo espando e arrivo in Q che è 16 cosa faccio ora? Q ho tre nodi sulla frontiera i nodi sono D e Q Q è un nodo obiettivo no però però peraltro non ha neanche dei figli quindi li rimane perciò nella frontiera O D qual è espando? espando D ci siamo detti perché è quello che mi ha costato meno per essere l'aggiunto e lo espando guardiamo qua sopra giusto per verificare lo espando in B in C e in E allora per finire in B come vedete a questo nodo non è associato 1 ma è associato 4 perché abbiamo capito che il costo non è per raggiungere da D a B ma è il costo cumulativo di quel percorso il path cost in ciascun nodo che viene memorizzato e lo ripeto il path cost che viene memorizzato non il costo dell'ultima azione quindi sarà 3 che è il costo per raggiungere D a partire dallo stato iniziale S più 1 che è il costo per raggiungere B a partire da D quindi 3 più 1 4 benissimo e poi avrò espanderò C ed espanderò E chiaramente C come vedete è molto più costoso di B e D quindi finisce in una diciamo così se questa fosse una heat map in una zona di questa heat map diversa perché ha un costo superiore benissimo così vado avanti adesso sulla frontiera O, B, E ed E questo è molto interessante perché come vedete c'è un nodo ripetuto E c'è un stato ripetuto su due nodi diversi che è questo da una parte però mi è costato 5 per arrivarci dall'altro mi è costato 9 e vado avanti 4, 5, 9 espanderò quindi B con B raggiungo A A poverino non ha figli quindi lì si ferma la strada e lo posso continuare a espandere eccetera eccetera eccetera adesso io penso che avete dei dubbi su questo perché ok benissimo ottimo ve lo ve lo spiego passo passo se ci sono dei dubbi perché in alternativa e nessuno associate a ciascun nodo c'è il corso del percorso corso del percorso additivo su tutte le azioni svolte per raggiungere quel nodo e ogni volta espando il nodo che sulla frontiera ha il costo inferiore al costo inferiore quindi best first dove in questo caso best e costo inferiore o algoritmo di Dijkstra allora qui in aula mi asseriscono quindi mi sembra di capire che avete capito giusto? se a casa avete dubbi perché mi dite perché dubbi faccio fatica a inventarli allora questa cosa di utilizzare un concetto di una funzione costo in effetti ci piace molto ci piace molto perché per esempio guardando questo problema risolve in automatico uno degli issue delle questioni che abbiamo discusso prima per esempio per l'algoritmo in profondità quindi questo best first dove è il costo ad essere la misura di bontà di un nodo risolvere un problema qual è il problema? guardiamo questo questo questo altro caso di studio senza dover impostare un massimo limited branch ma anche senza dover tenere traccia vi dico io denodious bands potenzialmente quale può essere una cosa che mi risolve? la completezza che non abbiamo messo vincoli lo esploriamo tutto quindi tecnicamente sì questo ci pensiamo dopo prima concentriamoci sulla allora i problemi della complessità computazionale vanno sempre genuti presenti ne abbiamo parlato perché ovviamente i problemi possono esplodere complessità e di conseguenza la complessità del problema e quindi la complessità computazionale diventa intrattabile ma è un secondo diciamo se vogliamo obiettivo che ci diamo perché il primo è avere appunto un algoritmo completo cioè che trova una soluzione ma che poi questa soluzione sia potenzialmente ottima ce l'auguriamo ripeto tipicamente l'ottimalità hanno dei requisiti ecco il fatto di espandere solo i nodi migliori mi porta al fatto che sostanzialmente difficilmente io per esempio ammetterò o quantomeno espanderò dei nodi che ho già risultato perché è abbastanza naturale che quei nodi siano più costosi non è detto perché potrebbe essere guardate qua che potrebbe essere che da Rad a Zerind ci sia un chilometro di distanza e quindi io faccio avanti e indietro un bel po' di volte lo faccio un bel po' di volte ma ad un certo punto mi fermo per forza quindi anche il problema dei cicli in qualche modo me lo vado a risolvere anche se il problema è naturalmente ciclico perché ad un certo punto capirò che anche fosse uno ripeto dopo aver fatto avanti e indietro 70 volte raggiungo il 140 e a quel punto mi conviene andare a Silvio piuttosto che continuare scusate a fare avanti e indietro Rad a Zerind ok e infatti come vedete sostanzialmente vabbè da su qui da Rad e Spando in Zerind Sibiu e Timisoara che sono i figli la frontiera a questo punto avrà Rad Oradea Spando Zerind perché in questo momento è quello migliore 75 ok ritornerò da Rad ritornerò a e andrò a Oradea o Sibiu e per ora sono ferma qua aspettate a questo punto nella frontiera ho Arad Oradea e Sibiu Arad quanto costa? questo è un'altra e questo è un'altra che ve lo rifaccio perché quello è già parzialmente risolto vediamo se ce l'abbiamo passo passo qui non c'è lo faccio io vediamo se ci siamo capiti da Rad da Rad partono tre strade una che finisce in Z una che finisce ad S e una che finisce in P associato a un costo 75 140 111 quale? spando frontiera questa costo uniforme non direi al momento però la frontiera è questa abbiamo detto che spandiamo il best first costo minore e quindi spando lui Z Z2 sole possibilmente e sono di nuovo Rad e l'altra è O ok io qui invece di metterci 75 come nelle slide vi ho fatto vedere prima che ha sicuramente più senso mettere il costo complessivo per raggiungere questo nodo perché vi ricordo che nodo non significa stato e associato al nodo c'è il costo il pad costo per raggiungere Rad seguendo quella strada lì ed è 150 e mentre Z da Z da Do 75 più 71 quindi in questo caso 146 ok benissimo cosa spando ora? la finitiera mia è questa ok ok questa è la mia frontiera quelli sono i nodi che io salvo in frontiera e sottolineo qui volendo potrei dire l'ho già visto inoltre questo qui è sicuramente a costo migliore di questo perché questo è la costa zero però potrei anche non interessarmene in questo momento espanderò sicuramente quello da te che è la soluzione che voi avete al momento qua sulla slide bisogna che guarda ok qui si ritorna in Arado oppure si finisce in questa città ok bene quindi sarà un 118 più 111 200 29 piuttosto che 118 più 118 200 ok benissimo quindi questa è la frontiera ora perché qui l'abbiamo persa dalla frontiera la frontiera si sposta qui e a questo punto saranno qui che espanderò e così via saranno qui che espanderò quello al momento che è il nodo di partenza che abbiamo già visitato ce lo dimentichiamo eccetera eccetera e così andiamo avanti ad un certo punto potrebbe essere che questo qui ritorna ad essere uno dei nodi che costano di meno e quindi decido di rispandere potrebbe capitare non è detto che questo anzi sicuramente capita al passo dopo perché da Sibio benché vada aggiungo 80 99 con 150 rimane il valore più più basso e quindi ricordatevi che vi verrà esplicitato in questa ricerca a costo uniforme se dovete o meno tenere traccia dei nodi visitati oppure no cambia perché se Torino se tengo traccia dei nodi visitati questo sicuramente lo elimino subito dalla franghiera se non tengo traccia dei nodi visitati dopo aver espanso Sibio sicuramente mi trovo a dover espandere Arata di nuovo perché espandendo Sibio ottengo dei nodi che saranno Fagaras e Riminku i quali ammesso che si lega così Rimniku i quali hanno un valore di corso 150 140 più 90 9 140 più 80 allora per concludere la lezione di oggi e mi ho fatto vedere appunto di vero