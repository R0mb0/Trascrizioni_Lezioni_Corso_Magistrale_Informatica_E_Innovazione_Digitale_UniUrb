Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Grazie a tutti. Ed è in qualità di studente? No, ci sono, ci sono. Ecco che arriva anche Leonardo. Ecco che arriva anche Leonardo. Ciao. Grazie a tutti. E' un'altra... c'è un'altra... E' un'altra... che hanno qui. c'è un'altra... sono arrivata... sono arrivata... c'è un po' di persone... c'è un po' di persone... era qui... e quindi... ciao, ciao... ciao... posso parlare... un microfono... e... no, no, no... no, no... dell'ultimo secondo... ho chiuso una call di lavoro in questo istante... non ho fatto il tempo di tempo... e chi non l'ha fatto direi? No, no... Nel senso che praticamente siamo tutti nelle stesse condizioni. No, no... ma mi spiace perché mi piacerebbe essere lì... e seguirei le lezioni anche sicuramente meglio. In realtà poi... in realtà in questo specifico caso... probabilmente avendo anche un docente che fa le lezioni da remoto... anche lui... forse ti troverai... dico meglio ma sicuramente altrettanto bene a seguire... a distanza. Senz'altro, senz'altro. Ho provato tra l'altro a configurare anche l'altro PC... spero di... non ci siano problemi per... Sei riuscito a configurare i ghefi? Ma... in realtà ho fatto un trucco che... invece di lanciare la versione a 64... a 64 bit lancio l'altra... e quella funziona. Ah, quindi forse Java 32 versus... non so perché ma... comunque... Luca sappi che neanche... cioè no, devo dire che... quasi tutti sono riusciti a installare senza problemi... però... è riuscito a mettere in difficoltà anche qualcuno in questo gruppo di... con background da computer scientist... quindi è proprio... Ghefi lo fa... è fatto apposta... insomma... ha una... ha una selezione all'ingresso molto alta... è un po' random... bisogna dire... e le cose sono anche migliorate negli anni... Ah... sì, sì, sì, è vero, vero... C'è stato un periodo in cui... soprattutto installarlo su Mac... era un delirio di conflitti di Java che... facciano tremare i polsi... ma... vabbè... non è... ma poi non lo useremo un pochino domani... intanto comunque loro sono... sono pronti... ragazzi dobbiamo aspettare qualcun altro... secondo voi o possiamo iniziare? Io sto scorrendo i vari nomi... mi sembra che siamo tutti... ok... io prendo Luca come punto di riferimento che... no, no, no... no, no... perché ne sai... conosci l'ambiente... bene... allora iniziamo direi... oggi come vi avevo anticipato abbiamo come ospite Luca Rossi che è un... professore associato all'IT University di Copenhagen ed è anche come vi anticipavo ieri uno... diciamo... dei... dei massimi esperti... di social network analysis... soprattutto applicata ai social media... ha scritto anche... sicuramente un libro forse anche di più... devo dire che questa sua attività di pubblicazione è proprio specifica sullo social network analysis... non la seguo così con... attenzione... però... so che... diciamo... si occupa sia dal punto di vista dell'applicazione social media sia anche dal punto di vista più dello sviluppo... chiamiamolo così teorico del metodo... in profondità di questi... di questi temi... quindi ho pensato a che chi meglio di lui poteva introdurvi al mondo dello social network analysis... vi dico solamente una cosa... poi lascio la parola direttamente a Luca... e il... nel blended... forse l'avete notato ma forse anche no... troverete le... diciamo degli script delle lezioni di oggi e i dati anche... eh... che serviranno per seguire quello che Luca... eh... che il professor Rossi... come vogliamo... eh... presentarlo... Luca va benissimo... Luca va benissimo... eh... e... seguirà... quindi... penso che vi possa essere utile scaricarli... sono due file HTML... un file RDA... che sarebbe... un file... diciamo... di... di dati di R... eh... che può essere... caricato in un modo che scopriremo fra... fra poco... eh... a questo punto direi che... se non ci sono domande diciamo... di tipo organizzativo da parte vostra... lascerei proprio la parola a Luca... eh... in modo tale che... eh... entriamo subito nel vivo della lezione... ok? sempre questo... c'è sempre questo momento di delay in cui... è uno... due... tre... ok... ok... ehm... vabbè... intanto... vabbè... intanto condivido un po' di scale... eh... mi puoi abilitare a... ah... giusto sì... arrivo sì... ehm... vabbè... intanto vi dico... un po' due cose... su di me... veramente due... non c'è... troppo da dire... eh... però poi mi sa che così vedete... eh... non so che cosa sto condividendo... scusate... c'è... la... la presentazione però in modalità... mhm... diciamo... non presentazione ma... allora fammi... giusto... questo... qua... così dovesse vedere la presentazione... esatto... ok... allora... eh... vi dico... prima due cose su di me... e poi che cosa ho pensato per questi due giorni... eh... sperando di aver allineato... eh... bene... eh... bene le cose... se non l'ho fatto... me lo dite... eh... per ottenere... in... in... in... in corsa... ho passato come... laureato in sociologia a Urbino... ho fatto il mio dottorato a Urbino... eh... e ho passato a Urbino un periodo... considerevole... diciamo... della... della mia vita... anche accademica... e poi nel 2013... eh... sono a Copenaghen... dove... prima come assistant professor... e poi come associate professor... lavoro all'IT University... che è una... potete immaginarlo come un politecnico... che però è solo dedicato a discipline IT... ehm... in varie... varie sfaccettature... ehm... dove insegno... un po' di cose... eh... insegno... un corso chiamato... Digital Media Analysis... eh... insegno un corso che si chiama... Network Analysis... e... collaboro con un corso... di Digital Design... and Interactive Technologies... eh... di fatto... quando si tratta di fare ricerca... ho lavorato parecchio su reti online... in particolare reti tratte da social media... e... un po' su un tipo particolare di rete... che sono reti multi-layer... che è una... una nicchia della nicchia della nicchia... della... della Network Analysis... di cui... non parleremo... ma... se siete curiosi... eh... vi mando... lungo PDF... che ha a che fare con... il libro che Fabio prima... prima... città... ehm... in ogni caso... in ogni caso... eh... che vorrei provare a fare... in questi giorni... è... raggiungere due... due scopi... uno... ehm... che è quello di... eh... offrire una... una... una... una overview... eh... mi scusi in anticipo se... userò troppi termini in inglese... ma io non ho mai insegnato queste cose in italiano... e quindi ogni tanto... ho dei problemi... ho dei problemi... odio farlo... ma... davvero non mi vengono... mi vengono le parole... quindi... vi chiedo scusa in anticipo... ehm... comunque... quello che vorrei fare... è darvi una panoramica del... ehm... di un po' di cose legate a network analysis... assumendo che... non abbiate un background specifico... eh... in questo senso... che magari ne abbiate sentito parlare... abbiate visto certe cose... ma non abbiate un background specifico... lo faremo... saltando pie pari... per la parte... ehm... diciamo... formale e matematica... della network analysis... che è la parte che normalmente va sotto il nome di graph theory... e che ha a che fare con l'analisi matematica delle reti... che lavora molto con... matrici... quella parte lì... la saltiamo... la prendiamo... la mettiamo... la mettiamo da parte... e ci concentreremo molto su una parte più applicativa... diciamo... quali possono essere... eh... gli usi... le applicazioni... o alcune... di... aspetti interessanti che si possono usare... o come si può pensare di usarla... nel contesto in particolare... dell'analisi dei... di dati online... dati presi da social media... eh... di varia natura... facendo questo... parallelamente... cercherò di... eh... fornirvi... o una... ehm... un'introduzione... a un package specifico... per... R... che si chiama... che prevede... che è fatto per fare... network analysis... eh... io non so... quanto familiarità voi abbiate... con R... immagino molta poca... perché se capisco bene... avete installato... a studio... ieri... ah... quindi... io vi farò vedere del codice... al capire tutto il codice... non è... non è sempre necessario... però se avete... eh... delle domande... lo... lo... lo guardiamo... eh... cercherò di spiegarvi le parti... che sono più legate... alla network analysis... pensando che poi magari possiano le parti... che possiate... eh... voler... riutilizzare... eh... replicare... replicare in futuro... però comunque... il codice... eh... come dire... con R... le cose si fanno in tanti modi diversi... eh... quindi il codice che vedete... è una possibilità... non prendetelo come... come Bibbia... o come... o come cose di questo genere... insomma... allora... io... come eh... Fabio diceva... vi ho mandato degli... degli HTML... che sono sostanzialmente... dei markdown... state vedendo il mio... studio... vero? Sì... vi ho mandato dei markdown... eh... che... ripercorrono la lezione che... che ho in mente... quindi... per facilitare un po' anche... eh... la vostra... eh... il vostro seguire... il mio consiglio sarebbe... di seguire... avendo il markdown aperto... e... R aperto... e sostanzialmente... se volete... potete... scrivere il codice... se non volete scrivere il codice... potete copiare... incollare... e per come è fatto... è molto semplice... copiarlo... incollarlo... senza... senza errori... ehm... di solito... la lezione la faccio così... per cui... non ci saranno slide... particolarmente belle... ma... dovrebbe essere utile... effettivamente... il codice... come funziona... e come... restituisce... restituisce certe cose... eh... Luca dico una cosa... siccome... eh... loro hanno... eh... RStudio... diciamo... tra virgolette... installato... e... quindi magari... diamogli un secondo di tempo... per... ehm... entrare... diciamo... a fare... le... le loro cose... e... siete in una... condizione di poter seguire... da questo punto in poi... con RStudio aperto... così... riprendiamo... e... direi che potete tranquillamente... intervenire anche in audio... per... per una questione di semplicità... così... non dovete switchare tutte le volte... sì... e io non me la prendo... se volete anche avere le webcam attive... adesso non so se avete delle... delle policy... eh... non lo stavo a chiedere... spingermi fino a questo punto... però... diciamo... c'è... c'è un aspetto... eh... diciamo... di natura pedagogica... se uno non capisce... e fa una faccia confusa... io non lo vedo... ehm... quindi finisce che... quando uno fa lezione... e... nessuno fa lezione per se stesso... diciamo... ecco... oppure per le persone che sono... brave enough... da avere la... la... la webcam attiva... ehm... ehm... ci siete ragazzi con... ehm... RStudio Cloud? Sì... mi si sta aprendo adesso... ok... sì... anche per lo dico... anche perché non è proprio performantissimo... quindi... per quello... non faremo delle cose particolarmente... è RStudio Cloud? se l'avete come... cioè... è un... è un cloud di Neo? dicevo... a loro che... ehm... è uno dei miei obiettivi farlo installare... ma non ci sono riuscito ancora... stiamo mostrando la versione free... quella... sulla... diciamo... liberamente... o... utilizzabile... esatto... non ricordo adesso che... che... limiti ha però... ehm... mi sembra che sia... mh... un... piccolissimo la macchina... del polente... beh... comunque qualunque cosa poi non riusciate a fare... ci sono un paio di plot... che può essere che... richiedono un po' di... di... di... di tempo... ma... insomma... lo guardate da me... poi lo potete fare in locale quando... quando... quando avete tempo... se volete... insomma... eh... va bene... intanto che... ehm... guardate... ehm... guardate... ehm... guardate questa cosa... iniziale del codice... trovate... eh... richiamate una serie di... una serie di package... una serie di library... eh... che userò a un certo punto nel codice... non servono tutte subito... quelle veramente importanti sono... iGraph... e... ggplot2... eh... e... gggraph... in realtà ggplot2... non... non serve neanche... quindi... eh... iGraph... che sono una per fare l'analisi... e una per visualizzare... visualizzare i grafi... ehm... se non sono installate... le dovete... le potete installare con... con... il codice che è... che adesso vi decommento... così lo vedete meglio... che è install.packages... il nome del package... e... specificare il repository... o non specificare il repository... questo è... sostanzialmente indifferente... eh... e poi... una volta che li avete installati... alcuni package richiedono un po' di... di tempo per essere installati... in particolare... iGraph... perché ha una parte in C... che richiede un sacco di tempo... ma... se tutto va... va bene... ehm... iGraph l'avevano installato già ieri... quando hanno installato Quarnet... quindi... quello ci dovrebbe essere... allora... parliamo un attimo... di reti in generale... io poi... se a un certo punto... non ci siete... potete seguire... seguire... il mio schermo... e non ci sono grossi problemi... sì... scusa... ti interrompo un secondo... dimmi... dove possiamo trovare noi... io ne ho trovato... dove... dove... dove... dove... dove... dove... dove... dove... dove... dove... lezione... lezione... lezione... si... a quel punto lì... ci stiamo vedendo adesso... per quello... allora... no... a quel punto lì può essere che tu non lo vede in realtà... dovrebbe essere così... ok... sì... infatti è così... ok... eh... ed è... ed è... ed è colpa mia perché l'ho... l'ho nascosto... ah... quel codice lì c'è ma... eh... l'ho... l'ho nascosto... è in... adesso senza entrare nel dettaglio... questo include... false qua... che mi mostra questa parte del codice... ehm... comunque... allora... prima di tutto ci chiariamo su un paio di cose... eh... una rete... nel... contesto della lezione di oggi... eh... e di domani... è... un insieme di... oggetti... collegati da relazioni... eh... oggetti e relazioni... in un qualche modo... direte voi... nel senso voi... il... il ricercatore... quando... ehm... osserviamo... persone... offline... osserviamo delle persone... i nostri oggetti sono le persone... le nostre entità sono le persone... e... eh... le relazioni che loro possono avere... che siano scambio di denaro... amicizia... ehm... andare... al teatro assieme... qualunque cosa... sono i nostri... le nostre relazioni... noi... abbiamo un momento... in... quando facciamo network analysis... che... dobbiamo decidere... chi sono i nostri nodi... e chi sono i nostri archi... cioè... in qualche modo... dobbiamo decidere... qual è la rete... che stiamo... eh... definendo... che stiamo osservando... che stiamo studiando... sembra una banalità... ma in realtà... per... parte di un... di un corso... che dura un semestre... la domanda... a ogni progetto... quali sono i nodi... quali sono i nodi... quali sono gli archi... è la domanda più importante... che uno si deve fare... per... non tanto... eseguire del codice... che quello basta scriverlo... ma per interpretare i risultati... perché tutti i risultati... che avremo... saranno basati sul fatto... che noi abbiamo scelto... quei nodi... e abbiamo scelto quegli archi... perché... network analysis... di fatto... si fa sulla network... ma se la network cambia... perché tu... hai deciso di guardare una cosa... invece che un'altra... tutte le analisi che facciamo... sono... vincolate da quel... da quel contesto lì... quindi... qualunque cosa... diremo... nel contesto di archi... e nodi... quando facciamo alcuni tipi di network analysis... le network ci sono date... se studiamo... non so... le reti... le power grid... le reti elettriche dei paesi... le network ci sono date... se studiamo le reti infrastrutturali... le reti ci sono date... in un qualche modo... qualcuno le ha definite per noi... e qui... è più facile definire... rispondere a queste domande... se studiamo reti sociali... è un pochino più... difficile la questione... perché... spesso... siamo più o meno d'accordo... che i nodi sono degli individui... ma delle volte i nodi possono essere delle aziende... possono essere delle pagine Facebook... possono essere degli account... che non sono la stessa cosa dei individui... e le relazioni... eh... buonanotte al secchio... perché le relazioni possono essere qualunque cosa... noi decidiamo... che costituisca una relazione... misurata... in qualunque modo... noi decidiamo che quella cosa possa essere misurata... adesso noi abbiamo... facciamo questa cosa... spesso lavorando con dati di social media... per cui la mediazione delle piattaforme... ci aiuta a definire... o comunque ci impone di definire... questo è un nodo... questo è un arco... ma pensate... quando si faceva social network analysis... negli anni 70... dove la gente andava in giro... con i questionari pen and paper... e chiedeva... ok... quali sono gli amici che vedi più spesso... e con questa domanda... costruiva delle reti... a partire da singole persone... a quel punto... diventa chiaro che... come costruiamo gli archi... ha un impatto abbastanza diretto... su tutto quello che... che chiederemo... da ora in avanti... però... in generale... e questo vale... un assunto... tutte le volte che parliamo... di network analysis... dobbiamo avere... da qualche parte... nel fondo della nostra mente... una chiara tabellina... con... questi sono i nostri nodi... questi sono i nostri archi... e quello diciamo... ci serve per... capire... i risultati... i numeri... le metriche... che... osserveremo... a un certo punto... allora... se voi... caricate iGraph... con library... iGraph... magari scudo... questa tastiera che clicca meno... possiamo costruire... manualmente... una... una rete... col codice che vedete qua... graph edges... e noi... specifichiamo... una serie di edge... queste sono edge... dove tu metti i nomi... ma possiamo scriverci... abc... o cde... quello che vi pare... e poi... possiamo aggiungere questo... comando qua... questa parte di... attributo che è... directed... e in questo caso... diciamo... directed false... lo vediamo in un secondo... che cosa succede... però... guardate questo codice qui... e... e poi... scrivete... in rg1... che è il nome... dell'oggetto r... che abbiamo... che abbiamo appena creato... vedete che iGraph... vi dà... un po' di informazioni... sulla rete... che abbiamo... appena creato... già vi dice... vi fa capire che è una rete... perché... non vi dice... i nomi... vi dice che è una rete... dove ci sono... tre cose... e tre cose... che sono essenzialmente... tre nodi... e tre archi... primo numero è nodi... il secondo numero è archi... vi dice altre informazioni... e vi dà... una overview... delle... delle connessioni... che esistono... c'è Joe connesso con Bill... c'è Joe connesso con Sophie... e Bill connesso con Sophie... vi farei notare... che qui noi... non abbiamo dato... a nodi e archi... abbiamo dato solo gli archi... infatti abbiamo... edges... e una... un vettore di archi... e iGraph li ha presi... a coppie di due... perché un arco... comunque... connette due nodi... e iGraph... fino a lì c'è arriva... e prende l'1 col 2... il 3 col 4... il 5 col 6... e... e... e... via andare... possiamo visualizzarlo... giusto per capire... perché aiuta a visualizzare... e usiamo questo package... che si chiama... gggraph... che... mi permette di visualizzare... grafi... usando la stessa sintassi... di ggplot... non scendiamo nei dettagli qui... non importa... l'idea è che... possiamo visualizzare grafi... aggiunge... gestendo separatamente... come vogliamo visualizzare... il link... cioè gli archi... e come vogliamo visualizzare... i nodi... se noi... usiamo questo codice... vedete che a un certo punto... mi fa... un bruttissimo triangolo... però... c'è... Sophie... c'è Bill... e c'è Joe... e hanno... le loro... le loro connessioni... quindi questa... diciamo... è come noi... immaginiamo... quando parliamo di... network analysis... immaginiamo di avere a che fare... con delle robe... che più o meno... hanno questa faccia qua... ci sono dei nodi... collegati con delle linee... e... e quella è la nostra rete... teniamo... a mente... che... la visualizzazione... e il scrafo sottostante... sono due cose diverse... una è... la struttura... che abbiamo a che fare... l'altra è... come abbiamo scelto... di visualizzare quella struttura... e... c'è una mediazione non banale... tra queste due cose... che cercheremo un po' di raccontare... velocemente... allora... noi abbiamo fatto... una... una micro rete... con tre nodi... e tre archi... questa micro rete... perché... ci sono tutte le possibili connessioni... lì... la chiamiamo... click... quindi... quando avete una rete... dove tutte le connessioni possibili... sono effettivamente realizzate... avete una click... questo è un triangolo... una click con tre... con tre... con tre archi... scusate... e anche tre nodi... è chiaro... o dovrebbe essere chiaro... che non tutte le relazioni sono uguali... una base... fondamentale... della... della... network analysis... distingue tra... relazioni... che hanno una direzione... e relazioni... che non hanno una direzione... pensate... essere amici... è una... relazione... che immaginiamo... non avere... direzione... se io sono amico tuo... tu sei amico mio... e se pensate a Facebook... ad esempio... la... la visualizza così... è una... una relazione... due persone... che deve essere reciprocata... e quindi... se io non accetto... la tua amicizia... Facebook... non stabilisce... questa relazione... ok... pensate... dei social network... che vi chiedono... di accettare questa cosa... quindi abbiamo una relazione... che non ha direzione... ed è la... cosa che abbiamo fatto... quando abbiamo specificato... questo... qua in alto... questo directed... uguale false... che sostanzialmente dice... ai graph... di creare... gli archi che vediamo... ma... di non dargli... una direzione... chiaramente... non tutte le... le relazioni... sono... senza direzioni... ci sono delle relazioni... che hanno chiaramente... una direzione... e che è anche molto importante... la famiglia ad esempio... cioè... se io sono tua madre... tu non puoi essere mia madre... cioè... questa è una cosa... è una cosa chiara... no? se io devo dei soldi a te... è molto diverso... che se tu devi dei soldi a me... e qui... se io sono un tuo follower su Twitter... tu non sei un mio follower su Twitter... quindi abbiamo delle relazioni... dove la direzione è importante... la direzione e la direzionalità... diventano importanti... in molti casi... in particolare... tutte le volte... che abbiamo bisogno... di usare la rete... per simulare... del passaggio di informazioni... pensate... io seguo te su Twitter... allora... se io seguo te su Twitter... vuol dire che quello che tu scrivi... io lo vedo... ma se tu non segui me su Twitter... quello che io scrivo... te non lo vedi... e quindi nel momento in cui abbiamo... queste dinamiche... che ci interessa visualizzare... la direzionalità... diventa... diventa importante... questo... secondo codice qui... crea essenzialmente... un altro... un altro grafo... uguale... ma lo visualizza... mettendo delle frecce... sulla base... della relazione... spero che lo vediate... se no... ve lo disumo un po'... ci sono delle... orribili frecce rosse... che però... fanno vedere che adesso... questi archi... sono direzionati... questo lo abbiamo ottenuto... semplicemente... cambiando il... directed false... in directed true... nel nostro... nel nostro grafo... quando abbiamo creato il grafo... ora... mettiamo in chiaro una cosa... nessuno crea... le reti... a mano... più... nel senso... nessuno crea... si mette lì e scrive... iGraph... file... rete... con... Bill, Joe... e... e... Pincopallo... di solito... carichiamo delle reti... da... file... che abbiamo... che abbiamo trovato... eh... o che abbiamo prodotto... o che abbiamo esportato... o che qualunque cosa... però normalmente... c'è un momento di... collezione dei dati... e un momento di... eh... lettura del... del dato... dentro iGraph... iGraph... permette di importare... un sacco di... eh... di... di formati... di grafi diversi... il formato più semplice... che potete immaginare... è sostanzialmente... quello che si chiama... una edge list... cioè una lista di... archi... una lista di edge... faccio una parentesi... perché me la sono dimenticata... di solito la faccio... prima... ehm... la network analysis... è una di quelle robe... che ha tanti padri... e tante madri... per cui... è una roba... che è stata usata... ed è usata... e ha un relativo successo... in vari ambiti disciplinari... dalla sociologia... alla fisica... a computer science... questa è una cosa bella... uno dei problemi... che arriva con questa... questa dinamica qui... è che molti termini... vengono chiamati... leggermente diversi... in maniera leggermente diversa... a seconda del... dell'ambito disciplinare... per cui... se sono... in un ambito... sociologico... molto probabilmente... parlerò di attori... invece di nodi... se sono in un ambito... computer science... molto spesso parlo di nodi... se sono in un ambito... di fisico... spesso parlo di vertici... se sono in un ambito... in un ambito... sociologico... e parlo di... posso parlare di archi... o di relazioni... in un ambito... computer science... posso parlare di link... Troverete leggendo un po' di varietà terminologica, però alla fine sempre dei nodi e degli archi, o degli attori e delle relazioni, sempre delle stesse cose parliamo. Vogliamo vedere un attimo come possiamo importare dei dati dentro iGraph in modo da lavorare. Nel vostro spazio comune, non so che cosa usate, dovreste avere anche un CSV che di fatto è fatto così, questo comando lo legge dentro R. Per usare questo comando dovete avere... Luca, dico solamente una cosa, perché non so se hanno scoperto, ma immagino che l'abbiano già scoperto, come importare un file in Rcloud dal proprio computer locale. Non so se l'avete brillantemente risolta questa cosa o avete bisogno di... Sì, ho visto che c'è dentro Environment Import Dataset, credo sia quello, poi ancora non l'ho provato. Allora, diciamo, per importarlo come file, adesso Luca non lo può far vedere perché è nella versione desktop, ma c'è un'iconcina upload che consente di caricare il file dal proprio computer locale al file system della macchina virtuale. Quindi se mai aveste bisogno di caricarlo dovete fare in questo modo. Invece se avete la versione locale il file system è lo stesso, quindi basta spostare i file. Invece se la versione locale lo trovate qua e potete o import dataset, anche vi fa vedere com'è il file e possiamo guardarlo assieme e vedete che di fatto è un file molto semplice che contiene una colonna che si chiama source, una colonna che si chiama target e una colonna che si chiama wait. Quindi è un file super semplice. Lo potete caricare direttamente dalla console se usate il comando read underscore csv. Il comando read underscore csv richiede che voi abbiate caricato il package che si chiama reader, altrimenti il comando è read.csv, ma sostanzialmente non cambia niente. E a questo punto però se noi guardiamo in questa parte qui, noi copiamo e sostanzialmente leggiamo nel nostro environment.dr il nostro file, però non è un grafo, è semplicemente un csv. Quindi se noi chiamiamo g, che è il nome che gli abbiamo attribuito, vediamo che è un file con tre colonne, una si chiama source, una si chiama target, una si chiama wait, ma non è un grafo, è un file che ci rappresenta degli archi. Che sono archi lo sappiamo noi, né R né i graph al momento questa cosa sanno, quindi bisogna in qualche modo che glielo diciamo. E glielo diciamo facendo questa cosa qua che è graph.data.frame dove gli assegniamo il data frame che deve usare. graph.data.frame si aspetta di avere due colonne, almeno, che prende come source e come target, e poi tutte le altre colonne che trova, in questo caso la terza colonna che si chiama wait, verranno assegnate come attributi sull'arco. Questo. Lo facciamo, poi spieghiamo che cos'è questo wait, giusto per capire. Anche qua, così vedete meglio. Ok. Questo è il nostro grafo adesso, e adesso vedete che se chiamiamo g, il nostro i graph sa che ci tratta di un grafo, non ci fa più vedere la nostra, la nostra lista di righe, ma ci fa vedere il grafo, ci dice quanti nodi ci sono, quanti archi ci sono, e questo grafo è un grafo preso da un libro della serie del Trono di Spade. Spero che siate più o meno familiari con i nomi dei personaggi, così li usiamo un pochino. E due personaggi, perché la domanda fondamentale è sempre quali sono i nodi, quali sono gli archi, due personaggi appaiono collegati in questa rete, se all'interno del libro si sono parlati, si sono apparsi nella stessa dinamica, si hanno interagito assieme. E il numero che vedete dopo, cioè questo weight, è il numero di volte che questa interazione è avvenuta. Per cui, tante volte numero alto, una volta numero basso, meno di una l'arco non c'è. Ok? Questa qui è la preview che ci dà iGraph dei nostri. Ditemelo se ci siete, fatemi un cenno, se posso andare avanti. Io ci sono qui qui. Ok. C'è un chat, ci sono, ok, perfetto. Allora, questa è la preview che ci dà iGraph, ci dà alcune informazioni che possiamo imparare subito a leggere. Ci dice che questo grafo non ha direzione, è undirected, con una U e una N. e lo sappiamo perché in un qualche modo gli abbiamo detto noi, quando l'abbiamo letto, gli abbiamo detto directed false e quindi lui ci conferma che è directed, che non ha una direzione. Ci dà un numero di nodi e un numero di archi. 107 nodi, 352 archi. Ci dice che il grafo ha degli attributi, che è questa riga qua, at. Questi attributi sono due. Uno che è name, che è applicato a v, quindi è applicato ai vertici, è un attributo che è applicato ai nodi. Ed è un character, è una stringa di testo. Abbiamo un altro attributo che è weight, che è applicato agli edge ed è un numerico. E quindi è un numero. E noi queste cose in qualche modo le sapevamo già, però è bello sapere che adesso anche iGraph le sa. E poi ci fa vedere le prime x righe della lista degli edge. Ok? Quindi abbiamo un po' di cose. Ora che abbiamo una nostra rete dentro iGraph, possiamo finalmente cominciare a farci qualcosa. La prima cosa che possiamo fare, vabbè, è se proprio non ci fidiamo della nostra overview, è chiedergli quanti archi ci sono nel nostro grafo che facciamo con iCountG. E ci conferma che ci sono 352 archi. V-CountG, G perché abbiamo chiamato questo grafo G, ci dice che ci sono 107 nodi. Di queste cose le sapevamo già perché sono informazioni che arrivano nella preview, ma giusto per confermare, se parte V-CountG1, che è un grafo che abbiamo creato prima, ci dice che ci sono 3 nodi. Quindi con V-Count e iCount avete il numero dei nodi e il numero degli archi. Una cosa utile per descrivere una rete è il concetto di densità del grafo. La densità del grafo è sostanzialmente il rapporto tra gli archi o gli edge che osserviamo rispetto agli archi potenziali. Quindi possiamo fare, il problema è sempre definire quanti sono gli archi potenziali a questo punto. Però se ci pensate un attimo, forse ci possiamo arrivare a quanti sono gli archi potenziali in un grafo. Qualcuno vuole lanciarsi? No? Ok. Comunque, diciamo che abbiamo una formula che sostanzialmente è il numero di archi per il numero di nodi, per il numero di nodi meno uno, perché noi di solito non ammettiamo che un nodo si connetta con se stesso. In questo caso è 3,5. Non so qual è questo caso, però no. È difficile avere un virgola come arco potenziale. Un arco o c'è o non c'è. Cioè l'arco potenziale per capirci è se tutti fossero connessi con tutti. Quindi il massimo numero di archi possibile. Quindi diciamo in questa rete di Game of Thrones abbiamo 107 nodi. Ipotizziamo che tutti si possano connettere con tutti, ma non con loro stessi, perché non ha molto senso avere quello che si chiama un self loop. In certi casi ha senso, in questo caso diciamo che non ha senso. Quindi è il numero di nodi times il numero di nodi meno uno. Poi a seconda che noi si prenda una rete direzionata o non direzionata, quindi che gli archi possano andare in due direzioni o in una direzione sola, quel numero che ci viene lo dividiamo per due o lo teniamo come sta. Comunque senza dover fare questa operazione possiamo anche chiedere semplicemente al graph di farlo per noi e gli chiediamo la graph density di G, che è il nostro grafo. In questo caso la nostra graph density è 0.06. Sembra un numero basso, ma in realtà se noi guardiamo le reti, le reti sociali, è un numero normale, è un numero che ci aspettiamo. Le reti normali sono normalmente reti che si definiscono sparse, perché non sono densamente connesse. Perché così? Perché l'abbiamo osservato un sacco di volte e abbiamo visto, osservazione dopo osservazione, che trovare delle reti sociali che siano densamente connesse non ne abbiamo mai trovate. Per cui uno può anche guardare e dire, le reti sociali mi aspetto che sia sparsa, scarsamente connessa. Ci sono delle teorie sul perché questo avvenga, ma sono teorie che vanno nell'ambito sociologico e possiamo anche lasciarle da parte per il momento. Ora abbiamo una nostra rete, proviamo a visualizzarla un attimo e la possiamo visualizzare col codice simile a quello che abbiamo fatto prima. Stavolta magari ve lo descrivo un attimo, così riuscite anche a vedere meglio. Scusa Luca, e la graph density, quindi da che valore a che valore può andare? Allora, la graph density parliamo di grafi, sostanzialmente grafi sociali con cui abbiamo a che fare noi, sono tutti grafi sparsi, sono tutti grafi nell'ambito di, non so, 0.0, 0.1 e siamo già in alto. Grafi con densità maggiori si trovano in ambiti molto specifici, si trovano ad esempio nelle reti biologiche, nelle reti di interazione tra proteine, ci sono una serie di ambiti della network analysis che hanno a che fare con grafi molto densi, ma sono ambiti molto molto particolari. Normalmente potete immaginarlo anche così da un punto di vista di allocazione delle risorse, normalmente un attore, specie un attore sociale, ha un numero limitato di risorse con cui poi, che deve distribuire, e queste risorse vengono distribuite tra un sotto insieme, diciamo, di tutta la rete sociale che potenzialmente c'è. E quindi normalmente non vengono mai osservate delle densities molto alte. Ma la density di G1 è 1? La density di G1 è 1, sì. Ok, quindi il massimo è 1. Sì, sì, è un valore che va da 0.1, possiamo poterlo, ma graph density G1 è 1. Però, no scusate, è 0.5, perché in realtà G1 è 1. Esatto, sì. Esatto, è diretto. Però possiamo... Comunque, vabbè, in realtà G1 non è una rete, è una cosa che abbiamo costruito noi a tavolino e quindi non c'ha molto a che fare. G1, giusto perché se non è stato chiaro, è 0.5, perché noi abbiamo fatto gli archi diretti e non abbiamo messo tutti gli archi che potevano essere messi. Se vi faccio rivedere il plot di G1, che adesso non ho più qua e non volevo perderci troppo, è questo qua. Vedete, abbiamo un arco che va in qua, ma in una rete direzionata, in teoria possiamo avere un arco che va da qua a qua. Abbiamo un arco che va da qua a qua, ma non abbiamo un arco che va da qua a qua. Abbiamo un arco che va da qua a qua, non abbiamo un arco che va da qua a qua. Quindi abbiamo la metà degli archi che potenzialmente possiamo avere e questo è sostanzialmente il motivo per cui il nostro risultato è 0.5. Se rifacciamo G1, giusto perché poi dopo sembra che io nasconda i segreti della network analysis, ma se la rifacciamo non direzionata, a questo punto, quando rifacciamo la graph density, diventa 1, perché una rete non direzionata quel problema non l'abbiamo più. Torniamo a visualizzare un attimo la nostra rete e così rivediamo un attimo come possiamo visualizzarle, cerchiamo di capire un po' questo codice. Allora, gggraph è un package che serve a visualizzare grafi e lo fa con la sintassi che è stata introdotta nel mondo DR da un package super famoso e super usato che si chiama ggplot2. L'idea è di dividere il più possibile gli elementi che compongono la visualizzazione. Quindi nel caso di un grafo, gli elementi che compongono la visualizzazione sono essenzialmente tre. La struttura, che è, se volete, il modello sottostante, gli archi e i nodi. Quindi la struttura la visualizziamo, gli diciamo qual è il grafo che deve prendere in considerazione, qual è la struttura che deve prendere in considerazione con la prima parte del nostro comando, che è questa gggraphg. però vedete che se la visualizzo non c'è niente, perché non gli ho detto su questa struttura come deve rendere visibili gli archi e come deve rendere visibili i nodi. Quindi se noi aggiungiamo gggraphg i nodi, ci attacca su questa struttura i nodi, vedete poi io specifico la dimensione dei nodi in modo che sia più visibile, però ci attacca la dimensione, ci attacca su questa struttura i nodi, però se aggiungo anche gli archi, avremo i nodi e gli archi. Nodi, struttura e archi sono tre elementi che sono gestiti separatamente in un qualche modo. Quindi la prima parte del comando dice visualizza questo grafo, ma non ti dico ancora come visualizzare gli archi, come visualizzare i nodi, la seconda parte ti dice come visualizzare in questo caso i nodi e la terza parte come visualizzare gli archi. Una cosa che è importante, siccome a capire e ricordarsi, siccome la parte visuale della social network analysis ha avuto un gran successo, siamo tentati a pensare che la visualizzazione sia la rete, ma la visualizzazione non è la rete. La visualizzazione dipende da un algoritmo che sta lì nel mezzo tra la rete e la visualizzazione, che si chiama algoritmo di layout, cioè che è un algoritmo che dice al computer dove deve mettere i nodi, come deve sovrapporre gli archi, per ottenere, a seconda dell'algoritmo, la visualizzazione migliore che c'è. Algoritmi diversi ottengono risultati diversi ed è molto difficile capire qual è il risultato migliore. Ci sono degli algoritmi che sono ottimizzati per ottenere certi risultati, per rendere più visibili certe dinamiche, ci sono algoritmi che sono pensati per rendere molto visibili le strutture di comunità, ci sono algoritmi che sono pensati per minimizzare l'overlapping degli archi tra di loro, in modo che gli archi siano il più possibili, che non si sovrappongano. Ci sono una serie di problemi di questo tipo, però a noi ci interessa solo capire che tra gli archi, tra la forma della rete e la rete, c'è un rapporto che non è banale e come vedete qui ho selezionato uno, due, tre, quattro, cinque algoritmi diversi e ottenete, in realtà questo non è un diverso, perché questo è semplicemente uno di questi, è esattamente questo, sono quattro algoritmi diversi e ottenete quattro forme diverse del nostro grafo. Il grafo è sempre lo stesso, abbiamo usato sempre lo stesso file di partenza, quindi come vediamo la rete e come la rete è, sono due cose diverse e c'è questa mediazione non sempre facile. GG Graph vi dà questa opzione che si chiama Nicely, che è questa che trovate in questa cosa qui, che sostanzialmente, prendendo una serie di misure del grafico, prova a intuire qual è l'algoritmo più appropriato, data la dimensione del grafo, la densità del grafo, il numero di archi, il numero di nodi, cose così. A volte ci prende, a volte no, però se non sapete che algoritmo pigliare, gli dice fammelo carino e lui fa del suo meglio per fartelo carino. Insomma, bisogna anche apprezzare lo sforzo. Quindi, secondo me, questo è giusto per capire ed è importante perché se io vi chiedo, torniamo un attimo a questa visualizzazione qua, se io vi chiedo così, a occhio, se questa rete ha delle comunità, quante comunità ha, la vostra risposta, da un punto di vista visuale, ma l'esplorazione visuale delle reti è una questione utile, importante, perché visualizziamo le cose per capirle meglio, la vostra risposta cambia molto a seconda del layout che vedete. Perché se usiamo questo DRL qua su, vedete che vi viene quasi scontato dire che, beh, certo, ci sono tre comunità ben distinte in questa rete. Guarda, ce n'è una qua, una qua e una qua. Se usate l'algoritmo KK, già comincia a diventare più difficile vedere le tre comunità. Nel senso che, boh, forse, magari posso identificare questo gruppo qua, che è tenuto insieme solo da questo nodo, però non lo so, nell'algoritmo FR, sicuramente ne identificate due, però forse tre, chi lo sa, LGL, boh, per cui capite che la sensazione che abbiamo, le intuizioni che abbiamo delle reti, sono fortemente create dall'algoritmo di layout che abbiamo applicato. ed è il motivo per cui fidarsi troppo delle visualizzazioni non è mai una buonissima idea. È una cosa che usiamo per esplorare, è una cosa che usiamo per raccontare dei risultati, ma dopo che i risultati li abbiamo, in qualche modo, già ottenuti. Se io so che ci sono tre comunità, perché lo misurate in un'altra maniera, poi domani vedremo come, posso decidere di visualizzare quelle tre comunità con un algoritmo che magari mette in evidenza quella dimensione lì. Quindi è una questione un po' scivolosa. Allora, un altro concetto utile per accapezzarci e credo utile anche per quello che è il futuro dell'attività che volete fare nel corso, è il concetto di componenti. Che cos'è un componente della rete? Un componente della rete è un gruppo di nodi che è isolato rispetto al resto della rete. Per cui, in questa, ed è una cosa che con iGraph prendiamo con il comando components g. Components g vi restituisce un oggetto che contiene all'interno varie informazioni, contiene una lista dei nodi per ogni componente, contiene la dimensione di ogni componente e poi contiene anche il numero di componenti. In questo caso, nel caso di questa rete, come avete potuto vedere anche prima visivamente, c'è un unico componente, quindi abbiamo un component g uguale 1. Lo potete ottenere solo quel numero semplicemente facendo un comando e accedendo direttamente alla parte NO che è la parte del numero. Questo non vuol dire che, però la cosa importante è che un componente è un gruppo di nodi isolato dal resto della rete. Il fatto che i nodi siano isolati dal resto della rete è una questione un po' problematica perché e vedremo tra un po' molte misure che possiamo calcolare sulle reti hanno a che fare con il concetto di distanza tra due nodi. Allora, la distanza tra due nodi è definita come il numero di archi che io devo traversare se devo spostarmi dal nodo A al nodo B. Quindi, se il nostro nodo A e il nodo B sono, torniamo su all'inizio, sono Sophie e Joe, la nostra distanza sarà 1. Se non ci fosse una connessione diretta e per andare da Bill Sophie dovesse passare da Joe, la distanza tra Sophie e Joe sarebbe 2 perché deve attraversare due archi. Il problema è qual è la distanza se dei componenti sono sconnessi dal resto della rete, cioè se io non posso raggiungere un gruppo di nodi traversando la rete perché non c'è materialmente un arco che li connetta. Questo problema è un problema non banale e sostanzialmente viene gestito in molti casi semplicemente lavorando invece che su tutta la rete lavorare su quello che si chiama giant component che è il componente, il gruppo di nodi connesso più grande di tutti quelli che vedremo, di tutti quelli che troviamo nella nostra rete. In certi casi questa cosa ha senso, in altri casi questa cosa è più problematica perché escludere dei componenti, vuoi perché magari non sono così piccoli, perché la differenza tra giant component e componenti minori non è così grande, o vuoi perché in realtà ci dicono delle cose, è problematico. Però ci sono, se non escludiamo questi componenti, ci sono tutta una serie di metriche e ne parleremo di alcune che molto banalmente non hanno senso. Perché? Perché assumono un unico componente e quindi avere delle distanze infinite tra due nodi perché appartengono a componenti disgiunti è una roba che queste metriche che pur sono molto usate, che poi hanno molta importanza, eccetera, non riescono a gestire e quindi lo vedremo tra un po' però è importante il concetto di componenti perché il componente è un gruppo di nodi che internamente funziona come una rete ma non necessariamente anzi, ma non è in connessione con il resto della rete e su questo nodo, su questo gruppo, su questo componente possiamo applicare alcune metriche ma non possiamo applicarne altre. Facciamo questa cosa qui e poi dopo facciamo una pausa. un po' più, perché Fabio mi ha detto che siete abituati a tirare lungo ma siccome non è che parlate molto io devo prendere fiato e bere un po' di tè. Allora, un concetto base diciamo della network analysis, dell'analisi delle reti è il concetto di grado, grado credo che sia come viene tradotto in italiano, comunque è la degree. la degree di un nodo è il numero di connessioni che quel nodo ha. Se noi scriviamo degree G abbiamo un bel elenco con il nostro nome del nostro personaggio di Game of Thrones e il numero di connessioni che ha. Possiamo, sapendo che i nostri nodi hanno degli attributi, possiamo anche usare questi attributi per chiedere la degree di un nodo in particolare. Ad esempio, la degree del nodo Aria ha 19, ha degree uguale a 19, la degree del nodo Fion a degree 4. E così sappiamo anche un po' come usare. Stiamo iniziando a vedere come usare gli attributi. Cosa ce ne facciamo di questi attributi? Beh, li possiamo usare per selezionare dei nodi all'interno del nostro grafo. Possiamo, invece, usare il comando V maiuscolo che in iGraph vi permette di accedere ai vertici, ai nodi. Quindi, se io faccio V di G ottengo l'elenco di tutti i miei nodi. Se faccio E di G ottengo l'elenco di tutti i miei edge, di tutti i miei archi. In preview viene omesso, ne vengono omessi molti perché sennò diventerebbe illegibile. Sapendo che abbiamo un comando per accedere ai vertici, per accedere ai nodi e per accedere agli edge, per accedere agli archi e sapendo che nodi e archi in questo caso hanno degli attributi, beh, possiamo usare una sintassi che è molto simile a quella che usereste in R normale per accedere a un nodo specifico o a un edge specifico. Ad esempio, in questo caso possiamo accedere al nodo dove il name del nodo, dove l'attributo name del nodo è uguale a brand. Ovviamente accediamo al nodo dove l'attributo del, non abbiamo niente da avere, quindi chiediamo e lui ci restituisce un nodo che si chiama brand, e il grattere cacchio lo sapevamo anche prima, però comunque questa è l'idea. Oppure possiamo chiedere solo, di avere solo gli archi, usando la nostra e che serve ad accedere agli edge, dove l'attributo weight è maggiore di una soglia, maggiore di 20, e vedete che ne abbiamo solo 51. Possiamo vedere solo quelli che sono minori di 20, e ne abbiamo molti di più. Possiamo anche vedere l'arco dove il peso è uguale al massimo peso possibile che osserviamo negli archi, ed è la relazione tra brand erodoro. A questo punto in realtà se pensiamo, se torniamo indietro quando dicevamo per capire le cose dobbiamo capire il contesto, e ricordatevi come ho detto che è stata formata questa rete, questa qui è la relazione più forte dove il peso è maggiore tra tutte le relazioni che osserviamo. Possiamo anche vedere relazione minore, ce ne sono tante di relazioni minore, quindi possiamo immaginare che la distribuzione della forza delle relazioni sia abbastanza skewed dove abbiamo poche relazioni molto forti e molte relazioni poco forti come è probabile che sia. Possiamo anche aggiungere degli attributi ai nodi che abbiamo, cioè noi abbiamo creato degli attributi, l'attributo name viene creato di default dai graph ogni volta che trova una, che crea una rete. L'attributo weight l'abbiamo creato nel nostro file perché c'era una colonna weight rispetto ai nostri edge, però possiamo anche aggiungergli degli attributi. Ad esempio possiamo aggiungere al nostro grafo il valore del, la degree di ogni nodo. Quindi quello che facciamo qui è selezionare gli archi, se lo date, selezionare i nodi del grafo e come faremmo in R aggiungere l'attributo che vogliamo aggiungere, quindi col dollaro deg e gli buttiamo dentro la degree di g. Quello che dobbiamo sapere per capire perché questo comando funziona è che iGraph indicizza i nodi e qualunque operazione noi facciamo sui nodi, i nodi verranno sempre riproposti in quell'ordine per cui l'ordine che noi otteniamo da vg è lo stesso se guardate i nomi ordine che otteniamo da degree g. Vedete Imon Eris Imon Eris Alistair quindi in realtà facendo questo prendiamo questi risultati qua questi numeri qua e li mettiamo come attributo che chiamiamo deg nel nostro grafo adesso se chiamiamo di nuovo g vediamo che il nostro grafo ha un attributo in più che è deg che è un attributo dei vertici e che è un numero perché degree è un numero ha senso fino a qui? ok a questo punto ora che abbiamo un attributo sul nostro grafo beh possiamo usarlo e quindi possiamo vedere quali sono i nostri attori i nostri personaggi con degree maggiore di 10 ce ne sono un po' ok ora vi faccio una cosa l'esercizio mi sa che lo saltiamo però volevo farvi un faccio vedere una cosa poi dopo facciamo la pausa adesso quello che faccio qui è creare un data frame che è una struttura di dati sostanzialmente una tabella che creiamo dentro R dove chiamiamo DD creiamo un data frame dove la nostra ci creerà una colonna sola dove la deg V dove la colonna sola sarà la degree dei nostri nodi adesso faccio vedere come viene fuori è un unico colonna vedete una colonna lunga con la nostra degree ok perché faccio questo perché voglio farvi vedere una cosa che è una cosa importante rispetto alla teoria dei grafi e rispetto ai grafi sociali prima ve lo faccio vedere e poi ve lo spiego questa qui quella blu quello rosso è la distribuzione della degree per la nostra rete vedete vedete abbiamo un sacco di personaggi con bassa degree diciamo meno di 10 e poi abbiamo via via meno personaggi con degree molto alta questo tipo di distribuzione è una distribuzione che trovate sempre nelle reti sociali quella blu è la distribuzione della degree di un di un grafo random che ha lo stesso identico numero di nodi ho creato prima dopo vi faccio vedere il codice per curiosità ma prendendo un grafo e creando i nodi in modo casuale quindi sostanzialmente assegnando una probabilità per un nodo di esistere o non esistere ma non privilegiando un nodo rispetto a un attore quello che otterrete è un grafo con una degree distribution sostanzialmente normale quello che sappiamo è che c'è una prova matematica di questo di cui non abbiamo tempo di andare adesso ma che un grafo random vi produrrà una degree distribution normale mentre le degree distribution skewed in particolare rispetto in particolare oltre una certa dimensione della rete in particolare con distribuzioni power low sono tipiche o indicano meccanismi di formazione sociale quali sono questi meccanismi è una lezione che teniamo per un altro per un altro momento però è un modo se voi aveste una rete e non sapeste da dove viene osservare la degree distribution è un buon meccanismo per cominciare a dire beh questa rete è una rete sociale o questa rete sociale intesa che è stata creata osservando raccogliendo entità sociali che interagiscono tra di loro oppure è una rete che probabilmente è creata da meccanismi casuali questo diciamo più complesso di così ma sostanzialmente l'idea è questa per vedere come l'abbiamo creata sostanzialmente ho creato un grafo casuale che iGraph crea con random graph game dove richiede di sapere il numero è un questo random graph game è basato su un modello di grafi che si chiama Barabagi Albert ma insomma questo è no scusate Erdosreni che sto dicendo Erdosreni dove chiede di avere il numero di nodi chiede di avere una probabilità per il l'arco di esistere in questo caso abbiamo dato 0 1 e chiede poi quale se vogliamo specificare la probabilità o se vogliamo specificare il numero di archi possiamo anche aumentare la probabilità il grafo aumenta di densità chiaramente ma se guardate alla forma della distribuzione la forma della distribuzione rimane invariata sempre un po' bimodale quindi insomma comunque rimane invariata e direi che sono le 5 facciamo 5 minuti di pausa se avete delle domande questo è un buon momento o potete fare anche l'esercizio se non volete lasciare neanche un secondo di tempo di pausa io torno subito vai vai ok li intrattengo io se ci sono arrivo subito si si ci vediamo fra 5 minuti ok anche voi se volete fare una pausa fatela pure allora torniamo tra 5 minuti si si va benissimo finiremo finiremo comunque più o meno all'orario che avevamo deciso potremmo finire ai 35 qualcosa del genere ma più o meno saremo lì perfetto perfetto grazie non so Pari stai cercando di dire qualcosa perché il microfono spent si no è che stavo scrivendo nella chat con la diceva la gg arrange che libreria usa che non ho trovato la gg aspetta che non ti ho sentito bene la gg arrange allora gg arrange dovrebbe essere sempre i graff credo dopo chiediamo a luca ma mi sembra strano che sia qualcosa di diverso dai graff mi dice che non la prova dopo ho seguito comunque il codice non lo so perché poi dopo noi usiamo ovviamente una frazione di queste potenzialità per degli obiettivi molto molto specifici no ma poi immagino che di solito avrete una serie di librerie che comunque è un altro processo esatto grazie che Grazie. Ok. Non so se qualcuno è andato via e dobbiamo aspettare che torni. Non so Fabio se è in mute. Sì, qualcuno credo che sia allontanato. Mi chiedeva Paride Arrange se appartiene a un'altra libreria oppure GG Arrange. Ah, GG Arrange. Sì, GG Arrange è la libreria pub che è... Adesso la faccio vedere. Qua in alto, qua in alto, qua in alto. GG Pub. In pratica semplicemente serve a disporre più plot all'interno dello stesso plot. Magari lo mettiamo nella chat così. Lo metto così. Ma comunque dopo facciamo così. Dopo rigenero questo qui e così ci sono anche tutte le cose. Quando siete tornati ragazzi fate un cenno. Nel metto mi sono cambiato la maglietta perché per un twist inaspettato è arrivato tipo un caldo tropicale. Stamattina tipo nevicava. E il bello di essere in Danimarca dove... Sì, sì. Quest'estate, questa primavera è un po' problematica. Imprevedibile. Ecco Luca, ho visto per un attimo che è tornato. Però è il microfono spesso? Sì, ho visto, ho preso il click. Dicevo finisco di masticare e poi... Guardo le canne. Ok. Ok. Vogliamo ricominciare? Ok. Allora, poi se non so adesso io... Fabio mi ha detto che magari preferite finire un po' prima. Cerchiamo di finire sulle tre quarti se vi va bene. Allora, adesso abbiamo, giusto per fare un micro recap, abbiamo introdotto il concetto di degree o di grado che è essenzialmente il numero di connessioni che un nodo ha. Chiaramente se abbiamo una rete direzionata abbiamo la possibilità di avere in degree, le connessioni che il nodo riceve, out degree, le condizioni che vanno dal nodo verso l'esterno. Nel caso in cui ci sia una rete non direzionata, avremo semplicemente la degree e via. La degree è importante per un sacco di cose, un po' perché contando essenzialmente il numero di connessioni ha un rapporto molto diretto con la struttura della rete. Quindi potete capire chiaramente la struttura della rete. Studiando la degree distribution potete capire la probabilità, ad esempio, di essere connessi con un nodo, con altri nodi, eccetera. È una metrica che, ad esempio, non soffre del problema di cui parlavamo prima dei componenti, che è possibile contare in componenti sconnessi quante connessioni hai nel componente A e quante connessioni hai nel componente B. Quindi è una metrica molto semplice, ma in realtà anche molto potente. Ed è anche la prima soluzione che viene in mente quando si chiede, vogliamo usare queste reti per individuare i nodi più importanti delle reti. Cioè, una delle applicazioni classiche della network analysis è usare le reti per identificare gli attori che sono più importanti. Detto con un altro termine, per identificare la centralità degli attori. Quanto un attore o tutti gli attori sono importanti all'interno della rete che stiamo studiando. Il modo più semplice, probabilmente, che viene in mente è dire, beh, se uno ha tante connessioni, allora è molto importante. E questa qui è, di fatto, in soldoni, la definizione di quella che si chiama degree centrality. Cioè, conto il numero delle connessioni e poi il nodo con più connessioni e più importante, faccio il mio bel ranking e ho tutti i miei nodi e ho un criterio per dire questo è il mio nodo che, se voglio individuare chi è il capo qui dentro, è questa persona qua. Chiaramente, e noi lo facciamo, l'abbiamo già fatto, adesso il nostro grafo sappiamo che ha un attributo sugli attori che si chiama degree centrality. e quindi possiamo chiedere ad I-Graph qual è l'attore che ha la degree centrality più alta e sappiamo che è Tyron, che, oh, ha senso? Forse sì, se avete presente il libro, se avete presente la storia, dire, oh sì, sì, forse, probabilmente ha senso. Ora vediamo un altro po' di metriche di centralità, perché sono comunque importanti e perché, vedo, una delle prime cose che uno vuole fare quando ha una rete per le mani è capire chi sono gli attori importanti dentro questa rete. Però, se ci cominciate a pensare un attimo, importanza non è proprio un concetto chiarissimo. Che cosa vuol dire importante? Cioè, nel senso, anche dentro una rete, che cosa vuol dire importante? Vari autori hanno introdotto varie misure. Le metriche di centralità sono n più una, potete inventarne anche voi una, se vi va, nessuno vi dirà che non è giusta, per cui fatela, inventatevi una bella metriche di centralità, pubblicate e poi siamo felici. Diciamo, concettualmente, cercano di interpretare alcuni aspetti di senso rispetto a cosa può voler dire essere importanti, essere rilevanti, essere centrali all'interno di una struttura. Metriche diverse hanno sensi diversi sia a seconda del tipo di rete. Cioè, alcune metriche hanno senso in una rete sociale, non hanno nessun senso in una rete di trasporto o in una rete geografica. Alcune hanno senso per problemi specifici. Ad esempio, vedremo una metrica, tra poco, che ha molto senso se studiamo una rete e vogliamo simulare su questa rete la propagazione di un virus, ha molto meno senso per altre questioni. Un'altra metrica molto famosa è quella che si chiama betweenness centrality. La betweenness centrality cerca, concettualmente, di identificare i nodi che sono all'interno del numero maggiore di percorsi più brevi tra tutti gli altri nodi. Questo richiede un po' di unpacking, questa cosa. Però, abbiamo detto che la distanza tra due nodi è la distanza che un numero di archi che dobbiamo traversare per andare dal nodo A al nodo B. quindi, se torniamo alla nostra rete per andare da questo nodo a questo nodo, abbiamo un arco e la nostra distanza è una. Ora, immaginate una situazione un po' più complessa con più nodi, con più archi. C'è l'assunto che quando bisogna spostarsi da un nodo all'altro, misuriamo la distanza sempre con quello che chiamiamo shortest path, cioè, la distanza è sempre uguale al numero più basso di archi che devo traversare per andare da un nodo A al nodo B. Perché, chiaramente, nel momento in cui ho una rete grande, le possibilità di andare tra il nodo A e il nodo B aumentano. Posso prenderle la comoda, posso girare intorno, posso fare 50.000 giri o posso seguire la distanza minore. Lo shortest path è la distanza minore tra due nodi e ogni nodo, ogni coppia di nodi ha uno shortest path o anche più shortest path a patto che siano della stessa lunghezza. A quel punto l'assunto è che quando ci si muove tra due nodi si scelga sempre lo shortest path. Cioè, gli assunti della network analysis sono razionali. Se puoi prendere la strada più corta, prendi la strada più corta e non prendi la strada più lunga. La between centrality quindi quello che fa è cerca di capire, non cerca di capire, conta sostanzialmente per ogni coppia di nodi quanti nodi sono all'interno degli shortest path. Cioè, io prendo il nodo Luca e conto il nodo Luca all'interno di quanti shortest path tra tutte le possibili combinazioni di nodi che ho in questa rete si trova a Luca è in mezzo a tre shortest path. Il nodo Fabio è in mezzo a 50 shortest path. Quindi, il nodo Fabio ha una between centrality più alta rispetto al nodo Luca. E questo è abbastanza semplice. L'intuizione dietro a questa cosa è che se tu sei su tanti percorsi più brevi, su tanti shortest path, avrai un maggior controllo rispetto al fluire delle informazioni. Perché l'assunto, ripeto, è che si prenda sempre lo shortest path per andare da A a B. E se tu sei lì nel mezzo, avrai un controllo o comunque la possibilità di influire o comunque la possibilità di avere un effetto su quello che ti passa attraverso. E siccome sei su tanti shortest path, ti passerà attraverso molta più informazione, molti più collegamenti, molti più dati, di quanta non passi attraverso un altro nodo che non è in nessuno shortest path. Quindi Luca, essere su tanti shortest path ha anche un'implicazione rispetto all'importanza di quel nodo per tenere in qualche modo insieme la rete perché se non ci fosse il shortest path sarebbero più lunghi in media. Infatti, una delle cose per cui si usa la shortest path è per capire, per identificare non solo i nodi importanti per il fluido delle informazioni, ma identificare i nodi che vengono chiamati bridge, cioè nodi che con la loro esistenza o collegano due comunità, voi immaginate due comunità che sarebbero disconnesse, sarebbero due componenti, ma non sono disconnesse perché c'è un nodo che li tiene assieme. Immaginate che ci sia una comunità a Urbino e una comunità a Copenaghen e io che ho fatto, ho studiato a Urbino, lavorato a Urbino, vivo a Copenaghen, lavoro a Copenaghen, sono l'unico essere che ha questa caratteristica e che quindi tiene insieme queste due comunità che altrimenti sarebbero sconnesse. Se mi uccidete le due comunità la rete si decompone, diventa due componenti. Quindi è chiaro che la mia rilevanza non è tanto perché magari posso avere anche solo una connessione con Urbino e una connessione con Copenaghen, ma la mia rilevanza è perché tengo insieme queste due cose. chiaramente quando andate a controllare lo facciamo dopo questo discorso, scusate, quindi la between centrality cerca di misurare un'altra idea di importanza che non è più l'importanza dovuta a tante connessioni e tanto onore ma è l'importanza dovuta alla struttura della rete è particolarmente dipendente dalla presenza di questo nodo perché se rimuovo quel nodo la distanza media tra i nodi aumenta i componenti si può aumentare a tal punto che nel caso dei due componenti che si sconnettono diventa infinita aumenta molto e quindi l'idea di between centrality va in una direzione diversa un'altra un'altra un'altra un'altra metrica di centralità è quella che va sotto il nome di closeness centrality la closeness centrality ha un non è difficile da spiegare però non ci riesco mai quindi abbiate abbiate pietà la closeness centrality semplicemente misura la distanza tra un nodo e tutti gli altri nodi quindi tra il nodo A il nodo B il nodo A il nodo C il nodo A il nodo D il nodo A il nodo E tra un nodo e tutti gli altri nodi e il nodo che ha la distanza minore cioè che è più vicino cioè che è close con tutti gli altri nodi in generale ha la closeness centrality più alta cioè la misura della closeness centrality è che un nodo possa essere più vicino o meglio meno lontano da tutti gli altri nodi a cosa serve la closeness centrality? beh se noi ipotizziamo che ci voglia del tempo ad esempio per propagare qualcosa sia essa un'informazione o sia essa un virus e che questo tempo sia legato alla distanza direte cioè al numero di steps che la cosa che vogliamo propagare deve passare allora è chiaro che se io devo decidere chi infettare con un'informazione con un virus se infetto la via closeness centrality più alta il nodo che ha la closeness centrality più alta quello che otterrò è che rispetto a tutti gli altri nodi questa cosa che voglio propagare avrà meno steps meno passaggi da percorrere per raggiungere l'intera rete quindi quando si fanno ad esempio le simulazioni di prevenzione epidemiologica si cerca di identificare i nodi con closeness centrality più alta perché vogliamo evitare questa dinamica qui vogliamo evitare che esseri infetti siano dei nodi che potenzialmente possono infettare tutta la rete molto facilmente come vedete le scusate sono dimenticato vediamo la closeness centrality prima e quindi chiediamo calcoliamo la closeness centrality come abbiamo fatto esattamente come abbiamo fatto con la between centrality creiamo nel nostro grafo nei vertici del nostro grafo un attributo close calcoliamo la closeness di g e poi chiediamo qual è il nodo con la closeness centrality più alta e ci viene fuori che ancora una volta a tyron facciamo anche la betweenness giusto per essere infatti lo stavo per richiedere facciamo anche la betweenness non mi ricordo se è sempre tyron o meno john e se ci pensate john snow ha un po' più senso che sia tyron perché john snow quello lo mandiamo alla barriera quindi c'è tutto un gruppo di attori che hanno a che fare solo con john o comunque che conosce solo lui tyron anche lui ci va alla barriera però non mi ricordo se ci va già in questo libro oppure no comunque vedete abbiamo degli attori che non sono tutti uguali per cui possiamo vedere poi il ranking di tutti gli attori però in ogni caso quello con la betweenness centrality più alta non è lo stesso di quello che ha la degree centrality e la close-up centrality più alta l'ultima metrica di centralità ma davvero la lista delle metri di centralità è molto lunga e non è spesso si tratta anche di variazioni sul tema è quella che si chiama e-game vector centrality allora l'e-game vector centrality sostanzialmente parte dalla è una formalizzazione dell'idea del è più importante avere tanti amici o è più importante avere amici che sono importanti perché a un certo punto uno può dire beh vabbè ma sai che c'è che se io ho cinque amici ma questi cinque amici sono il papa il presidente dei Stati Uniti il presidente della Cina e non lo so qualcun altro sono tanto importanti non perché sia importante perché abbia tanti amici ma perché i miei amici sono molto importanti questo concetto viene concretizzato nella eigenvector centrality dove quello che si conta la misura dell'importanza è data sulla base delle connessioni dei nodi a cui siamo connessi per cui se io ho un amici con tante connessioni mi porto dietro il peso di queste connessioni che hanno i miei amici calcolo in vari modi e poi ottengo una metrica che è definita non tanto dal mio numero di connessioni ma dal numero di connessioni dei miei amici il modo più semplice è fate la somma delle connessioni di tutti gli nodi a cui voi siete connessi se tu sei connesso a un hub in modo altamente connesso ti porti dietro in corpo e anche tutte le sue connessioni e questa cosa qui la possiamo vedere esattamente come quasi esattamente come come l'altra e ci dice che il nome con il nodo con la maggiore gain vector centrality è Tyron ora come avete intuito dal fatto che ci è venuto Tyron a quattro volte su tre questo è difficile tre volte su quattro la correlazione tra le varie metric di centralità è abbastanza alta adesso questo non dovete farlo è giusto per farvelo vedere se guardate un attimo il nostro plot della correlazione la correlazione tra le varie misure è abbastanza alta è chiaro che alcune sono più correlate de altre per cui in uno scenario dove comunque la correlazione tra le varie misure è diciamo positiva ed è positiva abbastanza abbastanza alta vedete che la correlazione tra gain vector e betweenness ad esempio non è altissima così come non è altissima quella tra betweenness e closeness quindi abbiamo un po' di differenza questo po' di differenza varia e lo vedrete variare a seconda delle reti però quello che mi importa sottolineare è che l'idea sottostante la centralità di queste metric è essenzialmente diversa poi siccome iGraph e come qualunque altro software che lavora con le reti vi dà la centralità di qualunque metrica vogliate il punto importante è capire perché uno sceglie una metrica rispetto a un'altra perché sono tutte diverse quindi a seconda della mia diciamo definizione di centralità o importanza nel contesto specifico può avere senso sceglierne una o sceglierne l'altra tenete presente che tutte cioè in particolare la betweenness e la closeness in misura minore la eigenvector sono affette dal problema di cui parlavamo prima cioè sono affette dal problema dell'essere utilizzabili all'interno di componenti disconnesse e questa è una cosa che se non ci pensate ma semplicemente le calcolate ottenete dei risultati però perché la distanza esiste non è che non esista semplicemente esiste la distanza e quindi la betweenness centrality e quindi la closeness centrality che è applicabile all'interno del componente quindi se avete un componente molto piccolo un componente molto alto calcolate betweenness centrality o closeness centrality ottenete dei valori però quei valori sono relativi al componente non sono relativi alla rete nel suo insieme e la comparabilità tra queste due cose fa un attimo vista potete anche normalizzare i valori però non è così concettualmente così a problematico compararli perché se sei in un componente molto piccolo e compari questa cosa con un componente molto grande insomma bisogna capire un attimo che cosa si sta facendo allora vediamo un attimo ci sono domande fino a qua no? ok allora volevo provare a farvi vedere l'ultima cosa di visualizzazione adesso visualizziamo un po' lasciate stare i warning che ho io che sono problemi locali visualizziamo mettiamo un po' insieme tutte le cose che abbiamo usato in questa in questa rete e abbiamo e cerchiamo di visualizzare di ragionare un attimo su come le possiamo visualizzare e anche interpretare allora questo è il codice lo vediamo un attimo magari lo zoom anche un po' meglio ok abbiamo detto quando visualizziamo con gggraph stacchiamo i nostri elementi prendiamo la struttura del grafo che possiamo anche dargli un layout qui se vogliamo poi aggiungiamo i nostri nodi aggiungiamo questo è più possibile aggiungiamo il nostro il testo che in realtà sono queste etichette che aggiungiamo che vengono gestite come un elemento separato aggiungiamo i nostri link e poi mettiamo un tema che semplicemente è un insomma cambia lo sfondo anziché farlo grigio o fa bianco così lo leggete meglio allora che cosa facciamo quando aggiungiamo il germ node point questo è una sorta di crash course in ggplot allora quando attacchiamo vogliamo visualizzare qualcosa uno dei nostri elementi ma questo elemento il modo in cui lo vogliamo visualizzare è fisso semplicemente lo scriviamo come in questo caso abbiamo germ edge link che ci fa la gli archi e vogliamo che tutti i nostri archi indistintamente abbiano alpha che è un valore di trasparenza uguale a punto 2 possiamo cambiare alpha e mettere color e dire che vogliamo che i nostri archi siano rossi ok i nostri archi sono tutti rossi adesso ok perché noi abbiamo applicato il nostro la nostra opzione color torniamo con alpha che è un pochino più bello a tutti gli archi indistintamente ok se invece vogliamo che l'attributo che scegliamo nella visualizzazione sia attaccato a un dato attaccato a un'informazione ad esempio attaccato al valore di degree centrality e che quindi ogni nodo in quanto ogni nodo ha un valore di degree centrality diverso venga visualizzato in un modo diverso dobbiamo usare quelle che ggplot ma anche gggraph in questo caso chiama estetiche se guardate dove mettiamo i nodi che è questa parte qua mettiamo questo qua sotto vedete che abbiamo un as che sta per estetic e dentro l'estetic diciamo beh la size cioè la dimensione dei nodi la fai uguale a deg che è l'attributo che noi abbiamo per la degree il color cioè il colore dei nodi lo fai uguale a bet che è il colore che noi abbiamo della between l'attributo che noi abbiamo della between centrality possiamo formiamo il text germ node text che è questo layer dove attacca un nodo un'etichetta e gli diciamo beh la label di questi nodi siccome è diversa per ogni nodo la mettiamo dentro una estetica e la label la facciamo la label stessa cioè quello che ci devi scrivere la prendiamo dall'attributo name e la size quanto devi fare grande quella label la prendiamo dall'attributo tag quindi la size della nostra label è proporzionale al valore della degree anche la size del nodo è proporzionale al valore della degree così abbiamo dimensione del nodo e dimensione della label che rappresenteranno il valore della degree e colore che rappresenterà la betweenness se non ci piace la betweenness ci mettiamo non so cosa che abbiamo messo la closeness close e abbiamo un'altra cosa abbiamo il valore di close e un valore di degree senza scendere troppo nei dettagli della visualizzazione quello che mi interessa mi interessa capire qui diciamo secondo me con questo codice potete cambiare i parametri e vedere un po' l'effetto che fa però in teoria potete avete tre cose a disposizione le etichette la dimensione del nodo e la dimensione del e il colore del nodo domande? no? ha senso da qua? faccio una velocissima riflessione sul sul fatto che c'è il modo di approcciare queste cose appunto attraverso come lo stiamo facendo noi il codice che fa comprendere alcune cose a basso livello poi vedrete che ci sono strumenti come Gephi che quindi rendono tutto questo attraverso un'interfaccia grafica user friendly piuttosto user friendly diciamo non alla portata di tutti ma molto semplice che dall'altra parte rischiano di mettere uno strumento piuttosto potente in mano e a persone che non ne comprendono esattamente il significato per cui tu molto facilmente calcoli tutte queste queste metriche crei molto facilmente dei grafi delle visualizzazioni molto belle ma dopo talvolta diciamo manca la comprensione piena di quello che uno sta esattamente facendo o comunicando beh c'è anche Gephi ha questo aspetto tant'è che Gephi è anche venduto da venduto insomma promosso da chi l'ha realizzato come un software per l'esplorazione visuale dei grafi quindi punta molto sull'aspetto visuale produce visualizzazioni anche molto belle tant'è che esiste tutta una una dimensione che si chiama Gephi Art cioè di grafi molto belli molto evocativi che però non dicono niente perché in realtà quando un grafo ha più di qualche centinaio di nodi la capacità effettiva di cogliere delle strutture l'occhio non ce l'ha non credete a qualunque cosa vi dicano quando i grafi sono un po' troppo grandi l'occhio lo si prende in giro molto facilmente però sono diciamo enormi palle di nodi con colori sfumati e un po' fluo che se le mettete su uno sfondo nero fanno molto science fiction e funzionano molto bene sono belle da vedere che tu in quelle cose riesca a leggerci qualcosa di più di ci sono tanti ci sono pochi nodi o ho usato questi colori diciamo è un po' è un po' è un po' discutibile tempo stesso è utile da un certo punto di vista cercare di visualizzare le reti perché ci può servire delle intuizioni però sappiate che sopra le centinaia di nodi è molto difficile molto molto difficile e lo vedrete anche quando lavorerete con Gefi e reti grandi quando chiedete a Gefi di applicare un algoritmo di layout e ce ne ha un tot che cercano di massimizzare la struttura cioè massimizzare l'interpretabilità della struttura quel povero poveretto sta lì a lavorare per giornate intere cercando di mettere un nodo di qua un nodo di là per evitare che gli archi si sovrappongano tutti ma poi alla fine gli archi finiranno per sovrapporsi e i nodi che si vedranno saranno quelli che si vedranno e una serie di altri problemi quindi non è non è così così straightforward della cosa però quello che mi interessava adesso era essenzialmente la parte di calcolo di metriche di centralità capire come con iGraph possiamo assegnare le metriche ai nostri attori e quindi avere dei grafi che quando interrogati adesso hanno un sacco di attributi perché adesso abbiamo la tigree abbiamo la closeness abbiamo la between abbiamo le gain vector abbiamo il weight che è un attributo sugli archi potenzialmente possiamo anche stabilire degli archi e degli altri attributi sugli archi pensate potreste avere dei grafi potreste avere un timestamp che attaccate all'arco e in quel caso avete una rete che diventa quella che si chiama una rete dinamica cioè dove gli edge esistono ma solo all'interno di specifiche finestre temporali per cui è un tipo di reti completamente diverso che si analizza anche con meccanismi non semplicissimi però diciamo il meccanismo è lo stesso da un punto di vista di iGraph abbiamo questo oggetto che rappresenta il grafo all'interno del quale abbiamo accesso con la V ai nostri attori ai nostri nodi con la E ai nostri archi e attribuiamo attributi che poi possiamo utilizzare per fare un po' un po' quello che ci pare volevo a questo punto dato che abbiamo cinque minuti no niente perché se no non apriamo niente di nuovo direi non so se Fabio sei d'accordo sì no io mi fermerei qui perché credo che abbiamo