Allora, riprendiamo al discorso della volta scorsa. Allora, siamo arrivati la volta scorsa, abbiamo visto come funzionano i provider in generale, quindi abbiamo visto che un provider in genere è un oggetto che offre un qualche tipo di dato alla vostra applicazione. La vostra applicazione può fare watch, quindi può dare un'occhiata, può seguire il provider ed essere ricostruito in tempo reale appena il provider cambia in qualche modo. Abbiamo visto questa cosa in due modi, abbiamo visto che il provider, quello di base proprio, in realtà è un provider semplice, cioè viene costruito una singola volta e poi rimane inalterato per sempre. Questo provider, questo greeting provider, abbiamo visto che in realtà rimane sempre valorizzato a questa stringa qui, quindi non c'è modo di cambiarlo, una volta che è stato costruito rimane tale e quale, perché usiamo provider stesso. Però è una cosa che era inutile, però era interessante. Abbiamo visto che i singoli provider vengono memorizzati a cascata grazie a un oggetto che si chiama provider scope. Il provider scope è questo widget da contenitori di provider e quindi si chiama scope, però è perché funziona un po' come lo scoping delle variabili nei linguaggi di programmazione, soltanto lo scoping è relativo al sottoramo di altri widget. Quindi avete un provider scope, in questo caso è un provider scope tradice, quello più in alto in assoluto, che quindi tutti vedono, quindi è visibile da parte di tutti i widget della vostra albero, e quando dico widget in realtà intendo i consumer widget, quindi i widget che sono legati in qualche modo a Riverport e quindi hanno visione di questo provider. e questi vanno a leggere, in sostanza, i provider nella loro versione del provider scope più vicino nel loro alto. Quindi se voi avete un provider scope inferiore, potete ridefinire alcuni provider e sovrascriverli. E questo è quello che abbiamo fatto qui dentro, andando a sovrascrivere quel provider che effettivamente non era modificabile. Il grid di un provider è un provider che non è azionabile, cioè non è modificabile perché non ha uno stato interno veramente, però grazie al fatto che si può creare un provider scope più piccolo, cioè più piccolo perché è più in basso nel nostro albero, che ha uno scope quindi più piccolo, e qui dentro stiamo ridefinendo il provider, il grid di un provider, con un valore fisso, quindi facciamo l'override con un valore dato da noi, in questa cosa è Ciaone, e quindi questo grid di un viewer qua sotto avrà visione di questo provider scope qui, e in realtà a cascata avrà visione anche di quello superiore, giusto? Per cui se accedesse a provider non sovrascritti li vedrebbe grazie al provider appena sopra. Quelli sovrascritti però valgono questi qui. Ok? Quindi grazie a questo meccanismo qui riusciamo a definire i provider su più livelli. E quindi quello che avveniva qui, dove abbiamo due crisi in provider che mostrano due schermi, cioè due, no, un provider in realtà è uno, che mostra questo Ciaone qui, nonostante noi appunto sappiamo che in realtà il valore era un altro. Ok? Questi, quando facciamo override with value, immaginate che dentro il provider scope in cui stiamo facendo l'override c'è una copia effettiva del provider, quindi c'è un altro provider con un valore fisso diverso. Entrambi i provider sono immodificabili, perché questo all'override with value, quindi questo valore qui, è un valore fisso. Quindi qui c'è un provider lì con un valore che è definito a quel livello dell'albero. L'altro provider è fisso, ma è fisso perché il provider stesso non è modificabile. Ok? Quindi è un provider di questi qui statici che non può essere alterato. In realtà tra un secondo vedremo anche che il provider qui può essere alterato in altro modo, però lo vedremo da un istante. E... E... E... Mentre i provider più... Diciamo che gli elementi più complessi sono quelli che hanno uno stato interno, un stato semplice interno, e con stato semplice si intende un oggetto che può essere esposto direttamente dalla state provider. Quindi la state provider non fa che impacchettare un oggetto semplice, appunto è semplice perché Dart può verificarne l'uguaglianza in maniera così atomica. Quindi in sostanza qui abbiamo un intero, molto semplicemente, e quindi ogni provider scope avrà al suo interno potenzialmente un intero, cioè che fa capo a questo se è il provider qui. Questo se è il provider si può modificare proprio, per cui in questo caso, accanto al provider, ha questo intero interno che può essere modificato grazie al fatto che... Questo lo parlavamo da qualche parte nel podio, adesso devo trovare assolutamente il punto. Aspetta che forse viene il pulsante, giusto? Esatto, qui. Perché si può andare ad accedere, non al provider stesso, il provider è il valore ovviamente, ma al notifier, quindi in qualche modo la sorgente di quel provider, e in questo caso possiamo accedere all'oggetto stato, che è un intero, e modificarne in qualche modo. E modificarlo si intende rimpiazzarlo. Ok? Questo è molto importante perché poi lo vediamo... Non lo leggiamo a tornare a seconda. E abbiamo già visto questa cosa del rimpiazzo, anche nella to-do list, dove abbiamo il provider, che è il nostro provider più sofisticato finora, che è questo to-do items provider. Questo to-do items provider cosa fa? Espone un notifier, che è la nostra to-do list, quindi un oggetto complesso che notifica il cambio di stato e che include uno stato interno che è un'istanza di list to-do item. List to-do item è un oggetto complesso, per cui non possiamo... Potremmo anche potenzialmente, però non è il caso, non possiamo includere in uno sit provider di questo tipo. Ok? Perché Dart non ha modo di verificare che la lista sia uguale a se stessa. Quindi c'è un oggetto, diciamo così che un notifier, un gestore, che in qualche modo racchiude tutte le operazioni di modifiche e alterazioni dello stato e poi è capace di, a cascata, notificare i widget che dipendono da un provider e dir loro, attenzione, l'oggetto di stato che ti interessa è stato modificato. Ok? Quindi potenzialmente potremmo fare questo. questo si può fare, quindi uno sit provider che include semplicemente una lista di to-to-item. Questo si potrebbe fare e abbiamo anche abbozzato la volta scorsa. La cosa che in questo caso ci rende un po' difficile lavorarci è che quando poi nel codice facciamo questa cosa qui, questo lo chiamo list provider, quando qui faccio list provider modifier, io qui ho accesso a state, questa è un'istanza di list to-item, chiaramente, quindi possiamo lavorarci tranquillamente. L'unica cosa che posso farci con questa lista è rimpiazzarla integralmente, posso solo cambiarla. E quindi sono molto limitato ad operazioni che posso fare e ogni volta che accedo a questo state qui e la sovrascrivo, la devo sovrascrivere integralmente e tutti i widget dipendenti vengono ripostruiti. Mentre se smistiamo tutto, cioè facciamo passare tutto quanto attraverso un notifier più sofisticato, almeno sulla carta, come la nostra to-to-list, qui dentro abbiamo modo di metterci della logica nostra che magari gestisce le cose diversamente. Quindi possiamo metterci dei controlli, la validazione, possiamo aggiornare lo stato soltanto se effettivamente cambia qualcosa. Per esempio, qui non lo facciamo, però potrebbe essere ragionevole fare questo assegnamento soltanto se l'oggetto è comparable, adesso questa è una cosa banale che si dovrebbe fare, però ci costruisce anche poco farlo, però in questo caso l'assegnamento viene fatto anche se l'oggetto non era una lista. Quindi la lista non cambia effettivamente, però comunque tutti gli oggetti hanno ripostruito lo stesso. Per cui qui effettivamente possiamo rendere un po' più più sofisticato il nostro codice e di nuovo ottimizzare il funzionamento dei nostri provider. Ok, adesso se aggiungiamo un po' di elementi qui, per vedere dove eravamo arrivati, qui avevamo costruito, avevamo costruito la nostra lista di oggetti con la list view builder e avevamo creato questo, cioè avevamo seguito questo approccio che su una carta è un po' complesso, però poi diventa intuitivo lavorandoci. Cioè per ogni oggetto nella list view facevamo un provider scope di un oggetto specifico, quindi che creava, cioè andavamo a sovrascrivere il current divide provider dentro questo livello qui, quindi a livello di ogni oggetto qua, esponendo un to-do, come diciamo, un to-do item all'oggetto sottostante. To-do item viewer poteva a questo punto semplicemente andare a leggere il, fare watch di questo provider sapendo che si trova in uno scope in cui questo oggetto qui è sovrascritto. E qui. E questo è quanto. Quando andiamo a spuntare l'oggetto, adesso quello che mancava è che questo, il checkbox ancora non funziona, il problema di fondo era, ma questa spunta la voglio far funzionare? Sì, ovviamente bisogna in qualche modo collegarci a questo oggetto qui. Ok? Quindi qui dentro possiamo andare a fare proprio quello che vogliamo fare, quindi l'oggetto, facciamo così, item check, e ci metto C, questo C è il nostro booleano nullabile che non gli vero per niente. Ah, ok. E il nostro booleano nullabile che ci dice se l'oggetto è spuntato o meno. Add backprint ovviamente. Meglio. Ok. Ora, con chi dobbiamo parlare per fare, per raggiungere la spunta o meno al nostro oggetto? Allora, possiamo farlo a vari livelli, però l'unico oggetto cioè che abbia dell'intelligenza propria, cioè della logica interna, è la nostra to-do list che tra l'altro ha il nostro famoso set one. Ok? To-do list qui dentro non ce l'abbiamo, qui dentro non ce l'abbiamo ancora utilizzato, per cui siamo il current to-do item provider che ci espone un to-do item, giusto? Questo progetto qui che torna un to-do item. Un to-do item è un oggetto così, passivo, immutabile, che non ha nessun modo per alterare lo stato, tant'è che appunto è immutabile, quindi l'unico modo è possiamo creare un oggetto uguale a prima con una spunta messa o tolta. Non possiamo modificarla, possiamo parlare con la to-do list. E lo possiamo fare però perché dentro il nostro oggetto qua, come dicevo prima, appunto si sovrastiva una cascata. Questo scope qui non contiene to-item provider, quindi in realtà quando andiamo a leggerlo nel nostro oggetto to-do item viewer, se lo leggiamo, parliamo comunque in generale del provider scope più alto, quindi questo è perfettamente legale farlo e possiamo farlo direttamente qui dentro. Quindi qui dentro facciamo quello che facciamo anche prima in realtà, quindi facciamo ref read perché non dobbiamo fare, non dobbiamo aggiornarci se viene modificato, non ci interessa, to-item provider, ci interessa il modifier. Questo ci dà accesso alla to-do list, la distanza to-do list, quindi questo oggetto qui, che dovrebbe avere set done, esatto, set done e a questo punto ci interessa l'id dell'oggetto che abbiamo perché abbiamo l'item, e poi il done sarà c, punto strumento perché sappiamo che non sarà mai una spunta, non sarà mai un handleable. Ok? A questo punto sappiamo che quando clicchiamo sulla spunta andiamo a modificare il provider più alto e quello a cascata dovrebbe modificare tutto il resto. Viamo a restart e vediamo che succede. ok, e funziona. Ok? Adesso quello che abbiamo, che è successo è che abbiamo fatto set done on-off sulla lista, la lista si è modificata, a cascata ha ricostruito tutti gli oggetti che vedete dalla lista stessa, ossia la list view. La list view si è ricostruita ricostruendo ogni item della sua lista e passando il tutto item aggiornato agli elementi della lista. Ok? Per cui, in realtà, allora, quello che abbiamo fatto è gli elementi inefficienze, ovviamente, perché non abbiamo modificato direttamente l'oggetto, però abbiamo la certezza che tutto si è precoore. Ok? Quindi appena la lista viene modificata, cambiando la spunta, a cascata tutto quanto viene cambiato. Scusi, però se la lista è questa, la lista è scelta, la mente è quello che è con... Sì, c'è un'altra pagina. Sì, esatto, allora, adesso lo facciamo, faremo una pagina di dettaglio, cliccando su questo apriremo una pagina diversa con il dettaglio e anche lì potremo andare a modificare gli oggetti e vedremo che in alcuni casi non tutto funziona. Ok? Perché, cioè, questo funziona e è giusto che funzioni, però ci sono delle cose, cioè, bisogna fare attenzione ad alcuni piccoli dettagli. Però in genere questo è l'approccio più semplice, tra virgolette, perché lo voglio dirvi è che tutto questo... No, non trovo il nome, sì. Tutta la list view qui, cioè, quindi, tutto... Cioè, tutti i pezzi di interfaccia che dipendono dai dettagli dei nostri video item in realtà sono legati a a questa pagina qui. che è la pagina, no? La build della mia homepage che viene ricostruita quasi sempre, praticamente. Appena io ho unito la lista in qualsiasi cosa avvenga, tutta la lista viene ricostruita e siamo sicuri di tutto sempre coerente da questo punto di vista. Però, attenzione, perché quando stiamo passando l'oggetto a to do item viewer, stiamo copiando, cioè, stiamo passando una copia. Questo è forse quello che faceva riferimento. Cioè, qui stiamo creando un provider scope dove all'interno c'è un oggetto che però è fisso, cioè questo list di index qui, stiamo tirando fuori un to do item che è immutabile e quindi la pagina to do item viewer qui ha una propria statica di quell'oggetto. Quindi, questa pagina qui in realtà fa watch, però in realtà questo oggetto qui non può essere mai modificato. questo provider più il current to do item provider non verrà mai ricostruito perché viene letto una singola volta e non può essere alterato in alcun modo, viene passato alla to do item viewer per valore. Per fare un parallelo ardito è un po' come prima quando facciamo le cose a mano e passavamo l'oggetto direttamente dentro il costruttore. Cioè, è un po' come questo. Prima facciamo così, ma prima non c'era provider scope e costruivamo direttamente to do item viewer passandogli to do item se ricordate qualche volta fa e quello andava bene però to do item viewer chiaramente poi era legato in maniera dissolubile a quelle istanze di oggetto. Qui adesso abbiamo usato i provider però in realtà funziona ancora la stessa maniera. Cioè, provider scope contiene quell'oggetto lì e lo stiamo facendo stiamo facendo l'override passandogli il dato da fuori. To do item non potrà essere mai modificato da dentro tra virgolette perché non c'è modo di farlo perché perché il perché questo provider qui non è modificabile questo è un provider che posso solo sovrascrivere andando giù. Questo è soltanto comodo perché posso riciclare to do item viewer in più pezzi della mia interfaccia questa è l'idea cioè in base a dove metto to do item viewer andrà a leggere il corrente to do item provider del provider più difficile. per cui tu da me posso riciclarlo e lo faremo se riusciamo a riciclarlo dentro una pagina e a sua volta contiene un provider che contiene l'oggetto. Adesso lo facciamo proprio con quello che dicevamo prima con il click. Prima di farlo un piccolo detour sui provider perché finora abbiamo usato sempre il provider semplice che vi ho detto che è un oggetto molto statico che non viene mai modificato. Questo è vero fino a un certo punto perché in alcuni casi può modificarsi anche il provider questo oggetto semplice quando si modifica automatico quando dipende a sua volta cascata da altri provider stiamo giocando complicazioni su complicazioni per così tanto però a cosa serve questa cosa qui? Immaginiamo di dover leggere non la lista nella sua interessa magari ci interessa non visualizzare gli oggetti così nei loro dettagli ma ci serve solo sapere quanti to do item ho in memoria quindi ho un contatore di to do item un po' come questo quindi per non duplicare lo stato chiaramente potremmo creare un counter secondario una cosa del genere e fare to do items counter potremmo fare questo ho messo che scrivesse si faccio scrivere bene questo partirebbe da zero perché il provider to do item provider parte con la lista vuota quindi questo parte con zero e avrei un provider secondario che tiene traccia di quanti oggetti ho detto alla lista però questo non è farlo così è legale è possibile non viene la polizia di fattare da prendervi ma non è consigliato perché lo stato di questo provider qui è potenzialmente slegato dall'altro provider quindi c'è il rischio di perdere per strada un aggiornamento e precisamente avere dei provider che danno valori che non sono pareti per cui la cosa ideale è far dipendere questo oggetto qui questo provider qui scusate da questo come si fa? allora si usa provider sempre si usa provider perché questo è un provider questo qui è un provider è un provider che non ha dello stato interno cioè è un provider che non ha stato suo ma dipende da altri provider nella fattispecie dipende da questo provider perché qui dentro fate caso qui abbiamo questo oggetto ref qui che è esattamente lo stesso oggetto che viene passato al quasi questo oggetto si somiglia molto all'oggetto che viene passato ai widget quindi quando facciamo ref.read ref.watch e così via quello è il modo che abbiamo per legare il widget a un provider qui dentro possiamo fare la stessa cosa quindi basta fare ref.watch di qualcos'altro e possiamo andare a interessarci dei valori dello stato interno di un altro provider prego mi ricordo la cosa il watch legge anche o ascolto è nostra? no il watch legge e rimane in ascolto quindi legge ogni volta che la sorgente viene modificata cioè legge e rileggi quindi se facciamo un watch quando fare la rilega in quel caso non legge perché abbiamo fatto un altro build e rimane in ascolto per questo esatto esatto quindi per esempio qui dove è? qui sì per esempio qui siamo ecco questo è un buon esempio qui stiamo leggendo effettivamente la lunghezza della lista cioè ci stiamo interessando di quanti oggetti ci sono dentro la to-do list e con watch leggiamo il dato quindi questo ci ritornerà una lista e poi teniamo fuori la lunghezza e in più lega il nostro widget quindi questo oggetto qui my home page al provider appena il provider cambia il widget viene ricostruito e rilegge il data quindi ha questa dipendenza che in realtà poi nasconde questo meccanismo di dipendenza che è quello di con gli inherit widget che implementano questo no questo context depend on cioè eccetera ma l'avevo visto cioè internamente poi avviene questo internamente usa questo no non ce la faccio scrivere il context no ecco no quindi dipende da uno stato o da un inherit widget che appena viene modificato a cascata questo widget si ricostruisce quindi watch farà esattamente questo il comportamento è lo stesso quindi tornando di là dove ero qui sì qui quindi faccio watch di provider to do item to provider quindi mi interessa la lista e ritorno length ok quindi il contatore di to do items è essenzialmente leggo la lista e ritorno la lunghezza questo posso esprimerlo direttamente con la con la freccina perché è una cosa funzionale ok ok a questo punto questo provider qui si aggiorna a cascata ogni volta che si aggiorna questo quindi c'è uno stato unico che è questo qua e questo qui è semplicemente un provider quindi un oggetto che ci fornisce c'è accesso a un dato aggiuntivo di cui però non tiene traccia internamente quindi qui dentro qui dentro mail per esempio quando vado a leggere qui andiamo a leggere la length della list e quindi a questo punto in realtà perché fare questo quando posso fare direttamente questo no leggo direttamente l'altro provider che mi torna già un intero faccio fare il lavoro di estrarre length all'altro provider comunque cambia molto e in più per cioè farvi vedere a cosa serve questa roba qui allora qui c'è già c'è ok a questo punto aggiungiamo magari un elementino anche qui ho quattro cose da fare vediamo come l'ho implementato ecco l'ho implementato direttamente dentro la dentro la home page e portiamolo fuori mettiamo facciamolo cioè rendiamolo uno stateless widget esterno e vediamo quando si ricostruisce perché questo è vediamo qui un to do items counter viewer è un bellissimo oggetto viewer questo è un consumer widget ok ok qui ci metto il codice che ho detto il main quindi ci metto questa cosa qui ok qui ci metto il to do items eccetera ok ok lo mettiamo così poi chiaramente lo vogliamo mettere const perché vogliamo che sia immodificabile devo sbagliato a chiamarlo sicuramente devo saldare ah non probabilmente meglio ok ok perfetto qui dentro ci copio le cose di prima poi ci metto la classica blackprint per vedere quando viene costruito o meno ok qui dentro non faccio questa cosa qui ma faccio direttamente do items counter provider non length perché ci va già questa cosa qui vive dentro il file provider che poi devo includere text non gli sta piacendo ok importiamo il widget ok pensavo che ci siamo ok allora facciamo partire tutto adesso quando clicco qui mi aspetto che venga modificata la to do list quindi viene modificata la to do list a cascata si modifica il to do list provider ovviamente e visto che chi dipende dalla to do list provider tutta la my home page quindi my home page che qui fa ref watch to do items provider è legata alla to do items list no naturalmente in più ci è legata anche una seconda volta perché in realtà fa ref watch to do items counter provider questo provider qui no in realtà fa è una indirezione perché a sua volta fa watch di quello per cui ho due legami entrambi che alla fine puntano a questo to do list provider quindi appena modifico questo mi aspetto che my home page venga ricostruito e questo è abbastanza naturale a cascata poi vengono costruiti anche i vari widget la to do list item quindi my home page viene creato to do item viewer è questo oggetto qui e to do items counter viewer è questo cosa qui ho una cosa da fare ok quindi ogni volta che faccio un più uno adesso troverò my home page to do item viewer lo trovo due volte perché ne ho due a questo punto e poi counter viewer perché a questo punto non me l'aspettavo che era solo uno perché misteri ah no perché mi sa che tutorial viewer è un altro oggetto che non è quello che stavo pensando non importa comunque ok quindi ho tre oggetti la to do list ogni volta che la ripildo si ripilda my home page e anche to do items counter view e va bene adesso se io clicco su una delle spunte cosa succede che la la spunta va a fare set down su to do list giusto quella cambia lo stato della lista cioè la giornalista e a cascata tutto lo che diventerà la lista dovrebbe ribildarsi no quindi a cascata si ripilderà my home page e plausibilmente anche questo però se ho fatto le cose correttamente vedrete che grazie alla magia di provider questa cosa qui non si ripilda quindi adesso posso mettere adesso chiaramente qui ripetisco questo è un testo quindi il fatto che si ripilda o meno non cambia la vita nessuno sono 3-4 manosecondi nell'ottica però immaginate che sia qualcosa di più complesso in questo modo avete evitato che un widget e un sottotolbre si ripildi perché perché Riverpod fa sì che i provider facciano anche da cache cioè hanno una cache interna e quindi fanno da da blocco per le rebuild esattamente come i widget const fanno da ferma porta per cui appena voi mettete uno stateless widget che è const nel vostro albero dei widget potenzialmente se quello non dipende da altre informazioni questo non viene rebuildato se le cose non cambiano quindi è quello che abbiamo fatto a vari livelli del nostro minasoluro per evitare che le cose vengano rebuildate ed è quello che facciamo anche con il provider come funziona questa cosa funziona in questa riga qui quindi è molto economico da posizio del codice perché to do items counter provider torna soltanto se to do items provider viene modificato banalmente però va a verificare che il valore precedente e il valore nuovo siano diversi esattamente come faceva l'internet widget che avevamo fatto a mano c'era il metro che diceva rebuilda soltanto se il valore è diverso da il provider lo fa in automatico per noi quindi se length non è stata modificata allora non scateno la rebuild perché tanto non serve quindi qui il provider fa da da blocco e quindi se visto che quando spunto qui è vero che la lista viene modificata però questo aspetto della lista non viene modificata c'è la sua lunghezza e quindi questo provider qui non scatena la rebuild di questo oggetto qua no di questo oggetto certo noi noi sono utilizzando tutti i consumer per utilizzare il provider si tuttavia utilizzare i conseguenti le switchet e utilizzare un altro provider che offre il provider dentro il consumer si come tutti tra i vari widget che si si consumer widget consumer widget c'è anche il consumer basta no ah il consumer si ok il consumer si ok che soltanto non c'è il consumer si utilizzare tutte le per esempio il network e watch e dentro il consumer si che a sua volta la state le consumer si si no quello si no è giusto perché non ne ho parlato siamo al consumer no giusto si esatto questo che sta dicendo il vostro collega è molto giusto dirlo perché poi magari visto che abbiamo fatto abbiamo usato il consumer widget qui è della classe base astratta da cui stiamo derivando per poter accedere al magico mondo dei provider no del di RiverPod è un modo che abbiamo economico cioè che non richiede di creare la seconda classe è usare il consumer quindi è un widget default che prevede che sia un builder credo esatto builder come come come ok vabbè vabbè builder che dovrebbe prendere context e ref ok il consumer è un modo diciamo così rapido economico per fare quello che abbiamo fatto un secondo fa creando un widget proprio quindi invece di creare una classe al dettaglio che deriva da consumer widget che poi fa la build eccetera lo posso fare in una singola così chiamata specificandolo in maniera funzionale quindi questo questa cosa qui è quello che abbiamo fatto faticosamente creando una classe dedicata in sostanza è la stessa identica cosa consumer l'unica differenza no in realtà non c'è nessuna differenza perché questo qui poi internamente poi rebuild solo se è necessario quindi in realtà anzi facciamo per fare la stessa cosa che ho fatto prima dovremmo fare questo così ok quindi il consumer è un widget standard che non fa altro che prendere una funzione cioè passiamo la funzione di build che non è altro che questa funzione qui in realtà cioè è questa cosa qui quindi è un widget è un consumer widget generico a cui stiamo fornendo la funzione build in sostanza è un modo per non dover fare la classe in virgolette quindi stiamo fornendo di quella funzione buildly come parametro quindi questa funzione qui è la funzione che stiamo fornendo come builder e quindi in diciamo così in meno tempo abbiamo fatto la stessa cosa che prima qui comunque dentro il builder dentro del consumer abbiamo accesso al context che è il build context abbiamo il widget ref che è il riferimento con cui possiamo fare il watch dei vari widget e più c'è il child che in realtà è un po' così ci lascia un po' perplessi ma è un modo che abbiamo per passare un oggetto statico cioè passare un albero di widget qui che non ha nessun legame con i provider a questo punto questo sotto albero qui di widget non ha legami con il ref perché non li può avere ok che viene passato da fuori e viene questo c'è qui sarebbe qui in genere possiamo lasciarlo nullo per cui in genere possiamo tranquillamente non specificarlo questo sarà null quindi possiamo ignorarlo e ignorarlo anche in maniera esplicita dando gli underscore quindi underscore evitare significa è una variabile di cui non mi interessa utilizzare quindi tolgo il nome quindi in questo modo se noi vorremmo riscontrare una tronda dove abbiamo il testo prima è che il testo lo hai in account provider e poi in un punto di mettere i diffidi del widget possiamo mettere di reddare un con di questo test e secondo elemento child sì volendo se child non dipende dal provider si può portarlo da fuori perché è statico e non varia questo è un'ottimizzazione perché in quel punto quel child non viene ribildato insieme a questo quindi l'idea se riusciamo a separare il nostro apri in maniera efficace ed efficiente in questo caso child non ha nessun legame con ref non fa ref watch eccetera però è statico e lo possiamo passare dentro qui e poi riciclare internamente questo builder qui funziona esattamente come questo oggetto qui quindi per dimostrarlo possiamo fare building consumer con un mix di italiano e inglese e alla stessa maniera adesso posso proprio parire qui sopra se non ho messo nel posto giusto e quindi questi due contatori chiaramente ribildano esatto ribildano soltanto quando cambia la l'unica cosa da fare quindi qui building consumer con builder è il nostro contatore questo se io spunto ah no ok esatto in questo caso non funziona in questo caso ovviamente però è giusto così non funziona perché perché il consumer si trova dentro un oggetto che è legato alla lista ok quindi questo consumer qui si rebuilda comunque anche se il conteggio non è stato modificato perché non è un oggetto esterno dalla lista quindi è comunque dentro questa build qui ok questo questo questo oggetto qui che in realtà è tutta la nostra pagina è legato al dove siamo al to do item non lo so non sono perso ah qui al to do item provider quindi tutto questo blocco qui viene ribildato comunque quando la lista cambia e quindi anche il consumer quindi in questo caso qui il consumer non ci è venuto in alcun modo in aiuto giusto? perché questo consumer qui è legato al al build context che è già dipendente dalla to do list quindi in questo caso non ci risparmia quest'altro qui invece questo è un elemento costante quindi un const e non viene ricostruito anche se tutta la lista viene costruita questo non viene ricostruito perché è sempre lo stesso concetto quindi è sempre il const è sempre quello che ci salva nelle nostre ricostruzioni se la pagina non dipendesse da to do item provider allora funzionerebbe anche il consumer come facciamo a districare questa dipendenza? quindi fate sempre attenzione quando fate refwatch fate attenzione perché il contesto lo scope di codice in cui vi trovate in cui fate refwatch qualcosa tutto quel contesto viene ricostruito sempre ogni volta che quella cosa cambia salvo elementi cost per cui se vogliamo impegnarci a districare queste cose qui come possiamo salvarci? andando a a tirar fuori in questa list di ubuilder qua ce lo dobbiamo slegare dalla home page se vogliamo possiamo farlo tranquillamente questo è giusto per compiutezza facciamo to do list una classe che è un consumer widget tutto tutta la list view io la sposto qui tutta questa cosa qui la togliamo ok sarà const e qui ci mettiamo adesso a questo punto qui dentro io dipendo da to do item provider e così via ok va bene ok adesso è pure const giusto ok a questo punto ho tolto tutto il list item dal resto dell'albero quindi se adesso non ne ho lasciato in giro qualcuno in teoria dovrebbe non rebuildare neanche questo perché quando quando aggiungo elementi adesso sì se spunto elemento a questo punto ok si rebuilda soltanto questa parte qui cioè proprio la to do list in sé prima si rebuildava tutta la home page e tutti i suoi sott-elementi salvo quelli che erano const e quindi erano bloccati adesso stiamo effettivamente ragionando soltanto questa parte qui questa sezione che è una list view di oggetti e basta ok allora dovrei che proviamo a questo punto a fare una pagina questo è per cui facciamo che ah un altro cosa che possiamo fare è togliere gli elementi questo lo decidiamo prima rapidamente quando vogliamo togliere con con trascina perché abbiamo fatto l'aggiunta di elementi abbiamo fatto la spunta di elementi non abbiamo fatto la rimozione che cambia molto però visto che ci costa un nanosecondo quando vado a farlo se mettiamo un oggetto della lista dentro un widget che si chiama dismissible lo rendiamo rimovibile è un widget abbastanza comune in flat per cui l'altro vale vederlo probabilmente allora qui dentro quindi ogni ogni oggetto ogni singolo oggetto della lista è dismissible quindi l'idea è che questi oggetti qui saranno trascinabili via ok e quindi metteremo questo oggetto cioè questo dismissible come radice dei singoli oggetti che hanno costruito la lista quindi in sostanza saranno il dismissible sarà il padre di provider's code quindi questo faccio grab with widget dismissible ok e qui ci sono due oggetti aggiuntivi uno è la chiave che è consigliata averla e l'altra è on dismissed che è quello che succede in sostanza ok a che stanza la chiave è un modo che ha Flutter per identificare i singoli oggetti del nostro della lista quindi qui ci possiamo usare qualsiasi cosa usiamo una value key e ci mettiamo magari sì l'index potrebbe variare quindi ci mettiamo l'id del oggetto lo vediamo fuori qui e qui usiamo come item id quindi è un id univoco dei singoli oggetti della lista e la cosa più univoco che abbiamo è l'id dell'oggetto in sostanza on dismissed è la funzione che viene chiamata quando l'utente scrolla via l'oggetto direction è in che direzione lo sto facendo perché chiaramente in alcuni casi può avere senso non so se lo fate verso sinistra lo archiviate verso destra rispondete al messaggio su whatsapp cose di questo genere quindi in base a questo potete discriminare in questo caso se non ci interessa e cosa facciamo qui andiamo a togliere l'oggetto dalla nostra ministra quindi facciamo sempre ref .read della nostra beniamata to do items provider notifier qui abbiamo già fatto il remove mi sembra il remove che prevede che passiamo l'id niente di più facile è l'id item ok quindi qui bisogna metterci un altro intero giusto per dire chiaramente la stessa cosa si può fare con un pulsantino x con qualsiasi oggetto grafico che torna utile per togliere gli elementi va benissimo adesso diventa diventa spostabile in automatico lo fa tutto il widget dismissed quindi è tutto molto comodo e qui rimuoviamo vedete che la lista si comporta così come ci si aspetta ok è tutto coerente con lo stato che abbiamo nella nostra applicazione quindi con la chiamata remove noi stiamo togliendo l'elemento dal tutto e tutto viene animato da dismissible bravo grazie mi sono visto la linea delle persone potremmo dire che da un verso come lo si chiama e dall'altro è un dialogo esatto per cui si può fare if direction e poi cambiare qualcosa tranquillamente questo si può fare affinché poi c'è modo di rendere anche più sofisticato questo approccio e darvi le menù laterali che compaiono e quant'altro però il dismissible in sé non fa altro che rendere rimovibile l'elemento, poi potete complicare chiaramente il comportamento il dismissible come volete però di base serve soltanto a renderlo così scorrevole sui lati se volete degli oggetti, dei pulsanti che compaiono, ovviamente li potete mettere diventa una parte del widget stesso che viene dismissed e poi potete infilarli a lungo i bordi ok, a questo punto vogliamo renderlo anche cliccabile perché appunto l'idea era di a questo punto di navigare verso una pagina dedicata ai singoli oggetti della nostra to-do list, per cui l'idea è finché clicco qui va bene che la spunta viene cambiata se clicco qui voglio andare su una pagina in cui posso modificare i contenuti della tua list o degli item o altre cose per cui quello che faremo è navigare finalmente che è un'occasione per creare una pagina secondaria, vedere come si comporta lo scaffold vedere come funziona la navigazione e vedere come si comportano come si comporta l'editing dei testi che è anche una cosa così banale, ma banalissima da fare allora visto che anche qui seguite sempre no come la struttura del progetto la potete inventare voi liberamente quello che vi conviene fare è se avete proprio delle pagine di riferimento della vostra applicazione vi conviene fare proprio una directory a parte per gestire proprio le singole paginate quindi pages in questo caso e che chiaramente possono essere composte da una serie di widget che avete scritto dentro widget quindi dentro pages ci andrò a mettere la mia to do item page da essendo una pagina è un pochino più complessa di un di un widget semplice però fondamentalmente è sempre un widget quindi alla fine cambia ben poco possiamo immaginare che sarà un widget che dipende dallo stato no dei provider quindi sarà direttamente consumer widget ok qui dentro allora cosa cambia fondamentalmente allora immaginate dover creare una seconda pagina questa pagina qui è l'unica pagina che abbiamo finora è la nostra home page per cui ora è una struttura molto simile tant'è che andiamo a vedere come è fatta l'home page che nella sua essenza alla fine è uno scaffold quindi la build cosa fa ritorna uno scaffold e poi a sua volta contiene una serie di altre informazioni e così via facciamo la stessa cosa per fare un po' prima copio fino a qui almeno fino a qui anzi fino a qui tant'è partiamo qui finito importiamo le cose mancanti e le azioni qui le togliamo con il pulsante ci interessa più ok questa pagina qui questo tutorial page andrà a a livello così logico andrà a sovrapporsi sulla pagina sulla nostra home page quando navighiamo nelle nostre applicazioni ogni diciamo così ogni framework di UI ha un po' il suo la sua logica interna e il suo paradigma di navigazione che può cambiare radicalmente in Flutter funziona con uno stack di navigazione in sostanza qui noi abbiamo una pagina di partenza da cui partiamo e poi da lì possiamo impilare delle pagine che si si mettono sopra quella sottostanza poi quando andiamo a toglierele dallo stack andiamo a navigare indietro tra virgolette e togliamo la prima pagina e se c'è una pagina sottostante torniamo alla pagina di prima questo meccanismo qui viene gestito dalla nostra material app in sostanza qui questo oggetto qui fa questo lavoro di gestione della navigazione e lo fa andando a definire in sostanza la la il widget di partenza che è la la base in qualche modo quindi questa questo oggetto home qui è il widget che viene messo sul primo livello della nostra stack navigazione e poi se vogliamo navigare altrove andiamo a metterci sopra la home in sostanza quando andiamo a fare queste operazioni quindi aggiungere pagine togliere pagine questa aggiunta e rimozione di pagine avviene con un'animazione in genere quindi è la nostra material app che anima questa questa transizione da una pagina all'altra e lo fa in base alla piattaforma su cui ci troviamo quindi in questo caso material app vedrete che fa degli effetti di transizione da una pagina all'altra che sono coerenti con quelle che farebbe android su su un'applicazione nativa ogni pagina deve implementare tutta la sua infrastruttura ok per cui la nostra my home page my home page si porta dietro lo scaffold e la bar e i pulsanti e il body e così via lo farà anche to do item page ok quindi to do item page avrà un suo scaffold che sarà ovviamente identico a quello dello scaffold della home page chiaramente però soltanto per caso in realtà qui potremmo tranquillamente andare a fare uno scaffold con un colore diverso così ci aggrada con un titolo tutto suo e potenzialmente anche uno se li grafico diverso qui dentro ci interessa leggere il to do item che abbiamo appena che andiamo a esaminare e qual è questo to do item è un to do item che andiamo a leggere dai provider come al solito ora per fare un esperimento facciamo esattamente come abbiamo fatto con il nostro to do item viewer che cosa faceva questo andava a leggere il current to do item provider cioè il nostro provider che ci espone un singolo elemento corrente che in quel momento è interessante in qualche modo per cui facciamo la stessa maniera la stessa maniera la stessa to do item page andrà a leggersi il to do item corrente ok questo non è importante ovviamente no ok e a questo punto abbiamo il nostro item che possiamo usare qui nel text quindi qui ci mettiamo il titolo del nostro item quindi il fatto che noi usiamo quel provider lì sottintende che current to do item provider debba avere un valore nel contesto della pagina per cui qualcuno deve fornirci un provider che vaga qualcosa se usiamo questo chiaramente la nostra applicazione esploderà e quindi quando andiamo a navigare alla pagina to do item provider dobbiamo fornirle un'istanza di cioè un'istanza dobbiamo fare l'override di un provider e fare in modo che quando andiamo a leggere qui fare watch abbiamo un valore che abbia che abbia senso un'altra domanda sì non lo potremmo passare al costruttore e utilizzare un costruttore possiamo farlo e e faremmo come abbiamo fatto la volta scorsa con to do item viewer quindi lo passeremo qui dentro direttamente e può andar bene in sostanza però la cosa che ci torna comoda è che questo current to do item provider cioè se lo passiamo qui nel costruttore poi bisogna passarcelo dietro a ogni livello del nostro albero dei widget così facendo invece sappiamo che in tutto l'albero che ci troviamo e l'albero sottostante fino alla foglia chiunque ha riferimento a accesso a quel current to do item ok per cui se adesso chiaramente la gerarchia è molto piccola però se qui avessi 7000 widget poi alla fine un widget in fondo ha bisogno del titolo del no oppure se è spuntato meno può farlo solamente leggendo questo oggetto qui senza che me lo devo passare giù per tutta l'albero l'albero questa è un po' un po' l'idea quindi questa cosa si fa quando facciamo i widget semici ad estanti sì sì sì sì in quel caso con una pagina in generale non ho capito cioè è inutile passare un quadro su ora dopo per fare il watch sì per esempio sì sì esatto quello può essere utile in quel caso se abbiamo un widget a sé stante che tra l'altro magari soprattutto se non dipendono dallo stato generale dell'applicazione cioè magari avete un widget che mostra un colore un'immagine delle cose che sono fornibili da fuori e nel caso può per senso fare uno stateless widget che non ha visione dei provider e che gli vengono passati dati estremamente un po' come viene per i widget standard sono tutti stateless e tutti vengono costruiti da fuori però appena avete un legame qualsiasi con lo stato dell'applicazione in realtà fate molto prima quando lo vede e si fa sul fatto allora non è solo che non vi voglio parlare allora qui dentro no scusate quindi qui dentro adesso non facciamo nulla ma torniamo alla nostra lista che in realtà si trova qui dentro quindi oltre ad essere dismessi voluto tutto il nostro blocco in più vogliamo che è uguale che sia anche cliccabile se ricordate in realtà ci sono vari bot per andare cliccabile in oggetto però il più generico è no il gesture detector per cui mettiamo il gesture detector dentro il cioè attorno provider scope esatto qui che ok che avrà on tap come metodo che ci interessa ok ora attenzione anche al a come si interessa queste cose perché il dismissible copre una serie di gesture quindi delle delle mangi in particolare lo scorrimento che è la il tap tenere premuto e slide in una direzione e viene mangiato dal dismissible il gesture detector quindi ha una visione più limitata delle gesture che arrivano a lui perché funziona l'albero ovviamente per cui vengono dall'alto e vengono dal passo dunque a questo punto il gesture detector può riconoscere gli on tap perché questi vengono ignorati dal da questo perché il click non ci fa nulla se facciamo al contrario avremo il gesture detector che potrebbe mangiare il trascinamento per cui vado attenzione a quello che vengono annidati ok qui dentro allora qui dentro abbiamo comunque abbiamo il nostro item qua l'oggetto ce l'abbiamo già disponibile a questo punto faremo una cosa cioè andremo a parlare con un oggetto che si chiama navigator ok il navigator è un classico inherited widget di material app quindi è sempre un widget per cui bisogna fare navigator punto off perché dobbiamo andare a pescare il navigatore di riferimento quindi il navigator punto off context ci dà accesso al navigator che vale in quel contesto lì ossia questo andrà su per tutto l'albero e ci andrà a parlare col navigator della materiale ok perché questo è un inherited widget perché dato che così in questo modo dobbiamo sempre riferimento al navigator in alto un po' come il tema il tema dell'applicazione in più in più perché concettualmente esattamente come il tema volendo possiamo avere più temi anidati se vogliamo per avere sezioni colorate in altro modo e così via anche i navigator possono essere anidati volendo immaginate di avere un'applicazione complessa in cui avete poi ci accadrà magari tra qualche volta quando parleremo con le schede e così via in alcuni casi abbiamo il navigatore generale dell'applicazione che è questo qui della pagina però in alcuni scenari ci sono delle sottopaginette che sono navigabili alla stessa maniera quindi immaginate di avere una sottopagina qui con delle schede oppure qualcos'altro a cui serve una navigazione in quel caso navigator va riferimento a quel insieme quindi fate sempre attenzione a come i widget perché a volte i widget che possono essere anidati in loro stessi voi avete una visione parziale perché rimanete alla visione del widget di quel tipo appena sopra adesso in questo scenario qui non ci riguarda perché c'è un solo navigator però in alcuni scenari possono esserci più navigator che possono assorciare ve lo dico giusto perché a volte ci si intreccia non si capisce perché non funziona nulla non non accade però se si fanno tante cose anidate a volte ci si perde un po' e questo è il motivo però adesso non preoccupiamoci di questo prima non facciamoci la testa prima dovuto il navigator cosa vi permette di fare una serie di cose e le che vedremo adesso sono pop e push pop e push sono due metodi che permettono di fare di modificare lo stack di navigazione pop no push aggiunge un elemento pop molto bene quindi push è quello che ci interessa adesso perché andiamo ad aggiungere una nuova un nuovo percorso si chiama quindi una nuova pagina sopra al navigator che c'è adesso al metodo push va fornito un oggetto root quindi un percorso questo sembra così una complicazione inutile però è così che chiama internamente gli oggetti navigati quindi le destinazioni alle quali possiamo navigare Flutter per cui passeremo una root in particolare passeremo una material page root perché la nostra applicazione è una material app e il fatto che questa sia una material page root fa sì che nel navigare material app faccia tutte le famose transizioni di cui parlavo prima adesso poi vedremo in azione vedremo cosa cosa succede perché ci sono delle delle risolvenze dei spostamenti che rendono più gradevole la cosa in base al tipo di root che usiamo chiaramente cambiano le risolvenze prego è allo stesso livello di non page oppure è all'interno di non giustissima domanda è allo stesso livello in realtà rimpiazzerà a livello grafico per cui qui quello che accade qui dietro material app è che stiamo definendo la home che se andiamo vedere la documentazione ci dice che tra l'altro è la widget for the default root quindi quello è il percorso default della nostra applicazione quando viene inviata si apre con quel percorso lì il percorso contiene un pubblico sulla pagina se adesso navigliamo da un'altra parte passando un'altra root al nostro navigator quello che avviene è che la my home page viene cancellata cioè viene nascosta non è più visibile non è più in realtà rimane visibile sotto sulla carta però viene affiancata da questa nostra seconda root che però è graficamente superiore andrà a nascondere la home page quindi a livello grafico home page sparisce non verrà più visualizzata sebbene esista ancora questo lo fanno automatico il nostro scaffold perché qui le root prendono tutto lo schermo la home page ha lo scaffold qui quello scaffold è quello che continuerà ad andare questa cosa qui qui appena facciamo push nuova root questa andrà adesso la vedremo per un secondo andrà a sovrapporsi e andrà a coprire tutto perché contiene a sua volta un secondo scaffold con un tipo di verso quindi tutto quanto viene rimpiazzato immaginate che tutto viene buttato via e viene coperto dalla pagina appena sovrapporti dalla pagina dalla root appena sovra però tutte le pagine tutte le root attive rimangono nel vostro album tant'è che se lo vedremo quando modifichiamo qualcosa si cambiano tutte e sono tutte legate allo stato prima di noi eravamo qui materiale del paese root che cosa dobbiamo fornire a questo un builder quindi questo funziona sicuramente come funziona funzionano tutte le cioè la maggior parte degli oggetti platter con questo builder forniamo una funzione con cui continuiamo a costruire l'oggetto che dobbiamo mostrare a schermo che oggetto è? è la nostra to do item page quindi veniamo a costruire la nostra to do item page in questa maniera qui questa va importata ok allora manca solo una cosa perché questo tutto da do item page ha fatto che può essere const ovviamente non facciamo la const questo oggetto qui non ha il provider adesso qui lo stiamo creando andrebbe a leggere il currbs do item eccetera ma non lo troverebbe anzi perché ci troviamo ancora a parte proprio gli errori sono in tasse quindi funziona ancora peggio meglio perché ci troviamo allo stesso livello della home page quindi dalla home page quando clicco e accedere un'intervista eccetera non ce l'ho e quindi c'è l'eccezione di più prima avviene avviene questo che è buono quindi questa cosa qui va wrappata esattamente come facciamo qui dentro il provider scope facciamo la stessa maniera wrap il provider scope il child è questo e il override override così e facciamo override di questa roba quindi si comporta alla stessa identica maniera si torna quindi la list view fa delle cose abbastanza eccessivamente complesse forse così a leggerla così cioè crea singoli oggetti nella sua list view ognuno dei quali contiene un provider scope con l'oggetto che deve visualizzare in più se clicchiamo su la list list view item quindi l'oggetto della list view item c'è il gesto detector che va a creare una nuova pagina che poi contiene un provider scope con un singolo elemento e poi al suo interno c'è la pagina è un po' ma c'è ma c'è ma è così però a questo punto nella pagina di destinazione quando andiamo quando accediamo con la pagina abbiamo accesso al current to do list eccez eccez eccez eccez clicco questo molto bene compare la ore in ipsum nel titolo perché viene letto da qua to do list item page quindi questo watch the item leggiamo il titolo e lo mettiamo nel titolo qui sopra notate che qui allora qui abbiamo fatto molto poco abbiamo fatto lo scaffold con l'appar abbiamo messo il titolo e poi la pagina è vuota qui compare la freccia magicamente perché lo fa lo scaffold per noi lo scaffold internamente va a leggere il navigator di riferimento il navigator è quello della nostra applicazione dentro material app per cui è lo stesso che abbiamo appena modificato con push il navigator contiene due pagine cioè una una root home e poi la root nuova in cui ci troviamo e visto che lo stack è lungo più di uno in automatico lo scaffold ci mette la freccia poi non do fare nulla e lo scaffold in automatico si accorge quindi si può navigare indietro per cui questo è automatico se clicchiamo qui di nuovo non c'è nulla da fare lo scaffold da solo fa navigator pop quindi va a togliere la root e torniamo indietro tant'è che se clicco qui torniamo qua e adesso si vede molto male perché il mio pc è molto lento però c'è una micro transizione elegante e gradevole che passa a una pagina d'altra a forza di farla si vede meglio ok e quella è la transizione di material design per la navigazione su stack tutto questo e altra cosa su android tutto quanto è agganciato anche al tasto quindi chiaramente se cliccate il tasto back cosa avviene il tasto back manda un impulso tra virgolette all'applicazione attiva di android che riceve la non back eccetera quella viene sparata al material app al navigator e il navigator se riesce fa pop ok per cui anche qui questo è equivalente non dovete fare assolutamente nulla questo fa semplicemente navigator il punto se volete potete farlo anche a mano ma non serve quindi qui dentro possiamo fare un pulsante che fa il punto però è perfettamente equivalente se noi dovessimo un locale il navigator sul pulsante del contatto sul e la navigazione diretta se dovessimo riparare prima un'opera singola e poi usare il navigator si usa lo stessi del comodo o allora lì è un po' complicato purtroppo perché cioè no dipende da quello che vogliamo fare quando c'è di mezzo la sincronia diventa complicato per definizione per cui nel tap allora gli interfacci utente nascono sincroni tu pigi un pulsante e aspetti che avviene qualcosa in maniera immediata quando non avviene in maniera immediata c'è qualcosa che non funziona per cui ovviamente nel mondo moderno nulla è veramente sincrono perché è tutto asincrono per cui però ciò non di meno ogni metro ogni event enter quindi ogni metodo di risposta al tap al slide al dismiss e così via sono comunque sincroni ma li possiamo rendere asincroni qui dentro volendo se abbiamo bisogno di fare delle cose asincrone questo vale per tutti i metodi asincroni possiamo renderli asincroni dart infatti ho sbagliato sui tassi ok quindi qui dentro se noi vogliamo fare che non so scarica un file qualcosa di molto lungo si può fare posto che sia asinc e poi dopo possiamo fare qualcosa di sincrono come navigare questo è legale e funziona e va bene però il problema è che l'utente mentre clicca aspetta che qualcosa venga non c'è modo per segnargli questa cosa perché flutter è reattivo cioè nel senso che dovete cambiare lo stato per avere qualcosa di visibile qui dentro non potete fare colora qualcosa di rosso o mostra un icona di attesa di windows con una rame che è in 80 e così via perché in flutter non si può fare in flutter bisogna modificare lo stato segnalare che c'è qualcosa che sta avvenendo e poi ripildare sulla bisogna per cui se c'è qualcosa di importante che bisogna fare in background cosa si fa e questo lo faremo domani quando faremo l'HTP se stagliamo qualcosa e poi appena c'è lo usiamo fondamentalmente il fatto che stiamo facendo qualcosa in background è uno stato per cui poi dipende come volete farlo chiaramente potete farne se avete una cosa molto importante che va fatta e volete che è così un'attività di primo ordine potete fare un provider molto grosso tipo sto facendo cose state provider ok questo state provider cosa fa di base è false ok quindi qui dentro ormai stiamo finendo quindi la facciamo questo è solo ipotetico però su una carta funzionerebbe quindi se se volessimo fare questa cosa faccio così sto facendo cose notifier state true ok faccio cose molto lente appena fatto false ok nel frattempo cioè qui si rebuild l'applicazione qui si rebuild di nuovo di nuovo però nel frattempo posso fare quello che voglio in più grafica questa è un po' l'idea chiaramente da questo stato qui deve dipendere qualcosa in interfaccia grafica che dice all'utente che sto facendo cose ok per cui banalmente potrebbe essere vicino alla radice della mia pagina un grosso caricamento una scritta un overlay in segno di trasparenza possiamo immaginarci cose più o meno sofisticate più o meno esteticamente gradevoli però quello che fate fate l'importante è che mostrate l'oggetto di caricamento soltanto quando questo è true ok quindi di base tra l'altro è una cosa che si fa spesso e su varie app si vede anche cioè quando avviene qualcosa di molto lento si copre tutta l'interfaccia diventa che so merita o c'è un caricamento in sua impressione in azioni e quant'altro quelle compaiono quando questo set of notifier diventa true quando passa a false che lo si può togliere e a quel punto l'applicazione può mostrare il risultato delle cose che ha avanti chiaramente questo è un approccio estremamente fatto con l'accetta per cui ho un provider che è true o false in base a quello che si fa va bene tra alcuni scenari ma non per tutti i scenari se dovete fare molte cose o fate un provider per ogni singola cosa pure però diventate cioè diventa molto noioso molto presto oppure siamo un provider cioè un future provider che lo faremo domani cioè un provider che può non avere un valore questi sono tutti provider che hanno sempre un valore un future provider non è altro che un provider che che cioè include la possibilità di che qualcosa non sia pronto in sostanza appena me lo apre lo vediamo anche vabbè lo potete immaginare comunque contiene in sostanza un boolean che vi dice ho fatto o non ho fatto e e poi vi dà accesso a un dato che si aprirà a un secondo certo a un certo punto quindi è il modo con cui potete fare che ne so se i nostri studio item fossero molto costosi da costruire potremmo metterli dentro dei future provider e caricarli alla bisogna ok però l'importante è appunto questa tanto questo è fondamentale cioè qualsiasi cosa riguardi la vostra interfaccia utente e il suo stato alla fine dei conti deve essere un provider perché sono i provider che vi permettono di costruire quello non è inevitabile è vero che a un livello molto basso del vostro audio potete cavarvela con lo stesso provider però a quel punto il caricamento mettiamo vale solo per quelli che ci sono e quindi magari può essere utile come per esempio se dovete caricare una gif animata per dire un esempio che magari quella non impatta tutta l'applicazione perché non è una cosa rilevantissima però se volete caricarla nel background e farla comparire con il tempo che ci vuole quello può essere uno stessual provider perché non è una cosa rilevante per tutta la presentazione non è una cosa che vi posare dietro però poi dipende dal caricamento di quella gif e quindi quello può essere uno stessual provider che internamente va a fare lo scaricamento della gif ripodificarla e così via e poi la mostro quando va questa è un po' idea ora io voglio fare sei minuti quindi direi che non basta il tempo anticipazione per domani allora faremo un'ultima cosa che è sempre legata alla navigazione e navigheremo in base a un provider che è un'altra cosa fondamentale che faremo ossia faremo una scritta di login immaginiamo di legare questa tool list a un vostro account online con le cose da fare avremo quindi una pannella una schermata di login con un'usima password quando facciamo login compare la lista quando siamo sloggati compare invece le pannella di login qui avremo un provider che è il profilo utente dell'utente quindi un provider che se è nullo l'utente non ha fatto login se contiene qualcosa l'utente è logato e poi in base allo stato di quell'oggetto faremo un widget di altissimo livello che vi redirige sulla pagina rilevante quindi login oppure la nostra pagina così in quel caso vedete anche come funziona a livello potete annidare varie strade di strade di navigazione e legarli se volete allo stato dei vostri provider ok qui non so se avete ancora dei dubbi che possiamo fugare in questi ultimi tre minuti però questa la navigazione funziona esattamente come funzionava la no la spunta per i nostri oggetti abbiamo una serie di oggetti list view item interna alla lista che non fanno altro che dare un oggetto da visualizzare ai nostri ai figli quindi o to do item viewer che è questo oggettino qui violaceo o to do item page che invece è un oggetto più importante che chiaramente fa la stessa cosa ah altra cosa chiaramente to do item viewer che è questo si può lidare dentro la page questo era per dimostrare ma che vanno a cascata le cose per cui come diciamo prima no per cui la comodità del provider è che poi tutti gli oggetti a cascata hanno quella quella quella cosa se qui dentro ci metto c'è il to do item viewer se mi piace non lo so ah non è conto ah no non è importante più banalmente ok se lo inglobo qui dentro questo oggetto qui leggerà esattamente come la pagina oddio lo stesso oggetto quindi non devo fare assolutamente nulla riciclo gli elementi così come li trovo e e ho l'oggetto anche al dentro della nostra la nostra pagina per cui adesso creo di nuovo gli oggetti apro qui vabbè se non è bello ma si può adattare mettendo la colonna giusta ah non funziona esatto adesso vediamo perché non funziona e perché ve lo accenno non funziona perché questo oggetto qui va a è dentro una pagina che è stata costruita con un oggetto e non viene ricostruita come la lista cioè la lista per chiudere per chiudere in maniera confusionaria la versione allora questo oggetto qui è dentro la lista la lista viene ricostruita da home page appena cambia la lista quindi qualsiasi motivo che faccio il mio list to do item viewer viene ricostruito grazie alla lista in cui si trova qui posso mettere le spunte funziona se lo apro quando clicco qui viene scatenato viene scatenato questo oggetto qui dove siamo questo navigator qui questo navigator qui crea una root e gli passa un oggetto che è questo oggetto qui questo item qui questo item qui è statico quando viene passato viene passato come un oggetto fisso prendi questo qui e mostro fine e lo mostro dentro questo provider scope qui ora visto che siamo questa cosa qui viene messa nella root quando lo apro finché non lo modifico va benissimo perché prende l'oggetto per come era fatto e rimane qui se lo spunto l'ho spuntato in realtà però nessuno me l'ha detto perché io ho nella root ho l'oggetto fisso che mi è stato passato da fuori questo scope qui nessuno dipende dalla lista proprio tutti dipendono soltanto dal current to do item provider che però è statico quindi non ha nessun legame con to do list questa qui ok per cui non vengo ricostruito se torno indietro magicamente la lista è stata ricostruita ok quindi mi sono incartato un po' da solo adesso domani lo risolviamo però in sostanza è perché la lista dipende dall'oggetto che ha la verità la versione interna quindi le spunte eccetera questa visione qui invece ha un oggetto che non può essere ok per cui questo chiaramente non è ideale lo risolviamo però è un problema in cui ci si può imbattere quindi funzionerebbe ma non lo vediamo subito lo vediamo domani sì esatto e questo tra l'altro tradisce il fatto che tutti gli oggetti sul navigator sono tutti minimo appena io adesso qui aggiungo la pagina lei è viva ovviamente perché la vediamo per quanto non funziona sotto la lista c'è ancora e riceve gli aggiornamenti e si ripica ok quindi questo è così però adesso quello che faremo domani è rendere questa pagina qui consapevole del fatto che dipende dal distanza di spazio lo faremo con un altro oggetto di provider misterioso che è pronto in questo caso ok ci vediamo domani con altri dubbi e un altroավ