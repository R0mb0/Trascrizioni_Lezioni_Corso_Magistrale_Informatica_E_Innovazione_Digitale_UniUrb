ok per cui siamo riusciti a faticosamente diciamo così a rendere interattiva la nostra interfaccia e fin qui va bene adesso cerchiamo di renderla un pochino più efficace nel propagare lo stato perché appunto come dicevo prima il problema di fondo è che questo stato qui che è pacchettato qua dentro quando diventa più complesso diventa molto grande potenzialmente e se vogliamo farlo con i famosi si fatica molto perché andremo a crearne uno per ogni singolo oggetto quindi chiaramente non è una cosa che scala vediamo come ci può fare con il nostro amico rimetto come prima quindi rimetto privato lo stato e dentro il viewer quindi a questo punto qui non potrò più accedere allo state quindi questa cosa qui torna ad essere inefficace perdiamo di nuovo la capacità di spuntare e mettere il foglio della spunta ma la rimettiamo per un secondo ok allora intanto dove siamo nel mail ok allora partiamo dalla dalla dalla A di Riverpod Riverpod è dato il nome di Riverpod è un cos'è ma è una è una cioè sono le lettere di provider riorganizzate per mettere per scrivere Riverpod perché fondamentalmente Riverpod è un sistema a provider per cui prevede che ci siano una serie di gestori di qualcosa che vi provide che vi forniscono delle informazioni e voi nelle vostre viste nei vostri vari widget andate a registrarvi presso questi provider di dati e se questi dati vengono modificati in qualche modo è il provider che vi notifica del fatto che la vostra widget deve in qualche modo ricostruirsi quindi l'idea è quella di avere un insieme di provider tutti dinamici se volete e capaci di notificarvi di aggiornamenti modifiche e quant'altro che causano poi delle rebuild delle build dell'interfaccia però specifiche quindi l'idea è proprio quella che dicevo prima di avere di avere uno stato che si propaga in automatico e di permettervi di registrare gli elementi più vicini alle folie del vostro albero di widget a queste modifiche in modo tale da fare delle build veramente minimali e ottimizzare quindi il flusso della vostra applicazione quindi idealmente che ne so se spuntiamo un oggetto qui vogliamo che soltanto la checkbox venga aggiornata ok? non tutta la list view e se modifichiamo la lista aggiungiamo degli elementi vogliamo che soltanto questo numero qui e ovviamente la lista stessa vengono aggiornati non tutto il resto dell'applicazione quindi l'idea è di registrarsi selettivamente alle informazioni che ci interessano per andare a aggiornarci quando andiamo a registrare cioè a includere RiverPod qui la prima cosa che andiamo a fare per sfruttarlo è dentro il main cioè a livello proprio globale possiamo andare a definire i nostri provider nel codice i provider sono tutti quanti globali quindi sono tutte delle variabili globali che vivono da qualche parte del vostro codice e adesso qui lo mettiamo nel main perché chiaramente è il nostro file comodo da utilizzare però un'altra cosa che si fa spesso è si crea un file providers.dart che contiene soltanto i provider però sono i provider di un stand esatto praticamente sono i provider quindi una serie di oggetti che forniscono accesso ai dati interni della vostra applicazione quindi stiamo districando lo stato dalla interfaccia utenti quindi quello che andiamo a fare a lato pratico è togliere questa lista qui che non sarà più stato della home page ma diventerà stato incapsulato dentro un provider dell'auto turista ok quindi l'idea è quella però prima di fare un provider dell'auto turista andiamo a fare un provider molto più semplice cioè un provider che fornisce accesso a una stringa proprio come esempio molto molto banale che si può provare quindi andiamo a creare un provider con RiverPod e lo chiameremo greeting provider giusto vedere come funziona di tipo provider ovviamente quindi la classe che usiamo è provider la importiamo questa vive dentro la flat RiverPod chiaramente ok come ho fatto un provider un provider non è altro che una funzione cioè un provider stesso è un una classe un oggetto che vi fa da interfaccia da accesso a una funzioncina che crea il dato ok mi sarebbe chiaro per un secondo questa funzioncina che genera il dato ha come parametro un unico parametro che sta ref che vediamo tra un secondo e ritorna il dato al quale stiamo facendo l'accesso quindi usiamo questo sintassi funzionale e ritorniamo questo è il nostro provider più primitivo che si possa immaginare serve a ben poco per ora ovviamente scusi abbiamo avuto dipendenza a flutter provider qui nel un'eo e flutter riverpod questo qui e quando usiamo provider questo qui si trova dentro questo file qua si come no si quindi flutter underscore riverpod e poi in realtà riverpod è più complesso di questo nel senso che ha vari sottocomponenti che possono far fare cose aggiuntive quindi possono darvi aiuto aggiuntivo che però non useremo per semplicità quindi useremo solo flutter riverpod però in realtà se date un'occhiata approfondite riverpod ci sono altri pacchetti che potete opzionalmente utilizzare però per ora ci mettiamo a questo ok quindi il provider è un'istanza che vive qui dentro e non fa altro che nascondere cioè impacchettare una funzioncina che prende in input un provider ref che poi vedremo cos'è è in sostanza diciamo così è il è il contesto dello stato immaginate che questo provider ref è tutto il vostro stato dell'applicazione quindi viene fornito alla vostra funzione e ritorniamo una stringa statica ok questo qui vive a livello globale nel vostro conto chiunque può avere accesso a questo provider questo vale sia nel main chiaramente e a maggior ragione anche in un file providers.com eh sì .com .darts scusate magari per maggiore chiarezza lo faccio al volo io di creo providers qui no .com l'ho detto non so in automatismo io no providers.darts ovviamente ah no sì ovviamente l'ho detto e l'ho anche fatto per cui proprio l'ho convinto l'erro neanche scritto molto bene il caffè non lo ancora vedo perfetto evidentemente ok sto semplicemente spostando l'oggetto qua ok l'importo perfetto adesso chiunque voglia avere accesso ai main provider quindi allo stato applicazione deve importare providers.darts va bene a questo punto cosa ci facciamo con questo oggetto visto che è un provider che ritorna che cosa una stringa manualmente la usiamo da qualche parte nel nostro nella nostra faccia dove mostriamo una stringa lo possiamo fare in vari punti chiaramente direi che la cosa sensata è metterlo qui sopra quindi mettiamo un altro text prima della lista e ci scriviamo quello che viene fornito dal nostro provider va bene ok prima di farlo però l'unica modifica importante che bisogna fare alla nostra applicazione è che esattamente come avviene per l'inherited widget che in qualche modo lo stato vive dentro lo stato di uno central widget però poi dentro la gerarchia dei nostri widget c'è questo enhanced widget che si propaga quindi incausa lo stato con river mode avviene la stessa cosa ma avviene con un singolo oggetto che dobbiamo mettere in qualche parte della nostra gerarchia questo oggetto questo widget fasull che non faccio che fare da provider in sostanza si chiama provider scope si chiama e lo possiamo infilare in un livello abbastanza alto della nostra applicazione quindi per esempio lo potremmo infilare qui o ancora più così per rendere proprio l'elemento radice in assoluto possiamo metterlo addirittura qui sopra quindi qui wrappiamo my app dentro un oggetto che si chiama provider scope questo oggetto qui va sempre importato da flattery questo può essere tranquillamente ops const ok quindi allora ho creato un provider qui che non è altro che un'istanza provider globale che tutti possono utilizzare che ritorna una stringa ok poi per poterla usare in giro per il nostro codice flutter per il nostro prodotto flutter serve che ci sia un provider scope che è praticamente l'elemento radice che fornisce accesso a questi a questi provanti a cascata perché comunque internamente ovviamente Riverbott ricicla le cose di flutter quindi internamente userà una serie di digit così via che non fanno altro che sfruttare questi meccanismi di flutter solo che lo fanno in una maniera pacchettizzata che ci permette di farlo con meno dolore però fondamentalmente questo serve per inciocchettare per dare accesso a questo file qui a questo oggetto qui ok ora cascata dentro my app posso fare riferimento ai vari provider Riverbott che ho nel mio progetto per cui internamente qui che cosa posso fare una serie di cose volendo però mettiamoci qui un oggetto prima dell'expand qui aggiungiamo qui un widget che non fa altro che mostrare questo saluto eh sì esatto poi a che livello lo fate questo è abbastanza arbitrario gli altri conviene farlo a livello altissimo così tutta l'applicazione ha accesso a tutti i provider perché come al solito in Flutter fate attenzione alla gerarchia perché se voi usate uno qualsiasi dei provider serve che ci sia un provider scope appena sopra almeno e altra cosa che magari abbiamo visto adesso abbiamo visto poco in realtà però quando voi fate anzi è una buona occasione per tornare un attimo qui quando qui avevamo fatto questa operazione qui no qui facciamo find ancestor state of type e così via questa chiamata qui quindi questa chiamata che va a cercare no l'avo che ci dà accesso allo stato in realtà sale per la gerarchia dei widget e si ferma alla prima occorrenza di my home page state quindi appena incontra una si ferma significa che se abbiamo un albero complesso con più istanze adesso in questo caso non ha molto senso però con più istanze di my home page magari annidate potrebbe venire chi si ferma alla prima quindi fate attentamente al fatto che se avete più istanze dello stesso oggetto che incapsula dello stato voi fate sempre riferimento alla prima istanza alle quali avete visione ok quindi o questo vale anche per il tema per esempio quindi per esempio questo theme off sale su nell'albero della nostra gerarchia e si ferma dove? si ferma sul theme data di materiale però in effetti se noi volessimo fare una non so una sottoparte della nostra applicazione che ha un altro tema magari ha i pulsanti arancioni invece che i pulsanti viola come in questo caso nulla ci impedisce di prendere creare una seconda materiale più in basso poi quella sezione cioè tutto il sotto altro sotto rama dei nostri widget prendono il tema dalla prima istanza e mettere l'app che incontra e quindi rientra l'arancione ok quindi potremmo volendo avere più materiale annidate in se stesse e avere una parte dell'applicazione che è verde una parte gialla una parte viola grazie al fatto che ogni pulsante di sotto ha bisogno soltanto della prima istanza del tema che incontra ok per cui nel caso del tema è abbastanza evidente nel caso qui del click pure se avessimo più my homepage state ma in questo caso non era non avveniva e questo viene anche per il provider scope nel senso che se lo mettiamo a questo livello tutti quanti hanno visione dei vari provider se lo mettiamo più in basso ci può stare che alcuni widget non lo vedano altra cosa si possono avere ovviamente più provider scope ok con con vari provider diversi questo lo faremo ad un istante per complicarci la vita però è un modo con cui riusciamo a fornire dati diversi a sottosezione dell'applicazione fornendo varianti dei provider ma lo vediamo a seconda per ora accontentiamoci di questo provider ad altissimo livello e qui nel nostro codice andiamo a creare un widget che non fa altro che andare a leggere quel servito qui per impacchettarlo un po' crea un widget nuovo e lo chiamo greeting viewer che sarà allora sarebbe normalmente uno stateless widget no? a cui siamo abituati sarebbe quindi non è questo il caso mi finta di poter fare così ora quando andiamo implementare dei widget che in qualche modo hanno bisogno di fare riferimento a dei provider nella loro gerarchia di widget non usiamo status widget ma usiamo un altro widget astratto che ci viene fornito da Riverpod e il widget che ci interessa è il consumer widget si chiama è molto simile allo status quindi cambia molto tra l'altro vedete che ho visto probabilmente il consumer widget è stateless quindi è il corrispettivo in Riverpod lo status widget che però ha visione dei provider c'è anche il consumer stateful widget se abbiamo bisogno di stato interno quindi il corrispettivo dello stateful widget in Riverpod è il consumer stateful widget però si usa abbastanza poco perché l'idea di Riverpod è appunto quella di isolarci dello stato quindi in genere lo stato una volta che abbiamo Riverpod non lo usiamo più e questo build qui non è più fatto in questa maniera cambia lievemente vedete che facciamo lo con ride è identica se non che c'è questo widget ref questo ref qui che è un riferimento al mondo di Riverpod ai provider di Riverpod faccio autocompletare anche il costruttore come al solito per il resto è identico ai widget classici che siamo abituati a utilizzare ok quindi qui ci metto debug print come al solito ok e qui dentro ci mettiamo che cosa facciamo riferimento a questo provider qui che ritorna una stringa quindi ci metteremo un text di base quindi faccio text qui ci metterò la stringa per un secondo questo può essere cons non sarà cons perché dipenderà dal provider ok andiamo a leggere ok vabbè sarebbe da fare i nomi dei file non gli piacciono cambia poco ok a questo punto qui bisogna andare a leggere il provider come si fa? usiamo questo widget ref che appunto è il nostro riferimento al provider scope alla fine quindi questo oggetto qui è un modo che abbiamo per accedere a questo oggetto qui per te lo trovo questo oggetto qui in qualche modo ok facciamo ref punto e vediamo che ha una serie di strumenti di ausiliari in qualche modo e i più semplici da utilizzare sono read e watch read permette di leggere il valore di un provider in maniera così singola diciamo così e watch permette di sorvegliare diciamo così il valore di un provider e aggiornarsi nel caso in cui questo cambi ok quindi sono due cose simili ma un po' diverse quindi read si usa quando siamo sicuri che non ci serve tenere traccia delle modifiche del valore del provider watch facciamo se vogliamo essere ricostruiti nel caso in cui il provider cambi esatto quindi sono il corrispettivo di se ricordiamo come facevamo con col context find ancestor eccetera eccetera è read quindi va pescare lavo e lo legge una volta e basta l'altro è depend eccetera eccetera quindi depend on internet element eccetera eccetera quello è il watch depend se ricordate con l'inherit widget crea un legame di aggiornamento tra il build context di riferimento e il widget che stiamo andando a leggere ok stessa cosa fa watch quindi ref watch è quello che ci interessa in genere con provider se siete in dubbio su cosa usate usate il watch sempre perché watch vi garantisce che il valore che state andando a leggere è sempre aggiornato perché se dovesse cambiare il fatto che avete chiamato watch scatena una rebuild della vostra interfaccia quindi la vostra interfaccia è coerente con quello che è il valore read questo non lo fa read lo legge una volta e poi dice ok va bene così con watch invece siamo sicuri che ogni volta che il provider cambia questo ci ritorna cosa forniamo a watch forniamo l'istanza quindi vedete qui è un oggetto provider list eccetera quindi il provider stesso quindi gli forniamo questo è un po' strano ma è così il pattern gli forniamo proprio questo oggetto qui faremo il provider quindi vai cioè leggimi questo provider qui questa parte che devo importarlo chiaramente quindi importo providers questa operazione questa operazione qui che cosa fa ritorna l'oggetto che il provider fornisce ossia una stringa vedete qui type string quindi questo ritorna una stringa a questo punto cioè quello che ritorna watch dipende dal tipo di provider che stiamo guardando chiaramente quindi questo è un provider di stringa quindi watch ritorna una stringa e quindi questo text qui è soddisfatto certo ok ok e non basta segnare a provider visible di stringa ah no non lo so perché c'è un'altra stringa beh adesso non non so ah perché nel qui ah ok facciamo un esempio perché in effetti ha senso mettiamo che ci sia cioè il provider posso ritornare quello che vogliamo quindi possiamo avere un altro provider che ritorna un contatore no? abbiamo fatto mille contatori nei nostri quindi qui possiamo fare ref che ritorna un due tre questo è un provider di intero provider int e quindi qui se noi usassimo il counter provider si potrebbe fare questo darebbe errore perché questo watch qui ritorna un cioè prevede che questo esatto devo castarlo è intero quindi possiamo fare two string sull'intero quindi questo ref watch ritorna un intero poi l'intero è un po' castato a string se no non è non è visualizzabile da text quindi il provider può essere che lo troviamo e dobbiamo fare dopo watch cast sì esatto watch ci ritorna il tipo del provider che il provider è in capsule che ci fornisce quindi questo può essere qualsiasi cosa può essere un oggetto qualsiasi quindi potremmo tranquillamente cosa che faremo tra un secondo tra l'altro potremmo avere un provider di to do item quindi fornire anche accesso a un to do item o una lista di to do item perché è quello che ci interessa poi per quanto riguarda la lista però l'oggetto che fornisce è perfettamente al vitrario torno un attimo qui no e torniamo al nostro item provider quindi questo non devo castarlo ok a questo punto il greeting viewer lo inseriamo qui nella nostra gerarchia di oggetti quindi lo mettiamo qui importato anche questo questo chiaramente è const ok e uno spazio ok vediamo un po' se tutto torna adesso ovviamente non sarà una cosa praticamente emozionante però ci sarà un text che ci scrive ciao mondo e lo fa non sulla base di testo statico nel widget stesso né sulla base di stato della nostra applicazione ma lo fa sulla base di informazioni che vengono dal provider esterno questo finora è molto inutile però tra un secondo lo faremo con la lista per cui ha più senso che lascini la nostra Allora Allora, chiamo il provider un attimo Perché l'esempio del counter è abbastanza utile penso Per cui potrebbe essere un buon esempio Allora, il provider, un'altra cosa che possiamo fare Per vedere quando il provider viene costruito È modificare un attimo questa funzione qui E renderla non più funzionale Ma giusto cambiare la sintassi Per capire quando il provider viene costruito Quindi qui lo rendo sintassi in formato operativo Lo diciamo così E qui mettiamo the backprint Non metto il risco detto per essere più evidente nel codice Ok, perché dovevo capire quando questo provider viene... Quando questa funzione viene chiamata, no? Per capire come funziona esattamente Per cui proviamo a lanciare di nuovo la nostra applicazione Quello che vedremo è che questo provider qui viene lanciato una singola volta Appena prima Cioè appena prima Mentre viene costruito l'oggetto che fa accesso In sostanza Quindi viene costruito, diciamo così All'ultimo secondo Come? Viene costruito un nuovo error assoluto Viene costruito, cioè viene... Un attimo Insieme Abbiamo dato la lista di oggetti che viene costruito Quindi viene costruita la home page Viene costruito greeting viewer Che è questo oggetto qui che visualizza il dato Questo qua Questo dato qui ha bisogno di greeting provider Quindi fa ref watch greeting provider A questo punto RiverPost si accorge Ah, questo widget qui ha bisogno di greeting provider Greet provider devo instanziarlo Per cui andrà a vedere in provider scope Se già esiste Ok? Il nostro provider scope contiene i vari provider Questo qui Finora il greeting provider non esiste ancora Non è stato distanziato Per cui viene creato per la prima volta La tag è qui vediamo nel codice Appena dopo Quindi l'ordine è esattamente questo Quindi building greeting viewer Poi facciamo accesso a watch A questo punto se ne accorge Costruisce il greeting provider E a quel punto Dentro provider scope C'è quel valore Di greeting provider che è stato istanziato Quindi greeting provider assume il valore Ciao mondo come stringa E lo assume per sempre Tra virgolette Perché questo è un provider Fisso Non può essere modificato E quindi non c'è modo di schiodarlo In qualche modo Ok? Quindi è un provider che in sé È molto inutile in questa forma Poi chiaramente Perché non può essere modificato Però poi ovviamente si possono anche modificare Però in genere questo provider qui Viene instanziato una singola volta Non ha altre dipendenze Quindi non viene modificato Tant'è che la nostra interfaccia Se bene possa essere Viene ricostruita mille volte E quindi Ah vabbè Sì Greeting viewer Tanto non viene neanche ricostruito Perché è sempre qui Ed è sempre cons Quindi qui vedete Che non viene ricostruito Ma anche se venisse ricostruito Quindi se io togliessi qui No Se togliessi qui La costitudine A greeting provider Ok Che costringe Greeting viewer ad essere ricostruito Vedrete che Il provider viene ricostruito Una singola volta Perché Quella watch lì Semplicemente va a rileggere Il valore che già conosciamo Quindi adesso clicco qui Si ricostruisce Home page Greeting viewer Produire E così via Ma il greeting provider Non viene ricostruito Quindi viene costruito Una singola volta Perché Non è stato modificato Ok Quindi il provider Si comporta effettivamente Come una specie di cache Se volete immaginare In questa maniera Quindi è Un valore che rimane Dentro il nostro Provider scope E non è modificabile Ora Chiaramente A che serve In questo modo A più poco Nel senso che Questa è una stringa Potrei fornirla in altro modo Veramente Perché Fare tutti questi giri Con una stringa costante Effettivamente È vero E facciamo un esempio Con il counter provider Che è un altro esempio Abbastanza illuminante Quindi questo counter provider Qui ha Lo stesso Funziona Alla stessa maniera Il greeting provider E viene installizzato A 1, 2, 3 E non cambia mai Quindi anche qui Possiamo immaginare Che se qualcuno Lo reggesse Verrebbe istanziato Una singola volta E rimarrebbe Con quel valore lì Anche qui Per apprezzarne Il valore Magari Così Ok Quindi se adesso avessi un pulsante Qualcosa che mostra Questo conditore qui Vedrei che non cambia mai E questo è poco utile Se vuoi avere un provider Che cambia eternamente Mi serve un altro tipo di provider Che è uno state provider Quindi un provider Che ha dello stato interno Questi provider qui Non hanno stato Quindi hanno uno stato Cioè hanno un valore Ma non hanno uno stato Non è modificabile Esattamente come uno stateless widget Alla fine dei conti Quindi viene ricreato una volta Se non cambia Non viene ricreato mai Per renderlo cambiabile Bisogna dargli E renderlo uno state provider Se il provider Funziona per me Dalla stessa maniera Quindi ritorna A 1, 2, 3 Mettiamo Però questo posso modificarlo Quindi questa forzione qui Che viene invocata qui Viene invocata una singola volta Quando lo stato viene inizializzato Quindi quando inizializza lo stato Viene messo a 1, 2, 3 E poi da quel momento in poi Posso cambiarlo Ritorna? Se vogliamo mapparlo Nel nostro modello aumentare Nel In quello che facevamo Con lo stato Del widget È come se Qui dentro il main Avessi Lo stato Della nostra applicazione Questo qui mettiamo Con Un int Counter 1, 2, 3 No? È la stessa identica cosa Aveva uno stato Che viene inizializzato A 1, 2, 3 Stessa cosa Quindi questo è lo stato Però È lo stato Che non vive dentro un widget È stato Che vive dentro un provider Però alla fine dei conti Non cambia Ok Quindi questo stato qui Non ci serve Proviamo un attimo A utilizzare questi Questi oggetti Così Li apprezziamo meglio Per farlo Io direi Che possiamo Vediamo un po' Dove possiamo Mostrare questo contatore Mettiamolo Sempre in un widget Qui Non sarà bello Ma vado in uguale Lo mettiamo in un widget Qui magari a destra Che ci mostra Il testo Quindi Mettiamo qui Il greeting viewer Lo mettiamo dentro Una riga Rapid row Ok E qui ci mettiamo Un altro widget Che si chiama Counter viewer Lo copio Brutalmente Da Greeting viewer Tanto fa la stessa cosa Ma legge Un altro provider Quindi questo è identico Spiccicato Ma si chiama Counter viewer Ok E invece di leggere Greeting view provider Leggerà Counter provider Lo chiamato così Verro Ah Questo non mi piace Perché non è una stringa Ovviamente Possiamo fare così Per esempio Contatore E poi Metterlo Tra In varie parentesi Quelli Di quanti una stringa E questo va bene Ok Ora Questo Fisora non cambia nulla Cioè adesso abbiamo Un altro elemento Lì Magari questo Lo mettiamo Lineato a destra Così Anzi Lo facciamo sulla riga Quindi la riga Qui ci mettiamo Il nostro Const Counter viewer Ok E sulla nostra Main axis Ci mettiamo Che vogliamo Alinearli Con Space Space Between Che li devo mettere Sugli estremi Importo Counter viewer Qui tutto questo Può essere Cons Chiaramente Quindi lo metto Qui fuori Mi torna Almeno Non so se Avete stato persi Qualcosa Le build un attimo Così vediamo Se graficamente È quello che vogliamo Quindi Quello che comprerebbe Il contatore 1, 2, 3 Si pone Ok Non è bello Ma funzionale Quindi questo è il contatore 1, 2, 3 E vedete che Counter provider Viene istanziato Di nuovo Appena Sub Cioè appena Viene utilizzato Quindi Counter viewer Visto che fa RefWatch Di Counter provider Andrà a istanziare Counter provider E a popolarlo Con un valore Di report Che è 1, 2, 3 Per come l'avamo costruito Quindi va bene Però il contatore Può essere modificato Finalmente Per cui Cosa facciamo Serve un pulsante Qualcosa Che ci permette Di modificarlo Io direi che il pulsante Lo possiamo mettere Qui sopra Non so Lo mettiamo appena prima Di 0 O 2 2 2 2 2 3 3 3 4 5 5 6 6 7 7 7 8 7 8 8 8 8 8 9 9 9 9 9 9 9 10 9 10 10 11 10 11 10 11 12 13 Quindi abbiamo Un oggetto Che a questo punto Dovrà Andare in qualche modo A modificare lo stato Come va Come si fa A modificare lo stato Di uno state Provider Semplicemente Con E anche qui Il meccanismo è un po' strano Però dobbiamo andare A leggere Il widget Ref Quindi esattamente Come avviene qui Con No Con il counter reviewer, scusate, abbiamo bisogno di questo widget ref. Per cui il widget contenitore deve essere un consumer widget. Ok? Perché altrimenti non abbiamo accesso al provider scope. Quindi bisogna convertire adesso il nostro My Homepage, perché siamo dentro My Homepage, no? Siamo dentro My Homepage, la parte. Questo qui va convertito in uno stateful, è consumer stateful widget, ok? Perché è stateful. Poi tra un secondo lo rendiamo stateless, perché perderemo anche la tutoria, perché la metteremo in un provider. Però per ora la lista è ancora qui, come è stato. Quindi questo adesso diventa un consumer stateful widget. Salviamo. Prego. Quindi noi quando utilizziamo sicuramente il problema di My Homepage, nella stragrande maggioranza dei casi avremmo tutti i nostri widget, i widget, i nostri saranno tutti stateless quanto consumer widget. Esatto. Esatto. E cioè, anche i consumer sono stateless. Anche? Anche i consumer sono stateless, in realtà. Cioè, derivano da stateless widget, se sono proprio un riferimento alcuno allo stato. E i consumer widget lo ha internamente, se non so se lo riusciamo a vederlo subito, però sono a loro volta, vabbè, ok, mi. Sono implementati in questi stateful, però sono, cioè, li utilizziamo come se fossero stateless, perché non c'è modo di applicare dello stato al consumer widget, ok? Perché qui dentro funziona esattamente come il widget stateless. Ok? è un po' misterioso, però. Sicuramente quando vuoi utilizzare consumer widget, ce ne abbiamo tolta mezzo con stateless. Sì, cioè, nel senso, ce lo trattiamo come uno stateless? Sì, esatto, esatto. Non è stateless all'atto pratico, cioè, se l'hai sui codici, non è stateless, perché è implementato internamente con uno stateful widget, però questo ci interessa fino a un certo punto, però perché dentro un consumer widget noi non abbiamo modo di avere stato, ok? Perché è implementato esattamente, cioè, ci dà l'interfaccia che è identica a quella di uno stateless widget. Ok, quindi, adesso, voglio dire la domanda, e quindi, quando noi abbiamo per esempio una pagina come un widget, perché ho avuto una schermata, una schermata, sì. Certo. un'applicazione in questo caso, noi possiamo definire questo my homepage come stateless widget che al suo interno ha dei consumer widget che hanno loro volto invece di essere. Esatto, esatto. Infatti faremo esattamente questo, perché, idealmente, si fa esattamente così, cioè, per quanto possibile, si cerca di fare tutto quanto stateless, per quello siamo sicuri che non ha nessun legame con lo Stato e ne è quei provider né niente. Quindi, i widget stateless sono i nostri widget preferiti perché sono sicuramente i più efficaci. Li possiamo costruire con dei dati, quindi è quello che fa il Todo-Eiter Viewer, però, che è il nostro widget ideale, no? Prende un dato, viene costruito una singola volta e buonanotte, va bene così. Se abbiamo bisogno di dati, dobbiamo cercare di renderli più settoriali possibili. Quindi, il widget più in basso possibile deve diventare un consumer widget per avere visione dei provider e potersi aggiornare con lo Stato dell'applicazione. Quindi, questa è un po' l'idea. Ed è quello che stiamo facendo adesso, pezzo per pezzo, andando a creare questi greeting viewer e counter viewer, perché questi sono dei widget molto piccoli che però dipendono da uno Stato esterno, però sono così piccoli che possiamo riciclarli in tanti luoghi dell'applicazione. Non perso che la metà, quindi ho convertito in consumer status widget, il nostro state widget, adesso qui cambia ovviamente lo sta, qui cambia la sintassi di questo oggetto qui. Cambia il tipo di base, per cui facciamo di creare l'override, così, quindi non cambia niente se non che non è più state, ma è consumer state, ovviamente questo va tutto ripattezzato, diciamo così. Quindi qui questo di nuovo torna mind state, eccetera. Vai, la puoi fare. è un stesso tipo, immagino, però dovrebbe accettarlo lo stesso, ok, quindi questo è un consumer state, ok, quindi cosa cambierà? Cambierà la build, ovviamente, quindi la build non è più build, vabbè, facciamo a mano, quindi qui ovviamente ci aspettiamo che ci sarà qualcosa, un widget, quindi cambia semplicemente quello. È giusto? Facciamolo, facciamolo fare. Tolgo il metodo e io lo faccio ricreare, siamo sicuri che è contento. ah no, non è giusto. Al widget rshorter ce la fornisce in un altro modo, visto? Ok, entrava. Ok, quindi questo va bene e a questo punto abbiamo accesso allo stato, al widget ref qui dentro il consumer state che dovrebbe esporci il widget ref, esatto, quindi lo usiamo direttamente come ref, non ce lo fornisce come parametro della build, ma ce lo fornisce come campo dell'oggetto. Quindi, per farla breve, qui dentro possiamo fare ref, appunto, qualcosa e lo facciamo dentro il nostro base button. Quindi qui dentro vogliamo andare a modificare che cosa? Il nostro provider qui, questo qui è immutabile, questo provider è stato, questo provider con stato interno e quindi counter provider andiamo a leggerlo intanto, quindi facciamo ref.read di counter provider, adesso qui la sintassi è un po' discutibile ma è così, questo counter provider ha una serie di campi notifier che non sto vedendo, notifier, quindi andiamo a leggere, attenzione, non il provider stesso ma un oggetto mistico, misterioso, che si chiama il notifier del provider, è un oggetto che incapsula lo stato del nostro notifier, e a questo punto questo oggetto qui possiamo usarlo come se fosse una variabile modificabile. Quindi questo oggetto qui ha uno state, che è l'intero effettivo, e lo possiamo riassegnare, e lo facciamo facendo più uno. Ok, qui di nuovo la sintassi è discutibilissima, però che cosa accade? Quindi non so se avessi fatto ref read di counter provider, questo mi dà accesso all'interno. Questo è quello che abbiamo fatto prima per leggere il dato. Abbiamo fatto watch, però se posso vedere read e watch sono la stessa cosa. Quindi quando read leggo il dato una singola volta, e così avrei potuto leggere il dato, anzi facciamolo così, quindi leggiamo il dato e quindi diciamo, prima del click il contatore era, così può essere un po' racconto, quindi diciamo abbiamo letto il dato in questa maniera. Non mi piace? Ok. Perfetto. Poi con questo altro sintassi discutibilissimo, cosa facciamo? Accediamo, leggiamo, non il provider stesso, ma quello che è dentro il provider, quindi quello che sta aggiornando gli altri widget che dipendono da questo provider. Quindi è un oggetto più rilevante, in qualche modo, del provider stesso, del valore, ma è quello che fornisce il valore, tra virgolette. Questo oggetto qui ha internamente un, ha l'intero vero e proprio, quindi l'intero che viene modificato e che si propaga. Quindi questo state qui è di tipo T, cioè qui è di tipo int, in questo caso perché è un counter provider, ma è chiaro che se facessimo la stessa cosa con il notifier di greeting provider, gli sarebbe una stringa. Quindi questo state qui è semplice lo stato interno del provider, lo modifichiamo e a quel punto immaginiamo che tutti i widget che dipendono da questo provider qui vengono notificati. Esattamente come avveniva con l'inherit widget che si propagava in automatico, anche il counter provider si propaga appena viene modificato e tutti i widget dipendenti da questo oggetto qui vengono aggiornati. Quindi quando vogliamo aggiornare un provider, leggere, non un provider, prendere lo stato e prendere il produttore. Esatto. Quindi se vogliamo utilizzare il produttore, non avremo un watch del provider del basket. Esattamente. Quindi quando leggiamo qualcosa, possiamo fare ref.watch del provider, quello ci dà il valore del provider. Questo è un provider, dentro incapsula una stringa, questo qui in particolare, questo incapsula un intero. Con watch e ref sul provider, leggiamo, però solo lettura, quindi non possiamo modificarlo chiaramente quel dato, possiamo leggere e ricevere il dato. Se vogliamo modificarla in qualche modo, bisogna andare a accedere a un oggetto di più alto livello, che è il notifier di quel provider. Quindi leggiamo il notifier di quel provider e con quell'oggetto lì, con il notificatore, possiamo andare a manipolare il suo stato. Il notifier dentro di sé ha questo oggetto state. Vedete qui è un... lo state modifier è l'oggetto che incapsula lo stato, state è semplicemente un'istanza di valore t, vedete qui dentro è questo t, sostanza, lo possiamo rimpiazzare con questo set qui, lo possiamo modificare e in quel caso lo rimpiazziamo. Attenzione perché non stiamo modificando lo stato stesso. Questa è un'altra cosa, una piccola cosa da cui tenere conto. Nel caso dell'interno chiaramente non è rilevante, però nel caso di un oggetto più complesso, se tra un secondo useremo il set modifier di to-do item, non stiamo modificando il to-do item, stiamo rimpiazzando il to-do item, questo è fondamentale, perché lo stato può essere solo rimpiazzato. Se venisse modificato, non c'è modo per aggiornare il provider. Il provider si accorge del fatto che è stato modificato soltanto se la sua istanza è stata riassegnata, modificata integralmente. Nel caso dell'interno chiaramente è l'unica cosa che possiamo fare, possiamo semplicemente assegnare un altro interno e quella cosa che possiamo fare. Nel caso del to-do item, no, ma per fortuna abbiamo implementato to-do item come un oggetto immutabile. Di nuovo, si sfrutta questo pattern, questo paradigma, per cui quando andiamo a usare state provider di to-do item, non li modifichiamo mai, ma semplicemente li andiamo a rimpiazzare. Questo rimpiazzamento causa questa rigenerazione a cascata. Qui magari non è perfettamente esplicita questa cosa qui, perché si sta usando il più uguale. Ora, più uguale, la sintassi, leggere il valore, aggiunge e riassegna. Quindi in realtà, forse è più chiaro se faccio così. Ok, quindi è un assegnamento. Prego, come no? Sì, sì. E quando... E allora, qui andava cambiato il tipo da state for widget a consumer state for widget e qui diventa consumer state e non più state. E poi qui consumer state for widget. è giusto? Sì. Anche questo va modificato, però. Quindi questo diventa un consumer state. Forse è quello. Ok. Sono conquistato le cose. Quindi si cambia questo, questo e questo. Che diventano dei consumer state, così via. Poi in realtà, my open page state non va modificato, questo... perché la build rimane esattamente identica. ok? E a questo punto abbiamo accesso al red. Ok, vediamo se funziona. Se no, siamo a capo a piedi. Ok, adesso creo di vari oggetti, va bene. Abbiamo un contatore di uno qui e... ok, funziona. E meno male, diciamo così. E... Notate che questo, costruendo counter provider, non viene più invocato, ok? Quindi qui è stato già creato una volta, quindi quella funzione lì che prepara il counter provider, questa funzione qui, viene creata, questa viene lanciata soltanto una singola volta. quindi è come se fosse tra virgolette, come se fosse un singleton nella vostra... dentro il vostro provider scope. Perché? Inoltre, tra virgolette, cioè per ogni istanza di provider scope, che è questo, può esistere una sola istanza di ogni provider. Posso dire chi ha? Quindi praticamente dentro provider scope c'è una mappa che per ogni provider ha un valore. Ok? Quindi questo provider scope qui, al lato pratico, conterrà un greeting provider che va nel ciao mondo e un counter provider che viene inserizzato a 1, 2, 3. Poi può essere modificato. Quel counter provider che viene modificato continua a vivere qui dentro. Qui. Quindi, a cascata, tutti i... tutti i widget che dipendono da quel counter provider ottengono lo stesso valore. Cioè, se adesso io leggessi il counter provider su un altro... da un altro widget, adesso non so quale potrebbe essere, immaginate, anche qui, per esempio, leggerebbe lo stesso valore e quindi ha accesso allo stesso stato. Se ho più provider scope potrei avere concettualmente più provider diversi dello stesso tipo, volendo. Questo faremo tra un istante quando andremo a propagare dei two items dentro queste istanze qui. ok? Quindi, a questo punto siamo... Cioè, adesso la nostra ricostruzione è molto ottimizzata perché quando clicchiamo qui sul contatore vedete che in realtà la home page non si ricostruisce neanche. Cioè, c'è soltanto questo contatore qui. Quindi, in questo senso, è super ottimale. Meglio di così non si può fare. In sostanza, quindi c'è proprio il minimo possibile che viene costruito. Il resto di interfaccia rimane perfettamente identica. Ok, adesso facciamo l'ultimo passo finalmente, cioè migriamo la to-do list e rendiamola un oggetto provider. Ok? Quindi, l'ultimo passo è creare un provider più sofisticato perché finora i provider sono molto semplici e, insomma, fanno ben poco. Adesso faremo qualcosa di più complesso. Allora, sulla carta provider è l'esempio base di un provider che non viene modificato. Se il provider è un provider di base che contiene un singolo stato, generalmente è uno stato primitivo. Quindi, in questo caso, un intero va benissimo, potrebbe essere anche una stringa, potrebbe essere anche un double, potrebbe essere qualcosa di un booleano, per esempio, cose del genere. Quindi, quelli vanno benissimo. Però, appena abbiamo bisogno di qualcosa di un buon più sofisticato, ci serve un modello per impacchettarlo. Perché adesso faremo prima un altro modello che si chiama to-do list, che è proprio l'oggetto che impacchetta la nostra lista di oggetti da fare e poi renderemo un provide. Quindi, prima di tutto, facciamo to-do list punto dart. Questo è l'oggetto che impacchetta la lista e vi da anche accesso, avrà anche i vari metodi di modifica della lista. Quindi ci sarà add item, remove item, switch item, cose via, li metteremo tutti quanti qui dentro. Quindi, prima erano direttamente nella classe stato, che non era bellissimo, adesso abbiamo una classe che fa soltanto questo, che esiste lo stato della nostra lista. Quindi, to-do list è questo qui. Adesso vediamo che cosa estenderemo tra un secondo. Internamente, andiamo a riprendere i dati. cosa faremo? Prenderemo la nostra do-do list tra questo e questo. La togliamo da qua, la mettiamo qui e stessa cosa vale per i metodi che modificano la lista. Questi qui non sono più solo stato, ma vivono al di fuori. Adesso potremmo finalmente dimenticarci dello stato dell'applicazione. lo sposto qui. Poi adesso li modifichiamo un attimo perché non va bene ancora così, però concettualmente ci arriviamo. Chitwitem va importato, black print va importato da widgets. Ok, statestate non esiste chiaramente, adesso vediamo come cambiamo. Ok, e nel frattempo prima di andare avanti cosa facciamo? convertiamo la homepage in un widget stateless finalmente, adesso diventa stateless, per cui quello che andiamo a cambiare è, questo diventa un consumer widget, ok, togliamo stateful, qui è un po' complicato di non cambiare tutte le cose, cioè complicato in realtà no, però togliamo questo, questo fa sì che my homepage non contenga più create state perché non ha più stato, quindi in realtà basta cancellare queste righe qui, attenzione a cosa cancellate, quindi la build diventerà parte della classe direttamente my homepage, perdiamo la classe my homepage state non serve più, quindi cancello queste righe qui e build diventa level right della classe consumer widget. Adesso a questo punto la forma qui è diversa perché qui nel parametro c'è widget ref, ref, ok. abbiamo perso una classe però è più pulito, adesso my homepage effettivamente è senza stato, cambiano alcune piccole cose, cambia che qui non è più widget title perché non c'è più questa doppia coppia, state e widget ma è tutto quanto dentro il singolo widget quindi questo non serve più e chiaramente non c'è più set state quindi questo qui non si può più fare, questo adesso la cancelliamo un attimo e cos'altro? Chiaramente tutta questa roba qui non funziona più perché tutto i items non ce l'abbiamo più diventerà un provider chiaramente e anche item non è più non è più legato a nulla vediamo un secondo come fare ritorno a bianuale adesso ancora non compila chiaramente adesso lo aggiustiamo sì è widget ref widget ref ref ok ok allora questo lasciamo un attimo sospeso torniamo alla nostra tutorialista chi siamo altra cosa che manca scusate anche lo uid non li generiamo più qui nel name in realtà li generiamo di là nella turist in questa cosa la togliamo non serve più questo pure lo mettiamo qua perché chiaramente adesso add item è qui dentro quindi non serve più al di fuori turiste tutto quanto è impacchettato qui dentro quindi anche a livello di scope di gestione dello stato chiaramente è molto più organizzato molto ripulito in questa maniera che abbiamo i widget da una parte e lo stato dall'altra ok ora come fa a funzionare questa cosa qui adesso questa to do list qui allora sulla carta noi potremmo lavorare potremmo immaginare di fare così facciamo un altro provider che si chiama final to do items provider per esempio potrebbe essere un state unifier non scrivetelo ancora questo è tutto dopo asullo cioè funzionerebbe anche però non è quello che vogliamo fare questo potrebbe ritornare una lista vuota di oggetti quindi questo e lo state unifier sarebbe uno state unifier di o meglio no sarebbe un to do list visto l'ho chiamata in quel modo quindi questo potrebbe tornare to do list e sì e cosa quale sì sì esatto esatto quindi l'idea è che questo qui questo che viene invocato una singola volta crea un oggetto base diciamo così e poi quando andiamo a modificare l'oggetto lo rimpiazziamo ok quindi l'idea è che se riusciamo a rimpiazzare la lista in realtà possiamo farla ancora più semplice se la to do list qui non vogliamo neanche crearla se usiamo il set of data potremo direttamente creare una lista può far così metterò un list di to do item addirittura se non mi piace chi è strato ah vabbè ho sbagliato in classe quindi è chiaro non funziona e sì questo chiaramente non si può fare in questi in questi termini quindi questo qui sarebbe un return di questo vabbè avete capito che sto cercando di fare litigando con con dart però questa è l'idea che voglio ok questa è l'idea quindi questo è uno set provider che come state interno ha non un interno una stringa ma una lista di to do item quindi potremmo utilizzarlo direttamente così con la difficoltà con la difficoltà cioè sta bene così solo che non posso ogni volta che andiamo a modificare la lista non abbiamo i metodi add item remove item e così via perché dobbiamo rimpiazzare l'intera lista ogni volta quindi da fuori se volessimo fare questa cosa qui da fuori di qui potremmo fare questa cosa come invece di fare add item in questa maniera qui dobbiamo fare esattamente come qui che dobbiamo fare ref read to do list provider l'ho chiamato giusto notifier mi sa che non l'ho chiamato in questa maniera ah to do items come? perché sono non perché adesso vogliamo aggiungere un elemento ammesso che usiamo il provider in questa maniera vogliamo modificare lo stato quindi qui facciamo state cosa possiamo fare qui andiamo a ricreare una nuova lista quindi qui dobbiamo creare una nuova lista di oggetti quindi quando usiamo state provider lo state provider è il provider più semplice che si possa avere cioè un provider che ha uno stato interno e noi abbiamo accesso a questa variabile qui possiamo modificarla rimpiazzarla quando vogliamo quello che facciamo con l'intero con l'intero diciamo così è ancora banale per cui va bene ci può star bene però se abbiamo uno stato di verità più complesso concettualmente potremmo fare questa operazione qui ma dovremmo implementare add item qui dentro cioè andremo a fare cosa? questa roba qui non è proprio ideale possiamo farlo ma non è bello quindi questa cosa qui la mettiamo qua la sintassica è andata però così e chiaramente per farlo vogliamo leggere prima i due item precedenti possiamo farlo chiaramente come cosa facendo mi sto comportando esattamente come sto facendo sopra con il contatore solo che adesso sto lavorando con anzi no non è vero questo era stavo usando il metodo per aggiungere elementi è per per switchare elementi in realtà voglio aggiungere un elemento quindi in realtà quello che andrei a fare è vado a metterci la lista di due items e poi creo un due item in modo ok vabbè id titolo forse vi torno come si tassi adesso lasciate perdere che è orribile però questo è cons ok altra cosa sintatticamente arcana questi tre punti qui vuol dire prendi l'array esistente infilalo nell'array cioè spalmato e poi aggiungi l'ultimo elemento qua sempre in esatto esatto per cui se facessimo così potremmo mettere l'oggetto in prima posizione esatto e poi qui segue cioè questo vuol dire apri l'array e impieguo dentro l'array per così com'è ok se non lo metto non funziona perché questo è un array di item quindi sto creando un array con due elementi di cui il secondo elemento è un array non è quello che voglio con i tre punti spacchetta l'array e lo mette dentro l'array che sto creando posso fare la stessa cosa a mano creandolo a mano ovviamente però così è più immediato quindi questo posso farlo tranquillamente e funzionerebbe cioè sulla carta per cui avrei questo to do add provider e lo posso tranquillamente gestire in questa maniera qui però non è ideale perché a me è bello avere una serie di metodi che danno accesso quindi permette di aggiungere impostare rimuovere e così via quindi per le metodi di gestione dello stato che voglio sfruttare in qualche modo per cui non useremo lo state provider ma useremo una cosa di ovviamente più sofisticato che è il state no lo state lo state notifier provider che è il modo di di di flutter per permetterci di implementare direttamente un oggetto che si può modificare da solo non so che mi spiego cioè qui se il provider il provider dà accesso all'intero che non ha le forze di modificarsi da solo all'intero non può fare molto e siamo noi a rimpiazzarlo da fuori quindi nel main che noi facciamo imposta l'intero cambialo e poi lo state notifier cioè il provider ci notifica se l'oggetto è più complesso di un intero ovviamente può implementare queste capacità di modificarsi di alterarsi e incapsulando queste capacità ed è quello che stiamo cercando di fare con la to-do list quindi nella to-do list non facciamo soltanto questa operazione qui che adesso stiamo aggiustando ma deriviamo da una classe che è lo state notifier che a sua volta che a sua volta espone un tipo quindi espone internamente il suo stato che cos'è? è lo stato questo quindi è list to do item una cosa abbastanza quindi questo oggetto qui lo perdo lo butto via to-do list non c'è più perché ci arriva tramite lo state notifier quindi state notifier è l'impacchettatore il gestore l'encapsulatore dello stato che include una list to do item perché internamente sto gestendo quello stato lì tant'è che qui non ce l'ho più non è più il campo della mia della mia classe ma è già qui dentro ok è come se per farvela per farvela lunga no qui scusate è come se state provider internamente contenesse una classe che non è altro che un int state notifier immaginiamo adesso non è importante farlo ma è come se questo anzi si può anche fare questa classe qui è una classe che internamente gestisce un intero ok è un int state notifier lo state provider non fa altro che crearvi uno state notifier quindi un notificatore di stato interno che gestisce in questo caso un intero e non avete bisogno di costruirlo se volete costruire da voi una classe che gestisce le modifiche di stato perché magari appunto mi saranno i metodi per raggiungerli rimuovere mettere le spunte e così via allora serve uno state provider che no serve uno uno state notifier che fa questa cosa qui per conto per conto quindi che incapsula un oggetto di questo tipo e poi finalmente espone questi metodi qui come ci chiamo la lista è nascosta e si chiama state state questo qui è la nostra lista ok cioè la lista ancora esiste ma è dentro state notifier a che serve questa cosa perché praticamente avendo questa proprietà state che possiamo andare a modificare possiamo reimplementare il set state cioè stiamo spostando tutto quello che era lo state full widget dentro il mondo magico dei provisor del set of fire però funziona nella stessa identica maniera cioè lo set of fire è il corrispettivo della classe stato della my home page uguale quindi prima avevamo my home page che aveva lo stato interno fatto da noi e poi c'erano vari metodi che alla fine andavamo a chiamare set state qui avendo la stessa cosa non facciamo set state ma facciamo cioè assegniamo a state quindi quando facciamo set state qui semplicemente andiamo a fare state uguale la lista di prima con l'aggiunto del new to do item quindi con la sintassi che ci ricordiamo cosa avviene facciamo punto punto punto state quello di prima e poi new to do item quindi questa è la nostra nuova lista ok quindi questo qui set state che prima è quello che facciamo prima lo cassiamo ok per cui quando andiamo a creare scusate a chiamare add item cosa avviene che noi andiamo a creare un oggetto e poi andiamo a rimpiazzare lo stato attenzione è un rimpiazzo stiamo modificando la lista questo è molto importante se facessi se facessi state punto add new to do item questo io lo potrei fare purtroppo però questo bello stiamo grande se modifico lo stato attuale questo non ha modo di notificare a cascata tutti quanti che lo stato modificato qui lo stato va rimpiazzato devo assegnare una nuova lista alla lista del che sto pacchettando a questo punto anche il set done viene abbastanza automatico perché è la stessa cosa ma lo facciamo direttamente non su to do items ma set state chiaramente non c'è più questo qui lo taglio così facciamo state uguale uguale questa roba e dove dove to do items chiaramente state di nuovo se state non c'è on dei él si esatto s esatto esatto un Si può fare in quel modo l'importante è che alla fine assegniamo una nuova lista. Quindi si potrebbe fare una lista d'appoggio. Se non volete districare con la sintassi arcana di Dart, vi conviene fare un array d'appoggio, create l'array e poi lo ripiazzate. Se no, bisogna implementarlo anche. Facciamo remove string id. Rimuoviamo il key item con il tal dettaglio, per cui creiamo uno state, che non è altro che lo state. Qui è carino usare il literabile. L'iterable di Dart ha una serie di simpatiche funzioni, metodi di accesso, che filtrano. Quindi c'è where, dovrebbe essere where, ci permette di prendere tutti gli elementi, per cui questa proprietà è vera. Per cui tutti gli elementi che non hanno quell'id, quindi sarebbe a dire element id diverso all'id, to list. Non so se è legibile, però se avete mai usato link u, link, sarebbe dire C sharp, questa... Si chiama link, ed è un modo per fare delle... come se fossero delle query a sequela, praticamente dentro il codice, per farla molto astratta. Quindi questa è come se fosse una where dentro... su tutta la lista degli elementi. Questo where qui ritorna un iterable, quindi un iterabile di to do item, che poi possiamo far diventare una lista. quindi qui prendiamo la lista originale, filtriamo gli elementi che non... cioè peschiamo tutti gli elementi che non hanno lo stesso id, quindi siamo effettivamente togliendo l'elemento con quell'id, e poi lo casciamo a lista. E questo è questo che rimpiazza. Tivo, allora, se per il suo nome dovessimo semplicemente muovere un elemento a un indice generico, potremmo fare state uguale state.remove... No, ah sì. Se facciamo state.remove... Se facciamo state.remove... Esatto, perché c'è remove at, che è il mezzo che useremmo per togliere l'elemento indexesimo dalla lista. Però attenzione, qui stiamo modificando lo state. Non è quello che vogliamo fare. Sì, potremmo fare questo. C'è il rischio grosso che state venga... perché modificare qualcosa che viene altrimenti utilizzato dall'interfaccia utente non è mai una buona idea. C'è il rischio abbastanza non secondario che qualcuno vada a facciare delle state in un istante e non trova l'elemento che dovrebbe esserci. Consideriamo sempre state come immutabile per risparmiarci dei mal di testa successivi. Quindi possiamo farlo, probabilmente funziona. Però non mi rischierete. Per cui, semmai farei una copia d'appoggio, farei remove at e poi la assegnare per essere sicuri che venga considerato immutabile. Cioè, praticamente, questo assegnamento qui deve essere... come si chiama? Atomico, per ricordare. Quindi deve essere un cambio atomico di stato che permette a Flutter di propagare tutte le giornate. Quindi, in ogni caso, è stato come hai usato una moda di dubbio. In caso di dubbio, esatto. Se hai fatto una copia esatta della stringa... della... lo dirò. La della... della... vista nuova. Che può essere anche una cosa del genere. Banalmente. Ok. Quindi questa è una vista nuova e a quel punto possiamo farci quello che vogliamo. Ups. Ok. Ok. Ok. Non so se vagamente qui ci siamo confusi tantissimo la vita perché purtroppo è fatto così, però immaginate che stiamo creando una classe che a tutti gli effetti è lo stato. È quello che era lo state prima dentro il witch, ma adesso è uno stato più nebuloso che vive da qualche parte. Vive dove? Dentro il provider. A questo punto manca il provider. quindi il provider non è uno state provider schietto perché è un po' più sofisticato di quello, è uno state modifier provider. Perché? Perché il nostro to-do list è uno state modifier. Quindi se abbiamo uno state modifier possiamo provideare e dare accesso direttamente a uno state modifier. quindi qui l'oggetto è uno state modifier provider. Qui spesso ci arriva da solo anche ci arriva anche Dart. Vediamo se è vero. Quindi ref bisogna inizializzarlo chiaramente. Quindi inizialmente la to-do list sarà vuota. Crea una to-do list vuota. va importata ovviamente ha ragione. Ok. Adesso vediamo se gli piace. A to-do list qui per essere costruita le serve. Questo viene dal fatto che il costruttore che è stato il notifier prevede che venga fornito lo stato iniziale alla nostra alla nostra istanza. Per cui qui dobbiamo fornire una istanza di list to-do item. Ok. E che viene fornita qui a super state. Super sarebbe la classe madre. Si dovrebbe essere vuoto. Quindi o lo mettiamo qui come vuoto direttamente così. Quindi tutte le adesso questo si arrabbia perché non conosce il tipo. Però è uguale oppure lo mettiamo qui. Quindi qui è più sensato farlo qui probabilmente. Mettiamo un array vuoto. Quindi stiamo creando una to-do list vuota inizialmente a meno che non vogliamo una to-do list che sia già pronta con qualcosa ovviamente. E stiamo inizializzando. Ok. Questo state to-do provider cosa fa? Ci dà accesso a to-do list che a sua volta è uno state to-doifier di che cosa? Di una lista di to-do item. Per farla proprio facile. Sono d'accordo. Purtroppo bisogna un po' entrare nella mentalità di farsi del male in questo caso. Però poi i vantaggi sono notevi. Se lo tolgo perché non serve a niente. Quindi cosa è successo? Avevo impacchettato lo stato. A questo punto possiamo usare questo to-do item provider ovunque nel nostro codice perché il nostro provider ce lo fornisce. Per cui nel main cosa avviene? Allora vengono una serie di cose. Cose spiacevoli. Allora to-do items qui non c'è più quindi tutti questi errori qui vanno aggiustati. Allora andiamo a farlo. To-do items length era la lunghezza della to-do item quindi cosa facciamo? Sappiamo che il provider ci dà accesso alla to-do list quindi cosa facciamo? Ref punto watch sempre perché attenzione bisogna fare watch perché vogliamo essere ricostruiti quando la lunghezza cambia cioè quando la lista cambia. Watch del to-do items provider questo ci dà accesso a cosa? A una lista vabbè questo va importato no perché non gli piace? Eh perché bisogna usare tutto il pro che è il slide non ah perché non capisce ok sì no ah ok non ha ok no non ha d'arte non ha capito di che tipo è questa roba qui anche se poteva arrivarci da solo quindi qui diamolo esplicito quindi questo provider qui vedete che la visto come to-do list di object quindi non sa che cosa ci torna da to-do list in realtà in realtà poteva arrivarci da solo perché questo è lo stato di list to-do item vabbè quindi è to-do list e ci ritorna una list di to-do item ok questo eh portiamo di nuovo lo faccio per chiarezza magari ve lo ripeto 27 volte ma non vi annoierete quindi l'idea è questa lo state notifier che incapsula che gestisce questo provider è un oggetto di tipo to-do list questo oggetto di to-do list è in realtà internamente ci espone uno stato che è di tipo list to-do item ok quindi l'oggetto di stato è list to-do item l'oggetto che lo gestisce è to-do list ok quindi questa è l'idea poi basta quello che ci serve gestire e fare chiaramente questi possono cambiare quindi a questo punto qui mi aspetto che finalmente qui capisca non è vero ok questo dovrebbe tornare quindi questo refwatch dovrebbe finalmente darmi accesso alla lista di to-do item è vero esatto quindi qui quando faccio punto a cosa sto accedendo a to-do no scusate sto accedendo a list to-do item non a to-do list qui ho accesso direttamente alla lista proprio quindi sto accedendo allo stato dello state notifier se come prima accedessi al notifier notifier se me lo lasciasse fare ah no qui scusate se accedessi al notifier di to-do item provider avrei accesso a to-do eh sì se avrei detto è uguale ho accesso stavolta all'istanza di to-do list vedete che c'è add item c'è remove c'è set done ci sono i metodi su to-do list quindi è il lo state notifier è l'oggetto questo è quello che notifica e giustisce che permette di modificare e così via eh lo il provider stesso in sé dà accesso all'oggetto incapsurato che è lo stato del notifier che è la to-do list per cui qui abbiamo accesso a length che è quello che volevamo fare ok quindi qui stessa cosa nel builder facciamo la stessa identica cosa soltanto che andiamo a accedere all'oggetto quindi qui cosa facciamo facciamo refwatch eccetera non più length ma elemento indexesimo identico questo funziona questa cosa qui a maggior ragione funziona qui sotto quindi ho tot cose da fare bisogna fare refwatch identico spiccicato tutte e tre questi oggetti qui fanno che cosa fanno fanno refwatch di to-do item provider visto che siamo comunque nello stesso build context quindi siamo comunque qui dentro l'unica cosa che avviene è che tutta questa build qui si lega a to-do item provider appena to-do item provider notifica che qualcosa è successo qualcosa è stato modificato tutti i widget dipendenti da quel provider vengono ricostruiti quindi la mia home page viene ricostruita appena si modifica lo stato quindi ho fatto un sacco di giri per fare quello che già facevamo con lo set-to provider per esempio il provider aveva la lista interna quando faceva la set-state si rigenerava e ricostruiva la sua interfaccia ho fatto dei giri per fare la stessa identica cosa però ci sono dei vantaggi che vedremo per un secondo se no non lo facevamo e l'ultima cosa che rimane da fare è agganciarci al pulsante che modifica lo stato qui qui lo facevamo in maniera brutale immaginando che lo stato che fosse uno state provider adesso è uno state notifier provider e possiamo fare delle cose un pochino più sofisticate quindi facciamo ref read del notifier e a questo punto abbiamo accesso a tutti i metodi di to-do list tra cui add qualcosa item e qui ci mettiamo y e ci mettiamo una descrizione ok quindi questo dovrebbe tornare ok se non ho fatto gli errori molto probabili di digitazione o altro se faccio rebuild qui dovremmo trovarci una condizione di prima in cui abbiamo una lista che cresce che viene modificata ah no adesso non si romperà perché non c'è più la la spunta la dosi ok quindi a questo punto il contatore funziona sempre meglio indipendente si riconosce da solo quando faccio più uno si riconosce tutto quanto anche i vari contatori chiaramente se non per il fatto che sono const quindi dovrebbero non farlo clicco vedete che adesso si sono aggiornati che cosa si è aggiornato qui ho uno cosa da fare perché parte di my home page si è aggiornato la lista perché sempre parte di my home page si è costruito il primo elemento ma il contatore non si è aggiornato quindi selettivamente il contatore sa che dipende dal contatore non dalla lista e quindi non è stato ripostruito anche se è figlio della stessa interfaccia se non facessi un contatore più uno solo con la lista non ce l'ha integrata esatto esatto quindi la lista non viene modificata perché cambia solo questo numero ed è quello che volevamo fare quindi la lista e il contatore sono due oggetti e se giornano in maniera selettiva andiamo ad aggiungere elementi qui questo si comporta esattamente come prima quindi non c'è non c'è nessuna non cambia cioè non cambia nulla però abbiamo ottimizzato questa cosa qui ora adesso facciamo l'ultimo passo poi è già ai tre quarti qui ed è già stato un marasma di cose brutte da imparare facciamo l'ultimo step che ci complica le vietanze ulteriormente ma è quello che è proprio il vantaggio il bello di un provider è che possiamo avere più provider scope di più livelli in cui vengono esposti provider con valori diversi ossia cosa voglio fare a questo punto per complicarmi la vita adesso io sto cioè il il to do list vive nella radice nel main e a cascata tutto questo qui dipende da questo to do item provider che può anche andare bene ovviamente però non è proprio ottimizzato perché adesso chiaramente ho tolto la capacità di mettere la spunta però immaginate che ci sia ancora io volevo che mettendo togliendo la spunta qui si cambiasse soltanto l'oggetto stesso non tutta la lista perché in effetti non riguarda la lista non devo ricostruire tutto quanto se cambio qualcosa di così così banale quello che faremo adesso è di spostare verso il basso un provider che fornisce soltanto un singolo elemento a i singoli oggetti qui nella lista ok per cui esatto ogni item quindi ogni to do item viewer andrà a leggere un singolo oggetto tramite un provider e ad ogni riga della list view forniremo un provider diverso ok adesso facendolo diventare più chiaro adesso to do item viewer sta leggendo l'oggetto perché glielo fornisco da fuori lo sto costruendo con l'oggetto che è una cosa che va bene ma lo rende molto coso dire statico ovviamente capiamo brevemente questa cosa e lo trasportiamo non so se salvare questo oggetto magari lo commento tutto e poi diciamo così commento così alla bisogno ce l'abbiamo ne crea una copia ok quello che facciamo è rendere il status widget un consumer widget come siamo abitati a fare quindi questo è molto facile consumer widget ok quindi cosa cambia anche la build qui abbiamo un'aggiunta per un widget ref ok a questo punto questo item qui lo togliamo lo perdiamo quindi l'oggetto non viene più dal nostro stato interno lo perdiamo proprio ciao mi anche questa mi piace questo perché ah no devo importare ok questo item qui non ce l'ho più quindi ok questo non ce l'ho più ok va bene come ottengo il mio item allora potrei fare in due modi in realtà o qui al to do item fornisco un intero fornisco un index e poi qui dentro proviamo a farlo un altro volo non fatelo è un esperimento se facessi in questa maniera qui qui dentro io potrei fare ref watch to do list come si chiama to item to do item provider ok e a questo punto avrei accesso alla lista e potrei potrei andare a accedere all'elemento indexesimo ok quindi qui farei item così e questo potrebbe funzionare ho ricostruito le cose di prima mi costruisco un indice tale perché non va ah perché punto ok e vado a leggere la lista globale e pesco l'elemento indexesimo e poi lo uso qui nel mio codice questo si può fare va benissimo dipendo comunque da to do item survivor quindi ogni volta che cambia questo oggetto qui vengo ricostruito quindi non è cambiato nulla da prima semplicemente vado non me lo passano da fuori mi passo solo l'indice che vado a usare per leggere dalla lista globale però non è cambiato nulla quindi questo item qui è esattamente lo stesso di prima e quindi questo watch qui è comunque troppo ampia cioè questa questa lettura qui è troppo grande tra virgolette non so mi sto ricostruendo con troppa frequenza perché dipende da un oggetto troppo complesso voglio dipendere da un singolo to do item per cui cosa facciamo allora dentro i nostri provider andiamo a creare un altro provider che chiamiamo current to do item provider che sarà sarà un provider notate che adesso posso usare il provider più più semplice quindi uso il provider questo qui quello costante quello immutabile ok perché non non deve essere modificato in effetti adesso un secondo diventa chiaro questo provider qui cosa espone to do item un'instanzio to do item e internamente può fare null per esempio in realtà questo non può farlo perché to do item non è nullabile quindi possiamo essere anche più brutal possiamo fare draw ok quindi questo è un provider che espone staticamente un to do item e di default quando viene costruito se accedo a questo provider senza che venga inizialmente in altro modo mi dà errore quindi provider pessimo da usare chiaramente però tra un secondo vediamo come usarlo questo provider qui espone l'elemento corrente concettualmente quindi in questo to do item viewer faccio riferimento a quel costruttore lì a quel provider lì quindi tolgo l'index non mi serve più tolgo questo non mi serve più tolgo questo non mi serve più perché il mio item a questo punto che cos'è rf.watch di che cosa del current to do item questo ritorna un to do item giusto? ricordate è fisso chiaramente se adesso lascia tutto così questo esplode subito questo questo corrent to do item provider non ho fatto che tirare un'eccezione quindi chiaramente non è molto utile però ok quando andiamo a costruire l'interfaccia non forniamo più l'oggetto direttamente cioè non costruiamo più il to do item viewer direttamente con l'oggetto perché non c'è più costruttore quindi non si può più fare andiamo a fare a modificare ovviamente qui il costruttore alla builder scusate così ok perché qui dentro posso creare un secondo provider scope e qui dentro quindi di base a questo tra l'altro è const giusto adesso devo fornire a questo giusto qui un un valore tramite il provider current to do item provider come si fa? creo un provider scope che lo ingloba wrapped with widget il widget è provider scope ed è ripetate il provider è il provider scope il primo widget che avevamo è questo provider scope quindi è una copia di questo provider scope che come va nei suoi vari parametri a modo di definire degli override h server per eccolo quindi prendo qui praticamente posso specificare una lista di provider il cui valore voglio sovrascrivere per cui per farvi un esempio questo vale per tutti i provider tutti i provider che ho se non li sovrascrivo vale il valore del provider appena sopra ok quindi a cascata li posso sovrascrivere esatto che a sua volta sarà cioè lo faccio così sovrascrivo e qui c'è override with value qui qui forniamo il valore con cui stiamo sovrascrivendo che valore è? è il valore di prima quindi è esattamente quella cosa che ho appena tagliato se ce l'ho ancora non ce l'ho più ah va bene si esatto questa roba qui facciamo così vabbè per farla per farla si si può fare in maniera ripulita facciamo in maniera orribile leggo la lista e fornisco al mio oggetto l'elemento indexesimo non so se è chiaro cioè probabilmente no perché sarebbe stato se lo fosse però quindi il current to do item provider di default non ha nessun valore no? quindi esplode e basta però se fornisco un provider più dettagliato più in basso nella mia gerarchia tutti i widget sotto a questo provider scope quando vado a leggere il current to do item provider hanno accesso a un altro valore quindi non è quello quel provider non esplode ma ritorna un oggetto fisso che è questo oggetto qui super per vedere se tutto non direi che in questo momento se stiamo in dettagli ogni elemento della lista che andiamo a costruire sarà allo scopo in provider scope con effettivamente il nostro cliente di campo esatto dove nella lista di overwrite del provider scope diciamo questo provider qui in questo provider questo scopo qual è il nostro scopo? esatto esatto in quello scope il provider tali e tali non vale come vale per tutti gli altri sopra ma vale un valore specifico che è questo che ho appena pescato dalla lista per cui non si dovrebbe fare il prodotto del set esatto l'idea è esattamente quella per cui adesso ancora non cambia nulla per cui stiamo facendo le cose iterativamente per cui adesso ancora il comportamento è lo stesso però adesso peschiamo cioè i singoli valori qui dentro vengono letti tramite un provider non più forniti al costruttore ma ogni singolo elemento qui dentro va a leggere il proprio oggetto tramite il provider chiaramente non lo vediamo a tanto sono tutti uguali quindi in realtà adesso magari interrompiamo perché sono già le una però la cosa che magari farò prima di ripresentarci la prossima volta è variare il titolo e la descrizione in modo tale da avere una visione del fatto che sono tutti oggetti diversi se no è un po' inutile e soprattutto a quel punto adesso l'ultimo step sarà ottimizzare questa cosa e avere i singoli oggetti che si aggiornano soltanto quando effettivamente un oggetto viene modificato ok quindi a cascata il fatto che stiamo creando dei problemi per esempio più piccoli e più specifici ci permette di leggere soltanto quando qualcosa viene modificato e avere notifica del fatto che quello che ci interessa è cambiato ma tutto il resto se cambia non ci interessa ok questo vale per il contatore è molto banale per cosa è un'altra cosa per ciao mondo è ancora più banale perché quella è una stringa fissa però ecco per esempio ciao mondo questo è un altro esempio che possiamo fare proprio al volissimo prima di chiudere se qui metto la stessa cosa qui un provider scope che fa l'override questo è un esempio abbastanza banale ma abbastanza chiaro se sapessi scrivere provider scope qui posso metterci l'override del greeting eccetera greeting provider dovrebbe essere operato i due value e ci metto ciao quello che vogliamo tutto questo non funziona più perché non è più const ovviamente così ok a questo punto adesso non è molto utile però questa stringa qui sarà ciao non sarà ciao mondo perché c'è un provider scope che lo sovrascrive quindi questo widget qui ha un'altra visione di quel provider lì di una parte vediamo ok questo è sempre molto stupido però a cascata vale per tutti quindi in realtà se volete che ne so cambiare il colore per un sottoalbero dei vostri widget potete farlo con un provider se volete cambiare delle string che sono sempre quelle potete fornire con un provider così via l'idea è di avere tanti provider quante sono gli oggetti effettivamente che vi serve avere così molto specifici nella vostra interfaccia prego ok ok vuole usare dei nodali per scrivere solo per il 27 e non per nessuna questa versione sì, è uno scenario ancora più complesso, se volessimo, però se i singoli widget sono molto costosi da costruire, potrebbe per esempio sì, sì, sì un esempio, se sono dei dati magari questa è la cifra è un buon esempio in realtà, perché se sono dei dati che non sono ancora disponibili, per esempio dovete scaricarli da Tenor o insomma i provider di cifra è un classico esempio in cui può aver senso fare così cioè potremmo avere dei widget che mostrano una cifra, un'azione qualcosa di sofisticato che viene scaricato lo fanno con un provider lo vedremo la prossima volta o quella dopo ancora forse è un future provider, quindi un provider che vi dà accesso a qualcosa che non è ancora esistente, quindi per esempio una cifra scaricata dalla rete in attesa di quello appena il provider ha scaricato la cifra, il vostro widget può rappresentarla, però nel frattempo rimane in attesa che quel provider diventi valorizzato e quindi è stato il problema lo scenario è esattamente quello quindi lei magari ha una interfaccia molto vasta con 8000 riquadri, non ancora pronti perché devono scaricare dalla rete qualcosa e lì usiamo un future provider che vi dà accesso in futuro a qualcosa che sta ancora essendo valorizzato quindi in caso la cifra scaricata o centralizzata e così via però questo è sì, lo faremo scaricando proprio delle immagini la cifra è una variante di questa idea che va benissimo quindi in ogni caso ogni volta che voi dovete in qualche modo avere un widget che dipende da un dato sia esso molto semplice come un intero sia esso molto complesso come una cifra scaricare quindi molto costoso da ottenere potete immaginare un provider che vi dà accesso a quello stato ok? quindi l'idea è proprio quella esattamente come prima ragionavamo in termini di stato mettendo lo stato in qualche parte dell'albero dei nostri widget adesso ragioniamo in modo tale da avere una serie di provider che vengono accesso a quello stato in maniera più piccola possibile cioè ogni provider dovrebbe occuparsi da un singolo elemento concettuale della nostra applicazione più provider lo avete più siete in grado di leggere soprattutto quello che interessa se avete un singolo provider con tutti i dati della vostra applicazione chiaramente diventa molto complesso leggere solo quello che interessa più riuscite ad andare nel piccolo meglio sarà il vostro la performance e la vostra applicazione in base ok immagino che ancora tutto molto nebuloso adesso vi aggiungo un po' l'applicazione così da far funzionare alcune cose meglio ve la carico su Blended spero prima di giovedì prossimo così intanto potete dare un'occhiata e poi giovedì facciamo le ultime operazioni di ottimizzazione sulla lista proprio e a quel punto abbiamo RiverPod più chiaro assolutamente a quel punto siete in grado di lavorarci in maniera spero profonda vi auguro un buon weekend senza provider e senza riprodottoved