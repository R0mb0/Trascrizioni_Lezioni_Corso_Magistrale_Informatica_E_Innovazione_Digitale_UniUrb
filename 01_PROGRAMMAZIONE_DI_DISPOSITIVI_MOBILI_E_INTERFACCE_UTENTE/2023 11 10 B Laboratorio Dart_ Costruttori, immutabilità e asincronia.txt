Allora, giusto per rivedere un secondino questa cosa che abbiamo fatto di corsa poco fa di là. Ci sono vari modi con cui possiamo specificare i parametri di un metodo, e questo vale anche per i costruttori, chiaramente in Dart. Quello più classico è quello posizionale, che è assomiglia a quello che abbiamo abituale, chiaramente. Si possono anche mettere dei parametri posizionali opzionali, quindi con un valore default che dovrebbe prendere opzionali. In questa maniera qui il parametro è opzionale ed ha un valore di default, quindi questo altro qui è poi specificato come se c'è, ha un valore che può essere specificato da fuori. Se non c'è, vale zero. Questo da fuori ha questo aspetto qui. Verticalmente, quindi qui posso passare un parametro o due parametri su entrambi i legali. Se questo manca, il secondo parametro vale zero. Ok, quindi in questa maniera è opzionale, ma comunque posizionale, posizionale perché l'altro sarà sempre in seconda posizione. e nell'altra sintassi ancora, quella con le grafiche, usiamo invece la sintassi nominale, quindi i parametri hanno un nome e noi nel costruttore dobbiamo specificare il nome dei parametri. Facciamo questi sintassi qui. Questo ci permette di riorganizzare i nomi e l'ordine come ci pare e piace. Questo è praticamente rilevante poi se abbiamo appunto molti parametri. E in più possiamo specificare alcuni parametri come opzionali. O meglio, quando usiamo la sintassi nominale, sono tutti opzionali in genere se sono nullabili, o comunque se hanno valore di default. Se invece vogliamo che un parametro sia obbligatorio, possiamo scriverci require. Se non ci mettiamo require, possiamo metterci un valore di default, quantomeno. Ok, quindi anche questo... Questa è un'altra possibilità. Ok, quindi molti modi per fare le stesse cose, bene o male. E va bene così. Ora, per chiudere questa cosa sui costruttori, la cosa a cui volevo arrivare è il vantaggio vero di questa immutabilità. Allora, il primo vantaggio più banale è quello di avere una classe che non può essere ulteriormente modificata, perché una volta che un punto lo otteniamo, siamo sicuri che quei valori non cambieranno più. E quindi, in particolare, questo è rilevante nella costruzione dell'interfaccia utente, perché in quello scenario spesso ne facciamo operazioni con tanti dati che ci arrivano e dobbiamo passare i dati ad altri oggetti, ad altre finestre, ad altri widget, ad altri controlli e così via, che devono in qualche modo rappresentarli a schermo. Se siamo sicuri che quei punti, quelle classi non vanno mutate, possiamo che... Ci possiamo. Chi implementa l'interfaccia utente può fare delle ottimizzazioni, per esempio. Però, quindi, se sappiamo che il punto non cambia mai più, per esempio, una volta che l'abbiamo presentato a schermo e abbiamo presentato quindi la coordinata X e la coordinata Y, sappiamo che finché il punto non viene sostituito da un altro punto, non dovremo mai andare a rirenderizzare, a ripresentare l'interfaccia a schermo. Quindi, se ragioniamo in termini di Win32, se in termini è lì, per esempio, se il punto non può cambiare, fin tanto che non viene proprio rimpiazzato, per esempio, non dobbiamo invalidare l'interfaccia e ridipingere la nostra finestra per fare un parallelo con quello che già conosciamo con Win32. poi la stessa cosa chiaramente varrà anche per Flapper. Quindi questo è il vantaggio numero uno. L'altro vantaggio è che se un punto, se una classe è immutabile, può diventare anche costante a tempo di... cioè costante in termini proprio di codice. per cui possiamo far diventare il punto non soltanto final, final già è un buon punto di partenza perché impedisce, no? al... cioè ci impedisce di ridichiarare, riassegnare la variabile. però con dei punti veramente immutabili possiamo trasformarli in dei punti costanti. Quindi a questo punto potremmo ambire ad avere dei punti const, piuttosto che final. Ok? Questa cosa ancora non è possibile, accanto male. Ok? C'è un errore. Perché il costruttore non è un const constructor. però adesso faremo assolutamente quello. Cioè renderemo il costruttore di immutable point un const constructor, ossia un costruttore che può generare degli oggetti che non soltanto sono immutabili, ma sono proprio costanti a tempo di immobilazione. Sappiamo come sono fatti e non possono più essere alterati in alcun modo. Per fare questo in realtà la cosa è abbastanza facile perché basta mettere un const davanti al costruttore. Questa cosa, quindi, cioè, questo era molto facile, quindi è quasi un po' troppo magico, quasi. Perché possiamo farlo questo qui? Perché possiamo rendere il costruttore di immutable point const? Perché il costruttore sa che tutto quello che lui sta assegnando qui dentro effettivamente è immutabile. Quindi qui dentro il costruttore fa una verifica interna e dice ok, i underscore x underscore y sono effettivamente dei campi final, quindi io posso rendere il costruttore immutable point e poi posso rendere un const const construttore, quindi un costruttore che crea un oggetto che a quel punto è proprio inscalfibile, indistruttibile, imperituro, eccetera, eccetera. Adesso che a questo punto questa istanza di immutable point non la posso cambiare neanche con la violenza perché una volta che x e y sono impostati sono inalterabili, ok? Quindi il costruttore ci dà garanzia del fatto che non possiamo cambiarlo. Questo in realtà vale per tutti i costruttori, quindi in realtà posso aggiungere const a tutti quanti costruttori. però volendo, cioè, è concettualmente possibile avere costruttori const e costruttori non const, anche se non ha molto... Ah, ecco, per esempio questo è un caso in cui non posso farlo. Ok, questo è un buon punto. Perché in questo caso mi arriva un oggetto che non è noto a tempo di costruzione, a tempo di compilazione, perché qui sto creando un punto sulla base di un altro punto che mi serve da ispirazione, cioè da copia, diciamo così, per cui il compilatore a tempo di compilazione non saprà come è fatto questo punto del point, o meglio, non saprà che interi contiene, come x e y, per cui, di conseguenza, il punto che sto costruendo non può essere const, perché il punto di ingresso potrebbe essere qualsiasi cosa. Ok? Per cui questi due costruttori qui è un buon esempio, in realtà, di due costruttori che non sono const e tre costruttori che invece sono const. Perché? Perché in questi tre costruttori qui io so a tempo di compilazione chi è y, chi è x, chi è altro, se c'è, perché è già nel codice. Ok? Per cui il costruttore, o meglio, il compilatore, a tempo di compilazione può vedere tutta la trafila di costruzione e vedere, ok, questo punto viene generato con x impostato a 10 e y impostato a 20, per cui lo posso creare soltanto una singola volta perché effettivamente non è costante. Ok? Non so se è ovviamente chiaro. Quindi sull'altro lato, a questo punto, questo può rimanere final come prima e non c'è nulla di male. Però visto che y e x sono entrambi delle costanti, perché sono dei letterari, quindi questo è zero perché vale sempre zero, non è uno zero pescato da dinamico, insomma, uno zero costante, per cui anche il punto sarà costante. Ok? Che vantaggi ci dà? Così sulla carta non molti, in realtà, sembrerebbe, però in realtà c'è un vantaggio fondamentale che è dato da una cosa molto specifica di Dart che è la canonizzazione delle variabili o delle costanti. Che cos'è la canonizzazione? La canonizzazione è un processo per cui il compilatore e in realtà anche il runtime, perché si aiuta la vicenda, ha una lista, diciamo così, generale di tutte le istanze costanti di una variabile e se io costruisco due volte la stessa variabile costante con gli stessi parametri e a tempo di combinazione ho la garanzia che siano identici, allora neanche li costruisco, cioè è proprio la stessa istanza. Esempio di questa cosa, anzi facciamolo sotto magari, quindi lasciamo così il codice qui inalterato così non ci cambia nulla, facciamo la verifica qui sotto. Qui facciamo la verifica di eguaglianza dei vari punti. Ok, rifacciamola. Quindi rifacciamo queste cose qui. Questa non serve niente. Facciamo una cosa molto simile. Quindi qui io creo due punti, questa volta sono degli immutable points invece. Ok, e qui faccio quello 0 e 10, qui è verticale 10 che comunque è sempre 0 e 10, no? Quindi qui veramente sarà la stessa cosa, devo cambiare il nome se non funziona. Mi stampo. Qui non sono final ma sono const. Ok. E a questo punto qui devo cambiare un po' di nome. Ok. Proviamo a compilare questa cosa qui e vediamo cosa ne esce. Quindi sorprendente. Allora, quando lavoravo con P1, questi sono i punti non immutabili, quindi punti immutabili. Noi quindi ne avevamo creati due, non sono... Vabbè, questo è un'altra cosa, non è niente. P1 non è mai uguale a 1, questo vale anche per gli immutabili, chiaramente. Potremmo anche portarlo via. Quindi P1 uguale a P2 sono uguali. Ma perché sono uguali? Perché abbiamo ridefinito l'operatore d'equaglianza, quindi esegue l'operatore d'equaglianza e vede che 0 e 10 sono equivalenti, quindi questo è ricordato. P1 però non è identico a P2 perché sono due variabili distinti. Quindi P2 e P1 sono due variabili di classe point, ma non sono la stessa. E poi se modifico P2, chiaramente poi non sono più uguali. E vabbè. Quando sono immutabili, vedete che I1 sempre non è uguale a I2, ma I1 è uguale a I2 perché l'operatore d'equaglianza è sempre lo stesso. L'ho definito? Ah no, infatti, magia. Non l'ho neanche dovuto definire l'operatore d'equaglianza. Quindi in MoodlePoint mi ero dimenticato di aggiungere questo oggetto qui, quindi questo operatore d'equaglianza non è neanche reimplementato, qui non c'è, però c'ho un di meno, I1 è uguale a I2, non solo, I1 è identico a I2 addirittura, nel senso che proprio a tempo di combinazione questi due oggetti, sebbene siano due variabili, I1 e I2, costruiti con due costruttori diversi, uno fatto con Cores, l'altro fatto con Vertical, questo oggetto, questa chiamata qui ritorna true, perché il compilatore è stato in grado di capire, a tempo di combinazione, che questo oggetto qui in realtà sarà sempre uguale all'altro, perché non può essere modificato. E quindi chiaramente perché allogarne due? Allogo uno, I2 e I1 appunto hanno la stessa variabile, a tempo di combinazione. E questa è la grande, diciamo così, magia di Dart che da quanto personalmente so nessun altro linguaggio fa in questa forma, a quanto so, poi magari è vero, però altri linguaggi esoterici magari lo fanno, però questa è una cosa molto particolare, che si sfrutta poi in Flutter per ottimizzare la nostra interfaccia utente. Però è una cosa abbastanza poco intuitiva, se uno viene da altri linguaggi a programmazione, perché ci sospetterebbe che questi oggetti costruiti in migliore separata, grazie a const diventano lo stesso oggetto. Attenzione che ci sono una serie di condizioni perché questo funzioni chiaramente, per cui tutti i parametri devono essere costanti a tempo di combinazione, quindi qui devono essere dei numeri già noti, qui non possiamo metterci nulla che venga generato dal programma runtime, chiaramente che altrimenti non è più const. Chiaramente possono esserci delle piccole... cioè questo dovrebbe ancora funzionare perché è un'espressione che può essere gestita dal compilatore della sua semplicità, quindi questo dovrebbe funzionare uguale. Ok, quindi questo torna ancora true perché ce la fa. Se facciamo cose completamente più sofisticate non funzionano, se qui ci mettiamo la radice quadrata di o la potenza di eccetera, quello non funziona più perché dipende dalla chiamata funzione che chiaramente il compilatore non può eseguire a tempo di compilazione. E tra l'altro vi dà errore proprio il compilatore, cioè se qui ci metto qualcosa... Ah, un esempio buono è... Questa roba qui dovrebbe darci 10, in teoria, quindi floor di 10.1 è... Ah, a parte quella deve portare... Non ti chiamaflora. Allora, quindi qui ci dà l'errore che questa... a parte che si, devo portarle in qualche modo... Vabbè, non lo sto trovando, non è importante. Comunque queste operazioni qui non sono costanti per cui non posso... Cioè questo qui diventa dinamico e non posso chiamare costore cons, costore cons, quindi questa cons qui non è più valido. Posso comunque renderlo final. Quindi questo... Questo va bene. A questo punto perdo i vantaggi di prima. Quindi se... Sono 10... Quindi questo è ancora costante. Posso chiamare un costruttore const, quindi questo è un costruttore const... Ok, questo è un cost... Ok, questo è un cost... Ma non definire come const le variabili, in questo caso sto perdendo i vantaggi della costitudine della nostra variabile. In questo caso torneranno a false. Vedete qui, quindi i 1 e i 2 non sono più uguali, perché a questo punto sono due istanze separate che però valgono la stessa cosa. Ok, adesso chiaramente potrei aggiustare livellemente questa cosa andando a... implementare l'uguaglianza anche per il new world point, che avrebbe senso. Proprio vedete che finché non implemento l'operatore di uguaglianza, Dart utilizzava l'operatore di... di identicità, giusto? Quindi andava specificamente a verificare che il punto fosse identico. Ok, adesso sovrascrivo anche questo punto, questo... questa... questa funzione qui. Ah, grazie, il sostegno... Giusto, Floor è un'operazione sul double, quindi l'idea era questa. Facciamola. Quindi era questa l'idea. Ok, così ha più senso. Allora, ritorniamo all'interno, quindi questo qui in teoria... anzi, questo funziona, quindi questo qui è... questo comunque è 10, giusto? Quindi questa cosa funziona. Ok, quindi è come prima, sono true, perché comunque Floor ci abbassa a 10 il valore, ma questo non può diventare const, perché chiaramente quell'operazione lì non riesce a farla costante. Anche se chiaramente Floor è un'operazione abbastanza banale, però il compilatore non può... non può eseguirla. Ok, quindi deve essere proprio un dato costante a tempo di compilazione molto semplice. Possiamo anche combinare const e non const, però la... diciamo così, la cosa funziona soltanto se entrambi sono const, chiaramente. Quindi se entrambi sono const, chiaramente punteranno alla stessa istanza e quindi identical sarà true. Se anche soltanto uno dei due non è const, chiaramente sono due istanze separati. Quindi i1 identico i2, mi aspetto che sia sempre false, ok? Nonostante poi sono uguali al livello di valore. Ok, spero che sia vagamente chiaro. Questo può essere un po' mistico, quindi ci sta a essere un po'... Chiedersi il perché e il per come. Ok, però ci tornerà molto utile poi quando andremo a creare l'interfaccia utente, perché con questo trucco, diciamo così, dell'accuso... come dire, questo escamotage degli oggetti const, riusciamo a aggiornare in maniera puntuale la nostra interfaccia utente, andando ad aggiornare soltanto ciò che effettivamente cambia, grazie alla immutabilità degli oggetti. Se la nostra interfaccia utente è costituita da tutti oggetti che sono immutabili, immaginate, no, di avere... immaginate che tutte le finestre che hanno creato con iWii32 fossero potenzialmente immutabili, come const. Quindi immaginate che potessimo creare delle... delle fine dei pulsanti che sono const. Se sono const, chiaramente possiamo ridisegnarli soltanto quando vengono rimpiazzati interamente, cioè quando l'istanza è effettivamente in inenza. Con questo trucco, Flutter riesce a... selezivamente aggiornare i componenti specifici dell'interfaccia utente senza andare a ridipingere interamente la schermata. Ok, allora questo direi che conclude per male il discorso su Dart. L'ultima cosa che devo dirvi è giusto su Async e su Await. Quindi, come tutti i linguaggi moderni, Dart supporta la programmazione asincrona, quindi l'idea che si possono esprimere dei valori che non esistono ancora ma che prendono corpo in futuro. Ok, quindi l'idea di poter... così aspettare che il valore venga ottenuto in qualche modo. Questa cosa come si fa in Dart? si fa con... cioè si esprime con un oggetto che si chiama Future. Quindi oggetto Future è una classe di base del runtime di Dart che esprime un valore che ancora non esiste. Quindi è un valore che noi possiamo metterci in attesa che venga valorizzato in qualche modo. All'atto pratico cosa significa? Significa che, per esempio, se abbiamo un metodo che va a, come so, cercarne la rete delle informazioni, cercando di legge dei file, fa delle operazioni complesse internamente e quant'altro, magari può generare una stringa, no? con del tempo. Ok. In questo caso la restringa che ritorna sarà sempre il nostro periamato Ciao Mond ovviamente. però qui internamente se noi segnaliamo, marchiamo questo metodo come asynchro, lo facciamo aggiungendo async in fondo alla specifica stranamente, quindi qui, se conoscete C Sharp, avrete già visto async messo qua. in data si mette qua. Ok? Si mette dopo i parametri. Questo segnala al compilatore che questo metodo qui è un metodo asynchro, quindi internamente fa delle cose che richiedono del tempo e quindi possiamo metterci in attesa che questo metodo completi le sue operazioni. Adesso questo in realtà non è vero, quindi al momento questo metodo in realtà è un metodo asynchro, quindi il metodo che ritorna subito c'è un punto, però c'è un doje che possiamo comunque trasformarlo in metodo asynchro. Quindi questi sono due metodi equivalenti, quindi generate string sync, invece lo chiamo così e questo fa return ciao mondo. A parte che ho scritto male, ciao. Ok, quindi sono esattamente identici due metodi. Uno è sincrono, questo viene invocato e ritorna subito la stringa. Questo invece è asynchro perché viene invocato, il compilatore sa che è asynchro, poi è vero che torna subito ciao mondo, però in questo ciao mondo questa stringa viene comunque rappresentata come un oggetto che viene popolato nel futuro. Ok? Internamente non c'è nulla da attendere in realtà, però il compilatore questo non lo sa, si fida il fatto che noi lo facciamo in maniera asynchro. Per cui qui dentro possiamo fare le... possiamo chiamare entrambi i metodi alla stessa maniera. Quindi facciamo... Ciao, scusi, sync... Beh, forse così non è tanto chiaro. Facciamo... mettiamo qui la scritta. Sync async, quindi qui dentro nel main possiamo mettere print generate string sync. Ok? Questo la chiamiamo come un metodo tradizionale, quindi chiamiamo al metodo, questo ritorna una stringa e la passiamo a print, e finché va bene. Per la stringa asynchro la si può chiamare come un metodo classico, quindi generare string async, va bene. Anzi, facciamolo perché questo si può comunque... funziona, quindi possiamo chiamarlo. Ok, ora se andiamo a vedere dove siamo qui... Vedete che la prima chiamata ci ha ritornato una stringa direttamente che è sync ciao mondo. La seconda operazione invece ci ha ritornato un'istanza di future string, quindi quello che stiamo stampando qui, questa print qui, non stampa la stringa, ma stampa un'istanza magica, mistica, questo future di string. Questo future di string è un oggetto astratto che noi sappiamo che potrà diventare una stringa a tutto punto, però ovviamente non lo è, quindi è un oggetto che incapsula una stringa che in futuro potrà essere una stringa. Come si fa ad accedere a questa stringa a prenderla? Beh, bisogna aspettare che la stringa diventi valida, ovviamente, no? Quindi bisogna in qualche modo fare una wait di questo oggetto, perché i future possono diventare veri, cioè valorizzati, diventare valorizzati in un momento qualsiasi, quindi bisogna aspettare che lo diventino. Come si fa a fare questa cosa qui? Si fa con un'altra keyword che si chiama await. Con la keyword await, ecco, cosa facciamo? Await è una keyword che prende un'espressione a destra che deve essere un'espressione di tipo future, di qualsiasi tipo. Quindi possiamo fare await di un future di stringa, un future di tero, un future di double, un future di qualsiasi oggetto, chiaramente. In questo caso ho il future di stringa, tant'è che il... vedete che il tipo di questa await è string. Ok, notate che, visto che await viene applicato a un future di string, questo future di string, await ritorna una string. Quindi, a questo punto, questa print qui non stampa più l'oggetto future di string, ma stampa l'oggetto string, perché in quel momento avrà... quella future sarà stata aspettata e sarà stata trasformata in una stringa vera e vera. Questa await qui non è ancora legale perché si può aspettare per un valore soltanto in un metodo che è asincrone al suo stesso. L'asincronia, come si dice, è virale, si dice, o comunque è... in qualche modo è contagiosa, da virgolette, nel senso che per poter chiamare un metodo asincrono il metodo in cui ci troviamo deve essere a sua volta asincrono. Ok, perché la await va a cascata, quindi appena dobbiamo aspettare per un valore che attendiamo, dobbiamo poterci mettere in attesa di quel valore. Per cui, una volta che è iniziata a utilizzare metodi asincroni, dovete avere in partenza un metodo asincrono che vi permette di aspettare in primo luogo. Per cui, se lavorate in asincrono, a un certo punto, nel caso più reclatante, diciamo così, anche il metodo main deve diventare asincrono. Per cui adesso lo marchiamo in asincrono, il che significa che però il metodo main asincrono non può tornare un in, ovviamente. deve tornare un future di in. Perché anche quello, a quel punto, avviene un po' duro. Ok? Adesso non mi spiego. Cioè, se il nostro main dipende da cosa asincrono, chiaramente anche lui diventa asincrono agli occhi di chi lo chiama. Chi lo chiama il nostro main lo chiama il runtime. Per il runtime si può aspettare un main asincrono o un main sincrono, poi si comporterà di conseguenza. Però in questo caso il nostro main stesso diventa asincrono e il runtime, quando andrà a invocarci, farà await del nostro main. A cascata noi faremo await di questa stringa qui. Poi, ovviamente questa await qui non aspetta niente in realtà, che questa stringa qui è già pronta in realtà. Quindi stiamo facendo await di così tanto per sport, per virgolette. Però il risultato finale è che abbiamo due valori. Uno è generato in maniera sincrona e l'altro è generato in maniera asincrona. Ecco qui, quindi c'è async ciao mondo. Async ciao mondo. Ora, come detto, questa async qui non ha alcun senso, quindi non aggiunge molto. Però chiaramente al suo interno potrebbe fare delle operazioni veramente asincroni. Come per esempio la await più banale che si possa fare è mettersi in attesa di qualcosa. e Future ha un metodo che si chiama delayed che ci permette di creare un piccolo delay artificiale, quindi un'attesa. È come se fosse una sleep in C per dire. Solo che una sleep asincrona chiaramente. Quindi questo è un delay. Delay prende in input un oggetto di tipo duration. E qui vedete che duration, il caso vuole, che è uno dei classici oggetti di Dart con 3000 parametri. Diamo un'occhiata un attimo. Perché è un costruttore molto complesso. Vedete che è un costruttore con tanti parametri opzionali, tutti nominali. Quindi possiamo esprimere la durata con giorni, ore eccetera eccetera. Sono tutti a zero e tutti opzionali. Vedete che poi alla fine tutto viene ridotto a microsecondi con delle operazioni di moltiplicazione. Però il costruttore ci dà un'interfaccia carina per esprimere la durata che dobbiamo aspettare. Quindi qui duration, possiamo esprimere in vari modi e possiamo scegliere qual è il parametro che ci sente. Quindi in questo caso voglio aspettare per secondo. Ok? Quindi questa di lei qui ci ritorna un future di Dynamic perché in realtà è un future di nulla. Quindi è un future che aspetta un qualcosa, aspetta del tempo, tre secondi e poi va avanti. Allora, qui se non avete mai lavorato con la sincronia, anche qui è un come cost, è una cosa un po' mistica da accettare e da capire quello che succede. Quello che accade in pratica è che, visto che tutto è asincrono a questo punto, il nostro main stesso è asincrono, che cosa accade in pratica? Accade che il runtime va a invocare il nostro main. Il nostro main è asincrono per cui va avanti finché rimane asincrono. Poi qui si blocca. Perché si blocca? Perché questa qui deve fare una wait su questa stringa qui, su questo metodo qui. Questo metodo qui è un metodo asincrono per cui chiaramente internamente può essere composto da una serie di altre await, per cui il metodo comincia a eseguire, si blocca sulla prima await. A questo punto il runtime riceve di nuovo il controllo in realtà e rimane in attesa di questa delay qui. Appena il delay conclude, il runtime riprende da dove? Da questo punto qui. Nel frattempo poteva aver eseguito altro codice chiaramente, in parallelo, se avesse avuto l'occasione di farlo in questo caso. Non ce l'ha perché non ci sono altre esecuzioni parallele, però sulla carta poteva fare dell'altro. Riprende da qui, a questo punto la stringa è pronta, ritorna. Questo feature qui diventa una stringa effettiva, viene tornata a questa await qui, e a questo punto la stringa viene passata alla print. Poi è ancora asincrono, perché il resto del metodo viene eseguito in maniera asincrona, finché non arriva all'ultima istruzione, che è il ritorno in zero, che dà valore a questo feature di tipo int. Questo qui. Ok? A quel punto il nostro main asincrona ha concluso e a quel punto il runtime può tirare giù tutta l'applicazione. Però cambia proprio il modo di operare. Non è un singolo thread che entra ad esempio asincrona tutto quanto, è un thread che si blocca step by step su tutta la await che incontra in maniera ad albero. Quindi se la nostra await attende ad albero, veramente ad albero si fanno varie attese finché l'ultima attesa non viene conclusa. Ok? Questa è un po' l'idea. Per cui eseguendo questo codice qui, adesso vedremo che grazie alla await il nostro codice si bloccherà per tre secondi prima di darci asincrona. Ok? Siamo in attesa. Siamo in attesa sia qui, ok? Quindi la await qui è bloccata, sia qui. Giusto? Ok? Perché la await è proprio a cascata. Per cui questa await qui è in attesa di un valore future che deve essere ancora generato. Finché questo valore che non viene popolato, questa print qui non viene eseguita. Allora, se non aspettassimo, guardate cosa accade, si tolgo la await qui, è un metodo comunque legale, però non aspetta più nulla. Quindi questa future qui viene comunque eseguita, adesso la rendo un po' più lunga perché è più visibile, aspetta dieci secondi. Però questo metodo qui, pur essendo asincrono, non lo aspetta. Va asperito direttamente, va avanti. Per cui a questo punto, non essendoci questa await qui, questa await qui ritorna subito. Questa non ha nulla da aspettare. Per cui questa await torna subito la stringa. Che cosa accade in questo caso? Accade che andiamo subito dritti e il future delayed però esiste, cioè viene eseguito. Quindi c'è questo feature qui che deve essere ancora popolato. Vedete che a questo punto il nostro programma aspetterà in coda. Quindi adesso avrà subito fatto tutto. Ok. Adesso non sto terminando. Sto aspettando che l'altro, il future delayed di dieci secondi termini. Quindi questa cosa che viene ancora eseguita. Tra qualche secondo termina. Ok. Quindi comunque esegue subito il return. Esatto, esegue subito il return. Esatto, esegue il return. Perché questo return qui non dipende da nulla che sia awaitato. Awaitato è un termine italiano però. Ok. Quindi questa è un po' l'idea. Ah, tra l'altro, per esempio, un altro esempio. Adesso il future delayed è un esempio un po' costruito perché è un po' senza senso. che non è molto utile. Però quali sono casi l'uso veri delle await? Tutte quelle operazioni che richiedono tempo, quindi possono essere lunghe. l'accesso ai file, l'accesso ai database, l'accesso alla rete, operazioni che dipendono dall'utente. Quindi se l'utente deve cliccare... Questo vuoi avere un flutter. Se dovevo fare una finestra di dialogo che aspetta che l'utente clicchi su ok, per esempio. Quello si fa come un future perché praticamente il dialogo aspetta che l'utente clicchi su qualcosa e quando clicca quel future, quindi la risposta del nostro dialogo, diventa vero perché finalmente l'utente ha cliccato. Quindi la future può essere sia qualcosa... C'è un ritardo puramente così astratto e generato da noi in qualche modo, sia un ritardo effettivo perché dobbiamo aspettare che l'hard disk si svegli e vada a pescare un file. Questo magari possiamo anche farlo. Quindi magari facciamo un file. File. File è una... della libreria Dart.io. Dart.io è in tutte le operazioni di inputato di base, è un po' come standard.io di C. Qui gli passiamo un qualcosa. Questo qui magari. Ok, bene. Passo il percorso assoluto. Chiaramente va un po' massaggiato. Può essere un file qualsiasi. Per far prima carico il file del file della cartella stessa. Ok, quindi questo è un puntatore a un file X del nostro file system. D'altro non so anche se c'è qualcosa da dentro. Vabbè, molto poco. Quindi ci metterà poco a leggere. Allora, l'oggetto file ha una serie di operazioni che può fare. Quindi possiamo coprire file, creare file, scacciare le file, verificare che il file esiste e così via. Tutte le operazioni di base sono asincrone. Quindi vedete che vanno sempre in coppia per comodità. Quindi copy e asincrono. Non c'è l'intelligence, ma... Vedete che è future di file, eccetera eccetera. Quindi di base vi suggerisce. È ovvio che conviene fare una versione asincrona perché vi permette di fare altre cose in parallelo, se volete. In questo caso magari vogliamo leggere il file. Quindi bisogna fare read string. Questo legge l'intero file, poi ritorna come stringa. E lo fa in maniera asincrona. Perché questa cosa qui ritorna a future di string, vedete. Quindi magari facciamo final, anzi const, contents. Non posso farlo ovviamente perché dipende dal runtime. Così. Ok, e contents magari possiamo incollarlo qui in maniera digitale. Ok, quindi sto leggendo quello che deve fare, lo studio sto appiccicando qui dentro. E a questo punto effettivamente il ritorno, quindi quello che sto tornando da questo metodo qui, è dinamico. Cioè dipende da qualcosa che sto aspettando. Ok, quindi questa... Anzi qui ho sbagliato. Questa qui è una sync, non sto aspettando. Quindi qui in realtà sto stampando il future di nuovo. Una varietta ovviamente. Per cui ora aspetterò tre secondi. Dopo aver aspettato tre secondi carico il file e lo butto dentro la stringa. A questo punto se tutto torna, dovrebbe stamparmi i contenuti del readme. Se non ho fatto errori di altro genere. Cioè aspetta tre secondi, chiaramente quello lo fa perché sono in sincrono. E a questo punto mi stampa il file. O meglio, cioè lo ritorna alla stringa. Quindi questo feature qui conterrà il contenuto del file. Questo vale ovviamente per il file, vale a maggior ragione per il database. E vale un po' per tutto. Quindi vale anche altre molte altre classi e pacchetti aggiuntive così via di Flutter che andremo utilizzare. Ovviamente espongono dei metodi asincroni perché chiaramente dipendono da una serie di operazioni che il dispositivo deve fare. che vanno attese. Quindi anche questo è importante tenerlo andando. Adesso questo è molto simile a quello che avviene in C Sharp e in altre linguaggi. E anche nel moderno JavaScript che ha la stessa... stesso concetto di future, però se come si chiama? Non lo ricordo. In C Sharp, se conoscete, l'oggetto future si chiama task. In task però si è promise. Promise, grazie. Esatto. Quindi la task sono le promesse di qualcosa che verrà valorizzato. Però quindi è una promessa che in futuro diventerà vera. Ok? È lo stesso concetto in vari modi diversi. Ok, a questo punto direi che l'abbiamo veramente finito. Per cui possiamo chiudere la cosa con Dart. Secondo me ci sono mille cose che non vi ho detto in dettaglio, però... Sì. Ma è multi-thread come... Ah, questo è un punto. Non è multi-thread come altri linguaggi. È un po' stranino Dart. Perché di base parte col concetto che ci sia un singolo thread attivo alla volta. Quindi è un multi-threading, più multitasking organizzato dal runtime. Quindi tipo JavaScript però. In che caso? In JavaScript. Sì, JavaScript è single thread perché vive nel browser dove il thread di JavaScript è soltanto un thread per forza. Quindi JavaScript è un po' perché il runtime è limitato. e Dart nasce un po' con la stessa idea. Per cui il thread è sempre uno, di solito. E quindi in realtà quando facciamo delle await, è come se... Cosa vuol dire? È come se internamente il runtime avesse uno scheduler, come se fosse un semplorativo internamente e si giostrasse i vari future di volte in front. Cioè, è sempre lo stesso flusso di adeguzione? Sì, è solo un flusso di adeguzione che inizia col main qui, entra qui e poi viene fermato a più riprese con le await. E poi è un flusso di adeguzione per esempio? Noi possiamo fare più future per esempio. Perché allora la cosa importante a ricordare è che... Allora, sì, tutto molto... Diventa complesso perché va a toccare tanti argomenti. Allora, read a string, per esempio, che è un esempio abbastanza banale, che legge il file internamente. Chiaramente passa attraverso tutto il runtime di Dart che farà questa read a string come vorrà farla internamente lui. Ma alla fine dei conti va a parlare con le Win32, essendo noi su Windows. E quindi andrà a fare un'operazione che è read file, alla fine, che è l'operazione di default per la lettura, che se il runtime Dart è implementato bene, e ovviamente lo è, andrà a fare una lettura asincrona usando le Win32. Quindi quella lettura lì è asincrona perché dipende dal sistema operativo. Quindi aspetta che il sistema operativo vada a fare una lettura e segnali al runtime Dart di aver completato. Quindi sulla carta lì stiamo delegando l'attesa al sistema operativo. Quindi chiaramente noi in parallelo potremmo fare tante altre cose, mentre il sistema operativo fa questa lettura. Cioè non stiamo occupando del thread. Il thread è in pausa perché attende, però in realtà in parallelo potrebbe fare tante altre cose sulla carta. Qui in questo caso non avviene, però se noi vogliamo, un esempio più concreto, noi possiamo, eccolo, possiamo metterci in attesa di una serie di futuri, oggetti oggetti future. Ah, se lo facciamo, quindi qui non faccio la wait singolo, quindi questo è final future finto, e questo è final future file. Ok? Non faccio la wait, però, quindi questi sono oggetti di tipo future. Quindi questo è future nullo e questo è future stringa. a questo punto posso fare future wait e passo un array di future, che sono future finto e future file. così, ok. Così, ok. E questo wait, questo oggetto qui, eh, si è diventa molto complicato, questo wait qui, gli passiamo una lista di future e esso stesso è un future di liste di risultati. quindi questo possiamo fare da me. Aspettiamo la somma dei futuri. Quindi questo qui termina soltanto quando tutti hanno concluso. Chiaramente, read a string ci metterà molto meno di tre secondi, quindi l'attesa complessiva sarà da tre secondi. Però sulla carta, insomma, non sappiamo in che ordine del termine, no? Quindi qui, quando usciamo da qui siamo sicuri che entrambi hanno finito e quindi possiamo accedere ai risultati di future file. Quindi cosa possiamo farlo? Così, credo, se ricordo bene. Ah no, non è così, possiamo fare direttamente, devo accedere a quei risultati. Non è proprio meglio, eh, però si può fare. Results 1, che dovrebbe essere future file, e questo dovrebbe essere il tipo string. Cioè, non lo sappiamo però, vedete che ovviamente il future weight non può, cioè è su un tipo t che è il tipo di base, quindi il primo non ritorna niente, il secondo ritorna una stringa, quindi risults ritorna una lista di dynamic, quindi lista di oggetto, e siamo noi a sapere che questa sarà una stringa. Quindi questo posso anche castarlo per essere proprio esplicito, ma non è necessario. però comunque, mentre noi aspettiamo appunto che lo finito nel frusel file, nessuno non vieta di poter fare un altro dato. Certo, sì sì, noi infatti potrei fare un... Cioè, qui con questo thread no. Cioè quando faccio la wait il thread è effettivamente bloccato, cioè sta aspettando, perché non ha altro da fare. Se voglio fare qualcosa in parallelo posso farlo creando un altro metodo che è asincrono, e poi... E away do anche quello. E quello magari fate le operazioni, eccetera, eccetera, però deve delegarlo a qualcosa che lo fa in background. Allora, per fare questa cosa qui bisogna usare... Lo dirò... Lo dirò... Lo dirò... Lo dirò... Lo dirò... Lo dirò... Lo dirò... Se possiamo mettere... Per esempio si crea un altro feature, se si fa un intercambio, la sua data non va in più, il nostro punto è in più, nella vista su quello che fa, che potrebbe creare. Sì, no, è che per avere un thread parallelo di esecuzione bisogna fare dei make-age in più, che adesso non ricordo straordinario come si fa, purtroppo. Perché si fa raramente in realtà, nel senso che comunque la maggior parte dei casi, poi quando si lavora con Flutter... Non ricordo se era molto più semplice per qui. Però se volete ci guardiamo un attimo nella documentazione, perché c'era un momento... No, no, però è giusto. Ah, è questo. Ah, è questo. Ok, sì, scusate. Ok, era molto più banale di questo. Ok, ecco questo. Future di qualcosa... Ah, giusto, giusto. Mi fanno notare un'altra cosa. Allora, per fare qualcosa in parallelo, si fa con questo... con il costruttore di base, al quale bisogna passare una funzione. Come vedete qui questa sintassi un po' oscura. Questa è una funzione generica che non prende parametri e ritorna nulla. Ok? Quando la dichiaro così... Cioè, la sintassi non è bella, ma è quella. Quindi questo oggetto qui... Aiuto. E qui faccio delle operazioni matematiche impossibili, che ci mettono la vita a completare, che sono, abbiamo tutti i numeri primi, per esempio, che voglio avere. E questo qui è un future, quindi questo qui è... Ok, questo future mio posso aspettarlo qui. Questo... Questo viene eseguito in parallelo a questo punto. E questo è codice... Tanto questo è codice sincrono. Quindi questa cosa qui è sincrona, perché non è asincrona. Cioè, non dipende da altre cose asincroni. Questo è un codice... Cioè, proprio, che ne so, è un loop infinito che fa da... Qualcosa di estremamente complesso, ma che era questo termine. Comunque in nanosecondo, però era per dire. Quindi, ok? Quindi qui faccio delle operazioni complesse. Questo qui viene in maniera sincrona, ma a questo punto viene in parallelo con le altre. Scusi? Una funzione vuota, in senso che sarebbe diverso da... Lo scrivo meglio qui. Allora, ciò qui... Lo scrivo qui. L'operazione lenta. Ok, questa è la sintassi... Così scrivo un metodo che fa cose complesse. Così. E quindi qui dentro ha... Questo era solo per dichiararlo direttamente dentro il Fusion. Però in realtà qui posso passare la funzione. Operazione... Questo non lo rispette a... Non ho capito. In questo modo, questa operazione... La farei in parallelo, esatto. Esatto, esatto. Quindi abbiamo tre... Tre... Come si può dire? Tre rami di attesa. Uno che aspetta, semplicemente che scade un timer. Uno che legge da file, e poi qui dipende dal seno operativo che apre il file, legge il file, carica i dati, eccetera, eccetera. E poi questa cosa qui che è completamente astratta, che è invece un'operazione che noi facciamo nella CPU. Nella CPU, noi quindi il thread, il nostro thread di esecuzione, andrà a eseguire in parallelo a queste altre due operazioni. Quindi addirittura è in relazione di due porti. Sì. Sì, sì, sì, esatto. Per cui, internamente, Dart ha un pool di thread che può utilizzare. Ah. In realtà sarà sempre lo stesso thread, ma stranamente. Questo thread... Sì, esatto. Sì, esatto. Nascondo un po' di cose per semplicare. Cioè noi, in Dart, per nostra fortuna, non avremmo mai bisogno di usare i thread veramente. E questo ci permette di fare delle cose complesse senza andare a farci del male, come è molto facile fare con i thread. Per cui quello che avviene è che sarà sempre, comunque sempre, un solo thread in realtà in esecuzione. Perché delayed non ha bisogno di impegnare un thread. Perché è un'attesa col timer. Quindi lo fa... Il runtime per noi, c'è un timer che scatta due tre secondi e riprende l'esecuzione. Non c'è bisogno di avere un ciclo infinito che aspetta del secondo. Il file, come dicevo, poi dipende dal securativo che gli passa i dati. Questa operazione qui, invece, questa qui, ha bisogno di un thread. Questa fa delle operazioni matematiche... Matematiche, comunque quello che è, insomma. In CPU questo va assegnato un thread. Per cui, mentre aspettiamo qui, il nostro thread, l'unico che noi abbiamo attivo, farà questa operazione qui, mentre altri si occupano di questa cosa qui. Alla fine dei conti, finalmente, dopo la wait, siamo sicuri che abbiamo completato. Giustamente, vi dicevano nella chat che c'è un'altra cosa che è utile, in effetti. Perché qui noi stiamo aspettando in parallelo. Quindi abbiamo lanciato 3 future in parallelo e aspettiamo che tutti concludano. In alcuni scenari può essere utile concatenare degli await. e questo, in realtà, lo facevamo già prima. Cioè, se non... Un attimo, come facciamo fare questa cosa qui? Cioè, prima ne facevamo prima await di questo e dopo await di questa. Allora, facciamo... Facciamo le cose del bene. Quindi questa è l'attesa parallela, come se immaginate da un circuito elettrico, è come se avessero altri fili separati. Questo, invece, è quello... come si chiama? Serie? Seriale? Seriale? Non lo so. E qui aspettiamo uno per volta i vari future. await. Await. Await. In questa cosa, chiaramente, questa await qui generica non ci serve più. Ok? E questi future qui non sono più future, ma sono proprio i risultati direttamente. Che cambia un po' la sintassi, la semantica. Questo poi, in realtà, essendo un delay, non ricordo nulla. Questo commento non torna nulla. E questo è direttamente il contenuto. Vi spiego. Cioè, se faccio la await, quello mi ritorna il contenuto della Fusion giustamente. Non devo andare a gestire la lista di risultati, eccetera, eccetera. Questo è un po' più complesso a livello di sintassi, però questa await qui aspetta tutti e tre i futuri, e poi ci ritorna una lista dei risultati. Ah, altra cosa. Chiaramente i futuri possono anche esplodere, cioè possono creare delle eccezioni, quindi una delle tre può fallire. Se una fallisce, tutta la await fallisce. Ok? Quindi basta un fallimento e questo propaga in questo modo. Ok. E qui, chiaramente, essendo in cascata, questi si aspettano a vicenda. Quindi prima aspetto per secondi, poi leggo il file, poi faccio questa cosa qui e poi ritorno. Quindi l'attesa è la somma. Qui l'attesa è il massimo tra le tre future. In più, appunto, posso anche concatenare dei futuri, a figurette, a livello proprio di oggetti. Per cui potrei, per esempio, se voglio che... Aspetta, che cosa potrebbe per senso fare? Non lo so. Vabbè, comunque se voglio appiccicare un altro oggetto qui a future mio... Future mio dopo. Posso prendere future mio, che è già una future, e usare then, che è una funzione che riceve il valore generato da future mio. E qui dentro posso fare dell'altro. E qui... Vabbè, magari posso... Future mio dopo è un future di string a questo punto. Qui, se in tassi, posso immaginare che non sia proprio leggibilissima. Però, quindi, future mio è un oggetto future che esegue l'operazione lenta, che ritorna void, in realtà. Quindi questo future mio è un future di void, ok? Su questo oggetto che bisogna fare? Then. Questo qui value è void, perché future mio è... Ritorno a void, chiaramente. Quindi questo che viene, verrà seguito in cascata dopo future mio ha completato. E usando value, in questo caso usare value non ha molto senso, perché è void, quindi non può essere utilizzato. Però comunque, se avessimo un intero potremmo utilizzarlo. Torno al risultato. A questo punto abbiamo un future che in realtà è un future di un altro future, ok? Quindi è in cascata. Cioè, in questi casi, secondo me, possiamo andare sia il then che la wait. Sì. Qual è il pericolo? Qual è il pericolo di usare la wait resta con then? Allora, la wait, finiamo una colgolette, tutto procedurato, adesso in then, non siamo... E, beh, nella maggior parte dei casi la wait è più chiaro ed è sintaticamente anche più bello da leggere. Anzi, qui è più chiaro cosa stiamo facendo, stiamo aspettando le varie operazioni e così via. Il then è utile se voi ricevete un Q setta qualcun altro, mettiamo che una libreria generi un qualcosa, e voi volete agganciarci dietro un'operazione che viene fatta in cascata su quello. Quindi con il then potete esprimere l'attesa che segue un'operazione che è stata fatta, espressa da qualcun altro, magari. In questo caso, se voi potessi collegere un file da file system e poi, non vanno in franze, potremmo fare un... Sì, esatto. Un doverbo. Esatto. Potremmo fare questa cosa qui. Quindi questa then qui vale e poi, appunto, il future file è uno future che è la combinazione tra read a string e poi il then che ci ho appicciccato dentro. Ok, quindi, in realtà, con il then si possono fare varie operazioni più o meno complesse sisteticamente, però, a lato pratico, è equivalente a un metodo async che fa le cose con i vari await. Quindi, sempre esprime la serenità. Però è il... Diciamo così. La await in un metodo async è il costrutto del linguaggio che vi permette di esprimere delle operazioni fatte in serie, con l'attesa. Then è il costrutto del runtime, che quindi è l'oggetto di un runtime che permette di farlo a oggetti, in sostanza. Però, all'atto pratico, è più o meno lo stesso. Async e await sono dei... Così, è sempre, alla fine, il zucchero sintattico del compilatore che vi permette di fare le cose con più grazia. Ma potremmo fare tutto quanto con le then. Infatti, anche nel chat mi stanno dicendo, giustamente, che volendo possiamo rendere il metodo main non asincrono e poi fare tutto quanto con le then. No? In realtà. Quindi si può fare tranquillamente anche questo. Sono abbastanza equivalenti. Ok. Ma qui, chiaramente, con la sync ci si può intrecciare abbastanza con facilità, però noi lo useremo giusto, in alcuni casi, per operazioni su file, operazioni con le librerie che vanno ad interagire col sistema. Quindi non è che lo useremo chissà quanto. E quindi con un uso più o meno puntuale. Chiaramente quando l'interfaccia utente diventa asincrona, c'è un grado di complessità adottivo che non è da sottovalutare. Ok. Chiudo qui e passo, cioè passiamo a Flapper finalmente. Per cui per nostra comunità interrompo la restrazione così poi abbiamo dei file separati. non è un file separato. Grazie. Grazie. Grazie.