Quindi questo è il pacchetto che vi ho caricato poco fa su Blender, se volete lo potete scaricare. C'è tutto il pacchetto, eccetto la cartella binz, per cui dovrebbe essere abbastanza leggero, e se tutto torna, se tutto funziona, se lanciate flat run dalla cartella, cioè dalla root del progetto, in teoria dovrebbe partire e avere un aspetto gradevolissimo come questo, in sostanza. E, diciamo così, l'ho un po' ripulito nel rendere più evidente quello che abbiamo fatto in queste ultime lezioni, per cui giusto per, ci perdo un'altra dieci minuti, giusto per andare proprio nel dettaglio e fissare le cose, per essere sicuri di essere tutti insieme, in qualche modo, nel punto d'arrivo, perché abbiamo fatto varie cose diverse, cioè simili, ma in modi diversi. Quindi intanto abbiamo visto, fondamentalmente abbiamo sempre creato dei piccoli widget, gruppi di widget in realtà, assemblando altri widget. È una cosa che in genere in Flutter si fa molto spesso, quando si vanno a creare delle interfacce più sofisticate, raramente si va a dipingere sullo schermo direttamente, come abbiamo fatto con le widget 32, cioè non capiterà quasi mai di dover andare a cambiare pixel per pixel, quello che avviene e viene presentato a schermo, in genere si prendono dei widget già precostruiti, e si mettono insieme e si assemblano. Quindi quello che abbiamo fatto noi in questo caso, assemblando in una riga, abbiamo messo insieme un text sinistra, un colore qualsiasi, dentro un oggetto che è un container in realtà, e poi un text destra, e questo in varie stats. Abbiamo visto come si comporta. Più o meno qui l'unica cosa che ho fatto è, li ho resi un pochino più evidenti, andando a impacchettare i vari oggetti, le varie modalità di sviluppo che avevano utilizzato, dentro questi blocchi, non praticamente belli dell'estetico, però funzionali, e questo lo vedremo tra un secondo in dettaglio, però li ho messi dentro un container con una serie di proprietà strane che danno questo aspetto finale, che appunto è quello che volevamo, insomma, per suddividere i pezzi di interfaccia. Allora, tutta questa interfaccia qui vive all'interno di un main, cioè di una material app, ovviamente, con cui fondamentalmente il primo widget che incontriamo è questa material app, che come abbiamo visto brevemente insieme, fa una serie di cose, ma la cosa che fa è che espone un tema, quindi in qualche modo definisce qual è il tema dell'applicazione e poi lo propaga a tutti i widget sostanti. Che cosa significa in pratica? Significa che quando andiamo a creare una material app, andiamo a creare un pacchetto theme data che possiamo costruire in vari modi. Adesso in realtà ne vediamo soltanto uno, che è quello classico, diciamo così, che viene utilizzato e viene uscito anche da Flutter stesso, quindi con questo color scheme from seed diamo un colore fondamentale del tema e poi a partire da questo in automatico Flutter e, cioè seguendo le regole del material design versione 3, crea una serie di colori che verranno sfruttati da vari altri sottoli widget, come per esempio lo sfondo, il pulsante e così via. Il resto dell'applicazione vive tutta quanta dentro a Homepage, che è un widget stateful che ha dello stato interno, abbastanza piccolo, quindi ha un contatore e un colore. Quindi fondamentalmente lo stato dell'applicazione a livello più alto, quindi quello che noi consideriamo stato, cioè app state, quindi stato dell'applicazione in generale, sono queste due variabili. Chiaramente è uno scenario molto semplificato, però immaginate che qui possiamo avere vari altri oggetti e tra un istante è un progetto in cui questi due oggetti sono lievemente più sofisticati. Però non cambia fondamentalmente l'idea, ossia se abbiamo un'applicazione complessa, in alto, molto vicino alla radice dei nostri widget, ovviamente avremo un oggetto, un componente che è comunque un widget, ovviamente che ha dello stato interno e questo stato racchiude tutte le informazioni che vengono poi propagate verso il basso degli altri widget di cui è fatta la nostra interfaccia. Qui appunto è un intero, è un colore, ma potrebbe essere qualsiasi cosa. Come si propagano queste cose? Quello, diciamo così, è una delle difficoltà maggiore di programmare in Flutter e decidere come propagare queste informazioni. Cioè queste informazioni vivono da qualche parte nel nostro albero di widget, però devono arrivare nelle foglie e come farlo? Lì è tutta la difficoltà in sostanza. Non lo vedremo oggi, ma da domani a questo punto lo facciamo con RiverPod, che è una soluzione alternativa che sfrutta una libreria non ufficiale, cioè di terza parte, ma è come se fosse ufficiale di Flutter, per cui è abbastanza comune. Esistono varie altre soluzioni, però RiverPod è quella che abbiamo anche, che è molto comune, molto utilizzata, per cui la vedremo insieme. chiaramente poi nel vostro progetto potete usare lo stile che preferite, per cui se non volete appoggiarvi a nessuna libreria esterna, come RiverPod appunto, potete fare esattamente così. Cioè avete, a un certo punto avete uno set for widget nella vostra gerarchia dei widget e quello widget che contiene il vostro stato, fine, e quando andate a modificare questo stato qui, ovviamente qualcuno da qualche parte farà set state, andrà a modificare lo stato e a quel punto la vostra applicazione si ricostruirà interamente. Ok? Quindi fondamentalmente se volete sfruttare i fondamenti di Flutter proprio, potete fare in questa maniera e non c'è nulla di mare. Quando andate a ottimizzare il vostro alberto widget per impedire che tutto l'altro si ricostruisca a cascata appena cambia qualcosa di molto piccolo come il contatore, in questo caso, in genere in Flutter quello che si fa è si inseriscono degli elementi che sono const. Il trucco è inserire questi elementi const che hanno la proprietà di non ricostruirsi perché sono sempre uguali. Ok? Quindi se riuscite a definire degli oggetti che sono effettivamente const nel vostro alberto voi avete la certezza che Flutter non li ricostruirà. Un esempio di questo è il nostro questo container qui, quindi il primo container che incontriamo che è questo colore fisso qui. l'idea è che se riusciamo a impacchettare e fiocchettare questo container qui in un widget a sé stante e renderlo const allora siamo sicuri che Flutter non lo ricostruirà perché non c'è bisogno. Questo non avviene qui, questo colore fisso verde, questo qui, viene ricostruito ad ogni ricostruzione, a ogni rebuild di home page. Quindi home page quando viene ricostruita perché viene fatto, viene invocato state, viene richiamato build di home page, questo è inevitabile, cioè se lavorate con lo stato di un widget, con un central widget, chiaramente quando fate set state, la build viene invocata per forza, non c'è scampo da questo e quindi fin tanto che questo oggetto qui vive qui dentro verrà ricostruito forzatamente, ok? Per cui quando Flutter invoca build è obbligato a seguire tutto questo codice qui, questo codice viene eseguito nonostante questi siano degli oggetti const, comunque vengono ricostruiti dal metodo build, ok? Quindi questa costruzione qui, questo oggetto qua, che corrisponde a questo blocco qua, colore fisso, sinistra, destra, verde, questo viene ricostruito, poi è vero che continua alcuni elementi che sono const, però non cambia la sostanza, ok? Perché bisogna comunque ricostruirlo. Il trucco per renderlo non ricostruibile è tirarlo fuori, cioè renderlo un widget a se stante. Questo non l'ho fatto qui nel codice, ma se volete sperimentare, questo lo potete tagliare, ovviamente se lo potete prendere un widget vostro che si chiama il mio widget verde immutabile, ok? Che è stateless widget, chiaramente, e a quel punto quel widget lì, se lo dichiarate come const, semplicemente non verrà mai ricostruito perché è sempre la stessa istanza e non verrà mai fatto build perché è già costruito, ok? Non serve ricostruirlo perché Flutter riceverà l'istanza dall'albero, visto che comunque nulla che contiene può essere cambiato, quindi il colore è verde e rimarrà verde intanto che quel widget esiste. Può essere, scusi? Può essere eliminato? Sì, sì, questo sì, allora, esatto, questo si potrebbe fare volendo, quindi per esempio lo può non mettere nell'albero, sì, esatto, per esempio, ok, adesso non è const, quindi non, cioè, adesso cambia poco, però se noi rendessimo opzionale questo widget qui dentro, per esempio, possiamo fare anche come counter, la variabile, ricordo, la sintesi c'era, sì, ni, la sintesi un po', ok, questa sintesi che è molto arcana, è solo perché Dart viene di, così, è molto tollerante da questo punto di vista, questo stiamo mettendo un if, cioè un costruzzo di condizioni direttamente nel codice di costruzione, quindi è una cosa un po' che, un po' contornatura, da regoletti, se vogliamo, però, nel senso che qui bisogna essere veramente sicuri di non sbagliare, perché questo if qui si applica al widget subito dopo, il rischio di errore qui è elevatissimo, questo punto, perché passa a scambiare qualcosa e la cosa non funziona, però in questo caso, quello che avviene è che, se ricostruisco, quell'oggetto compare e scompare in base al contatore, se è pari o meno, e quindi l'oggetto adesso, ovviamente viene sempre costruito, quindi non ci si guadagna nulla, però se fosse un widget const, anche se compare e scompare, il widget in sé non vorrebbe ricostruito, ok? Sì, lo nascondiamo, nel senso non lo mettiamo nell'agro proprio, quindi, ah sì, giusto, una cosa da, attenzione a questa cosa, cioè qui stiamo ricostruendo l'agro interamente, se qui counter è pari, il container non compare proprio nella lista, quindi non è, è un po' diverso rispetto a rendere invisibile o rendere non visualizzato un oggetto come si farebbe, per esempio, in HTML e CSS, se siete avviati per il mondo lì, quindi magari l'oggetto ce l'avete nel vostro agro, no, nel DOM, cosiddetto, nel documento HTML è presente l'oggetto, il div, ma lo potete nascondere con CSS, questa è una cosa che si fa classicamente, però l'oggetto esiste comunque, qui lo stiamo proprio non aggiungendo all'altro, quindi l'oggetto non viene aggiunto all'altro, quindi non esiste proprio, ok, quindi non può neanche reagire ai click, non può fare alcunché, semplicemente bisogna condizionare il fatto che l'oggetto sia presente o meno, però questo in Flutter si fa di solito così, nel senso che poi vedremo altri esempi in cui costruiremo la nostra interfaccia utente, esattamente in questa maniera, cioè condizionando la presenza di uno, di un widget o un altro, sulla base di alcune proprietà del nostro stato, quindi questa è una cosa che si fa, e scriverlo in questa maniera qui non è mai una buona idea, per cui vi dicevo, questa si può fare, perché è legale in Dart, però se lo volete fare è meglio, se lo estraete, lo rendete magari una funzione, a parte che ritorna il widget o meno, in base ad alcune proprietà e così via, mettono nel codice così, è veramente molto rischioso. Rischioso non che accada nulla di praticamente brutto, però il rischio di applicare questo if ad altri widget non sotto la container è abbastanza elevato. Ok, poi faccio breve qui, quest'altro blocco qui dipende dal tema, per cui abbiamo visto che c'è questo pattern masterclassico, per cui se sappiamo che nell'albero in cui ci troviamo, di widget, esiste una variabile che viene propagata, quindi quello che classicamente è implementato come un inherited widget, quindi widget ereditato, in Flutter, questo se ne fa un largo uso in vari widget standard, uno di questi è il tema chiaramente, quindi in virtù del fatto che questo container qui, e tutto questo blocco qui si trova all'interno di un contesto, quindi un build context, dove andando su, verso gli avi, i trisavoli e così via, compare un material app, visto che c'è questa cosa qui, visto che siamo sicuri che il material app esista, che parte tra gli avi, allora possiamo fare theme.off, perché qualcuno, quindi material app in particolare, ci fornirà il theme data. Qui è, questo è un pattern classico, per cui si usa abbastanza comunemente, però anche questo è rischioso tra molte virgolette, perché se non c'è un widget che ci fornisce il tema, questa chiamata qui, chiaramente potrebbe tranquillamente esplodere, ok? Per cui qui dobbiamo essere sicuri, che questo oggetto qui si trovi all'interno di una gerarchia, in cui sia presente un tema. Se non c'è, chiaramente a runtime, questa cosa qui non funziona, e vi ritorna un tema vuoto. Questo legare a riga colorata al tema, fa sì che tutto questo blocco qui, venga ricostruito quando il tema cambia, quindi il tema può essere variato, si crea una dipendenza tra il tema, che è il inherited widget, quindi che si propaga, e la riga colorata che ne fa uso. In realtà, qui ho detto una cosa non precisa, non si crea nessun legame tra riga colorata e il tema, si crea un legame tra il context, questo oggetto qui, e il tema, in realtà, quindi il legame e attenzione è sempre tra questi due oggetti. Questa cosa è molto importante, e lo troveremo anche in River Quad, per cui va fissata in mente. Il tema, cioè la variazione eventuale del tema, si applica, cioè viene ereditata, dal build context, con cui chiamiamo la funzione statica off. Ok? Attenzione. Quindi quando cambia il tema, non viene ricostruito soltanto riga colorata, perché riga colorata non è il suo context, questo, nonostante a livello di sintassi, potrebbe darci l'impressione che qui stiamo ricostruendo soltanto riga colorata, non è così, perché questo context qui è questo context qui in realtà, no? A livello di scope della variabile. Quindi quando cambia il tema, non cambia riga colorata, ma cambia tutto il blocco di questa build qui. Quindi sarebbe a dire tutto home page. Ok? Viene rilasciutita. Questa attenzione, perché se noi leghiamo la tendenza cascata ai context sbagliati, volessimo, volessimo veramente essere super efficienti e legare questo colore qui al tema e fare in modo che soltanto il colore, cioè il blocchetto colorato, venga ricostruito quando cambia il tema, cosa dovremmo fare? Dovremmo creare un altro widget con una sua build e a quel punto the input of context sarebbe il context di quell'altro widget. Cioè non della nostra home page, ma del sotto widget che avremmo costruito. Quindi attenzione a come vengono annidate le cose che qui stiamo ricostruendo dentro home page. Se questo ricostruisce, tutto il context viene invalidato e si ricostruisce di conseguenza. Ok? Per cui questa questa chiamata qui è evidentemente inefficiente perché se cambia il tema chiaramente tutta l'applicazione viene ricostruito perché tutta home page dipende dal tema. Ora, è vero che è un problema che non si pone perché il tema in genere non cambia il runtime. Per cui nel caso del tema questo è un rischio che possiamo correre senza qualche problema, però è diverso nel caso del contatore. Il contatore cambierà tante volte durante l'esistenza della nostra applicazione per cui è ovviamente bene limitare il contesto che viene ricostruito quando cambia il widget del contatore. Ok, ultima cosa. A questo punto abbiamo questo oggetto qui che, diciamo così, contiene dello stato interno. Quindi questo oggetto qui è un oggetto che si chiama... dove c'è? Dov'è? A color switch, è questo qui. Ok. Allora, mi sono perso un elemento. Quindi prima c'è l'elemento blu. Questo è un color switch, quindi un blocco che prende il colore dalla home page. Ok? Quindi home page contiene un colore. Quando clicco qui cambia il colore della home page. Ok, quindi cambia... non era voluto. Mi sa cosa è successo. Sta ricostruendo. Bene, molto bene. Ok, quindi quando cambio qui cambia il... questa variabile qui in sostanza. Questo qui. Cambiando questo colore qui chiaramente ricostruisce tutta la home page. Quindi questo è inevitabile salvo gli elementi che sono const e quindi si ricostruisce anche di conseguenza questo elemento qui. Però in realtà quello che stiamo assistendo è una ricostruzione di tutta la home page. Tant'è che questo oggetto qui che semplicemente è una specie di canarino che ci dice che qualcuno ha ricostruito da fuori perché questo viene rigenerato casualmente ad ogni build ci dice che qualcuno ha ricostruito la home page e anche questo elemento qui. Questo widget qui che invece ha uno stato interno per poi un widget che ha uno stato che è più in basso nell'albero dei widget ricostruisce soltanto se stesso. Ok, quindi setState lo fa su un elemento inferiore. Quindi come vedete non ricostruisce anche l'elemento esterno. Ok, chiaro qui. Qui siamo in un sottorano. Stessa cosa vale per questo oggetto qui che chiaramente ha lo stesso stato. Un'ultima cosa che faccio vedere su questo a questo punto dovrebbe essere abbastanza visto e stravisto. Una cosa che magari potrebbe essere strana è che quando cambio il colore del tema questo cambio qui questo click qui va a cambiare non lo stato della home page ma lo stato di tutta l'applicazione. Quindi sarebbe questo oggetto qua. questo oggetto qui colorate app che al suo interno contiene un theme color che poi viene propagato nel theme data di material app quindi abbiamo un oggetto che è fuori da material app che ci permette di cambiare il tema del material app in sostanza. Quindi ogni volta che c'è bisogno di stato lo stato deve essere almeno un livello sopra rispetto a dove lo utilizziamo che ambientalmente non si può usare. Non possiamo questo importante non possiamo usare stato che vive più in basso nella nostra gerarchia. lo stato è sempre sopra. Quindi in questo caso se material app ha bisogno di un colore per creare il suo color scheme allora il colore dovrà venire appena sopra o alcuni livelli sopra se necessario. Quando cambiamo il colore del nostro tema ovviamente ci aspettiamo che tutti gli elementi vengano ricostruiti questo è inevitabile ma noteremo che sia un po' strana perché ci sono varie ricostruzioni. Vedete quante ci si fa caso anche per questo widget qui questo viene ricostruito almeno tre volte vedete come cambia colore tre volte o più volte perché fa questa cosa qui? Perché il cambio di tema in realtà è animato è fluido adesso che se voi cliccate qui adesso non ci si fa molto caso perché il colore è abbastanza blando per cui bisogna proprio passarci attenzione però se adesso cambia in maniera visibile vedete che il cambio è graduale per cui in realtà le rebuild sono progressive quindi queste rebuild che vedete qui ne arrivano un paio per quanto possibile e ricostruiscono più volte il tema perché il tema passa in maniera così graduale da un colore all'altro e quindi anche questo oggetto qui che non serveva molto viene ricostruito tre volte e lo vediamo grazie a questo effetto qua però è un effetto dell'animazione non di altre di altre ok dimostra anche quando nulla clicca nulla clicca con lo stato in realtà nulla viene ripintato che nel caso ideale le nostre apprezzazioni fatte rimangono inalterate per tutto il tempo possibile perché non c'è bisogno di ricostruire nulla quindi nulla fa il repaint dell'applicazione ma questo avviene anche per le Win32 che giornalmente una volta che hanno dipinto una volta sullo schermo finché non c'è bisogno di invalidarle non vengono non vengono mai ridipinte in sostanza ok termina l'app e ricostruiamo un'app nuova a questo punto faccio Flutter Create Hello2 lascio a fare per un po' mentre Flutter crea il template perché adesso partiremo da di nuovo da un template di base di Flutter che abbiamo visto rapidamente insieme qualche lezione fa però era ancora un po' misterioso adesso lo vediamo così alla luce di quello che abbiamo già visto quindi sarà molto più chiaro e poi da lì partiamo e vediamo come è chiaro quella che sarà l'applicazione che andremo a fare fino alla fine del corso in sostanza ossia un'applicazione che ci permette di gestire una lista di cose da fare quindi sarà un'app molto facile che è una classica to do app quindi sarà composto da una lista di oggetti questa lista di oggetti potrà essere mostrata a schermo e chiaramente avranno delle spunte dei checkbox che ci permette di segnalare se la cosa è stata fatta o meno e così via quindi nulla di particolare innovativo però un'applicazione di esempio abbastanza classica che tra l'altro ci permette di studiare una serie di concetti di Flutter che sono abbastanza comuni e abbastanza utili allora rebuild tutto per questo device qui adesso visto che ci metterà un po' perché deve ricompilare tutta l'applicazione per Android e lanciarla qui dentro adesso qui per quanto riguarda Android saranno due applicazioni distinte chiaramente due progetti sono due applicazioni distinte hanno degli D diversi è stata una cosa che se avete forse già notato poi quando parleremo di Android in specifico lo vedremo però quando creiamo le nostre applicazioni anzi diamo un'occhiata veloce mentre combina oltre a tutte le definizioni che troviamo nel HubSpec quindi il fatto che si chiama Hello2 e così via ci sono anche avranno per Android ci sono una serie di specifiche in più che troviamo nel manifest per Android quindi qui dentro la directory Android sotto AppSource Main un po' nascosto troviamo l'AndroidManifestXML che è un file XML che continua una serie di dati accessori che diciamo così modificano come viene vista l'applicazione una volta che è compilata dentro Android per cui senza perderci troppo tempo adesso che non è utilissimo la cosa che vediamo intanto che c'è un Android label un Android name questo è il nome univoco dell'applicazione questo è come l'applicazione viene riconosciuta internamente da Android questo deve essere un nome univoco proprio a livello di Android proprio non possono esistere due applicazioni con lo stesso nome sullo stesso dispositivo label è il nome con cui compare sullo schermo quindi l'icona ha il nome Hello2 in questo caso questa è l'icona poi vedremo come si fa e in realtà c'è poco altro di interessante per ora se vediamo qui nella lista delle applicazioni dovremo trovare Hello eccolo quindi Hello1 è questo oggetto questa è l'applicazione di prima che è stata compilata dal progetto di prima adesso appena la terminazione completa e installa l'applicazione vi comparerà anche un Hello2 che probabilmente corrisponde alla seconda applicazione queste applicazioni qui sono applicazioni di tutti gli effetti che possono essere quindi disinstallate e gestite come applicazioni qualsiasi sono applicazioni di debug chiaramente quindi in realtà ospitano il sistema di debug di Android di Flutter scusate e si mettono in comunicazione tramite ADB con il vostro qui con il vostro runner di Flutter poi quando quando compileremo la produzione fattore per Android in modalità release in modalità produzione tutte queste cose non avvengono quindi viene creato un pacchetto applicativo che è a sé state quindi non ha bisogno di nessun runner e non ha nessuna funzione di debug ma è semplicemente l'applicazione Flutter che gira in non aveva stand alone per così dire ok intanto diamo un'occhiata al codice chiudo tutto lasciamo compilare quindi questo ci interessa a un altro punto e qui questo non ci interessa neanche avremo lib nostro main dart ok mentre compila diamo un'occhiata insieme alle cose che abbiamo creato per cui abbiamo il nostro main il nostro main crea una my app esattamente come prima avevamo una nostra colorized app quindi è un app cioè uno state switch che può contenere dei dati ma in questo caso non fa nulla vedete questa è la radice della nostra applicazione però essendo stateless non contiene dati può contenere soltanto dati statici in questo momento fissi tutto questo espone una material app ovviamente qui questo rimane uguale a come abbiamo già creato e poi a sua volta abbiamo la nostra my home page che è la vera radice che è la cosa che vediamo nella schermata principale questa home page qui è stateful ok per cui internamente avrà una classe sorella che contiene lo stato contiene un contatore esattamente come la produzione che abbiamo fatto il secondo fa questo contatore quindi c'è un metodo privato al file che ci permette di incrementare il contatore e aggiornare lo stato e poi quando facciamo build andiamo a creare l'interfaccia per intero l'interfaccia vedete che è molto commentata in realtà perché già è tutto molto preparato così adesso magari ti conosco un attimo di questi elementi che sono più fastidiosi che altro e perché qui facciamo conoscenza con quello che è lo scaffold che è uno strumento abbastanza fondamentale per essere usata material design e in genere si usa sempre perché quello che dà quell'aspetto generale alla vostra applicazione che quello che un utente medio si aspetterebbe in qualche modo su Android questo può capitare perché perché mi chiede qui ecco perché su alcuni dispositivi purtroppo vi chiede 27 volte se volete cioè questo dipende dal vostro dal produttore del vostro cellulare quanto è difficile installarci le cose sopra quindi questo è uno Xiaomi e quindi è particolarmente erogioso sì è insopportabile è terribile bisogna registrarsi bisogna fare 27 cose bisogna avere la sim questo era senza sim ho dovuto mettere la sim fasulla motivi almeno inspiegabili no è completamente solo per tracciare per impedire di fare le cose in sostanza la costruito sta installando adesso per chiedermi conferma eccolo questa volta ce la fa e questa volta la lancia ok questo lo chiedo solo la prima volta che fate il run chiaramente una volta che l'applicazione è installata la può aggiornare senza dovervi chiedere 27 volte la stessa cosa però ecco ok l'aspetto finale è questo qui allora cosa vediamo a schermo in sostanza vediamo lo scaffold oggi in realtà vediamo prevalentemente gli oggetti base per il layout così prendiamo confidenza con quello che è la grafica come costruiscono delle UI in platter così che poi domani abbiamo 4 ore intere per vedere il river pod dalla A alla Z così se abbiamo dei dubbi amletici e qualcosa non funziona abbiamo anche il tempo per risolverlo insieme allora cos'è lo scaffold lo scaffold è un costruito abbastanza complesso in realtà che viene tradito dal fatto che ha veramente tanti parametri parametri di costruzione quindi varie cose che potete fornire o meno e a questo aspetto qui nel senso che ha una barra in alto che è più o meno alta in base a varie condizioni in cui si può costruire lo scaffold in genere la barra in alto contiene quella che viene comunemente chiamata la app bar quindi questa barra qui in alto che contiene anche il titolo dell'applicazione quindi questo titolo qui e optionalmente contiene anche degli action button cosiddetti quindi dei pulsanti che permettono di avere effetto sulla paginata corrente quindi se avete esperienza con l'applicazione che forse più sposa questo modello questo design classicamente è la versione di Gmail che è sempre abbastanza allineata con il material design che somiglia molto a questo chiaramente quindi quando avete aperto un'email nonostante l'email cioè il tiso viene mostrato qui sopra ma qui trovate le varie opzioni sono le azioni sulla pagina aperta quindi potete cancellare archiviare rispondere rispondere mi sa che d'altra parte cambia molto però le operazioni principali sono qui ok poi fondamentalmente l'unica proprietà che c'è sempre è il body quindi lo scaffold nella sua versione più scarna può anche non contenere un app bar questo possiamo anche magari commentarlo nulla vi nulla vi obbliga ad avere un app bar qui sparirà la bar in alto la cosa che serve sempre è la home quindi la home è scusate la home il body quindi il corpo della vostra finestra quindi fondamentalmente anche se non avete bisogno di uno scaffold perché non vi serve l'app bar non vi servono gli altri suoi elementi in genere se lavorate con material design in genere è sempre molto utile avere comunque lo scaffold anche se non lo usate perché lo scaffold in realtà si porta dietro una serie di cose accessorie che tutti i widget material usano bene o male ok per cui la colorazione l'animazione il fatto che si possa navigare da pagina a pagina è tutto generalmente gestito dallo scaffold per cui classicamente quando fate una personal material design avete ovviamente una material app come radice che è quella che dà il colore fondamentalmente c'è il tema e poi almeno uno scaffold che dà il resto della struttura dell'applicazione anche se poi non lo usate anche se poi fate una una UI completamente custom con pulsanti che non c'entrano niente come 3 design e fate cose completamente diverse in genere lo scaffold c'è perché serve a dare una serie di cose di contorno alla vostra applicazione quindi il body alla fine è tutto quello di cui avete bisogno nel caso più essenziale poi qui vediamo subito un floating action button che è un altro dei pattern classici di android che è questo pulsante qui che rimane in solito in pressione rispetto al body quindi questo qui flotta galleggia sopra al body ed è sempre visibile chiaramente può spostarsi in realtà quindi questo floating action button proprio perché galleggiante può spostarsi cambiare l'allineamento può essere al centro può essere a sinistra può essere a destra e si può spostare verso l'alto se c'è qualcosa sotto quindi se il vostro scaffold prevede che ci sono altri elementi sottostanti come tra un secondo vedremo c'è la la cosa più classica probabilmente è la navigation bar in fondo sottostante in quel caso tutto si riarrangia in modo tale di dare spazio agli elementi ok qui adesso prima di andare avanti l'unica cosa che qui avviene è che quando clicchiamo su questo pulsante qui viene il contatore quindi c'è questo aggiornamento qui questo aggiornamento qui che non è assolutamente efficiente quindi non che sia inefficiente nel senso che si aggiorna tutta la home page si ricostruisce e viene ricostruita tutta la struttura con il contatore aggiornato mostrato qui è inefficiente perché chiaramente si ricostruisce tutta la interfaccia cosa che potremmo evitare se andassimo a sottodividere gli eventi di interfaccia rendendoli conti come abbiamo scoperto che comunemente si fa in questo caso l'interfaccia è così scarna che non è che ci guadagniamo chissà quanto e quindi se ne ne facciamo a meno ok vediamo un attimo lo scaffold come possiamo renderlo più ricco perché come vi dicevo qui abbiamo una serie di proprietà anche qui che possiamo sfruttare ci sono tanti e non sempre cioè molte sono utili in alcuni rarissimi casi quindi molte hanno un effetto puramente estetico quindi per esempio possiamo cambiare la forma l'ombreggiatura la spazzatura del titolo l'altezza della toolbar il colore primario e via non che sia praticamente utile nel caso più comune leading questo dovrebbe essere un widget se non vado errato questo dovrebbe essere l'elemento esatto un widget che leading viene messo prima del titolo possiamo metterci un icona per esempio questa è una cosa che ogni volta che abbiamo bisogno di un'icona in material design possiamo far appelerci del widget icon ovviamente e come si costruisce esattamente come viene qui quindi il widget icon è un widget molto semplice che contiene un un'icona un'icona del set standard del material design la lista di icone completa è in questa classe icons che vi dà l'accesso a tutte le cosiddette material icons che sono veramente tante che spesso la potremmo usare in vari contesti qui adesso ci metterò un po' vedete che la lista è veramente interminabile c'è un po' di tutto se andate a cercare sulla documentazione ufficiale trovate anche la lista completa con l'esempio di quello che i vari icone contengono per ogni icona quindi per esempio phone è la classica cornetta ovviamente per ogni icona c'è in genere una variante che è outlined rounded e sharp quindi ci sono tre varianti c'è quattro varianti in realtà quella standard che è l'icona piena diciamo così colorata outlined è l'icona che è sfattata tanto dal tratto rounded è la versione rotonda esatto e quindi cambia poco e sharp non ricordo se cosa cambia ma dovrebbe cambiare molto poco ma sfruttiamo quindi qui stiamo aggiungendo un elemento alla nostra interfaccia leading verrà messa prima del titolo in genere ecco quindi in questa maniera qui abbiamo creato aggiunto un elemento leading c'è un'icona qui a sinistra del rispetto al titolo il titolo a questo punto viene centrato qui è classicamente dove va a finire la freccina se bisogna andare indietro oppure il menu il classico menu hamburger come si dice ma quindi il menu quello che trattini che apre la barra laterale e così via quindi possiamo metterci un po' quello che ci serve in base a come è fatta la nostra interfaccia oppure l'icona della nostra applicazione un altro classico se vogliamo mettere delle azioni bene qui c'è chiaramente la lista di widget che è actions qui di nuovo possiamo metterci quello che vogliamo però classicamente ci si mette un action action button come era il nome action c forse e il label questo è dato che in genere possiamo mettere tutti i widget esattamente come vogliamo per cui ok questo non è proprio quello che volevamo però visto che tutti i widget sono widget alla fine dei conti possiamo metterli come vogliamo qui questo è assolutamente contro qualsiasi standard del material design per cui non è quello che volevamo però abbiamo messo un altro oggetto un action chip dentro l'app bar senza che Flutter se ne lamentasse più di tanto perché chiaramente qualsiasi widget può essere messo al posto di altri widget perché alla fine sono dei widget standard quindi non questo è semplicemente contrario ai principi di buona creanza in material design però non è un problema inizio una chip ma non ricordo il nome della classe qui quindi poi lo facciamo dopo non cambia molto ok stessa cosa vale per il photogation button che appunto è un oggetto che contiene un figlio questo site qui che di norma è ovviamente un icono però sulla carta anche qui bisogna metterci proprio gli a quindi un text sarebbe certamente legittimo ok perché un widget alla fine vale vale vale l'altro questo non cioè questo ve lo dico non è sempre per il centro di perciò nel senso che alcuni widget all'interno di altri widget si comporta una migliore un po' strana quindi non funzionano bene però in questo caso un testo semplice dentro il photogation button si può mettere seppure in genere non è quello che si che si fa ok icon button è il nome del del widget che si mette classicamente qui dentro per cui facciamo così ok quindi qui l'oggetto è un icon button che avrà una proprietà icon che è un widget quindi anche questo in realtà potrebbe essere dell'altro ma possiamo icon mettiamo un'altra icona ok questo va bene e l'icon button chiaramente ha il classico la classica funzione on press che possiamo utilizzare per essere avvertiti del fatto che qualcuno ha cliccato sul pulsante possiamo anche incrementare il contatore questo magari ha un po' un effetto ok a questo punto c'è l'icona se clicco qui ovviamente c'è l'action click qui stampato e di nuovo incrementiamo il pulsante anche qui questo click qui fa sì che tutta l'applicazione venga ricostruita perché di nuovo si propaga sulla home page se ribilda lo stato è equivalente a click qui ok anche qui possiamo aggiungere più icone se vogliamo c'è una poi l'appbar si adatta se riesce se non riesce a contenerle le le nasconde ok questo ci siamo ok vediamo le altre classiche i classici widget di cui facciamo per farlo per vedere insieme avvio un attimo le slide ok per correttezza questo mi dice di essere const qui come al solito icon button non può essere const perché continua una funzione quindi questo qui questo è mutevole cioè mutabile per cui fa un effetto non può essere const però ai suoi componenti sì quindi l'icona tranquillamente può essere const ok perfetto ok siamo partiti da scaffoli quindi vediamo un paio di widget comuni il più comuni cioè i più comuni in assoluto sono chiaramente righe e colonie che abbiamo già visti poi ce li vediamo un pochino più in dettaglio perché sono molto semplici quindi sono porti esattamente come come ci si aspetterebbe perché sono appunto mettono in riga o mettono in colonna degli altri widget di qualsiasi forma colore e aspetto che si siano però ovviamente per quanto sono semplici sono anche abbastanza sofisticati perché possono adattarsi nel loro comportamento in particolare la cosa da finalmente è che ovviamente mettono in colonna e mettono in riga dei widget però lo fanno mantenendo degli allineamenti di questi widget quindi li dispongono allineandoli in qualche modo chiaramente e lo fanno su quello che loro chiamano l'asse principale e l'asse secondaria l'asse principale è cioè varia in base al tipo di widget che stiamo utilizzando l'asse principale per il widget riga è quello orizzontale quindi il widget riga mette in riga il widget quindi l'asse principale su cui lavora chiaramente è quello orizzontale in cui chiaramente vale nel mettere in riga le cose cioè le affianca orizzontalmente in sostanza mentre l'asse secondaria quello che si chiama cross axis per nel codice poi è l'asse verticale quindi chiaramente ovviamente gli oggetti possono essere messi in pila orizzontalmente ma allo stesso modo chiaramente il widget può decidere come disporli anche verticalmente allo stesso tempo stessa cosa vale per la colonna che fa le stesse cose ma è il contrario quindi l'asse principale è verticale l'asse secondario è orizzontale noi quando creiamo colonne e righe possiamo decidere in maniera arbitraria come il widget deve comportarsi su questi due assi vi faccio vedere un paio di elementi classici per la colonna quindi gli elementi che sono disponibili sono sei in totale questo vale per la colonna però se volete immaginarlo per le righe potete semplicemente ruotare tutto in 90 gradi ed è esattamente ubale quindi la riga si comporta ugualmente cambia l'asse chiaramente e gli oggetti che stiamo allineando adesso a parte i colori che sono sei colonne sarebbero sei widget di tipo colonne che stanno allineando internamente cinque blocchi di texto ah una cosa che non vi ho detto che ora text è un altro widget ovviamente fondamentale generalmente il widget text occupa il meno cioè la quantità minore di spazio possibile quindi si riduce ai contenuti che sta effettivamente mostrando a schermo ok è come se ricordate nel Win32 facevamo una misura no una premisura dello spazio occupato sullo schermo da parte di un testo Flutter fa la stessa cosa cioè premisura il testo che verrà occupato e poi adatta la grandezza del widget text in modo tale che occupi esattamente lo spazio di usare per contenere quel testo ok quindi questi oggetti qui in realtà se vogliamo delimitarli in qualche modo cioè i singoli testi hanno questa grandezza qui adesso sto disegnando molto male però questi blocchetti sono grandi esattamente questo è rilevante tra un secondo quando vedremo come si comporta però immaginate che il widget se li vedessimo adesso li vediamo chiaramente però avrebbero esattamente quella quella di un certo ok quindi l'alimento sull'asse principale start significa mettili a inizio dello spazio che ho e sarebbe a dire nel caso della colonna in alto and è l'inverso quindi metti in fine nello spazio che ho quindi metti in fondo in sostanza questa cosa start ed end sarebbe stato più logico chiamarli top e bottom forse non sarebbe stato più intuitivo però si chiamano top e bottom perché si chiamano start ed end e non top e bottom perché in base alla lingua diciamo comunque alla localizzazione della nostra applicazione start ed end possono cambiare perché sono lingue che vanno la lingua latina classica va dall'alto al basso e dalla sinistra a destra nel layout questo vale anche per le colonne quindi la colonna in un cellulare uno smartphone configurato in inglese o in italiano o quello che è si comporta in questa maniera che start è in alto e end è in fondo se lavoriamo su una lingua che invece è fusola al contrario l'utente che ragiona con la lingua locale che è al contrario ovviamente si aspetta che il top sia in fondo e il bottom sia in alto per cui per coerenza modernamente modernamente non si chiamano più top e bottom ma si chiamano start and end per essere più corretti a livello formale se lavorate sempre con faccio sempre il confronto con CSS perché ci sono molti molti paragoni se avete mai lavorato con il flexbox in CSS avete notato che anche lì si chiamano start and end e non top e bottom proprio per questo migliore perché anche lì se il browser è configurato in una lingua al contrario ovviamente adesso nella colonna non è molto sensato perché tutte le lingue che vengono in mente vengono sempre dall'alto e dal basso però il caso esempio è il giapponese che viene scritto dall'alto e dal basso e poi da sinistra a destra quindi l'andamento è verso il basso giusto se non vado errato mentre per esempio l'arabo è scritto da destra a sinistra quindi in quel caso cambia l'orientamento start and end delle righe ovviamente per l'arabo il nostro hardware dovrebbe start a sinistra e esatto esatto quindi se il vostro cellulare è configurato in lingua araba per esempio nelle righe start è a destra ed end è a sinistra e quindi in automatico la vostra interfaccia si comporta in maniera giusta per il corretto in senso che tutti gli oggetti che sono a sinistra nella vostra interfaccia vengono proiettati a destra e viceversa quindi è come se si flippasse tutto questo vale ovviamente anche per il testo chiaramente che è la cosa più importante che venga flippata però vale anche per i pulsanti quindi se avete mai visto in realtà è abbastanza estragnante a volte vedere che non so l'interfaccia di Windows in arabo e vedere che tutto è invertito quindi anche non so le X di chiusura sono a sinistra in alto ovviamente e lo start in basso a destra e così via quindi tutto quanto viene invece viene flippato center quanto meno non ha questo problema perché il centro è sempre quello quindi il center è molto facile condensa tutti i contenuti verso il centro ovviamente per quanto possibile e poi ci sono tre spaziature che invece distanziano gli oggetti da di loro in modo tale di rendere più o meno più arioso diciamo così il layout cioè space around space between e space evenly come funziona allora funziona così praticamente tutte e tre fanno in modo tale che la colonna occupi tutto lo spazio disponibile quindi stiracchia gli elementi stiracchia non è vero non li stiracchia ho detto male li sposta però perché questi rimangono della stessa canezza da prima quindi nella colonna blu avevano questo spazio qui nella colonna viola testo 1 2 3 4 5 sono sempre grandi uguali quindi attenzione questo qui allinea gli elementi ma non ne cambia le dimensioni sono sempre gli elementi stessi che si filano come quanto sono grandi quindi se avete un'immagine qui dentro l'immagine prenderà la dimensione naturale dell'immagine il testo la dimensione del testo la colonna non fa altro che decidere come impilarli ma non cambia le dimensioni dei contenuti ok quindi con space around cosa avviene che praticamente viene preso tutto lo spazio disponibile per la colonna e viene suddiviso equamente in qualche modo tra tutti i sotto widget facendo in modo tale che sopra e sotto tutti i widget avranno lo stesso spazio ok questo è più evidente se lo disegno quindi questo testo qui avrà questo spazio qui che è equivalente allo spazio che ha sotto e questo vale anche per il widget sopra scusate ok e così via quindi ogni widget ha un margine equivalente sia sopra che sotto space between fa la stessa cosa quindi fa tutto lo spazio disponibile divide per 5 ma il primo e l'ultimo elemento non dà spazio sopra e sotto ok quindi questo testo 1 chiaramente non ha un margine superiore però ha la metà del margine inferiore che lo divide dal testo 2 ok questo è risultato veramente molto bene space evenly è un pochino più strano e questo fa in modo tale cioè l'ambizione di space evenly è quello di dare una suddivisione che è armonica nello spazio cioè no armonica armonica è lo strumento armoniosa nello spazio ok perché se guardate da lontano questo space around può darvi l'impressione che l'impressione cioè è vero può saltare all'occhio che tra testo 1 e testo 2 c'è più spazio rispetto a quanto spazio c'è sopra prima di testo 1 e dopo testo 5 quindi testo 5 e testo 1 hanno meno spazio sopra e sotto mentre questo non lo viene con space evenly dove lo spazio viene suddiviso di commente e poi si fa in modo tale che lo spazio tra gli oggetti sia sempre uguale ok quindi cambia un po' la suddivisione quindi banalmente se dividessimo l'immagine qui sopra vedete cioè in realtà questa è la spazzatura è armoniosa ma non è equa ok perché il testo 5 ha più margine inferiore rispetto a quanto abbia le margini superiore però è adattato in modo tale da darvi una suddivisione esatta dello spazio luogo quindi se volete vederla in maniera così filosofica space around divide lo spazio disponibile in blocchi equi poi centra ogni blocco ogni contenuto al blocco quindi fa questo quindi è equo space evenly non è equo e suddivide in maniera imprecisa cioè precisa in maniera non equa quindi dando spazio al primo e l'ultimo elemento però facendo in modo tale che lo spazio vuoto tra gli oggetti sia equo questa è l'idea stessa cosa per le righe solo che lo flippiamo al presentato ok altra cosa qui abbiamo dato per scontato che la colonna si si si espande verticalmente quindi qui vediamo la colonna è colorata di rosso di blu di verde e così via perché diamo per scontato che la colonna si estenda in verticale ma questo non necessariamente è il caso perché la colonna può estendersi o meno lungo su asse principale in base a come la configuriamo di base non si estende questa cosa è specificata dalla proprietà main access size che determina se il widget si prova ad espandersi sulla sua asse principale può essere o min quindi cerca di minimizzare a comprimersi sull'asse principale o max se invece deve essere deve espandersi in maniera occupare tutto lo spazio disponibile questo tra un secondo poi facciamo qualche prova che diventa un pochino più più chiaro ultima cosa vi dicevo che c'è l'asse secondario ovviamente su quale possiamo spostarci e anche qui possiamo scegliere tre scusate quattro varianti start end center e stretch non ci sono le spaziature space between because non avrebbe senso perché sulla cross axis ad ogni posizione c'è soltanto un elemento quindi non c'è modo di spaziare quindi ad ogni posizione sostanza sarebbe il modo con cui la nostra colonna decide dove posizionare gli oggetti su quest'asse qui quindi chiaramente essendo una colonna ogni oggetto si trova in una posizione unica e non condivisa con altri oggetti per cui chiaramente non ha senso avere space around in questo caso start è a sinistra in lingua latina insomma le culture occidentali standard ai nostri occhi end è a destra set 3.5 ovviamente quindi di base questi sono tutti center sull'asse orizzontale e stretch è l'unica opzione che modifica il widget che viene contenuto che c'è che è contenuto dalla colonna quindi stretch stretch è un'opzione che va a variare come funziona il layout dei widget figli perché li stiracchia letteralmente quindi se noi applichiamo stretch i widget invece di comprimersi in modo tale da contenere soltanto il testo si allargano quindi una volta strecciati sull'asse orizzontale in questo caso si allargano in questa maniera ok quindi se se appliciamo stretch questi qui crescono meglio risultamente a occupare tutto lo spazio disponibile sull'asse secondario della colonna questo è utile in alcuni scenari tra un secondo lo vedremo perché ci permette di allineare il test a questo punto in maniera che sia sensato ok dobbiamo fare qualche esperimento di questo così sta più chiaro quindi rimetto qua abbiamo qui la nostra interfaccia benissimo allora direi che tutta questa bella cosa la buttiamo la cassiamo lasciamo soltanto la colonna aiuto non ci mettiamo nulla e poi vediamo cosa cosa fare qui per dare colore alla colonna la colonna ovviamente adesso se ribildo adesso non si vede perché non contiene nulla per mostrarla che la colonna non ha un aspetto grafico la mettiamo dentro un container ok per cui prendo la colonna e la rappo con l'aiuto del nostro amico del studio dentro un container la in carto qui e il container come al solito ci permette di applicare un colore non questo così vediamo vediamo la colonna vedremo molto poco perché la colonna comunque non è visibile perché non è visibile perché non contiene nulla quindi la colonna di default vi dicevo che si comprime la colonna prende spazio verticalmente quindi se non c'è nulla dentro non occupa spazio quindi in questo caso la colonna c'è ma è vuota mettiamoci qualcosa dentro mettiamoci un text un testo e poi c'è un testo lungo ci mettiamo un lore y ok questa volta si espansa a questo punto adesso la vediamo sono tre testi vedete come vengono allineati i default quindi al default vengono allineati non al default non molto qualcuno dice di pentire al centro ok quindi la colonna si espansa lungo tutto il contenuto del body quindi tutto è tutto rosso e gli elementi sono allineati verso lo start quindi verso il top in questo caso sull'asse orizzontale quindi l'asse secondario sono centrati sono disposti centralmente quindi vengono messi al centro e questo si vede cioè si nota una cosa un pochino strana perché c'è un mondo è centrato perché inizia qui e finisce qui quindi la colonna lo centra testo è uguale testo inizia qui finisce qui viene centrato in mezzo alla colonna questo blocco qui invece è un pochino strano perché essendo un testo che sborda quindi essendo un testo che va oltre la dimensione della colonna non può cioè text stesso non riesce a contenere il testo in una singola riga quindi quando avviene il passo di layout immaginate questo che il layout funziona a cascata quindi la colonna crea i suoi sotto elementi con la build quindi crea i tre i tre text e dice ok sei stato costruito il primo viene costruito con ciao mondo il secondo con testo il terzo con ufficio la colonna chiede ai tre text quanto sono grandi per fare il proprio layout quindi gli chiede quanto sei grande tu ciao mondo prenderà un tot orizzontale e dice mi basta questo ok testo prende ancora quello spazio quindi definisce delle larghezze misurando il testo text l'ultimo che cosa fa misura il testo e prende cioè specifica una lunghezza orizzontale che è troppo elevata quindi va adesso non so quanti pixel sono questi ma saranno circa 640 o poco in realtà meno probabilmente orizzontali e il testo magari ne prende non so 800 così a caso quindi la colonna dice ah io questo però non te lo posso promettere perché non entri dentro me stessa perché io al massimo posso essere larga 640 quindi obbliga il text a dire devi rientrare dentro 640 a quel punto il text cosa fa si comporta prende tutti questi 640 orizzontali quindi si estende fino al margine massimo e poi fa con un algoritmo che è di text breaking si dice quindi va a capo e semplicemente poi mostra il testo all'interno dello spazio a disposizione però vedete come è allineato qui adesso è il testo allineato a sinistra paradossalmente cioè il text è centrato rispetto alla colonna prende tutto lo spazio risontale interna interna interna il testo a sinistra per cui il comportamento è centrato centrato centrato ma il testo è a sinistra ciao mondo e testo sono ugualmente allineati a sinistra all'interno del text che però è allineato al centro questo è importante da capire quindi ciao mondo qui è allineato a sinistra di uno spazio molto piccolo ed è per questo che compare al centro ok perché ah ok questo si questo è un buon punto questo lo togliamo un altro perché questo qui è center che costringe il container ad allargarsi questa è una cosa che non stavo notando ma è giusto provare a toglierlo quindi faccio il remove switcher per cui il container diventa direttamente il figlio diretto di body se ne è che fa nulla ah quel centro lì adesso non aveva alcun effetto vediamo una cosa ok giustamente ah perché ah quindi il container costringe la colonna di espandersi perché al momento il suo anzi la sua proprietà main access size questa qui è impostata a uno dei due valori che è o min o max quindi di default è max quindi di default la colonna cerca di espandersi e coprire tutto il passo possibile ok come vi dice la documentazione quindi il center lì cambiava molto poco quindi mettiamo un secondo per capire quindi è la colonna in realtà che si espande per quanto possibile la colonna cioè il container è passivo in questo caso il container misura il widget figlio la colonna misura se stessa ok dice main access default è max quindi sull'asse verticale si espande finché può quindi si espande fino in fondo a quel punto i suoi oggetti interni li dispone in base alla disposizione del standard che è start e li mette in alto però la colonna in questo caso si espansa fino in fondo tra l'altro si espansa fino in fondo ma in orizzontale di solito non lo farebbe si espande in orizzontale fino in fondo perché c'è questo text qui che la costringe a farlo perché questo text qui sborda e quindi prende tutto lo spazio se qui commentiamo questo text qua che è quello lì che ci obbligato a prendere tutto lo spazio vedete qui adesso la colonna si è ristretta si è si è contratta perché orizzontalmente ha bisogno di meno spazio ok quindi questo è sull'asse secondario il cross axis e perché il cross axis si adatta a quello che che la colonna si adatta sull'asse secondario in base a quello che contiene diciamo mondo del testo ciao mondo è il windows più largo nei suoi dimensioni per cui la colonna assumerà le dimensioni quella e questo determina anche come viene centrato ciao mondo stesso che adesso ciao mondo è centrato all'interno di una colonna che è grande quanto ciao mondo ovviamente per cui a questo punto l'effetto è un po' strano perché adesso ciao mondo è centrato però rispetto a testo ok se adesso tutto questo lo rimettiamo dentro il nostro center adesso il center fa un po' un lavoro in più finalmente perché adesso aspettiamoci prima di farlo pensiamoci quindi container è grande quanto colonna il container si adatta quindi è flessibile non è il container non prende spazio di default la colonna è alta infinito ed è larga quanto il test se mettiamo tutto questo dentro center center immaginate il center si comporta come center prende tutto lo spazio possibile quindi si allarga tutto lo schermo e poi il center il suo contenuto quindi immagini quello che avremo va bene che avremo uno spazio bianco la colonna rossa e poi bianco lo faccio l'ho detto dovrebbe essere anche giusto spero ok è questo quindi adesso la colonna è centrata al suo interno c'entra tutto quanto e ciao mondo è centrato ma soltanto perché tutto quanto è accentrato stavolta questo può essere quello che vogliamo ottenere o può anche non essere la seconda però è importante capire come si lo riettano questi elementi come fanno il layout perché è molto facile poi incastrarsi in strani andamenti delle colonne e quant'altro e a questo punto visto che la colonna si espande di natura intanto dimostriamo cioè facciamo vedere cosa accade quando non si espande quindi quando vogliamo che sull'asse principale della colonna non prenda tutto lo spazio possiamo dirgli di prendere min e a questo punto si contrarrà e rimarrà cioè finirà qui in sostanza la colonna anzi no scusate ovviamente è dentro center quindi finisce finisce centrata se non ci fosse center a centrarci la colonna sarebbe in alto vabbè se non lo tolgo però è magica che sia sia così adesso se visto la colonna è pienamente contratta cioè non è più grande dei suoi elementi cambiare l'alienamento sull'asse principale non cambia nulla quindi qui abbiamo la proprietà main access alignment che è uno dei valori che abbiamo visto prima quindi è start end center space round e così via di default è start come sappiamo ok default è start qua se noi adesso mettiamo end questo allineerebbe gli elementi verso il basso ma non ha alcun effetto perché non c'è nessun basso cui spingerli quindi la colonna è grande esattamente qui start end e center sono i due parenti perché non c'è spazio dove spostarli altra cosa cioè se facciamo max chiaramente la colonna si allarga a questo punto diventa sensato lineare in basso quindi quegli elementi lì hanno un'area in basso ok rimetto qui il testo questo testo qui di nuovo farà in modo che la colonna si allarghi orizzontalmente e renderà inutile il center perché a questo punto center non avrà nulla da centrare la colonna è grande quanto body in orizzontale e in verticale quindi center non ha alcuna efficacia questo qui diventa perfettamente inutile ok è chiaro perché perché la colonna occupa molto lo spazio ok qui giusto per vedere facciamo lo space between lo space even quello più elegante diciamo ok e qui per dimostrare che i singoli elementi qui sono occupano lo spazio che occupano possiamo brapparli dentro un po' a tenere a loro volta quindi questo text qui magari lo mettiamo dentro un container blu giusto per dimostrare per vedere l'effetto che fa che avrà esattamente la divisione del test ok quindi di nuovo i testi sono sempre compatti a meno che per come sono fatti vengano allargati ora magari coloro anche il testo qui di giallo per dire ok ultima cosa il cross axis alignment qui è ci permette di lineare gli oggetti il orizzontale in questo caso visto che stiamo parlando di colonne e di default è center appunto ma adesso se mettiamo start vedremo che si spostano un po' verso lo start default che è a sinistra in questa in questa cultura si spostano tutto a sinistra adesso l'effetto è che tutti i testi siano allineati a sinistra anche se attenzione i testi ciao mondo e testo in realtà sono allineati in blocco a sinistra ma internamente cioè come dire sono allineati a sinistra ma perché gli oggetti iniziano tutti quanti a sinistra e per il testo sotto non è cambiato nulla in realtà visto che occupava tutto lo spazio qui anche qui magari lo containerizziamo c'è un ricordo sempre molto arbitrario quindi vedete che il text occupa tutto lo spazio perché è quello che deve fare ora questo testo qui cioè il testo stesso in realtà può text forse avete già guardato magari però text stesso ha una serie di proprietà che possono essere usate per variare come viene disposto il testo per cui anche text oltre a contare il testo stesso in realtà ha uno stile una direzione un alignment un modo di frappare un numero di linee massimo così quindi ci sono un paio di opzioni che possiamo impostare in modo da cambiare come il testo compare la cosa più più banale da cambiare è la text text align che ci potete allineare il testo però attenzione perché il testo viene allineato soltanto se è composto da più righe perché su una singola riga l'allenamento non ha molto senso a meno che non ci sia lo spazio necessario e cosa voglio dire è che se allineo il testo lungo qui sotto a sinistra e a destra anche qui di default l'elemento è a sinistra text align ok qui attenzione abbiamo c'è una commissione di cose quindi abbiamo di default cioè start ed end che hanno il stesso valore di cui dicevo prima quindi è inizio e fine di default che equivalgono a sinistra a destra qui se noi vogliamo possiamo fissare left e right quindi left e right esistono anche se in genere è meglio evitarli perché quelli lì sono a sinistra sempre a destra sempre mentre start ed end sono sinistra e destra in lingue che sono disposte in quella maniera center poi c'è justify che è l'allenamento giustificato che è quello che espande la spazzatura dei caratteri in modo tale che se sono su più righe si espandono tutto il blocco qui se possiamo right avverrà che il testo si sposta a destra chiaramente ok e quindi il testo in fondo qui lungo si sposta a destra nonostante il blocco stesso sia lineato a sinistra vedete che qui ciao mondo è a sinistra testo è a sinistra il blocco viola è a sinistra però è largo tanto quanto il contenitore e quindi il testo stesso va a destra se facciamo la stessa cosa con il testo qui del blu già sapete cosa accadrà però non si può vederlo se cambio l'allenamento di questo testo qui con text align right non accadrà un bel nulla nel senso che rimarrà esattamente così perché il testo verrà allineato a destra ma di cosa? del suo contenitore è troppo piccolo perché cambi nulla quindi questo qui è cambiato ma è a destra di questo spazio piccolo quindi non è non ha alcun effetto a meno che questo spazio non venga stiracchiato chi può stiracchiare lo spazio? il contenitore quindi la colonna stessa ha la capacità se ci serve di stiracchiare i contenuti orizzontalmente cioè sull'asse su cross axis cosiddetto se impostiamo il cross axis alignment come stretch abbiamo visto start and potete immaginare che è la stessa cosa ma a destra quindi si sposa tutto a destra e a questo punto è testo che non tolge testo allineato a sinistra però l'oggetto è spostato a destra l'oggetto widget text quindi non compare allineato a sinistra se usiamo stretch su cross axis cosa accade? che tutti i text vengono stiracchiati o meglio in realtà non i text tutti i container e poi a cascata tutti i text quindi a questo punto accade quello che è abbastanza intuitivo per cui tutti i text sono allargati su tutto lo spazio orizzontale e finalmente possono allinearsi tra di loro ok? per cui c'è un mondo a destra perché ha lo spazio per essere a destra finalmente ok? ultima cosa con justify qui vedete che justify ha senso solo se abbiamo più di una riga altrimenti da solo non fa alcun effetto justify è sempre a sinistra cioè la giustificazione è a sinistra e fa in modo tale che le righe quelle complete vengano allargate in modo tale da occupare tutto lo spazio il fondale ok? quindi vi dà quell'effetto blocchettoso tipo libro stampato seppure ma questa è una ma questa è una limitazione di quasi tutte le interfacce utente tutti i toolkit di interfacce utente la quando si fa il testo giustificato si agisce su quella che si chiama crenatura del testo cioè lo spazio intermedio tra i caratteri della singola della stessa parola e degli spazi chiaramente in genere l'attentamento della crenatura è molto primitivo su tutti i toolkit di interfacce utente per cui l'aspetto non sarà mai elegante come quello di un libro stampato vero dove ci sono degli adattamenti più raffinati che si possono fare per cui si può usare ma in genere in effetto non è particolarmente gradevole quindi in genere il testo giustificato in interfacce utente è abbastanza raro incontrare dei casi in cui sia veramente utile o esteticamente gradevole insomma quindi ve lo sconsiglio ok tutto questo adesso giusto per passiamo le slide così poi ha più senso tutto questo possiamo replicarlo per le righe volendo però adesso non lo facciamo perché non ci prendiamo tempo però per le righe accade la stessa cosa ma semplicemente sull'altro asse ok per cui potete ragionare sempre compattando o allargando le righe sull'asse orizzontale quindi il main axis min e max nel caso della colonna valeva in verticale nel caso della riga vale in orizzontale ok quindi di default una riga occupa tutto lo spazio orizzontale ma possiamo compattarla a sinistra cioè occuparla dove capita e i suoi figli possono essere allineati sull'asse principale e sull'asse verticale quindi il cross axis alignment ovviamente vanno le stesse cose e chiaramente possiamo comporli in piena libertà perché possiamo fare colonne di righe di colonne alla loro volta oppure righe di colonne così ok quindi in genere le colonne e le righe sono tutto quello che ci serve cioè che coprono il 90% delle nostre esigenze di interfaccia ad ente in genere perché basta ragionare a livello strutturato in righe e colonne e insomma normalmente trovate un modo per per creare anche interfacce sofisticate con questi componenti molto semplici ah volevo farvi vedere un'ultima cosa su questo magari che è utile qui ah cosa posso usare qui per espandere un po' vabbè di default gli oggetti prendono lo spazio di cui hanno bisogno l'abbiamo visto per cui il testo prende lo spazio minimo a meno che non sia non venga stiracchiato il container uguale per tenere il suo contenuto però c'è un caso in cui ci serve magari cambiare le proporzioni degli oggetti perché adesso qui qui gli oggetti sono tutti e tre diciamo così hanno verticalmente hanno le loro dimensioni proprie e non non vanno oltre ovviamente non c'è neanche bisogno quindi in realtà un esempio un po' un po' un po' immaginate avere del testo più più lungo oppure dei contenuti più complessi in questo caso i sotto elementi si contendono lo spazio disponibile quindi immaginate che abbiamo tre blocchi di testo molto lungo a quel punto tutti si accatassano insieme e devono dividersi lo spazio in qualche modo di default la colonna lo fa in maniera equa quindi dà uguale spazio a tutti i suoi finti diretti ok quindi è giusta quindi se noi avessimo un testo molto lungo avremmo del blu del giallo del blu del viola equidistribuito alla fine dei conti se questo non è quello che volete in alcuni casi il qualsiasi può essere utile invece avere che ne so un oggetto che è più grande o comunque ha il doppio dello spazio degli altri e così via in questo caso si può usare un oggetto flexible si chiama apriamolo qui al container blu faccio il widget forse vabbè possiamo vedere entrambi è uguale prima di expand expand cosa fa? expand prende un widget figlio e lo espande manualmente quindi all'interno di una colonna cosa avviene? che questo oggetto qui prenderà tutto lo spazio che può prendere in sostanza ok quindi questo è l'aspetto finale per cui adesso appunto cosa accade quando facciamo il layout praticamente il primo oggetto a fare layout è expand cioè quando la colonna deve fare il layout sui elementi la colonna ha a disposizione tutto lo spazio perché è massimizzata in verticale e fa pure stretch orizzontale quindi ha lo schermo a disposizione e si espande su tutto lo schermo va bene poi chiede ai vari container quanto spazio hanno bisogno questi qui sono tutti molto parchi molto modesti che prendono lo spazio del testo questo prende lo spazio del testo questo qui in questo caso expand si comporta in maniera golosa e dice voglio tutto lo spazio così ok per cui a questo punto la colonna è obbligata a dare tutto spazio al nostro primo elemento ok per cui quello si espande in maniera così perpotente e non collassa questi oggetti questi oggetti comunque ricevono lo spazio di cui hanno bisogno perché ne hanno bisogno in una quantità limitata ovviamente il resto disponibile viene dato all'expanded che è quello che richiede di più ok questo può essere senzato se abbiamo una riga o una colonna in cui abbiamo degli non so degli elementi a contorno che vanno alla destra o alla sinistra di un elemento più importante in quel caso l'espanded più importante magari applichiamo expanded e gli elementi appena destra appena sinistra comunque hanno lo spazio al loro dedicato fisso che non viene rubato però il resto viene occupato da expanded se ci sono più expanded nella stessa gerarchia chiaramente entrambi si comportano in maniera golosa e si dividono lo spazio quindi se applico l'expanded a questo la zona blu e la zona viola praticamente si dividono lo spazio ok perché sono entrambi espanzi in più l'expanded ha come proprietà come costruttore come parametro un campo flex che è un intero e quello praticamente è il moltiplicatore di potenza con cui si espande per così dire quindi se qui metto due di default è uno tutti gli expanded valgono uno di default se qui metto due vuol dire che questo expanded qui si espande al doppio della potenza di questo expanded qua quindi quello che avverrà è che il container ha uno spazio suo dedicato il resto dello spazio viene suddiviso in maniera tale da dare un terzo all'expanded qui sotto e due terzi all'expanded qui in alto questo vale due questo vale uno il total valgono tre e qui solo dividono in terzi quindi a questo punto ci sarà una preponderanza del blu rispetto al bione ok questo si comporta esattamente come il flexbox di CSS per cui l'ispirazione è proprio quella che se avete lavorato con il flexbox funziona esattamente così tra l'altro anche lo space between space events e così via su tutti i concetti che sono anche nel CSS per cui li ritrovate se volete e stessa cosa vale per il flex perché quella è il CSS la proprietà si chiama flex grow mi sembra e cos'è quanto se non ci sono text pendant quindi se tolgo questo il flex non ha alcun effetto quindi il fatto che questo sia 2 o 3 o 4 o 100.000 non cambia nulla perché essendo l'unico che spende veramente prenderà tutto lo spazio disponibile non cambia non può espandersi più di quanto non sia il massimo ovviamente sì questo qui sì questo è il moltiplicatore cioè se lo io per parlo mentalmente lo considero tipo dei palloncini che si confini in qualche modo con una potenza che è data dall'aria in sostanza questa è la potenza con cui lo stiamo espandendo di default è sempre 1 per cui se non mettiamo nulla questo vale 1 e se c'è solo un expanded non cambia nulla perché essendoci soltanto un widget palloncino quello che si conferrà fino a prendere tutto è buono se ce ne sono più di 1 quello che ha un flex maggiore si espande più rapidamente dell'altro in sostanza non so non so non so non so non so che tutta la pagina vale la somma dei flex ok quindi in maniera dinamico esatto esatto esatto quindi qui adesso è come se lo spazio è rimasto cioè un'olta che abbiamo fatto layout di questo che non è expanded rimane un tot di spazio mettiamo 100 pixel visto che abbiamo due expanded uno vale uno l'altro vale tre in totale farà fratto quattro ne dà un pezzo al primo e tre pezzi all'ultimo quindi questa è un po' l'idea adesso il 2 avrà un quarto dello spazio vuoto rimasto e questo avrà tre quarti dello spazio così chiaramente è un po' difficile prenderci le misure perché chiaramente bisogna sapere di cosa è composta l'interfaccia allo stesso livello dell'albero bisogna sapere se ci sono altri expanded o meno quindi non è proprio facile fare delle interfacce precise al pixel però se per esempio dobbiamo separare e fare una colonna che larga un terzo e una colonna larga due terzi è molto facile quindi expand uno vale uno lato vale due e a quel punto è diviso in quella maniera a parte l'expand c'è un altro oggetto che è molto simile che è il flexible che si comporta alla stessa maniera ci perchiamo tempo perché non aggiunge molto però il flexible è la stessa roba con qualche propria in più però per il resto non questo ci dice come se se si si adatta in maniera stritta sui contenuti no è tight scusate flex era 3 prima lo lasciamo così ok ok adesso non ha molto senso perché questo qui non vediamo non c'è solo spostamento però c'è il fit si applica all'oggetto fuori dovrei allinearlo questo comunque cambia soltanto come disporre poi i soggetti internamente quindi adesso il uso il fit non cambia nulla perché questo è sempre in alto a sinistra perché è sempre in alto a sinistra però in un esempio il flexible si adatta in maniera stretta sui suoi contenuti in altro caso si espande su tutto lo spazio disponibile però cambia poco e tanto male usare Xpand che è più chiara in sostanza ok questo per quanto riguarda le righe e colonne fondamentalmente che come dicevo prima generalmente è quello che ci serve per creare delle interfacce più meno sofisticate in alcuni casi ci serve uno strumento ancora più primitivo se vogliamo che è lo stack lo stack è un contenitore esattamente come righe e colonne però invece di mettere in pila i suoi figli i widget figli li mette uno sopra l'altro quindi li mette graficamente uno sopra l'altro quindi nell'esempio qui vediamo c'è lo stack ha tre figli e l'effetto grafico è questa cosa che in sé non è molto gradevole cioè li renderizza proprio uno sopra l'altro perché sono tutti i suvrapposti anche sempre questa cosa in sé non ha molto però in alcuni casi ci può tornare utile per alcuni effetti grafici in cui abbiamo bisogno di avere questa sovrapposizione di elementi magari facciamolo al volo così lo vediamo in pratica allora per mostrarlo in pratica la tolgo e li vai spendere così che dentro lo stack non hanno molto senso quindi remove questo remove questo ok a questo punto modifico la colonna in stack e tolgo queste proprietà qui che non hanno senso dentro uno stack ovviamente ok quindi la colonna è diventato uno stack e quello che fa è impilare tutti i suoi elementi come può tra l'altro vedete che lo stack viene centrato per cui in realtà lo stack occupa lo spazio minimo necessario per contenere sui tre elementi che sono i due testi piccoli e il testo grande quindi in realtà i testi piccoli sono nascosti dal testo grande sono sotto il testo grande qui sono qui in mezzo il tasso sono qui in alto in realtà perché dispone in alto a sinistra quindi qui sopra c'è ciao c'è ciao mondo quello che è e poi sopra tutto coperto dall'altro elemento e poi lo stack visto che si comprime lo quanto possibile viene poi centrato dal center da questo qui per renderlo evidente magari possiamo mettere il testo blu dopo il testo viola l'ordine con cui vengono risposte dipende da come vengono messi nell'ordine dei film qui si vengono renderizzate esattamente per come vengono presentate nel testo nel codice scusate quindi in questo caso abbiamo il giallo prima poi il viola poi il blu che errore ho messo ok a questo punto dovremo vedere il blu che sovrasta il viola in alto a sinistra quindi qui mi aspetto c'è un mondo sopra ok quindi sono uno in pilastro con l'altro sono stretti lo stack stesso ha fit come si chiama esatto che può essere lose o expand expand lo espande su tutto lo spazio disponibile lose invece lo lascia libero e quindi si compatta se lo espandiamo che cosa accade che prende lo spazio disponibile e non ci saranno più questo elemento bianco fuori come? no tutti gli elementi però visto che l'ultimo elemento è quello più in alto li copre tutti ok quindi ecco certo questo rende evidente il fatto che lo stack è inutile nella maggior parte dei casi se non poi ci facciamo dei giochi che poi useremo più avanti sì esatto animazioni o cose che compaiono scompaiono quindi in genere se abbiamo uno stack degli eventi magari ci serve perché sopra ci mettiamo qualche pagina che compare scompare e di solito si usa lo stack in questo caso oppure cose che si spostano se vengono animate in qualche modo e qui se mettiamo loose dovrebbe tornare a prima esatto quindi default è proprio loose anzi mi ril 어�esso dal test anche ok Quindi lo stack è questo e di suo, diciamo, non è parzialmente utile, ma ci permette all'interno, se abbiamo uno stack composto da una serie di elementi, possiamo usare degli elementi di posizionamento, dei widget di posizionamento, per ulteriormente definire come, cioè dove mettere gli oggetti al termine di uno stack. Per cui, center l'abbiamo già visto, quindi center già conosciamo che si comporta. Se volessimo, potremmo, per esempio, questo oggetto qui potrebbe venire centrato e a quel punto comparirebbe, nuovamente sarebbe prendere tutto lo spazio, nuovamente prendere tutto lo spazio che viene espanso dal fatto che lo stack si espande, ma se lo centriamo, allora è center che si espande e poi mette al centro il suo elemento. Center, come funziona? Center si espande lui e mette al suo centro il figlio. Quindi il container che è blu compare in mezzo. A questo punto finalmente vediamo l'elemento sotto, cosa che prima non vedevamo. Quindi center già la conoscevamo, però ci sono anche altri widget di elemento, che sono align, che permette di allineare l'elemento in varie posizioni prefigurate, quindi per esempio bottom light, quello che è, magari possiamo farlo anche al volo con il nostro elemento viola, così che vedremo l'elemento giallo. Bottom light, direi che va bene. Viola, cioè sotto a sinistra, però chiaramente sinistra ha poco effetto perché il viola comunque occo contro lo spazio, prima del giallo che occo contro lo spazio. Questo se vogliamo possiamo usare reposition, che è un po' particolare, si usa molto raramente perché ci richiede di esprimere in maniera esplicita la posizione di un oggetto, quindi si usa in casi veramente molto rari. Vedete che avrà top, right, left, height, width, così via, quindi ci permette, sono tutti quanti opzionali, per cui possiamo esprimere anche soltanto una di queste proprietà, e il position cercherà di spostare l'oggetto all'interno del widget padre, che attenzione deve essere uno stack. Quindi position ha effetto all'interno di uno stack, che permette di spostare l'oggetto al suo interno. chiaramente se il position fosse all'interno di una colonna, di una riga, che già gestisce le posizioni, non ha molto senso, quindi il position non funziona se non come figlio diretto o indiretto dello stack. In questo caso magari possiamo mettere top 10, magari così lo stiamo spostando, in modo tale da essere a 10 pixel dall'alto, dal top. Ok, adesso a questo punto vediamo tutti gli elementi, quindi il rosso è lo sfondo dello stack, questo è a 10 pixel dall'alto, questo è al centrato, questo è allineato a fondo a sinistra. Giusto? Ok, così. E facendo così possiamo giocarci un po' la nostra interfaccia grafica, usando lo stack, se vogliamo. Queste di nuovo sono le varie opzioni che abbiamo, chiaramente. Un altro elemento che abbiamo già visto e che è ancora più primitivo è il sized box, che è un elemento che semplicemente prende un tot spazio, se chiaramente si riesce all'interno del suo genitore, e cerca di costringere il figlio a sua volta di prendere lo stesso spazio. Ok, l'unica proprietà importante è che se usiamo sized box, sized box, diciamo, non so, largo 100, alto 100, anche il figlio viene espanso a 100, quindi è utile, nel caso più classico, magari sapete, dovete mostrare un'immagine o qualcosa che ha una dimensione dinamica, un'icona, un avatar di qualcuno, eccetera, eccetera, in una dimensione fissa, sized box è vostro amico in questo caso, perché mi permette di specificare dimensioni in maniera esplicita e il figlio si comporta, si adatta direttamente a lui. Un altro elemento molto usato è il padding. Padding è semplicemente un widget invisibile che vi dà dello spazio, quindi classicamente si usa per dare un po' di aria attorno agli elementi, quindi il classico scenario utilizzo in questo caso serve per dare dell'aria attorno al nostro container, quindi il nostro container rosso contiene a sua volta lo stack e così via, e tutti i widget figli sono tutti allineati in maniera netta contro il bordo della nostra applicazione, cosa che in genere non è una cosa bellissima, c'è sempre un piccolo bordino interno necessario per i testi e quant'altro per renderli fruibili, per cui in genere il primo elemento che si incontra nella gerarchia di widget all'interno del body di una qualsiasi pagina della nostra applicazione, di solito è il padding, quindi quel minimo di margine ai lati che permette di rendere la interfaccia non orribile, e quindi qui possiamo metterla attorno al center, quindi center centrerà a sua volta i suoi contenuti, però può essere utile metterci un padding sopra, quindi mettiamo un padding, ok, e padding come si definisce la sua dimensione? Con la proprietà padding richiesta e che si popola usando la classe edge and sets, quindi diciamo così spaziature dagli angoli, sarebbe a dire, che ha vari costruttori in base a quello che vi interessa, quindi qui abbiamo all, che è la stessa spazzatura su tutti gli angoli, sopra, sotto, sinistra e destra, left, top, right, bottom, quindi qui potete esprimere spazzature diverse sui quattro angoli, questa spazzatura soltanto su un angolo, e spazzatura simmetrica, se vogliamo, ok, per cui all è il più classico, all con 20 magari, darà lo stesso spazio di 20 su tutti gli angoli, questo spostará anche il rosso chiaramente, ok, il rosso è il contenitore, all è su tutti gli angoli come vedete, from LTRB, ci potete esprimere in maniera posizionale, left, top, right, bottom, questa forma qui, che somiglia molto a come si esprimono, si esprimono in CSS, seppure l'ordine non è quello, quindi left magari 10, 20, 30, 40, quindi left sarà 10 pixel, top sarà 20, right sarà 30, e bottom sarà 40, adesso questo non è, forse è un'esensato, ma può aver senso alcuni scenari, e poi a comune, molto spesso si usa simmetric, che vi dovete esprimere, i pixel verticali, i pixel orizzontali, che spesso ha senso, classicamente nell'interfaccia utente, è bene avere spazzature verticali minore, spazzature orizzontali, perché la visione umana, diciamo che si apprezza la spazzatura orizzontale, perché è la direzione in cui gli occhi guardano, in genere, e in genere anche gli schermi, hanno una dimensione orizzontale maggiore, questo non è vero, chiaramente per lo smartphone, classicamente, però per gli schermi tradizionali è così, per cui in genere, una buona suddizione di spazzature, potrebbe essere 8-16, o cose di questo genere, quindi 8 in verticale, 16 in orizzontale, beh, ho tagliato perché devo dargli i nomi, quindi, orizzontale 16 e in verticale, ok, così, funziona meglio, ok, quindi questo è quanto, ok, finiamo un altro discorso molto rapido, perché a questo punto, mi ho perso un portale io, vabbè, a questo punto è troppo tardi, però lo facciamo domani, dico l'ultima cosa, il container è, forse, appunto vi dicevo, è l'esempio più classico, di un widget molto semplice, che però in realtà, nasconde una complessità, tutt'altro che, come dire, prevedibile in qualche modo da fuori, perché ha tantissime proprietà, con cui possiamo configurarlo, color è corrispondo, e fin qui, è abbastanza intuitivo, in realtà come vedete, ha varie altre opzioni, può allineare internamente, il suo contenuto, quindi si comporta, assolutamente come un widget align, se volete, se questo non lo specificate, chiaramente non lo fa, però può farlo, può dare dei constraint, quindi può comportarsi, può mantenere una proporzione, se volete, può essere decorato, quindi può avere un bordino, un'ombreggiatura, e così via, questo è un secondo, e può avere delle altezze fisse, quindi si comporta come, grandezze fisse, perché si comporta come un size box, se volete, può avere margini e padding, quindi si comporta come il padding esterno, o interno, che cosa significa margin e padding? Margin è il padding al di fuori del container, quindi fuori dal colore, deve dire, margin, se lo applichiamo, crea un piccolo padding fuori, dallo spazio colorato, padding invece crea un piccolo spazio, all'interno del container, per vederlo in pratica, possiamo farlo su quello viola, magari, quando possiamo farlo, quindi, e quindi, broadcasting a delle destelle, ancheордino a delle destelle ok, adesso, il cos'è che non va ok, è andato e allora quindi il margin è questo margine qui che sposta il container e lascia il bordo all'esterno quindi il container è questa parte viola però al di fuori ha un margine di 10 pixel all'interno ha un padding di 20 pixel che è lo spazio che divide il contenuto il figlio, questo text qui, dal container stesso ok, quindi padding è interno poi c'è il bordino e poi fuori c'è il margin esterno, questo funziona esattamente come nel CSS, se siete abituati al CSS ritornerà perfettamente naturale altra cosa possiamo decorare se invece di specificare un colore possiamo decorare il nostro container che è la cosa forse più sofisticata che si può fare tra virgolette per cui qui si usa in genere un box decorator che è un oggetto che ci dovete decorare delle cose decorare cambiare graficamente gli oggetti che sono quadrati nello spazio come ovviamente è il caso del nostro ben amato container se usiamo decoration non possiamo usare color quindi se lasciassimo anche color qui Flutter si lamenterebbe perché il colore viene già dato al decoration quindi usiamo solo quello perché a sua volta qui c'è color quindi qui possiamo usare questo come color ok qui possiamo specificare un bordo per esempio box border scusate box border che ha altre proprietà che sono colore e ah no border all ok ha vari costruttori in base se volete il bordo solo su un lato solo su un altro lato così via quindi in realtà adesso prendiamo un bordo tutto per farla breve di colore non lo so un colore bianco di larghezza 2 per dire perché sono tutte cose che sono molto simili a CSS per cosa di miglior funzionamento altra cosa si può fare si può rendere il bordo stondato e qui si usa tutti questi bei costruttori che sono così un po' vanno un po' scoperti però abbiamo un raggio di 4 al bordo e poi per concludere possiamo aggiungere anche un'ombreggiatura al nostro al nostro box con box shadow che è un array perché un box può avere più ombre di oggetti box shadow e a sua volta hanno una vagalanga di proprietà che possono definire quanto è sfumato il numero di giovane qual è il colore usiamo un'ombra non lo so un'ombra verde così veramente orribile offset offset from direction che è 120 che è 4 spazi buona tutta questa roba che ho scritto ok a questo punto con questa sintassi alleghissima molto comprensibile avremo ottenuto un container che è orribile da guardare sì quindi la scelta dei colori rimane sempre molto discutibile però ecco facendo cioè anidando in questa maniera il nostro oggetto abbiamo ottenuto un oggetto che trafficamente magari è quello che volevamo un senso estetico molto poco sviluppato e e questo è quanto in questa maniera in realtà il container è il nostro strumento numero uno per creare interfacce utente più o meno sofisticata quindi quello che quando è l'equivalente del div in html con cui si fa ben umano tutto andando a cambiare margini padding sfondi decorazioni e così via chiaramente il box decoration è l'oggetto di decorazione più semplice che si possa fare farsi su proprietà colori semplici e così via ma tutti questi colori qui possono diventare gradienti ovviamente possono diventare immagini e quant'altro quindi chiaramente possiamo ulteriormente complicare la interfaccia sempre comunque andando ad utilizzare il container il container è il nostro elemento grafico numero uno in genere con cui andiamo a costruire graficamente l'aspetto grafico della nostra interfaccia poi annidandola in vari altri oggetti si possono ottenere degli effetti che possono essere interessanti e magari meno offensibili queste cose che abbiamo creato chiaramente una volta che avete degli oggetti che sono comuni quindi componentizzabili l'idea è che non riscrivete questa roba da zero ogni volta ma create dei widget a se stanti che contengono questi stili di riapportamento una volta che avete definito un aspetto che vi piace lo prendete tagliate tutto lo rendete un widget a se stante e poi passate le varie cose che vi volete far mostrare questo può diventare un singolo widget al quale passate un widget qualsiasi che in questo caso è il text il text è l'unico elemento mobile che può essere ripiazzato quindi in quel caso questo oggetto qui che è un contenitore viola o un'ombra verde può ovviamente contenere anche un'immagine può contenere una lista può contenere una barra può contenere qualsiasi altro oggetto che sia un widget di file ovviamente esatto esatto e create una piccola libria di widget standard che sono coerenti con il nostro stile grafico e poi riciclate quegli elementi fin tanto che riuscite più generici sono chiaramente più facile riciclarli quindi questo è un oggetto che è solo un contenitore però chiaramente nello scenario più comune avete oggetto un po' più calato in uno specifico quindi magari avete delle barre già pronte che riciclate oppure una pulsantiera o comunque oggetti un po' più sofisticati di questo però sì comunque per tentativi potete in Flutter spesso se si lavora veramente in codice si va per tentativi quindi magari questo margine qui ci sta ma è un po' basso per cui lo cambio e grazie al hot reload si possono fare delle modifiche e apprezzarle subito e questo è molto comodo un po' come come si fa in HTML quindi basta fare modifiche in tempo reale quasi e poi si apprezzano quasi subito e questo va bene e poi in realtà quando si lavora magari su interfacce più complesse in realtà si parte da un design che viene magari da un programma di design proprio si lavora con Adobe XD o Figma e così via che permettono di farlo in maniera ancora più comoda di questa e poi sulla base di quello si vanno a creare i widget che vogliamo utilizzare però questo è un po' il meccanismo ok abbiamo perso un po' di tempo con l'interfaccia di dente ma tanto quello è quello che dovrete utilizzare per forza e quindi ben venga e da domani vediamo come fare un'interfaccia che adesso non abbiamo fatto quindi faremo una to-do list primitiva quindi una lista di oggetti che è l'ultimo widget fondamentale che non abbiamo ancora visto che è la lista di oggetti che è un altro caposaldo dei widget una lista di oggetti più o meno complessi però a quel punto gestiremo lo stato della nostra applicazione quindi avremo una lista di oggetti di cosa da fare e vorremmo che quella lista venga impropagata in automatica alla nostra interfaccia questa è l'idea finale a quel punto avete tutti gli elementi con cui operare e ragionare su come fare il progetto con sostanza poi magari ottenendo un aspetto che sia più soddisfacente di questo ok ci fermiamo qui e ci rivediamo domani grazie grazie grazie grazie grazie grazie