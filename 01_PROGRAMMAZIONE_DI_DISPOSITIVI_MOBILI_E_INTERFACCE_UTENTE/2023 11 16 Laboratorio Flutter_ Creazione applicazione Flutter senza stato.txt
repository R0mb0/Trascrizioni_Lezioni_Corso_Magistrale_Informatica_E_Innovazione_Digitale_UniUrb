iniziamo appunto vedendo un attimo il singleton in Dart e poi riprendiamo Flutter dove siamo rimasti in una situazione molto confusa dell'altra volta insieme al template di base che ci dà Flutter ma siamo accorti che è più complicato dal previsto e soprattutto che è più strano dal previsto per cui adesso andiamo a spulciare tutti gli elementi uno dopo l'altro e vediamo insieme come funziona così diventerà pian piano più chiaro in realtà nella mia esperienza nel provare a dare questo corso ho visto che man mano le cose si confondono e le cose non diventano necessariamente più chiare immediatamente per cui in realtà all'inizio ci sarà un momento di confusione totale in cui si deve passare necessariamente a un certo punto diventerà tutto chiaro questa è la speranza e la promessa che vi faccio in qualche modo però prima di provare con Flutter vediamo un attimo il singleton allora il singleton se ricordate da appunto nel software è un same pattern del codice per cui vogliamo che creare un oggetto cioè che un oggetto possa esistere soltanto in una singola istanza quindi nel tutto il nostro programma in esecuzione vogliamo che una classe X sia istanziabile una singola volta e quindi ogni volta che noi richiamiamo quella classe o la istanziamo nuovamente in realtà otteniamo la stessa istanza in vari linguaggi si può fare in vari modi diversi si può implementare in vari modi diversi questo pattern in generale se venite da C Sharp e Java quello che si fa in genere è si crea un metodo statico che dà accesso alla singola istanza di quell'oggetto e poi si passa per lì quindi per volerla rimplementare così un pseudocodice vediamo se riesco creiamo la nostra classe singleton.dart ok? se vai a scrivere cioè scrivendo C Sharp pseudo C Sharp questo è il mio singleton e io farei una cosa del genere cioè creerei un private static singleton che si chiamano distanza e poi farci in modo che la classe non sia istanziabile da fuori ok? quindi crea un costitore privato questo fa sì che nessuno possa costruire una classe se non la classe stessa che è un po' controsenso però poi si lascia costruire tramite un un metodo o una proprietà statica come questa per esempio quindi questo potrebbe essere l'accessore al singleton questo è C Sharp che probabilmente non è non so se è valido ma ci provo se l'istanza è nulla allora creo il singleton e poi ritorno l'istanza ok? adesso a parte errori di battitura dovrebbe essere C Sharp abbastanza legale perché a questo punto l'istanza può essere soltanto una la posso costruire soltanto io quindi da fuori chi crea chi vuole accedere a singleton come deve fare lo fa tramite il getter quello appena sopra quindi farà singleton.instance e questo dà accesso all'istanza singola giusto? quindi questo si fa più o meno così in Java si può fare in maniera simile ovviamente non avendoci non essendoci i getter faremmo con un metodo quindi faremmo con un getter instance però non cambia la sostanza la stranezza cioè quindi questo pattern è abbastanza naturale però in C Sharp è un elemento alieno perché appunto invece di costruire un oggetto bisogna passare per questo metodo magico questo getter qui che non fa altro che darci distanza per cui si può fare una cosa che si vede in tante librerie in tanto codice che viene utilizzato all'atto pratico quindi non c'è nulla di male però Dart aggiunge un elemento a questo pattern qui che lo rende in mente più naturale nel senso che il singleton non dovrà passare attraverso l'istanza ma potrà passare attraverso il costruttore grazie al fatto che usiamo un trucchetto che in Dart si chiama il costruttore factory adesso volgo questo magari lo togliamo tanto non serve a molto per darvi l'idea chiaramente la stessa cosa si può fare anche con C++ derivati quindi può prima farle maresalze facciamo la stessa cosa in in in Dart quindi creiamo un costruttore privato che appunto diciamo sarà privato al file che non alla classe come sappiamo in Dart quindi non c'è modo per rendere privato alla classe ma lo lo mettiamo al file se è un altro dandogli un nome e dandogli l'underscore per iniziare quindi lo chiamerò internal e questo è il costruttore privato interno ok questo è un costruttore che ha un nome interno e basta quindi a questo punto la classe può essere installata soltanto tramite questo costruttore qui nominale interno e nessuno può farlo perché chiaramente non è la sua visione di questo costruttore tant'è che da fuori se provassi a costruire singleton mi darebbe errore ok questo non è importato come? si non è importato neanche quindi mi dà errore a maggior ragione però anche se l'importa non è accessibile quindi non posso così benissimo a questo punto voglio fare in modo che ci sia soltanto distanza quindi distanza la renderò statica esattamente come l'ho fatto prima in C Sharp e lo faccio con static singleton e questo sarà la mia istanza e di nuovo sarà privata quindi con l'underscore instance questo adesso è non nullable quindi qui Dart si arrabbia perché chiaramente questo può essere null quindi lo rendo nullable ok bene così non è usato ma questo lo devo fare un secondo bene a questo punto serve un modo per avere accesso a questa famigerata istanza che è sempre soltanto una quindi il nostro unico singleton qui voglio voglio accedervi in qualche modo normalmente lo posso chiaramente fare come cioè se vengo ad assiste lo potrei fare con un metodo statico una cosa tipo get instance e così via quindi questo lo potrei fare quindi a questo punto io farei if instance uguale uguale null allora lo costruisco perché ho venuto di posso farlo ok lo vedo questo è legale a questo punto posso fare return instance ok a questo punto da fuori ah sì c'è la nulla non possiamo farlo così che è più bello in effetti più elegante ehm giusto se non sarà nulla ok e va bene questo va benissimo ma non è proprio come Dart vuole che scriviamo il codice perché possiamo usare direttamente un costruttore che è un po' più naturale sull'altro lato quindi la stessa cosa la possiamo fare con un costruttore ehm factory quindi con un ehm con un costruttore che è semplicemente così che però è factory quindi e qui dentro facciamo la stessa cosa che viene fatta qua quindi questo qui è la stessa cosa di qui ok ora da fuori quindi questo in realtà possiamo probabilmente agassarlo era solo per farvi vedere che è la stessa cosa ok su questo lato qui a questo punto questo funziona con un costruttore normale quindi questo è diventare legale S è utilizzabile ok e ehm posso fare cose tipo ops posso farlo non è nel caso S2 eh singleton e poi posso verificare che ok e faccio la classica gameta identico che sarà S1 e S2 adesso non mi metto a eseguirlo ma diciamo ci aspetteremo che ci aspettiamo che S1 e S2 sia la stessa variante ah ok come funziona questa cosa qui giusto per chiudere eh cos'è il factory il factory significa che nonostante quello sia un costruttore in termini pratici cioè a livello di sintassi è un costruttore quindi lo usiamo esattamente come un costruttore classico sull'altro lato quindi sul lato di chi utilizza il nostro la nostra classe eh l'utilizzo di quell'oggetto non cambia in alcun modo quindi non c'è nessuna sintassi arcana da ricordarsi qualche metodo statico così via è un oggetto che si può costruire la differenza del factory è che factory non è un costruttore che costruisce un oggetto paradossalmente cioè quindi questo oggetto qui nonostante sintatticamente somigli a un costruttore in realtà non costruisce un oggetto ok quindi qui l'oggetto non viene costruito non c'è un'istanza nuova ma questo metodo qui che somiglia a un costruttore a livello sintattico ritorna un oggetto già costruito questa è l'unica differenza ok quindi il factory è un metodo è un costruttore fasullo tra virgolette che non fa altro che fare dei rimaneggiamenti interni e poi ritornare ad un'istanza valida di quella data class ok la differenza è che questo è un costruttore classico qui adesso ovviamente la classe non fa nulla per cui un po' di filo giustificare questa cosa ma mettiamo che qui ci siano delle stringhe non lo so dei canteri cose di questo genere questo costruttore qui chiaramente potrebbe inizializzarli in qualche modo quindi per esempio fa delle cose che adesso sono completamente inutili ma va bene per esempio quindi questo costruttore qui è un costruttore classico cioè standard un costruttore normale quando esegue crea un nuovo oggetto che va sullo heap vanno a memoria viene creato viene inizializzato viene rastringa e l'interno assumono un valore e poi dopo la costruzione dell'oggetto l'oggetto è finalizzato e può essere utilizzato questo è un costruttore classico questo è un costruttore che invece non crea un nuovo oggetto ma ne ritorna uno che già esiste sono due scenari classici in cui il factory si utilizza uno è il singleton appunto che è un scenario classico l'altro è se abbiamo una cache interna di oggetti quindi immaginiamo di avere un'altra classe che potrebbe essere una classe complessa sofisticata molto costosa da istanziare internamente potremmo avere un dizionario una mappa di oggetti già costruiti già pronti da essere utilizzati e a quel punto potremmo avere una costruttore factory che ottimizza il nostro codice andando a vedere se un dato oggetto che già che già corrisponde ai valori dettati dall'utente già esiste e poi ritorna qui se non esiste ne crea uno nuovo ok quindi dato questo è un altro pattern classico del libro di 3 patterns che si chiama che si chiama non me lo ricordo però è un altro pattern classico che fa caching nella costruzione degli oggetti qui la cache è un singolo elemento nel senso che il singleton è la cache fondamentale in cui c'è un oggetto e ritorno sempre quello immaginate di avere 100 oggetti già preparati qui quindi avete non più un'istanza singola ma una mappa di oggetti questo cambia molto no? la chiave potrebbe essere quella che vedete e così via e a quel punto il vostro metrò static potrebbe andare a pescare l'istanza di singleton qui dentro ok la differenza è questa qui ci si può sbizzarire e compiegare le cose come uno vuole però l'idea del factory è che è un costruttore finto che delega il lavoro di costruzione a un costruttore vero che in questo caso è questo e che non fa altro che tornare l'oggetto già ok chiaramente qui può fare delle altre operazioni sull'oggetto prepararlo modificarle e così via che in questo caso non ci interessa però questa è l'idea ok a posto basta chiudo e torniamo al nostro beniamato Flutter meglio che ci siano delle domande ma se no direi che andiamo avanti ok abbiamo visto la volta scorsa il template base però non mi sono soffermato su Flutter in generale qualcosa che abbiamo già visto abbiamo già discusso insieme adesso ripartiamo un po' da zero giusto per darvi una imparinatura di quello che è Flutter come funziona fondamentalmente e poi proprio ripartendo da zero vediamo proprio gli elementi di base così da capire meglio come funziona come vengono utilizzati per creare qualcosa che somiglia al template di base di Flutter quindi in qualche modo ci arriviamo piano piano in modo tale da renderlo più più chiaro perché se no partire da zero con quell'esempio lì non è particolarmente illuminante di solito per cui cos'è Flutter? questo lo sappiamo già è il toolkit per UI di Google che ci permette di creare applicazioni native questa cosa è importante applicazioni grafiche native per varie piattaforme con una singola con un singolo con un singolo con un singolo code base quindi un singolo code sorgente al momento le piattaforme supportate sono sei qui ne manca manca Linux come come icona quindi abbiamo Android Windows desktop diciamo così web quindi il browser tra virgolette quello che stiamo usando per le nostre prove iOS quindi iPadOS e macOS iPadOS per somiglianza vengono racchiusi con la stessa piattaforma quindi sono sei piattaforme che riusciamo a servire con la senza quasi senza modifiche nel nostro codice quindi dico quasi perché qualche modifichina ogni tanto serve per distinguerci da una piattaforma all'altra però per il resto in maggior parte dei casi Flutter permette di gestire tutto quanto senza alcuna modifica l'unico elemento cioè di questo che è importante ricordare è che appunto si parla di applicazioni compilate nativamente perché a differenza di quello che accade con tanti altri toolkit multiplattaforma l'applicazione che andremo a generare che andiamo a generare con Flutter cioè o meglio che andremo a compilare con Dart e poi ci dà il nostro eseguibile è un'applicazione nativa al 100% quindi un'applicazione che gira nativamente sul processore del dispositivo su cui andiamo a seguire l'applicazione e quindi non c'è nessun passaggio intermedio questo è diverso ovviamente su altri toolkit che tutto sommato sono simili multiplattaforma quindi per farvi un esempio con React abbiamo promesse abbastanza simili a vero di piattaforme di destinazione ma React usa HTML CSS e JavaScript internamente quindi in realtà usa tecnologie web che poi è vero che con React Native possono sposarsi in qualche modo con gli elementi nativi della piattaforma su cui andiamo a girare però di base abbiamo un'applicazione che si basa su un runtime che non è quello ma il runtime web per virgolette stessa cosa vale per Xamarin che adesso è diventato MAUI ultimamente Xamarin come si chiama multilattaforma che nasce in ambiente .NET diciamo così ugualmente permette di generare applicazioni per Android iOS per Windows e Mac OS però lì si porta dietro tutto .NET quindi quello che andiamo a generare è un'applicazione .NET che gira su runtime .NET che poi gira sulla piattaforma di destinazione quindi chiaramente è un approccio un po' diverso con delle complicazioni e che hanno un impatto anche nelle prestazioni delle applicazioni questa è un'applicazione invece che è nativa per il dispositivo che andiamo a usare come come bersaglio di compilazione in qualche modo con la forza esatto e questo è a maggior ragione vale anche per le piattaforme embedded questa è una settima piattaforma potremmo dire che non è ancora stabile è stata preannunciata in tante in tante occasioni non è mai stata non è mai diventata una delle piattaforme native di Flutter però concettualmente esiste anche una variante di Flutter diciamo così che è Flutter embedded che gira anche su dispositivi con capacità molto ridotte quindi con schermi integrati e prestazioni molto limitate e anche lì in quel caso possiamo girare con quasi gli stessi diciamo così elementi di base che usiamo per piattaforme più plasonate e più potenti in termini di prestazioni chiaramente quindi potenzialmente ci sono varie possibilità a livello di output diciamo così del nostro progetto ad online ci interessa realmente poco ma giusto per dirvi che Flutter è relativamente recente come tecnologia però in realtà pur essendo recente ha comunque otto anni sul gruppone tra molte virgolette per cui la prima tentativa di uso di Dart in ambiente mobile era si chiamava progetto Sky che è stato presentato al summit dei produttori Dart nel 2015 e questo si basava come vi anticipavo prima cioè l'altra volta sulla capacità di Dart di trans codificare fare transpilazione per JavaScript quindi la capacità di scrivere codice Dart che appunto è attivizzato a tutti i vari crismi di programmazione statica e quant'altro compilarlo in JavaScript e poi farlo girare dentro il browser in sostanza quindi Sky era il primo approccio di usare questo strumento fondamentalmente per creare applicazioni che girassero su ambiente mobile poi da lì Google è partito con un piano abbastanza ambizioso che ha visto prima l'alpha poi la beta e poi finalmente la pressione stabile nel 2018 di Flutter che era proprio l'idea di avere un sistema che potesse girare su tutte le piattaforme mobili semplicemente rimplementando tutto quello che è l'aspetto grafico dell'applicazione perché fondamentalmente quello che fa Flutter è di darvi uno schermo bianco vuoto su cui lavorare e poi rimplementare tutti i concetti fondamentali della piattaforma su cui andrà a girare in modo tale da evitare di dipendere dalla piattaforma stessa e quindi darvi la possibilità di avere un singolo codice per tutte le piattaforme questa è un po' l'idea cos'altro le versioni maggiori hanno avuto varie quindi nel 2018 era la prima versione stabile nel 2021 visto Flutter 2 che ha integrato cioè ha introdotto il supporto ufficiale alle applicazioni web e il supporto beta per l'applicazione di Dextra e poi Flutter 3 che è l'ultima rilasciata come versione maggiore ha dato il supporto stabile per tutte le sei piattaforme di cui vi dicevo prima la versione minore attuale che stiamo utilizzando deriva da Flutter 3.3 che è stata presentata in agosto dell'anno scorso che ha presentato anche una preview di un nuovo di un nuovo motore grafico interno che è questo impeller che in realtà non vedremo che vale solo per iOS e che lo rende ancora più efficiente come funziona di base? allora funziona diciamo fondamentalmente funziona in questa maniera ossia un'applicazione Flutter è un'applicazione scritta in Dart prevalentemente quindi noi andiamo a lavorare in Dart e la maggior parte dei componenti di Flutter sono ugualmente scritti in Dart per cui quello che vedete lì che è descritto come framework è tutto implementato in Dart ed è composto una serie di sottocomponenti che noi possiamo sfruttare nella nostra applicazione partendo dalla base c'è la foundation che sono tutti i componenti le classi di base che ci permettono di definire i colori definire i pixel definire queste cose qui poi sopra c'è tutto il i componenti di renderizzazione animazione gestione degli input e così via fino ad arrivare a quelli che sono gli elementi grafici fondamentali che sono i widget i widget sono quello che potremmo così collegarli al concetto di finestra quello che intende quindi è un elemento grafico che può essere presentato a schermo e che in qualche modo può essere composto con altri widget per darci l'effetto grafico sperato sopra questo quindi i widget sono un elemento grafico fondamentale sopra questo ci sono due diciamo così due famiglie fondamentali di widget di default che abbiamo a disposizione che sono i widget material che sposano il material design di Android e poi i widget cubertino che sposano invece il design di iOS e derivati questi li abbiamo dentro il framework di base di Flutter quindi Flutter nativamente si porta dietro queste due macro famiglie di widget già pronti all'uso e quindi chiaramente di base possiamo creare applicazioni che sembrano native grazie ai widget material e grazie ai widget cubertino su piattaforma Android e iOS rispettivamente se abbiamo bisogno di sembrare nativi su altre piattaforme chiaramente bisogna portarci dietro cioè importare qualche altra libreria aggiuntiva che ci dà altri widget che somigliano allo stile grafico alla linea guida standard per quella piattaforma specifica se vogliamo altrimenti chiaramente possiamo unire stili linee di design e piattaforme che non sono tra i loro coerenti senza che questo impatti in alcun modo il funzionamento della nostra applicazione se non nel fatto che poi l'utente magari si trova un pochino spaisato nell'utilizzare l'applicazione tutto il framework di flat è appunto dicevo implementato in dart e sotto c'è un engine quindi il motore grafico di base quello che potremmo chiamare runtime e derivati questo se vogliamo essere la nomenclatura che siamo abituati che è scritta in C++ e che include una serie di strumenti di base c'è Dart quindi il linguaggio stesso il runtime del linguaggio stesso che utilizziamo c'è il sistema di composizione del testo quindi quello che lì chiama text molto banalmente e poi c'è Skia che invece è un motore grafico che forse conoscete già ce lo dovete nominare forse è un motore grafico 3D accelerato che permette di presentare grafica poligonale su schermo è stato utilizzato e si può utilizzare per tanti scopi diversi Skia quindi si può utilizzare come motore grafico di base si può usare per creare dei videogiochi si può usare per fare tante cose diverse se avete eseguito un po' lo sviluppo di Android alcune versioni prototipali di Android sono state reimplementate sopra a Skia anche in alcune parti non è un progetto ancora in divenire a quanto so e così via quindi è un motore grafico esattamente come potrebbero essere le OpenGL un sistema grafico esattamente come potrebbero essere le OpenGL o le DirectX per altre piattaforme quindi Skia assolve un po' i stessi scopi e è la parte che sta per essere rimpiazzata con Impelers ok quindi in parte quindi è una il rimpiazzo di Skia e di parti del framework che si può come dire indirizzare il sistema diciamo così stanno per essere rimodernati in buona parte però fondamentalmente fino ad oggi c'è Skia sotto che si occupa di presentare i pixel a schermo in sostanza è un motore che è utilizzato da vari altri sistemi tra cui Firefox che ho scritto evidentemente non lo ricordavo e fondamentalmente si occupa appunto di presentare i pixel a schermo e tradisce in qualche modo la natura con cui funziona Flutter cioè Flutter vi da uno occupa completamente lo schermo dell'applicazione che voi andate a programmare e poi ci renderizza dentro i widget di cui è composta l'applicazione per cui diciamo così da fuori chi il sistema la piattaforma che ospita la vostra applicazione Flutter non ha alcuna idea di quello che sta venendo all'interno perché agli occhi della piattaforma quindi di Windows Mac OS Android e così via quello è uno schermo occupato al 100% da un'applicazione grafica che sta renderizzando delle cose tridimensionali su schermo esattamente come un videogioco per esempio solo la differenza è che questo videogioco implementato con Skia e Flutter renderizza delle cose grafiche che somigliano all'interfaccia grafica classica detto qui però agli occhi del sistema quella è una schermata accelerata graficamente che viene presentata a schermo e la occupa integralmente per concludere questa visione architetturale questo è quello che avviene con React Xamarin che diciamo così è l'approccio classico per cui come funziona classicamente abbiamo a sinistra abbiamo la nostra applicazione cioè la parte che noi implementiamo e la libreria che ci portiamo dietro quindi immaginiamo di scrivere un'applicazione con React Native in questo caso scriviamo l'applicazione con JavaScript o TypeScript o chi per lui poi questa applicazione qui si porta dietro React Native quindi che in questo caso si chiama viene identificato da quel bridge lì come brocchetto verde e quella è la parte del nostro applicativo quindi è la nostra applicazione cioè il nostro codice che parla con React React fa da bridge quindi da connettore in qualche modo questo connettore cosa fa ogni volta che la nostra applicazione ha bisogno di un pulsante di un testo a schermo di una lista di un oggetto classico che cosa va a fare va a crearne uno nativo della piattaforma quindi va a parlare con la frecetta in alto che vedete la frecetta che parla con gli OEM widgets quindi widget di default sarebbe widget della piattaforma stessa e li presenta a schermo quindi come vi dicevo prima se avete bisogno di un pulsante a schermo con React React traduce il vostro bisogno di un pulsante a schermo in tutte le chiamate del caso per produrre un pulsante che è un pulsante nativo quindi quello che avviene è che se definite un pulsante in React Native e poi lo fate girare su Win32 alla fine dei conti quello che viene fatto è una create window con la classe button e al quel punto avete un pulsante di Win32 dentro la superficie per cui l'applicazione è nativa e i componenti di recomposta sono oggetti nativi che sono coerenti con la piattaforma questo per quanto riguarda l'aspetto grafico se avete bisogno di servizi aggiuntivi come il GPS i prodotti i sensori la fotocamera l'audio eccetera sono tutti servizi sotto vedete i componenti blu sono quelle native della piattaforma ai quali potete accedere sempre tramite il bridge di React di React vi offrirà una serie di metodi di chiamate di sistema scritte per javascript che non fanno altro che tradurre la vostra chiamata in qualcosa che funzioni sulla piattaforma come vi trovate quindi Win32 Android e così via Flutter stravolge questa cosa qui andando a cassare quella parte di OEM widgets tutti i widgets nativi dai piattaformi vengono scartati integralmente perché vengono reimplementati da Flutter stesso quindi quando siamo Flutter abbiamo il nostro codice che è scritto in codice nativo cioè è meglio è scritto in Dart e poi viene compilato in codice nativo quindi è un binario nativo della piattaforma quindi x86 x64 ARM o quello che è o javascript se giriamo tutto il browser quindi il codice nativo tra virgolette per il web chiaramente è javascript quindi nativo tra virgolette dipende un po' da dove ci troviamo e poi ci sono la sistema di rendering integrato per Flutter che presenta schermo le cose e poi i widget che non hanno nessun legame con i widget della piattaforma quindi la parte blu del widget della piattaforma sparisce completamente e Flutter fa tutto quanto lato applicazione e poi presenta l'immagine finale direttamente sul canvas quindi sullo schermo finale della piattaforma questo è il fatto quindi ci risolviamo alcuni problemi di compatibilità che spesso sono causati da implementazioni parziali comportamenti diversi delle piattaforme e così via con il fatto che è tutto lato Flutter quindi Flutter fa tutto quanto e noi non abbiamo bisogno di implementare nulla di piattaforma in piattaforma stessa cosa per i servizi i servizi funzionano un po' alla stessa maniera quindi c'è quello che qui si chiama Bridge che in Flutter si chiama Platform Channel quindi in qualche modo è un canale che dipende dalla piattaforma che si collega ai vari servizi e quindi va a parlare con i servizi nativi da quel punto di vista non cambia molto la cosa che cambia profondamente è chiaramente come si presenta l'interfaccia utente ok vantaggi e svantaggi che si potete immaginare un po' da soli però per vederli insieme quindi avete il controllo totale dei pixel perché chiaramente la differenza in questo mondo qui è che quando andate a creare un pulsante in base alla plataforma su cui vi trovate e in base anche alla versione della plataforma su cui vi trovate quindi se passate da Windows che ne sono vista a Windows 11 chiaramente il pulsante standard cambia radicalmente quindi se la vostra applicazione cambia sistema cambia anche il suo aspetto grafico questo in Flutter non avviene perché il pulsante viene reimplementato a zero da Flutter stesso quindi sapete al 100% cosa vi aspetterà perché ci pensa Flutter e quello non cambia a meno che voi non cambiate chiaramente le versione di Flutter a quel punto le cose possono essere implementate diversamente però finché voi non cambiate la versione di Flutter quel pulsante lì rimarrà coerente graficamente e il comportamento il fatto che tutta la grafica sia annidata nella vostra applicazione fa sì che per modificarla non dobbiate ricompilare tutta l'applicazione qui in questo scenario qui visto che parte dell'interfaccia utente dipende dalla pattaforma fa sì che per vedere gli effetti delle modifiche che fate nel vostro codice voi dobbiate ricompilare tutto e rilanciare tutto quanto da zero perché poi l'applicazione deve ricreare l'interfaccia tramite il widget standard della pattaforma questo in Flutter può essere evitato perché tutta la parte grafica risiede dentro la vostra applicazione per cui quando facciamo debugging in Flutter c'è questo meccanismo molto comodo del hot reload per cui dentro il codice nativo della vostra applicazione c'è il debug in Flutter che non fa altro che ospitare il vostro codice e rilanciarlo quando c'è bisogno e può rirenderizzare l'interfaccia utente da zero perché la fa lui quindi si occupa al 100% Flutter stesso e quindi non deve andare a rilanciare l'intera interfaccia per ogni singola modifica questo è comodissimo nel web appunto funziona un po' meno idealmente come su altre piattaforma però se lavorate su Android o su iOS questo principio di hot reload è veramente molto comodo che basta fare piccolissime modifiche fare hot reload e immediatamente vedete l'effetto delle vostre modifiche nell'applicazione che sta girando effettivamente sulla vostra piattaforma le piattaforma sono native per cui sono compilate e hanno accesso a tutte le prestazioni e le performance del dispositivo non abbiamo accesso alle widget UI native e l'interfaccia è pienamente dichiarativa cioè non dobbiamo usare non dobbiamo aggiornare l'interfaccia utente in maniera manuale questo è l'aspetto più impattante se volete dal punto di vista del codice perché è un cambio di paradigma fondamentale avevo accennato brevemente qualche lezione fa vedendo i vari stili di programmazione che si possono adottare il fatto che Flutter sia dichiarativo esattamente come lo è anche SwiftUI lo rende molto alieno a livello di programmazione per quello che si vede di solito in programmazione e lo rende un pochino ostico da afferrare inizialmente questo cambio di paradigma come si può esprimere a livello proprio concettuale in questa maniera adesso ci arriviamo l'idea è quella di avere un'interfaccia utente che è pienamente funzionale cioè l'interfaccia utente che vediamo a schermo quindi i pulsanti le liste gli oggetti i testi e così via sono funzione di un oggetto che è lo stato interno dell'applicazione ossia in ogni momento in cui voglio rappresentare la schermo alla mia applicazione io posso farlo avendo da una parte lo stato dell'applicazione quindi un oggetto immaginate questo adesso è espresso in senso matematico quindi immaginate di avere una tubla di valori che possono avere varie forme che voi passate a una funzione che è stata implementata in modo x quella funzione prende questa tubla la elapora in qualche modo e poi vi sputa fuori l'interfaccia questa è esattamente come funziona la per in sostanza a livello così concettuale funziona così avete da una parte avete ciò che definisce lo stato dell'applicazione che possono essere che ne so i dati che l'utente ha inserito i dati a cui l'utente ha accesso in un certo modo e così via passate questo blocco di dati a una funzione che implementate in codice d'arte ovviamente in questo caso e questa funzione non fa altro che sputare una gerarchia di widget quindi i widget sono gli elementi grafici con cui lavoriamo quindi ci aspettiamo ad un certo punto ci sia una funzione che ritorna un altro widget sulla base di una serie di stati che passiamo dentro quindi questo è il meccanismo qual è il vantaggio di questo approccio è che modificando lo stato e conoscendo la funzione f che implementa che genera la nostra interfaccia utente in ogni momento modificando lo stato sappiamo che cosa uscirà dalla funzione f quindi è come una funzione matematica una volta che è definita e se copre tutto il dominio dello stato sappiamo che non c'è nulla che possa rompere l'applicazione giusto? nel senso che se io so che lo stato vada se è un intero se so che vada a 0 a 100 posso garantire che la funzione f supporta tutti i valori di 0 a 100 a quel punto la funzione f non genererà mai un'interfaccia utente che è rotta questa è un po' l'idea concettuale matematica la stessa garanzia non possiamo non possiamo averla con del codice interfaccia utente che lavora in maniera imperativa o in maniera procedurale così detta ma nel codice procedurale noi abbiamo una serie di funzioni procedure meccanismi e così via che reattivamente a quello che noi facciamo con l'interfaccia utente vanno a modificare lo stato e l'interfaccia utente ma non abbiamo nessuna garanzia che a un certo punto a forza di modificare lo stato dell'applicazione qualcosa non si rompa giusto è quello che classicamente può capitare se non si presta attenzione nell'implementare un'interfaccia con WIT32 con Windows Forms con tutti questi meccanismi questi strumenti che usano invece un approccio imperativo perché noi andiamo a modificare iterativamente l'interfaccia utente finché cioè nella speranza di sapere cosa facciamo se facciamo un errore cioè mettiamo un bug tutto potrebbe andare potrebbe rompersi perché noi abbiamo provisto una serie di una serie di eventi che possono capitare in questo caso questo non può accadere perché finché lo stato rientra in un dominio noto non c'è nulla che possa andare storto ok? quindi c'è un singolo percorso per virgolette c'è una singola diciamo così un singolo percorso di codice nella nostra funzione F che genera l'interfaccia utente che dato uno stato genera un altro widget ok? quindi questa è l'idea ora mi rendo conto che questa è una cosa estremamente astratta estremamente fuffosa però è quello che viene effettivamente e poi lo vediamo tra un secondo nel codice effettivo questo lo saltiamo un attimo lo rivediamo la prossima volta quando è più chiaro ok? perché la F famosa che va a costruire l'interfaccia deve nel caso di Flutter deve generare un altro widget che ha tutto cioè ha un aspetto che è simile a questo quindi è un altro widget che ha una radice ovviamente e a partire da questa ogni widget può a sua volta avere un figlio widget o una serie di figli widget mettendo insieme tutti questi widget qui alla fine Flutter riesce a rappresentare su schermo la nostra interfaccia ok? questo è fondamentalmente l'idea l'altra cosa fondamentale è che tutti questi widget una volta costruiti sono immutabili quindi ricordate che no? parlando di Dart vi ho visto quanto è importante fare classi immutabili perché fanno sì che cioè vi risparliano un sacco di rogne perché non c'è nessuno che possa modificarle quindi non c'è il bisogno di modificare le istanze delle classi in maniera imperativa perché semplicemente quando abbiamo bisogno di una classe con un valore diverso andiamo a istanziare uno nuovo e facciamo in modo che ogni istanza di ogni classe sia sempre immutabile questo approccio viene sposato al 100% da Flutter perché i widget di base di Flutter sono tutti immutabili ossia sono widget che sono stateless quindi internamente non hanno nessuno stato che possa essere modificato giusto che non c'è nessuna funzione che possiamo modificare invocare su widget per alterarli perché una volta costruiti hanno quella forma lì e non possono essere modificati quindi per farvi un esempio il widget che rappresenta del testo abbiamo visto la volta scorsa il widget che si chiama text molto banalmente il widget text non può essere modificato quindi una volta che c'è del testo dietro un widget non lo possiamo modificare non c'è il metro set text che modifica il testo e aggiorna l'applicazione non si può fare bisogna rigenerare tutto l'altro di widget e mettere e cambiare il widget text ok immaginate che qui la nostra interfaccia sia più o meno complessa adesso ne andremo a generare una in fondo qui potrebbe esserci come fa di segnare non lo so vabbè non è fondamentale uno di questi invisibili pulsanti questo vabbè non mi arrischio però immaginate che questo widget qui in fondo sia del testo per questo schermo che ci mettiamo ciao mondo se vogliamo modificare ciao mondo non c'è modo cioè questo una volta che è stato creato con ciao mondo non si può modificare bisogna ricostruire l'intero albero di widget perché è cambiato lo stato dell'applicazione banalmente quindi questa questa funzione qui deve essere rieseguita perché qualcuno ha cambiato lo stato dell'applicazione perché va mostrato un testo diverso e a questo punto questo widget qui viene ricostruito con un testo diverso ok quindi fondamentalmente Flutter si occupa semplicemente di prendere un albero statico di widget e presentarlo a schermo questo è tutto quello che fa poi chiaramente ci sono delle complicazioni su questo però di base è secondo questo allora per vederlo in pratica riportiamo da un esempio molto più banale di quello che abbiamo fatto la volta scorsa per cui riportiamo proprio dall'esempio fondamentale dal proto-esempio più banale che si possa creare quindi ho creato ho preso il main l'altra volta l'ho cancellato tutto e nel metodo main dove c'era run app ho lasciato run app e ci ho messo tre widget di base che adesso andremo a lanciare vi ricordo appunto run app prende il widget no questo qui se vedete la la firma del metodo prende il widget quindi in sostanza prende questo oggetto qui cioè prende in input il primo oggetto la radice questo oggetto qui in alto questo è il widget che stiamo passando a run app quindi quando facciamo run app lo facciamo su questo oggetto qui poi chiaramente a cascata quel widget può avere i sotto widget che lo rendono più o meno sofisticato però questo è quindi la mia radice è questa material app qui di nuovo dovete dopo prendere per buono un paio di cose se no la magia non funziona però un'applicazione per quanto banale la facciamo deve contenere alcuni elementi fondamentali per avere uno stile grafico vagamente accettabile altrimenti non è proprio molto bella per cui prendete per buono questo widget qui che è material app è il widget fondamentale radice che vi permette di usare la grafica material quindi la grafica è ispirata al material design ok questo ha una serie di proprietà cioè di parametri del costruttore che sono il titolo il tema e la home la home è il primo figlio del widget quindi questo qui è un widget opzionale che è la home ed è la vedete la default route of the app quindi è il percorso di default della nostra app per fare sempre parallelo se la radice è material app ok la home sarà questo widget appena sotto questo widget qui sarà il nostro widget home che è l'unico candidato dentro material app e qui anche qui prendo per buono ci sto mettendo un widget material che fa poco e niente che avrà un singolo figlio un singolo child che è una sized box senza parametri adesso vi dico a cosa servono però questo fondamentalmente è quello che serve per avere un'applicazione vuota e bianca adesso qui a partire da questo lancio il terminale e comincio a eseguire edge così lo vediamo lo vediamo in esecuzione spero e poi adesso vi dico che cos'è material e cos'è sized box ok lo faccio lo lancio su edge voi chiaramente lanciatelo su quelle che preferite ok mentre lasciamo che il pc ci pensi a lungo vi dico allora material app è la radice proprio dell'applicazione e in effetti fa una serie di operazioni di contorno di cui possiamo intuire l'importanza ossia che cosa fa da un titolo l'applicazione il titolo è quello che vedremo poi nella barra dell'applicazione in alto dell'applicazione android o in questo caso lo vedremo nella barra del titolo del browser quindi basta la piattaforma in cui siamo quel titolo lì vi harà usato in vari modi diversi qui definiamo un tema e lo facciamo sulla base di un colore adesso il use material 3 non ci interessa ma quello è un booleano che indica se usare la versione 3 del material design oppure no quindi qui c'è un po' di margine di manovra di customizzazione del tema che possiamo utilizzare anche qui se vogliamo vedere cioè vedere un po' vedete che sono mille opzioni che abbiamo dentro questo costruttore di team data con cui possiamo andare a costruire la nostra interfaccia cioè andare a customizzare interfaccia andando a specificare vari colori primari scuri chiari le ombre e così via o il font default se vogliamo modificare la nostra applicazione e poi c'è diciamo così il resto della nostra applicazione questo team data vale dentro tutto il widget material app quindi questo material app contiene questo team data qui e a cascata tutti i suoi figli avranno accesso a questo team data quindi a cascata se noi cambiamo un colore qui i widget sottostanti andranno a fare riferimento al tema del material app appena sopra la stanza questo è un meccanismo che poi andremo a spulciare in più dettaglio poi per così per convenzione ogni applicazione che usa material design deve avere un widget material da qualche parte nella sua gerarchia quindi questo siamo obbligati a metterlo altrimenti l'applicazione compare con quello con quello stiligrafico inguardabile come era la volta scorsa quindi sfondo nero col testo rosso e così via quindi il widget material è quello che poi dà diciamo così l'aspetto coerente alla nostra applicazione e anche questo ha un singolo figlio che è questo size box il size box è un altro widget veramente banale fondamentale che si usa è un box una scatola che ha una dimensione è una dimensione fissa si può creare con width e height che sono due interi due double scusate che danno la dimensione pixel pixel del dispositivo alla box ok nulla di particolarmente sofisticato poi ci sono vari costruttori che fanno delle cose più sofisticate ma insomma siamo lì quindi è un box potenzialmente colorato se non lo costruiamo con dei valori width e height saranno entrambi null quindi sono entrambi nulli e quindi è un box che non prende spazio se dovete mostrare nulla sullo schermo lo fate con un sidebox e adesso a questo punto a parte che è lo schermo sbagliato qui abbiamo la nostra interfaccia pratica molto vuota che è questa applicazione ora avviene esattamente quello che vi dicevo prima qui nel nel web avviene che la pagina web include un oggetto canvas che è il renderer per cui all'atto pratico schia viene renderizzato cioè la grafica dell'applicazione flutter viene renderizzata dentro un oggetto webgl del browser quindi alla fine l'applicazione grafica flutter è comunque accelerata graficamente e vive dentro il browser dentro il browser è un po' più più sofisticato perché ci sono vari strati software che vengono attraversati se lo fate girare su android invece è molto più compatto perché in android avreste un'applicazione applicazione android classica che al suo interno ha il renderer schia che rappresenta questi tre widget a schermo questi tre widget non fanno niente per cui il risultato è questo questo violetto chiaro ok è violetto perché è un colore di default che poi tinge lievemente il bianco di sfondo ma a parte questo non c'è non c'è molto altro ok questo è un'altra cosa più banale che si possa fare per cui andiamo un po' a complicarci la vita andiamo a creare altri oggetti quindi abbiamo visto la volta scorsa che possiamo creare del text quindi possiamo creare ciao mondo qui adesso io lo salvo e clicco cioè pigio r qui per cui farà hot restart l'applicazione e tra un secondo riparte con la scritta qui adesso abbiamo il nostro famoso ciao mondo questo è il widget text quindi è qui dentro e il widget text come dicevo è stateless quindi è costante non può essere modificato tant'è che già ha guardato l'applicazione in questa maniera in realtà tanti modi per cambiare la scritta non li vediamo in win32 avremmo immaginato di poter reagire ai click e così via mandando poi dei messaggi se ricordate i messaggi erano get text e set text no no possiamo potevamo mandare questi messaggi qui all'oggetto no alla alla finestra e questo avrebbe cambiato testo qui tanti margini per farlo in realtà non li vediamo per ora per cui chissà come lo faremo tra un secondo possiamo complicarci anche andando a mettere questi text qui in una colonna che siamo già fatti la volta scorsa ma giusto per compitezza anche qui lo rifacciamo quando lavoriamo con i widget spesso bisogna fare delle operazioni di copia e incolla abbastanza precise e chirurgiche in Flutter per non intrecciarci con le parentesi le parentesi forse sono il vostro nemico numero uno in Flutter perché è molto facile intrecciarsi brutalmente e poi perdere completamente la visione di quello che sta facendo per cui l'estensione per Flutter di Visual Studio vi aiuta un pochino con dei metodi adesso provo a farlo senza provo ad annidare questo oggetto qui dentro un altro widget che si chiama widget column quindi la widget di colonna la colonna qui che può avere una serie di figli il primo figlio è cincollo del text di nuovo quindi questa cosa qui dovrebbe non cambiare radicalmente la nostra interfaccia se non per l'allineamento lo riallineo lo rilancio piuttosto non è più per niente molto bene ok ok adesso vi da una serie di errori adesso andremo a vedere perché e cos'altro a questo punto avendo un singolo figlio chiaramente possiamo immaginare di averne di uno veramente banalmente quindi basta aggiungerli all'array risalvo e anche questo ci aspettiamo che abbia l'effetto che feriamo quindi è morto molto bene un piacere lavorare con questi mezzi vabbè comunque troveremo a questo punto tre trecciaumondo impilati uno sopra l'altro perché la colonna non fa altro che prendere i widget figli e impilarli verticalmente la colonna per cui fa quello che deve poi chiaramente la colonna poi vedremo potrà fare vari effetti di allineamento in un senso o nell'altro però per ora è questo qua quando andiamo si prego si si si ah giusto esatto con un punto quindi la colonna è questo widget qui così a occhio e ha tre figli che sono questi qui e la resa e la resa sono tutti esatto sono tutti esatto sono tutti fratelli e sorelle quei widget in sostanza poi il fatto che vengono rappresentati in colonna è un dettaglio di come di come lavora il widget colonna esatto però a livello gerarchico sono a quel livello poi ah ecco è un buon esempio perché ogni widget può essere ulteriormente complicato quindi in realtà è un buon esempio adesso uno di quei text lì lo modificiamo un po' così magari ha anche più senso che lo vediamo appena riparte adesso appunto avremo tre ciao mondo impilati però tranquillamente possiamo metterci un altro oggetto che vedo se riesco a metterlo esatto on top così intanto lavora e perché appunto un widget in flutter un widget vale l'altro quindi sono tutti equivalenti e quindi che ne so questo possiamo infilare qui in mezzo un size box un esempio di questo widget qui perché il size box ha varie proprietà tutte opzionali tra cui l'altezza che mettiamo 50 se mettiamo questo size box in mezzo alla colonna ci aspettiamo che tra il primo ciao mondo e il secondo ci sia uno spazio di 50 pixel occupato ok lanciamo qui ed è questo si sono dei pixel anche qui i pixel sono device independent penso che sono pixel che si adattano alla persona in cui ci troviamo quindi può dipendere dallo schermo e dai ppi e così via però si sono da considerare dei pixel no non qui questo è soltanto pixel però ci sono dei modi per lavorare con le percentuali per cui in questo caso il size box è proprio primitivo e lavora in pixel e basta possiamo fare anche un altro oggetto molto base diciamo così è il container il container è ovviamente più sofisticato del size box ma non tanto di nuovo ha una serie di proprietà che si possono intuire poi li vediamo tutti con con camera però per ora ne facciamo altezza 50 sempre e a questo a differenza setbox che non ha un aspetto grafico il container può avere anche un colore quindi facciamo color per specificare colori si usa una classe che si chiama colors che vi dà una serie di classi di colori di default che potete utilizzare quindi usiamo l'indico per esempio a questo punto a questo punto non tutti gli oggetti sono costanti qui vedete che avevo stato questo cons qui ha solo scarto un attimo per comunità però poi ah qui l'ho dimenticato per una virgola questa cosa è rilevante più avanti adesso fate finta che non sia importante adesso avremo uno spazio vuoto c'è un mondo e poi si suppone uno spazio vuoto colorato di blu e poi c'è un mondo quindi possiamo integrare e possiamo rendere più meno sofisticata questa cosa per annidare come dicevo prima ci sono degli strumenti che possiamo utilizzare di visual studio dell'estensione quindi con control punto oppure cliccando sulla sulla lampadina possiamo fare varie operazioni che vi aiutano un po' che vi semplificano la vita un pochino quindi per esempio possiamo frappare quindi incattare un widget con un altro widget a cosa serve questo? immaginiamo che vogliamo mettere qui c'è un mondo vogliamo rendere un più più sofisticato e mettere un testo un contento colorato e poi un testo in una riga mettiamo sono un'interfaccia che non hanno alcun senso però proviamo a farlo quindi questo text qui che è il terzo elemento della nostra colonna lo possiamo frappare lo possiamo incartare dentro una riga quindi wrap with row vi autogenera una riga e rende text quindi il widget che già c'è l'unico figlio della riga lo faccio quindi fa questa operazione qui qui a questo punto posso fare sinistra poi ci metto un altro container che a questo punto il container deve avere una una larghezza per essere visibile faccio 100 questo volendo rosso ok salviamo più questo e vediamo che comincia a dare errori infatti benissimo proveremo qual è il problema un giorno sì facciamo vedere vediamo se per pure caso cambiando browser ci da ok comunque ecco quindi a partire da questi elementi qui possiamo creare delle interfacce più o meno complesse e e più o meno sofisticate insomma se semplicemente andando a comporre oggetti adesso una cosa che facciamo è cioè qui abbiamo creato tutto quanto dentro lo stesso metro qui vedete quando vi parlavo di approccio funzionale è perché la funzione che genera tutta la vostra applicazione è in qualche modo è direttamente il main cioè il main è l'unico metro che abbiamo implementato finora è l'unico metro di cui è composta la nostra applicazione e questo metro non fa altro che prendere lo stato dell'applicazione che lo stato adesso è vuoto cioè non c'è nessuna variabile che definisce cosa avviene nell'interfaccia quindi l'insieme è vuoto e genera un algoritmo tutto qui quindi fondamentalmente se non c'è nessuno stato generare un'applicazione flutter è molto banale perché si tratta di avere una funzione che ritorna un widget in sostanza adesso appena parte Chrome cioè tra qualche secolo secolo e per la parte Chrome dividiamo gli effetti di questa cosa e poi proviamo a componentizzare la nostra interfaccia nel senso che spesso chiaramente si usano blocchi di componenti ricorrenti nell'interfaccia utente e quindi ha senso prendere una serie di widget che hanno un loro senso e prenderli un componente cioè un widget a se stante una parte che facciamo ok questa cosa allora vedete che qui adesso il container qui rosso non è visibile perché di default ha preso l'altezza 0 cioè l'altezza nulla e quindi esiste infatti ha una dimensione vedete che qui sinistra e destra sono separati da un oggetto che non è visibile non è visibile perché l'oggetto semplicemente è spalmato altezza 0 quindi qui devono dargli una altezza e gli diamo 20 forse lanciamo e a questo punto ecco 20 è più o meno l'altezza del testo quindi è coerente ma insomma è più un caso che altro qui notate che gli allenamenti sono un po' strani nel senso che qui vedete che ciaomondo è allineato al centro questo blocco qui size box qui non si vede non si vede neanche cioè non si vede ma non si vede giustamente nel senso che non ha un aspetto grafico questa riga qui è allineata a sinistra stranamente e questo qui occupa tutto il blocco blu cioè indico occupa tutta la larghezza e ciaomondo è centrato sulla in orizzontale questo perché righe e colonne hanno un comportamento abbastanza sofisticato di allineamento che bisogna capire per vedere cosa cosa fanno adesso è prematuro però sapete che possiamo giocare con gli allenamenti sia in orizzontale sia in verticale per far far loro più o meno quello che di cui abbiamo bisogno in generale per la maggior parte dell'interfaccia precedente di cui abbiamo bisogno che bisogna costruire in qualche modo manualmente righe e colonne diciamo che non coprono il 100% dei nostri bisogni però ci vanno abbastanza vicini alla fine sulla base di righe e colonne possiamo ricreare quasi tutte le interfacce che ci vengono in me prego ma anche mettere il container dentro il robot dentro il container il container lo ha quale? questo qui? sì perché qui prima avevamo un const qui fuori che avevo tolto quindi questo va tolto e anche questa cosa del const è un altro dei fondamenti di flutter un po' più mistici misteriosi che poi vedremo insieme per come funzionano però adesso anche questo è per maturo quindi togliamo il const e lasciamo perdere questo quindi tutti quelli sono dei warning e ci dice guarda questo oggetto qui potresti renderlo const se tu volessi perché lo dice? perché visto che text per esempio è un widget immutabile quindi una volta costruito non può essere modificato e la stringa con cui lo costruiamo è immutabile cioè una stringa costante allora tanto vale rendere tutto il blocco widget const è più efficiente esatto quindi praticamente adesso lo vediamo tra un secondo però visto che praticamente l'altra funziona proprio in questa maniera qui quindi ogni volta che deve presentare qualcosa a schermo fa questa cosa qui cioè esegue questo metodo qui più veloce è questa F più rapido sarà la ricostruzione e e quindi chiaramente avere degli oggetti const gli gli permette di saltare una distanzazione dell'oggetto quindi questo lo potete fare se avete la pazienza di fare potete mettere const ogni text e in questo caso quell'oggetto tag text non verrà più restanziato esatto esatto esatto quindi questo vale soltanto se il text che passiamo è const stessa volta perché const è virale cioè propaga e quindi tutto deve essere costante a tempo di computazione quindi quella è una limitazione però questo vale sia per size box che height 50 soprattutto non vale per container quindi il problema che ne stavo dando prima è che il const possiamo cioè tra l'altro const è una keyworded art che si propaga in profondità per cui quando applico const a text sto applicando const a tutto quello che è da text in poi ossia banalmente in questo caso la stringa quindi va bene la stringa va da sé che const quindi diciamo così a parte che questo non è dart legale però concettualmente sto dicendo guarda quella stringa lì è costante grazie lo sappiamo già però se per esempio rendessi costante il colpo esatto per esempio h colonna si può rendere costante questo propaga e text size box e così via sono costanti ma non tutti i widget possono essere resi costanti per cui container in particolare non è un widget che può essere costante quindi tutta quella questa questo const vi sta dando errore ed è il motivo per cui ho tolto const a material quindi questo lo togliamo però ecco l'idea è che più in alto riuscite a mettere const più efficiente la costruzione perché chiaramente più oggetti sono costanti a caduta a cascata ok quindi questa è un po' è un po' l'idea ok ora a questo punto se vogliamo ottimizzare la nostra interfaccia ottimizzare se vogliamo pacchettizzare rendere componenti la nostra interfaccia ci potrebbe venire in mente l'idea di prendere che ne so tutto questo blocco di di questa colonna qui per esempio oppure vabbè magari mettiamo questa riga qui questa riga che non ha alcun senso la prendiamo e la rendiamo un widget esterno a sostante ok perché magari è un oggetto che possiamo rutilizzare più volte quindi questo lo taglio ok a questo punto sparisce dall'interfaccia ovviamente quindi questa ovviamente non c'è più ovviamente come ci si aspetterebbe e lo andiamo a creare cioè andiamo a creare una classe che contiene quegli oggetti quindi facciamo riga colorata non so no altre idee questo per essere per essere utilizzato dentro l'interfaccia deve essere un widget quindi di base deve estendere deve derivare da un widget non si implementa widget di default ma si implementa se il nostro oggetto non ha bisogno di stato stateless widget quindi un widget che non ha nessuno stato ok quindi normalmente nella maggior parte dei casi la nostra interfaccia adentica sarà composta da una serie di stateless widget che noi implementiamo quindi qui estendo stateless widget a questo punto il video studio già mi dice che c'è un errore perché questa classe qui è astratta è una classe stratta che deve implementare almeno un metodo e quel metodo è build lo facciamo fare al nostro amico questo studio quindi con la lampadina che facciamo create one missing override questo appena creiamo qui ci crea l'override mancante che non è altro che un metodo che ritorna un widget adesso lo vediamo tra un secondo insieme ecco è un metodo molto semplice che è il corrispettivo della app come al solito quindi quel build è questo ok banalmente quindi stiamo implementando la f della nostra interfaccia questa f può essere complicata quanto vogliamo possiamo metterci cicli for possiamo metterci dei loop infiniti possiamo generare tutti i numeri primi da 1 a 7 miliardi bisogna fare tutto quello che vogliamo in questo codice perché è codice degli effetti però alla fine deve generare un widget ovviamente per cui basta fare return di cosa dei widget che abbiamo fatto prima quindi incollo qui ci metto un punto in virgola e se non ho fatto errori la build non ho fatto che ritornare quegli oggetti ok perché quel row a sua volta è un widget che ha già un suo funzionamento interno per cui il nostro widget in realtà non si occupa di definire come il widget viene disegnato a schermo o come si comporta in realtà non fa altro che assemblare altri widget e quindi è un widget diciamo così di di di di di di di di di di di di passaggio se vogliamo vederlo infatti ancora non l'abbiamo messo però immaginate che no per esempio avevo questa questa è la colonna questo widget qui magari internamente non fa niente però poi al suo interno contiene altri widget che fanno veramente qualcosa è il nostro caso quindi questo widget qui è il nostro widget colorato questa è la riga questo è il text questo è il container e così via questi qui fanno tutti qualcosa il nostro widget è semplicemente un contenitore di widget cioè un generatore di widget ed è quello che in gergo in Flutter si chiama è un widget builder perché che cosa fa? implementa di base ok proprio questa riga colorata qui lo possiamo richiamare di là lo era dove era? qui lo costruisco qui dentro ok perfetto a questo punto se ribildo l'interfaccia mi aspetto che abbia l'aspetto grafico di prima semplicemente c'è un widget in più che fa da così da maschera da corrente da aggancio che non fa altro che buildare quei tre quei quattro sotto il widget ok tra l'altro un'altra cosa simpatica a questo punto il container se ricordate non è const quindi il container non può essere reso const e poi vi dirò perché lo vedremo insieme perché comunque di base all'atto pratico è perché non ha un costruttore che sia const quindi in assenza il costruttore const è ovvio che non possa essere const poi perché perché è così c'è un motivo chiaramente però il container non può essere reso const quindi è un problema però a questo punto è ok è vero che il container non può essere reso const però questo widget qui sì cioè questo blocco qui è sempre uguale in realtà non cambia mai non ha non ha neanche parametri da costruttore cioè non varia mai è sempre lo stesso e anche se anche se anche se lo richiamiamo più volte anche se lo chiamiamo tre volte qui questo non cambia nulla cioè se non incrementare il numero di video oggetti ok ne abbiamo tre adesso però sono tutti tre uguali adesso ne hanno estenziati tre quindi ne esistono tre in memoria però inutilmente perché non è che fanno molto per cui perché non rendiamo questo oggetto qui const allora creiamo un costruttore const per il nostro riga colorata per farlo allora naturalmente ci vorrebbe di fare questo e lo possiamo fare quindi questo costruttore qui è validissimo in Flutter adatto vi suggerisce già di aggiungere il const tra l'altro già ve lo suggerisce quindi non mi sto dicendo nulla di particolarmente sofisticato però un'altra cosa che Flutter vuole diciamo così è che se c'è un costruttore che ci sia una chiave opzionale nel costruttore questo anche qui prendetela per buona è una è un oggetto qui una chiave che viene passata dal costruttore fate finta che non esista però ve lo suggerisce in varie occasioni prendetela per così com'è rendiamo questo costruttore const quindi a questo punto questo questo lo dirò questo oggetto qui può essere istanziato in maniera istanziato in maniera costante e quindi qui vi suggerisce guarda questo qui potrebbe diventare const const const const rendo const ok e non cambia nulla se non che l'interfaccia sulla carta è un pochino più è un pochino più efficiente poi cambiano dei nanosecondi in questo caso quindi è assolutamente inutile però sulla carta abbiamo fatto una cosa utile vediamolo vediamo cosa cambia in pratica tolgo const perché una cosa che conviene spesso fare per avere un'idea di quello che sta accadendo è usare l'output debug del nostro amico flutter devo ricordarvi come si fa eccolo dentro il build in genere vi suggerisco per avere nozione cioè per seguire cosa viene costruito di volta in volta di come raggiungere un debug print come metodo e lo chiamiamo ups sbagliato completamente tastiera ovviamente ok debug print è molto simile a print che abbiamo usato finora in dart per fare prove print stampa sempre su standard output debug print stampa soltanto sul log se siamo in debug quindi se compilassimo applicazione in produzione quel debug print non avrebbe effetto quindi spesso conviene per sapere cosa sta accadendo però ah altra cosa per sapere se applicazione gira debug o meno c'è questa simpatica linguetta che compare da destra che vi dice che cosa se è in debug o meno ok ribildiamo adesso quella errori a parte che adesso causeranno la morte di Chrome tra un secondo ce la fa? pensa che riavvio vabbè ok ce l'ha fatta a breve ci abbandonerà comunque l'idea che è questa questo widget qui che abbiamo creato viene ricostruito tre volte quindi tre volte compare nell'albero del codice giusto e tre volte viene fatta la build quindi quando Flutter deve presentare quel widget a schermo chiama build tre volte per sapere come è fatto internamente quel widget e ogni volta il widget genera questi tre cioè questi quattro widgets qui sotto ora se io faccio vendo questo const avverrà esattamente quello che ci aspettiamo giusto ossia more chrome un istante di pazienza vabbè quello che avverrà è che building viene eseguito una singola volta perché perché l'istanza l'istanza nell'albero è sempre la stessa e quindi Flutter sa benissimo che non deve richiamarlo più volte quindi se tutto funziona come ci aspettiamo quella no viene chiamato comunque tre volte adesso lo vediamo subito ce la fa non ce la fa verrà comunque richiamato tre volte perché viene costruito tre volte però l'istanza è la stessa se andassimo verificare in memoria quante righe colorate esistono è sempre la stessa istanza poi chiaramente viene buildato tre volte perché compare tre volte nel nostro app quindi necessariamente dovrà essere ricostruito tre volte questo è necessario però abbiamo ottimizzato quindi nonostante la build viene fatta l'istanza è la stessa ce la può fare è sempre bello aspettare con voi va bene quello che faremo tra un secondo appena riparte vedremo come si fa a variare lievemente la nostra interfaccia beh allora modificando quello che stiamo già facendo qui in realtà cioè come facciamo a definire che cosa mostrare dentro il text definire la grandezza del sidebox il colore di un container e così via passando al costruttore dei valori diversi ok per cui stessa cosa faremo con riga colorata che magari può aver senso passare a riga colorata il colore come abbiamo mostrato un'idea per dire è un'idea ok questo partito ok come vi dicevo appunto la building comunque richiamavo tre volte perché ovviamente riga colorata compare tre volte quindi deve essere costruita comunque tre volte perché nell'albero ci sono tre istanze tre istanze riferimenti a riga colorata che è la stessa istanza ok questa è la cosa veramente se andassimo dire il puntatore di riga colorata sarebbe lo stesso però cambia soltanto a livello di istanziazione della memoria per ora ok proviamo adesso a passarci i dati da fuori per cui diciamo questo magari dentro la classe possiamo definire un final color color è un oggetto della di quella che è la fondazione di flat quindi fondamentalmente i colori i punti queste cose qui sono nelle classi di base di flutter color è uno di questi rappresenta i colori ovviamente in rgb qui creiamo un color che è quello che andiamo a rappresentare qui dentro il container essendo final deve essere specificato nel costruttore quindi per costruirlo lasciando questa come opzionale questa è la sintassi questa è la sintassi per i parametri opzionali color non può essere opzionale perché non è nullo per cui deve essere definito necessariamente lo specificiamo con this punto color quindi la sintassi di costruzione del del campo che deve essere noto a priori no allora cioè sni possiamo fare le graffi vanno benissimo in questo caso questo qui è un costruttore posizionale cioè sarà sempre il primo elemento e a questo punto seguono i parametri nominali però essendo uno ovviamente è poco utile però sì potremmo farlo anche così quindi l'alternativa è questa chiaramente la differenza è che questo deve essere required ok poi adesso questo qui ah non gli piace perché c'è l'underscore ok giusto allora insomma le controindicazioni quindi color lo chiamiamo color e a questo punto nella lista qui possiamo fare color ok questo è l'altro modo in cui possiamo costruirlo la differenza è che adesso qui nel costruttore lo chiamiamo compare come parametro nominale quindi color color green colors piuttosto green green mentre nella variante di prima che era questa così ok in questo caso invece non serve la non possiamo dare il nome perché è sempre il primo parametro quindi la riga colorata richiede come prima posizione il colore cambia cambia poco ma ok a questo punto color qui deve essere usato a che parte se no vi dà un warning lo usiamo qui dentro ok quindi dentro la build facciamo riferimento a quel colore lì lo passiamo ce lo passiamo oltre al container quindi questo è un appoggio che ci dà il colore che utilizziamo dentro riga colorata e poi nel costruire noi stessi la nostra sotto il nostro sottoalberello il ramo diciamo così che stiamo costruendo che è la riga andiamo a specificare il colore che abbiamo già costruito a questo punto chiaramente questo è obbligatorio questo parametro qui per cui bisogna significarlo qui quindi facciamo le cose nell'ordine giusto ok prebuildo già cominciano gli errori è sempre un piacere ok quindi ho riciclato tre volte lo stesso widget e ho passato dei valori diversi questo che a questo punto chiaramente termino perché la velo scura a questo punto chiaramente l'idea è che queste tre istanze adesso che ci ho messo il parametro le tre istanze di riga colorata sono tre istanze diverse cioè abbiamo usato comunque const però esistono tre istanze di riga colorata una per ogni colore quindi ce n'è una rossa una verde una blu se capitasse di usare due volte il rosso riga colorata rosso mettiamolo la prima e l'ultima sono la stessa istanza ok le altre tre le altre due sono diverse ok ora rendiamo più allora a questo punto abbiamo fatto una riga le righe colorate in questa maniera è validissimo così chiaramente aggiungiamo quindi abbiamo reso questo qui un un sedice widget facciamo un altro un pochino più arcano che va a generare casualmente dei colori quindi qui adesso aggiungo un altro text ok quindi questo oggetto qui lo vado a buttare via non ci interessa più ok e vado a creare un class riga colore casuale con i nomi sono fortissimo ok anche questo faccio implementare l'override della build va benissimo così poi gli faccio creare il costruttore vedete qui faccio sempre con control punto quindi fa tutto in automatico in sostanza quindi ho creato prima la classe ho fatto extensate this widget poi qui faccio implementa l'override e poi l'ultima cosa che gli faccio fare è aggiungere la chiave al costruttore quindi mi crea il costruttore in automatico e const sempre non essendoci nulla dentro e colore per forza al momento poi magari le cose cambiano ok a questo punto qui dentro cosa facciamo andiamo a creare un container simile a quello che ho appena cancellato sopra quindi era un container alto 50 se ricordo bene e con un colore cos'era indico 50 e color color indico ok e dovremmo esserci perfetto ok e questo lo creo qui dentro ok a questo punto tra l'altro mi sta dicendo guarda attenzione tutto questo blocco qui è tutto const a questo punto il container non c'è più il container era il colpevole che ci impediva di rendere tutto const quanto const adesso text è const sizebox è const rica colorata sono tutti const text pure rica colore casuale è const che ho appena creato quindi a questo punto basta rendere tutto const vediamo se è abbastanza furbo da fare beh è una scelta nostra perché nel senso che ah ho chiuso il browser niente non ce l'ho più così questo qui perché l'elemento che ho tolto da sopra era semplicemente un container quindi era un blocco era quel colore bluetto alto 50 e non c'era non c'era il testo quindi è semplicemente perché era era fatto così prima quando l'ho tolto era più semplice però è arbitrario quindi ovviamente come come vi pare piace è una scelta puramente stilistica volete dargli altezza 50 e un colore indico potete fare ovviamente il colore che preferite e chiaramente ecco nella build come dicevo prima il vostro oggetto può essere complesso semplice quanto quanto vi pare insomma tra l'altro nella build copio sempre questo debug print che è sempre utile avercela per sapere cosa sta avvenendo ok torno un attimo su e qui appunto vi dicevo che prima non riusciamo a rendere tutto quanto const perché alcuni elementi non erano const tipo il container e quindi adesso a questo punto però possiamo farlo e se il studio ci aiuta posso fare add const qui lo fa no ni cioè ho tolto tutti i const qui e l'ho applicato all'array questo qui che sono tutti quanti const che è parzialmente giusto ma in realtà posso fare di più perché anche la colonna e i material sono const quindi di nuovo faccio la stessa cosa lo sposto a più uno lo rifaccio oh ecco che siamo soddisfatti adesso è tutto const nel senso che tutti questi oggetti qui vengono distanziati una singola volta ammesso che il parametro con cui vengono distanziati sia lo stesso quindi in realtà è vero fino a un certo punto nel senso che l'unica ripetizione è questa ricca colorata rossa in realtà ritorno o vengono sotto quindi i nostri widget sono const perché c'è un costruttore const dentro e perché appunto internamente non hanno nessuna non vengono modificate in alcun modo quindi non c'è lo stato non c'è nessuna variabile che può essere modificata cioè sono veramente const qui dentro la cosa si romperebbe se avessi variabile se mettessi qui un campo intero modificabile ok questa cosa si rompe perché il ricca colore casuale non è più cost perché questo intero qui può volendo essere modificato ok questa è l'idea ok appena la classe smette di essere immutabile si rompe la constità della classe ok lo commento però questa è l'idea ok a questo punto però facciamo una cosa carina proviamo a rendere casuale il nostro colore per cui il colore adesso il colore che adesso indico lo voglio variare un pochino e lo metto esattamente come viene qui sopra qui l'ho reso un final color color lo faccio uguale faccio final color color la differenza è che non voglio che venga passato da fuori cioè non voglio che venga passato dal costruttore voglio che sia durante la costruzione che l'oggetto viene costruito ora vediamo se questo si riesce a fare altrimenti in un altro modo ma istanziamo il nostro color quindi color adesso qui normalmente sarebbe indico ok e qui lo possiamo togliere da qui e usare color ok ho solo spostato dove color viene definito quindi lo definisco come final nella mia classe lo istanzio e a questo punto lo uso qui dentro per dare colore alla nostra interfaccia vediamo una compilata a questa per vedere se funziona grazie a tutti prima parte grazie a tutti forse per domani mi organizzo con Android così forse lo faccio girare su Android ed è un po' più più rapida la cosa forse adesso ci provo e vediamo se riusciamo a farlo fare in quella maniera siamo liberi ad aspettare il browser che poi tra l'altro è meno efficace come esempio perché vediamo se riesco quello che vorremmo fare vediamo se riusciamo al vero tipo di codice è di rendere quel valore lì casuale e uguale per tutti le istanze di colore casuale ora dovrebbe essere identico a prima in realtà quindi mi aspetto nulla di distranno solo che intanto lo vediamo c'è quella riga di colore indico che è in mezzo e che verrà costruita una singola volta che compare una singola volta nel nostro la nostra interfaccia quindi qui vedete che il bidding riga colore casuale compare e a questo punto c'è la nostra riga indico e fin qui ci siamo ora un modo per esempio proviamo a creare a pescare un colore casuale per farlo ci serve una random quindi un generatore di numeri casuali e lo possiamo pescare direttamente così random va importato da dark math ok a cosa punto probabilmente non ce lo farò fare però vediamo se riusciamo come scusi sì allora è una è una è una è una è una è una classe composta da da un seguito intero l'intero è un valore a 32 bit per cui può contenere i bit così spalmati cioè con un canale per il rosso il verde il blu e il canale alfa, quindi è un colore che può essere anche trasparente. E appunto, vive in un sicuro intero, ed è per questo che color è un oggetto che può essere anche costante, perché al fine è un intero fondamentalmente, e in genere non si costruisce mai con l'intero direttamente, ma si usano i vari costruttori che permettono di farlo specificando i quattro valori di cui è composto. Quindi from RGB, from RGB O, che O dovrebbe essere opacità, giusto? Sì, esatto. Che è l'inverso dell'alpha in realtà, e mi sa che fa quattro. E vedete che anche questi sono dei, sono... L'avevo visto previamente parlando di Dart, quindi visto che sono tutte istanze di interi, quindi sono immutabili, cioè è immutabile perché è final dentro il colore. Dov'è? Vabbè, non so dov'è, ma c'è. Comunque, quando andiamo a modificare il colore, lo facciamo con dei metodi che prendono un colore originale e ne creano un duplicato, modificando il canale alfa, l'opacità, il rosso, il verde e il blu. Quindi funziona in maniera immutabile, ogni volta che abbiamo un colore possiamo andare a crearne un altro, mutando quello che già c'è. Quindi non è che andiamo a modificare un colore che già è, e il sistema ne creiamo di duplicato, in sostanza. Ok, quello che voglio fare qui è pescare un colore casuale, e questo lo possiamo fare andando a pescare da... Vediamo anche Colors. Colors è questo soggetto qui che ci dà la lista dei colori, no? Se avete capito brevemente. Se diamo un'occhiata a Colors, come è fatto? Colors è una classe statica che vi dà una serie di colori, così, cioè ritorna come delle costante, quindi qui vi dà il nero, il blu e così via, tutti colori predefiniti qui dentro, però per comodità espone anche dei colori, delle liste di colori. Quindi per esempio vi dà una lista di rossi, per dire, o una lista di... di colori primari, che altro non è che questa lista qui, quindi è una lista di colori che vanno dal... cioè, sono i vari colori che sono più o meno primari che si possono utilizzare nell'interfaccia. Ok, per questo l'idea è che andiamo a pescare casualmente un valore da questa lista per inizializzare il nostro oggetto. Non ce lo farò fare perché non è costante, quindi adesso lo farò solo all'erococettuale, però lo faremo da fuori. Però idealmente lo dovremo fare è... cioè, lo che vorremmo ottenere è avere vari oggetti di la stessa classe che condividono lo stesso colore. Ok? Allora, quello che potremmo andare a fare, idealmente, è usare random e qui usare colors, primaries, length. Ok? Vabbè, questa è una sintassi orribile in poco tempo, però ci permette di estrarre casualmente uno degli elementi di colors, primaries. Quindi colors, primaries è un array di oggetti, colori, scusate, che ha una lunghezza tali e tali, con random nextint. Questo nextint ci ritorna un valore che va da zero fino a un intero X, non incluso. Ok? Quindi colors, primaries, la lunghezza dei colori primari. Mi sa che non gli piace il fatto che non è sulle quadri. No, no, questo dovrebbe andare bene, ma non va bene perché non è const. Quindi chiaramente questo è un valore non casuale, cioè è un valore casuale non costante, quindi non può essere, non può funzionare in un costitore const. Ok? se lo togliamo, a questo punto questo funziona. Per cui tutto deve essere, quando usiamo un oggetto const, deve essere const a tutti gli effetti fino al suo ultimo elemento. Se un questo elemento non è finale, chiaramente non può funzionare. Ok, per cui questa cosa adesso la possiamo lasciare in questa maniera qui e a questo punto quello che avverrà qui è che a ogni avvio il colore di questo oggetto qui cambierà. Ah, sì, giusto. Era const, non lo è più. Quindi questa cosa va tolta. Vabbè, lo loco del tutto, poi lo rimetteremo. Adesso ad ogni avvio, adesso a parte gli errori che dà purtroppo, se voi provate a avviare l'applicazione più volte, ve le vedrete che il nostro container lì cambia colore ad ogni avvio. Quindi adesso sarà... non lo so. Ecco, Gianno. Prego. Vedi, si piace il colore, mi dà numeri, perché il colore che è più usato è più usato. Prego il const è più usato. Qui? Sì, mi dà il colore che è più usato. E... Non ho capito dove. Cioè, dall'errore qui? Qui il const l'ha tolto dal costruttore? Sì. Dal costruttore? Vengo a vedere. Vengo a vedere. Vengo a vedere. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì. Sì.於. Sì. Sì. ci aggiorniamo domandina