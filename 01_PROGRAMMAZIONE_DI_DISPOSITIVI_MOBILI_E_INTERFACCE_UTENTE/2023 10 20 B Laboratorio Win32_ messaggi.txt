Per concludere questa sessione, vediamo, cioè, complichiamo lievemente quello che facciamo qui dentro. E l'idea che mi ero fatto un secondo fa durante il caffè, cioè, estraendo il caffè della macchinetta, era potremmo usare questo testo qui in mezzo allo schermo, che l'ho fatto precedentemente, per scrivere, cioè, per traccia di alcune informazioni di contesto. Quindi l'idea è, ci scriviamo la grandezza dello schermo, dello schermo, del client rect, ci scriviamo i PPI dello schermo, e poi ci scriviamo l'ultimo click che abbiamo ricevuto, cioè, su che coordinata era, e quindi, man mano che clicchiamo, ci aspettiamo che il testo qui si aggiorni. Quindi questo è quello che potremmo immaginare di fare. Per fare queste cose qui, quindi le informazioni che ci servono sono tre. Dimensioni dello schermo, ce l'avevamo già, PPI, adesso tra un secondo li calcoliamo, e il click del mouse, ok? Anche questo ce l'abbiamo in teoria. Per cui, il click del mouse è questo, questo, quindi X-Post, Y-Post, è dove è stato cliccato il mouse, in coordinate locali al client, quindi se clicchiamo in alto a sinistra sarà 00, e poi accrescere, scendendo verso il basso o verso a destra. Quello che va fatto nelle Win32, visto che la Paint, diciamo così, è asincona rispetto al click, quello che dobbiamo fare è ricordarci i valori, perché poi questi verranno presentati a schermo la prossima volta che c'è una Paint, ok? Quindi la Paint è sempre asincona, cioè apina sempre a posteriori rispetto a quello che è l'evento che scatena la Paint. Questo è un pattern classico delle Win32, perché L Battle Up non può disegnare, cioè non può farlo, perché nessuno gli ha ancora detto, cioè ha detto la nostra finestra, che è il tempo di ridisegnarsi. Quindi il ridisegno è sempre reattivo, cioè viene fatto su richiesto da parte delle Win32. Se nessuno ci chiede di disegnarci, noi effettivamente non disegneremo mai su schermo. Quindi qui non possiamo fare degli InPaint e del EndPaint, dentro è il bottom-up, perché non funziona, ok? Quindi non si può fare, anche se provassimo a farlo, non c'è modo. Per cui questo message box adesso lo documentiamo, perché non è utilissimo, ed è solo fastidioso. Però quello che facciamo, quello che si fa di solito, è che se ci sono dei dati che bisogna portarsi dietro, li rendiamo visibili al di fuori, di questa chiamata. Per cui in sostanza, questo x-pos e y-pos lo mettiamo come globale in questo caso. Allora, le globali, chiaramente come sapete già dal corso di programmazione C, non sono una bella cosa in C, per cui sono in genere mal viste. Questo vale anche per i Win32, in cui non è mai una bella idea avere le globali. in questo contesto non ci serve a niente e usiamo lo stesso. Però, ovviamente, se volessimo fare un programma più, cioè, fatto bene, avremo delle strutture date in cui metteremo questi dati, li pacchettizzeremo in maniera pulita e quant'altro. In questo caso, però, facciamo tutt'altro. E quindi facciamo last x e last y, che sono questi interi qui, e ci memorizziamo l'ultimo click, cioè la posizione dell'ultimo click. Quindi, in realtà, facciamo direttamente questo. Chiaramente last x e last y all'avvio saranno zero, saranno la valore di default per gli interi. Quindi all'inizio comparirà zero, ma va bene così. Ok. A questo punto vogliamo che nella VM Paint questo testo qui, che adesso era un testo costante, diventi un testo dinamico, nel senso che deve essere un testo che compugniamo a runtime mettendoli dentro le x e la y. Quindi, per fare questo, bisogna fare, cioè, scrivere su una stringa, che in C è sempre un'operazione molto poco divertente. In particolare, nelle Win32, vi ricordate la volta scorsa, che abbiamo litigato con la codice dei caratteri e quant'altro, ebbene, bisogna rifarlo, perché i caratteri in Win32, in genere, possono essere caratteri multibyte, e quindi, per allogare una stringa, invece di fare char e poi la stringa, usiamo tchar, che è il char type, sarebbe il tipo char delle Win32, che può essere, a un singolo byte, se compiliamo per Ashi, può essere multibyte, se compiliamo in Unicode. Adesso, finora, abbiamo compilato in Unicode, quindi questo tchar qui sarà largo, 16 bit. Certo, per caratteri, chiaramente. Per cui, qui lo chiamiamo buffer e ci mettiamo, facciamo un grandicello, e anche questo, diciamo così, non è elegante, facciamo un buffer molto grande, ci stiamo dentro, nella speranza che non sia mai più lungo di 2048 caratteri. Se lo fosse, chiaramente esploderebbe, ma vabbè. Va bene così. Per scriverci, allora, altro problema, per scriverci, non possiamo usare, normalmente useremmo la Sprintf, se ricordate, Sprintf è la funzione della libreria standard C che ci permette di scrivere su un buffer, quindi qui metteremo buffer, formato, e poi parametri, se ricordate. Esattamente la Printf fa la stessa cosa, ma stampa sul canale, stampa su standard aspect, la Sprintf stampa su stringa, questa non va bene perché lavora in caratteri semplici, ci serve una wide Sprintf, che è la stessa cosa, ma su buffer potenzialmente larghi. Il formato va passato sempre come text, se no, poi, non è contento. E qui ci scriviamo adesso, a questo punto ci scriviamo, allora, dicevamo, la grandezza dello schermo, quindi client, rect, mettiamo D, poi ci mettiamo un bel segno di moltiplicazione fotografico, mettere alla prova unico, D per D, qui potete mettere tranquillamente una X, ma la X, sappiate che la X è un carattere asci, il carattere di moltiplicazione è un carattere unico, per complicarci la vita, la facciamo così, client rect, D per D, prova da capo e facciamo last mouse, non so perché sto scrivendo il mio interesse, non è importante, D virgola D, la parentesi, così è più, se no, di una coordinata. ok, quindi tutta questa cosa qui prevede quattro parametri interi, no, percentuale D, che saranno, client rect, la dimensione, la left e top del client rect sarà sempre zero, come dicevo, quindi non è molto interessante, ci mettiamo right, che sarà la dimensione, la larghezza, e poi bottom, che sarà invece l'altezza, e poi last mouse click invece saranno i last x e last y, ops, last y, che dicevamo prima. Salvo errori miei di scrittura, in teoria dovremmo esserci, quindi questa cosa qui, questo buffer qui, possiamo a questo punto passarlo a draw text, perché questa stringa qui non ci interessa più, vi lascio copiare, se state copiando, ho fatto compilo, perché non è detto che non ho fatto degli errori, no, non è che compilazione, che funzioni è un altro rispetto, attimo, c'è sicuramente una cosa che non funziona, ma adesso vediamo subito che cosa è. Allora, provo ad eseguire intanto, poi vi lascio ancora copiare, se serve. MinEx, perfetto, allora, la capo non funziona, è molto bello, però già qualcosina c'è, quindi client rate, la dimensione, vabbè, è quella che è, se suppone, la small click è 0, quindi non è ancora sto applicato nulla, va benissimo così, se ridimensiono la finestra, mi aspetto che WM20 viene richiamato da Windows perché la finestra sta per essere ridimensionata e quindi quel get client rate ottiene la dimensione sempre aggiornata e quindi si aggiorna la dimensione, quindi qui abbiamo la stampa giusta, le dimensioni in pixel. Ok, ok, ok, questo funziona assolutamente bene, non va l'accapo, non va l'accapo perché Windows, vi dicevo la volta e mi sono dimenticato, non gli sta mica bene che l'accapo è solo backslash n, vuole anche backslash r, vero se è vero perché non so dove, no, non è vero, ah, grazie, ovviamente, se non è tonto, è specifico alle cose giuste, ma quindi forse non è neanche il backslash r, basterebbe forse il backslash n for, molto meglio, non è bello, non è bello, in realtà, poi vediamo perché fa questa cosa qui, ok, ritorna ok, ritorna ah, ci sono due problemi qui, ancora, allora, uno è che abbiamo tolto single line quindi giustamente prendere a capo però ha perso la capacità di di centrare il testo questa verità neanche non ricordavo c'è questa limitazione però in effetti a questo punto win 32 non allinea non centra verticalmente il testo perché probabilmente non sa quanto è grande il testo questa è un'altra limitazione dei font sempre molto fastidiosa per cui se vogliamo centrare il testo veramente dobbiamo farlo a mano con grande gioia cioè bisogna prima misurare il testo dividere per due lo schermo mettere la metà del testo solo metà del testo sotto quindi fare un po di aritmetica molto primitiva proprio farla a mano e poi il testo è centrato altrimenti non c'è modo di farlo adesso il win 32 sta centrando un ritorno del testo però poi sta scrivendo dal dal dal top verso il basso perché il testo è multi line e quindi può prendere più più righe e in 32 per motivi di efficienza non sta a calcolare quanto è lungo il testo perché il testo potrebbe essere anche molto lungo visto che abbiamo passato meno uno come parametro qui in 32 non ha idea di quanto sia grande questo buffer potrebbe essere tre giga di testo nessuno lo sta a specificare per evitare per calcolare tutto quindi 32 non lo fa se vogliamo centrare il testo bisogna farlo a mano però non è faccio vedere come si fa in caso altra cosa che adesso ancora manca se io clicco allora se clicco sul prima si apriva il messaggio box adesso si aggiornano queste variabili qui mi aspetterei che cliccando si aggiornino questi due numeretti qui questo però non avviene cioè sto cliccando immagino che il messaggio venga elaborato dalla mia finestra ma non si aggiornano nulla perché nessuno invia il messaggio paint alla finestra la finestra non sa che deve ridisegnarsi quindi questa cosa qui viene eseguita quindi la stex e la st y si aggiornano in maniera corretta possiamo immaginare non lo vediamo non lo sappiamo ma non si aggiornano la finestra per scatenare l'aggiornamento bisogna muoverla e improvvisamente compaiono i numeri giusti adesso compare l'ultimo click quindi posso cliccare ridimensionare e poi cambiano i valori però la finestra non si aggiornano da sola in sostanza ok quindi aspetta che ci sia un motivo per disegnarsi chiaramente quindi dicevo che vm paint viene fatto soltanto se veramente necessario e il il pulsante non lo rende necessario di per sé per cui cosa si fa di solito è per scatenare un vm paint si chi e si segnala a windows guarda la finestra non è più aggiornata devi aggiornare la finestra perché qualcosa è successo e le cose sono cambiate per farlo si chiama una funzione che si chiama invalidate rect cioè invalidate rect cioè invalida c'è una parte rettangolare dello schermo della finestra non è più valida quindi va ridisegnata sopra invalidate rect prende una serie di parametri che sono la finestra di riferimento il rettangolo che non è più valido qui se noi volessimo essere molto precisi questa è un'altra ottimizzazione che poi nessuno fa l'atto pratico cioè noi potremmo specificare esattamente quella zona della finestra che non è più valida ossia se poi volessimo essere veramente precisi potremmo andare a calcolare dov'è il testo e invalidare soltanto il testo così windows poi è costretto cioè ridisegna soltanto questa zona qui chiaramente è una follia parlo veramente a meno che a meno che non si sape veramente che lo schermo è suddiviso in tante sotto aree e riceva a ridisegnare soltanto quelle zone lì per cui in genere non si fa mai e si passa null come rect tutta la finestra e buonanotte e l'ultimo parametro è un booleano che costringe cioè suggerisce a windows se pulire lo schermo o il buffer o meno anche questa è un'altra ottimizzazione che negli ultimi anni insomma si usa sempre meno perché se appunto se siamo su pc veramente molto vecchi in alcuni casi possiamo ottimizzare le cose invalidando soltanto piccole zone e non cancellando il buffer che c'è già magari ottimizzando e ridisegnando sopra senza andare a cancellare il buffer originale però in genere sono ottimizzazioni che non hanno senso in un mondo moderno per cui si si si invalida tutto e buono a questo punto dopo questa chiamata qui la finestra è non più valida viene marcata come in gergo si dice sporca quindi una finestra dirty non più valida e va ridipinta a quel punto in coda a questo arriverà un messaggio one paint che disegna tutto non è detto che sia immediato perché i messaggi possono avere priorità diverse questo in realtà poi cioè se uno poi vede i messaggi come arrivano e i messaggi del ma legati al mouse e all'interazione dell'utente hanno sempre priorità molto elevata per cui i clic del mouse arrivano prima e one paint è sempre uno di quelli che arriva al prodotto veramente è un'operazione che richiede del tempo quindi in teoria è possibile che più messaggi di clic arrivino invalidino il la finestra in vari modi e poi a questo punto appena windows a un secondo di fiato perché il mouse generale 20 e quel punto sempre nell'ottica di ottimizzare e minimizzare le volte che la finestra in riscrizione ridisegnata ok a questo punto quando clicco avviene quello che ci aspettavano quindi la finestra viene ridipinta e finalmente avviene quello che si voleva d'altro possiamo anche notare che appunto il pixel qui dove finisce la parte nera è effettivamente il pixel 10 10 più o meno e il pixel finisce il bordo è la grandezza dello schermo meno 10 ovviamente quindi si ragiona effettivamente in pixel ok molto bene più indolore del previsto superiore e a questo punto vogliamo tanto faccio vedere come si misura il testo giusto per darvi un'idea poi non lo faremo perché cioè lo lascio come mi lascio come esercizio dal lettore matematicamente è abbastanza facile perché non è difficile cioè non è difficile farlo se vogliamo misurare del testo vedete qui il center text vertically questa lo specifica che ha documentazione vcenter funziona soltanto se usiamo single line quindi se il testo non è single line win32 non riesce a centrarlo perché proprio che dovrebbe andare a misurare quanti quanti a capi ci sono e questo non lo fa per misurare il testo calc rect esatto cosa qui questa questo magico valore qui possiamo possiamo specifico possiamo passarlo a a lo dirò alla chiamata draw text per renderlo una chiamata che non disegna veramente cioè diventa una chiamata fittizia che serve solo per misurare il testo quindi in realtà per misurare il testo bisogna fare due chiamate draw text la prima misura il testo la seconda lo disegna veramente quindi quello che si fa è adesso non lo facciamo però se volessimo farlo faremo draw text hdc il buffer è sempre quello quindi il buffer va bene meno uno alla dimensione il rettangolo adesso non lo passo ancora e come parametro passo dtt calc rect più tutti i parametri che servono che comunque servono dtt center dtt analysis ok quindi quegli stessi parametri che useremmo per disegnare aggiungiamo dtt calc rect e a questo punto questa chiamata qui usa il rettangolo di partenza come spazio di riferimento e lo allarga in base allo spazio che occupa che occuperebbe il testo se mai lo disegnassimo quindi questa è l'idea anzi prova a fare rect misura adesso questo rect qui che sto allogando qui è un rect tutto a zero quindi è stato appena creato sullo stack quindi top left bottom right tutti valgono zero lo passo qui alla funzione dopo questa chiamata non è stato disegnato ancora nulla ma misura è grande esattamente quanto il testo a questo punto destinazione faccio un altro rect che sarà allora destinazione top dovrà essere attenzione adesso qui è facilissimo confondersi è il mio rettangolo che è il bordo giusto? è il mio rettangolo top no non è vero è la grandezza del rettangolo quindi è bottom meno top questo è quanto è grande lo spazio sto incartando già no? questo è quanto spazio ho e poi ci voglio voglio togliere da questo la metà della misura quindi meno misura bottom fratto due faccio no? poi destinazione left può essere il mio rettangolo left perché comunque è centrato a sinistra quindi va bene così destinazione right stesso discorso perché tanto il testo è allineato al centro quindi non ci interessa la cosa che ci premeva era centrarlo bottom sarà la stessa cosa cioè lo spazio che ho a disposizione no un attimo non è vero questa cosa questa è l'altezza però in realtà devo aggiungere il margine iniziale devo aggiungere 10 devo aggiungere 10 la metà di quello no mi sono incartato questa è l'altezza per cui devo comunque dimezzarla sì esatto questa roba qui va bene ma a metà se non sto disegnando in fondo al rettangolo così e qui devo metterci i 10 iniziali quanto è bello lavorare con le guintettature no però ci aiuta a capire quanto è bello fare il layout con un flatt perché tutto è in automatico però l'idea è questa il top del testo è 10 perché è il margine magico che abbiamo chiaramente dovrebbe diventare una costante a che parte adesso fatto così non è bello ma uguale dice il margine poi ci metto la metà dello spazio dello schermo meno i margini quindi è il mio rettangolo bottom meno top è strumento quanto è alto il mio rettangolo che è lo spazio bianco fratto 2 perché voglio metà di quello poi da quello tolgo la metà dell'altezza del testo perché voglio andare in su della metà del testo quindi meno misura bottom fratto 2 tutto questo accrocchio incredibile dovrebbe portarmi nel posto giusto il bottom qual è? il bottom è aiuto il bottom è questa roba qui quindi questo è uguale a se vogliamo fare le cose veramente schifose facciamo le cose schifose il bottom non è importante non è rilevante può essere anche in fondo in fondo quindi ci mettiamo il mio rettangolo bottom tanto se è più alto non è un problema tanto windows disegna comunque in cima quindi l'importante è il top io dubito che questa cosa funzioni però vediamo se ci ho preso anche solo vagamente cambio questo non è più il mio rettangolo perché è il mio rettangolo a destinazione vcenter lo tolgo perché tanto sappiamo che non serve a niente compiliamo questo approcchio e sicuramente ho connesso vari errori di varia natura e invece no sono estremamente fatti ok quindi magicamente funziona non chiedere estremamente che cosa ho fatto però però funziona quindi questi abbiamo fatto un layout manuale centrando questo test banale sì se lei aumenta cosa? qua 11607 come c'è sicuramente l'età ah vabbè lo schermo ok invece dovrebbe essere 2400 perché è un attimo mi ero appena gasato perché funzionava in realtà non è vero ah vabbè non vogliamo sapere questo va questo allora sì perché il suo schermo ha un ppi che era 96 cioè lì Windows sta mentendo su quanti sono i pixel perché fa finta che lo schermo abbia 96 ppi mentre in realtà ne avrà 200 ed è se io mi spostassi qui sullo schermo principale che adesso voi non vedete avverrebbe la stessa cosa perché lo schermo del portatile è molto più denso rispetto al proiettore il proiettore invece in genere hanno dei ppi bassi a bassi perché sono i proiettori quindi qui stranamente torna quindi qui è 1 a 1 ppi quindi qui Windows dice 96 e probabilmente il proiettore ha 96 ppi possiamo immaginare e tant'è che torna però nel suo caso non torna e quella è la è la menzogna che Windows cioè spaccia come vera perché per compatibilità con le applicazioni vecchie quindi praticamente l'applicazione se fosse stata fatta per Windows 95 vedrebbe quel numero di pixel e poi viene allargata forzatamente sullo schermo che ha molti pixel quindi in teoria immagino che il testo sia lievemente sfumato vero? sì quello è questo effetto di zoomatura automatica che che non possiamo evitare perché l'applicazione è scritta come si scrivono applicazioni per Windows 3.1 adesso vi faccio vedere come si come si compensa questa cosa ma anche questo non capisco perché perché sparisce misteriosamente a fratti non voglio sapere ok ero tutto contento un secondo fa beh diciamo che proprio perfetto non è ecco c'è qualche caso limite in cui la cosa non funziona perché non funziona così male questo va risolto perché ne va del mio onore quindi quando massimizziamo a un certo punto si pantana tutto dopo il click il click cosa fa invalide secondo me potrebbe essere questo vediamo un po' perché ah no era da perché scusate debugging in tempo reale e quando si blocca in questa maniera in realtà funziona ancora tutto eccetto il testo il portito lo fa ancora quindi la paint la esegue e quindi è questa cosa che esplode allora vediamo perché secondo me ecco qualche problema di buffer che non viene pulito sembra essere corretto in teoria sto facendo errori di aritmetica oppure questi rect qui allora non non allora non penso sia questo problema però potrebbe anche essere quando alloghiamo queste variabili qui vivono sullo stack variabili esattamente come degli interi in teoria la specifica ci dovrebbe allocarle dovute a zero quindi mi aspetto che misura sia tutta zero zero zero zero però è anche vero che fidarsi del compilatore non è mai una bella idea quindi quello che si fa in jesus il win 32 si usa la procedura zero memory che serve forzatamente a zerare un blocco di memoria non so se questo è il problema però magari intanto proviamo quindi il puntatore a misura e size of rect questo questo fa sì che quel blocco rect sia a zero è un tentativo dubito che sia questo francamente però altrimenti non è un'altra idea brillante a meno che appunto qualcosa di ritmetico che ho sbagliato cosa peraltro molto probabile il buffer qui vabbè il buffer in realtà è una buona idea a zerarlo adesso vediamo con eccessiva cura magari però questo in realtà non serve perché da poi la sprintf ci scrive sopra quindi in realtà questo è perfettamente inutile ma questo lo descriviamo tutto questo pure quindi questo l'unico magari questo ok direi che era qui ok devi mai fidarsi del copilatore non c'è nulla che ci aiuti neanche neanche lo strumento che dovrebbe salvarci quindi ok queste variabili qui le ha allocate sullo stack ma non le non le non le azzerava quindi non so se TCC che fa così o perché va bene così comunque allora per per essere sicuri che tutto sia corretto bisogna impostare tutto quanto a zero o lo facciamo in maniera brutale così Zyro Memory è una funzioncina che prende il puntatore a qualsiasi cosa gli diciamo quanti byte sono e mette tutto a zero quindi è proprio il modo più brutale che si possa usare per azzerare qualcosa questo in realtà non serve perché ci stiamo scrivendo sopra un secondo dopo quindi Zyro Memory è perfettamente inutile in effetti perché non leggiamo mai la destinazione ma ci scriviamo subito quindi questo va bene però quindi il problema era in misura che magari quando viene chiamata la funzione conteneva ancora dei dati non veri e quindi la misura andava a sbarrellare ok direi che non ho risolto il mistero ok dove volevo andare a preparare a questo punto ah i ppi ok diciamo giustamente i pixel non tornano in base allo schermo che abbiamo che stiamo lavorando andiamo a calcolare questi ppi di cui vi parlavo la volta scorsa allora come si fa a calcolarli allora si fa in questa maniera qui si può calcolare allora in WMP si possono fare tutte le operazioni che ci servono quindi in questo caso potremmo calcolare i ppi anche qui dentro però come vi ho detto in più occasioni WMP meno lavoro fa meglio è per tutti per cui in genere quando bisogna fare una cosa solo una volta all'avvio dell'applicazione della finestra si fa dentro WMP quindi siamo sicuri che quella finestra fa con l'operazione una singola volta quindi qui dentro andiamo a calcolare una serie di cose quindi faremo due cose in realtà calcoleremo i ppi dello schermo poi vedremo che in realtà sul suo pc comunque non funzionerà purtroppo però quello no vorrei dico anche perché però risolveremo sarebbe una tragedia di greca praticamente però le dico come si fa se vai e poi carichiamo un font che sia un pochino meno brutto di questo di default c'è a chi piace sicuramente allora come si fa qui dentro intanto andiamo a ottenere di nuovo un hdc una handle to device context esattamente come lo facciamo con beginpaint quindi ci serve comunque un puntatore al dispositivo su cui andiamo a disegnare qui non lo otteniamo tramite beginpaint perché come vi dicevo beginpaint è valido soltanto dentro un messaggio quindi qui non possiamo fare beginpaint perché non tornerebbe un valore valido però possiamo comunque fare get dc di una finestra possiamo ottenere il accesso accesso al device context della nostra finestra perché magari dobbiamo fare delle operazioni che non sono di disegno ok quindi possiamo questo hdc lo possiamo ottenere ma non possiamo fare draw text perché non funzionerebbe però possiamo ottenere delle informazioni come per esempio avviene con la chiamata che si chiama get device caps che sta per get device capabilities cioè dammi le capacità del dispositivo adesso vi faccio vedere tutte le varie capacità che possiamo andare a leggere nel nostro dispositivo perché qui c'è una lunga lista di proprietà che possiamo andare a leggere o capacità che possiamo andare a leggere quindi che tecnologia viene utilizzata la grandezza orizzontale verticale la risoluzione i bit per pixel quanti sono i pennelli su quel dispositivo i colori eccetera quindi tutte cose che possono essere utili o meno per quanto riguarda il come si disegna su schermo quello che ci interessa al momento è il numero logico di pixel quindi questa roba qui log pixel x e log pixel y ossia il numero di pixel per inch quindi per pollice su questo schermo ok log pixel x e y allora in teoria a meno che non avessi uno schermo veramente esotico il ppi è uguale sia in risontale che in verticale perché in genere il pixel è quadrato cioè non toglie che sulla carta se uno fa uno schermo veramente strano con dei pixel rettangolari potrebbe esserci un ppi diverso in verticale risultane secondo me non vale la pena occuparsi di questo scenario apocalittico quindi facciamo finta che sia che non ci interesse e usiamo il ppi verticale o cioè è tanto uguale quindi non tanto quindi vogliamo get the best caps del del device quindi htc e vogliamo i log pixel y e questo ci ritorna un intero che sono il ppi verticale ok il ppi verticale qui sono messo dentro un intero in realtà poi lo vogliamo disegnare dentro la paint quindi facciamo un altro intero globale orribile e lo diamo per il ppi e quindi andiamo a scriverlo qua quindi in fase di creazione della finestra andiamo a caricare qual è il ppi verticale potremmo caricare anche quello orizzontale giusto per essere anzi facciamolo per essere sicuri che siano uguali non si sa mai ma in teoria poi metto dubito che storicamente esistano dei schermi sicuramente dei pixel non rettangolari ma è bello non lavorarci con quelli allora a questo punto mettiamo i ppi qui dietro nel testo quindi qui metto un altro a capo e metto screen ppi e ci metto d e d e ci metto or ppi qui e ver ppi qua h h formalmente correttissimi ok quindi li preallochiamo quindi siamo sicuri che il messaggio vmcreate viene inviato prima della prima paint quindi questa roba qui viene fatta prima di paint sicuramente questa è una garanzia che ci dà 1.32 e quindi siamo sicuri che questi due valori qui esistono quando viene chiamata la prima paint perché in assenza di finestra non c'è c'è poco da da disegnare ok non so se cosa inquadrarvi se d'altro c'è una riga in più a questo punto con il ppi che è un altro uno stress test del nostro algoritmo per l'allineamento del testo vediamo se ok funziona e come era promesso i ppi sono 96 ok e adesso immagino che anche sul portatile cioè se eseguito il stesso codice mi aspetterei che windows da da millantatore qual è continua a promettere che non c'è il ppi anche se è una una menzogna bella e buona allora come si fa a convincere windows a darci valori reali allora bisogna convincere windows che la nostra applicazione è stata scritta non per windows 3.11 ma per un windows più moderno che conosceva dei schermi a risoluzioni più alte adaltro appunto vi dico è sempre 96 per tutti i windows vecchi quindi a che serve questo lockpixel sx se tanto è sempre 96 in effetti è una domanda è una ragione cioè esiste ragioni storiche perché sulla carta l'utente poteva anticamente specificare i pixel verticali dello schermo volendo ma questo non veniva mai fatto in realtà e la maggior parte delle applicazioni venivano scritte ignorando questo valore quindi poi a un certo punto perché nessuno lo usava e quindi non è ignorato il valore esiste per ragioni storiche quindi lo possiamo caricare ma non serve perché quindi esattamente come per macOS è rimasto il 72 dagli anni 80 fino ad oggi su windows uguale è rimasto 96 e quindi non c'è molto da fare se non che se noi promettiamo a windows che siamo stati molto bravi e conosciamo il valore dei ppi allora windows può darci accesso al vero valore dei ppi solo se noi stiamo pre promettendo che ne faremo uso per adattare il test è esattamente quello che fa appunto esplorare i source era quando chiaramente questo è stato scritto per la versione corrente di windows quindi chiaramente deve adattarsi ai ppi deve fare questo magheggio qui per farlo serve che questo valore qui sia per i dire veramente per cui adesso qui non lo facciamo perché è troppo complicato e tra l'altro non sono mai riuscito a farlo funzionare con tcc il problema grosso è che il compilatore che non sono riuscito a convincere convincere a farlo a funzionare perché bisogna cioè il modo con cui si fa è che si aggiunge un manifesto un piccolo un piccolo file di testo all'eseguibile quindi il nostro ex il nostro eseguibile che vive qui dentro quando viene compilato questo eseguibile qui ci viene embeddato un piccolo file di testo un manifesto di effetti quindi esattamente come manifesto per Android per AWS per iOS di cui parlavamo la volta scorsa parlando di applicazioni pacchettizzate i moderni eseguibili per Windows possono contenere un piccolo manifesto che è molto molto scarno e può contenere un valore magico un numeretto magico che indica l'ultima versione per cui quell'eseguibile è stato preparato di Windows cioè quindi l'ultima versione nota di Windows per quando è stato compilato quell'eseguibile a quel punto Windows sa ok questo eseguibile conosce Windows fino a Windows 10 quindi viene eseguito con compatibilità per Windows 10 quindi tutte le funzioni vengono rimappate in maniera da funzionare per quella particolare versione di Windows questo non avviene per questo eseguibile che non continua nel suo manifest e quindi viene eseguito in modalità di super compatibilità per Windows 10.11 per cui tutte le funzioni che abbiamo a cui accediamo mentono proprio per forza perché devono riportarci a un mondo di 40 anni fa quindi non avviene magari se riesco a farlo funzionare per Visual Studio però sarà perché secondo me TCC ci ho provato ma non sono riuscito a farlo funzionare ci riuscirò stasera magari ve lo metto come guida sul blended se volete provare però se riuscire a infiliare questo manifesto dentro l'eseguibile a quel punto questa chiamata qui vi comincerà a non mentire più e tornerà 200-250-300 quello che è ok perché a questo punto a cosa serve questo PPI? serve perché conoscendo il numero di PPI che abbiamo possiamo finalmente fare la mappatura dei punti tipografici famosi di cui parlavamo la volta scorsa e avere un valore che abbia senso nel nostro eseguito faremo come ultimo passo facciamo proprio questo ossia creiamo un font che abbia senso per questo schermo qui per cui ah altra cosa dimenticavo tutti tutti gli oggetti che di cui otteniamo una handle come questo HDC in genere vanno anche rilasciati è come se allocassimo la memoria per cui questo DC va anche rilasciato con release DC dopo se no poi Windows alla lunga si offende cioè si offende alloca memoria che poi non viene dialogata quindi a tutto punto la memoria finisce e e questo è esattamente come avviene per il beginpaint e l'endpaint fanno lo stesso lavoro in sostanza get DC vi alloca un HDC e release DC ve la rilascia di nuovo ok a questo punto vogliamo calcolare la grandezza in punte del nostro font come facciamo a fare ah intanto prima alloghiamo fonti intanto che è anche un'altra cosa utile i font si allocano si creano con la funzione che si chiama create font ovviamente che ha una serie di parametri molto lunga adesso lo vedremo molto rapidamente e questa funzione qui vi ritorna un h font quindi è una handle a un font che non possiamo mettere qui nella variabile ma bisogna sempre tenerla come globale perché poi ci servirà dentro la paint per usare quel font quindi facciamo qui 8 font che è mio font con grande originalità e quindi vado a creare il mio font qui dentro ok create font cosa prevede intanto vuole il numero di punti tipografici del font quindi qui mettiamo qualcosa che abbia senso mettiamo 10 intanto poi vediamo come adattarlo anzi faccio vedere perché molti anche create font è veramente un po' come create window ha una serie di parametri molto arcani di quali poi se c'è in un remo però sappiate che esistono allora vedete che anche qui che bellezza quindi height è la l'altezza del font in un'etalogica quindi praticamente in punti tipografici quindi è il nostro 10 la larghezza del font non ci interessa perché la larghezza ci mettiamo 0 perché a quel punto Windows ci darà un font che è alto 10 non ci interessa quanto sia largo poi c'è escapement orientation e weight sono delle specifiche del font che anche qui non ci interessano orientation serve solo per i font cioè se vogliamo scrivere in verticale per esempio o per i font asiatici che hanno l'andamento in verticale perché anche qui mettiamo 0 0 e siamo felici così weight è il peso del font che sarebbe a dire la esatto ogni font in genere può avere un gran numero di pesi tipograficamente questo vedete che i valori vanno da 100 a 900 qui sono i stessi valori che si usano in tipografia standard e li trovate anche per esempio in CSS proprio pari pari per cui se in CSS usate font weight 100 è la stessa mappatura quindi qui in genere un font standard ha un peso di 400 per cui usiamo font weight normal o regular è differente altra cosa piccola nota margine tipografica stranamente il peso standard del font non è quello medio cioè 400 i font per il corpo del testo sono lievemente più leggeri del font medio tant'è che font weight medium è 500 ma il font che si usa nuovamente è 400 perché diventa più leggerino del peso standard poi la maggior parte dei font non è che cambia radicalmente in base a quello cos'altro ci serve allora ci serve qui abbiamo dei booleani che indicano se è italic quindi se è corsivo se è sottolineato se è striped alt quindi se è barrato quindi tutti allegramente false false perché non interessano potete mettere la true per avere quelle cose poi c'è char set andiamo nel regno di char set allora qui possiamo specificare a windows che tipo di char set che mappa di caratteri caricare per un dato font perché alcuni font hanno char set diversi in base a quello che andiamo a presentare a schermo per cui se qui avete c'è chinese big est europeo che ha tutti i caratteri con le varie gli vari accenti varie direzioni qui c'è il cirillico qui ci sono i caratteri appunto turchi con le barrette sotto la i senza punto tutte queste belle cose e così via a noi ci fa piacere usare la default char set per non complicarci la vita che userà il char set che ha più senso per quella versione di windows a momento che è attivo quindi in questo caso sarà i caratteri occidentali europei poi abbiamo precision e queste qua sono cose storiche che non sono veramente utili quindi usiamo out default precise calcolo default poi clip default precise per buono non è veramente importante poi qualità quanto deve essere buono il font che questo è una cosa che storicamente aveva un senso adesso in realtà windows è sempre a massima qualità perché non ha più senso ottimizzare e renderizzare male il font perché per fare fretta quindi default quality va sempre al massimo pitch è la rotazione default pitch è il font più rotato e poi finalmente il nome del font finalmente la cosa che ci interessava va per ultima quindi ecco purtroppo sono tutte queste belle cose a specificare in realtà cioè purtroppo la tipografia è una questione seria tra virgolette per cui sono mille parametri e qui si pisa a fornirli vedrete che tutte queste cose o almeno una buona parte di queste le troveremo anche in flatter ovviamente perché vengono mappate e quindi sulla carta potremmo aver bisogno di usare la stessa maniera poi è vero che molte di queste robe vengono tralasciate poi comunque la capacità di specificare un font in grassetto in corsiva e così via rimane ed è sempre utile qui ci mettiamo la cosiddetta font family quindi il nome della famiglia del font che può essere qualsiasi in Windows classicamente si può usare Arial su su Mac OS useremmo come si chiama San Francisco una cosa del genere oppure Taoma o qualcosa cioè i font quelli classici che sono su Windows li troviamo tutti quanti possiamo metterci il testo che più ci piace a questo punto se non ci sono errori il mio font viene allocato correttamente e a questo punto possiamo usarlo dove? sotto prima di fare delle operazioni di disegno quindi prima di fare draw text allora anche qui bisogna fare un altro po' attenzione perché come funziona la specifica del font vedete che qui in realtà draw text non ha nessun parametro in cui possiamo specificare il font quindi non c'è modo per dirgli disegna con il dato font perché il font fa parte della tavolozza quindi in qualche modo bisogna andare nella tavolozza con cui stiamo lavorando cambiare le font di default e a quel punto tutte le draw text che vengono richiamate da noi fanno uso del font attualmente attivo quindi in qualche modo il disegno in disegnare su schermo nelle guida 32 è una procedura che ha dello stato interno perché la tavolozza appunto viene cambiata in temporale man mano che noi modifichiamo la tavolozza tutte le operazioni che facciamo cambiano aspetto e quindi subito dopo la baking paint possiamo fare per esempio una chiamata che si chiama select object e che qui è una chiamata molto generica perché appunto object è qualsiasi oggetto per la tavolozza possiamo passargli il font quindi passiamo hdc che è il nostro device context come al solito e poi gli passiamo mio font come parametro questo non fa altro che attivare il mio font nella tavolozza ok da qui in poi tutti i draw text usano il font custom quindi questo vale sia per quella quella del text di misura che userà il font nostro per misurare il testo sia questa se vogliamo usare font diversi bisogna farlo bisogna ricordarsi qual è il font attivo di volta in volta un'altra cosa che fa select object è vi ritorna il font precedente questo è comodo in alcuni casi se volete usare font diversi volete tracci di quale è quello precedente appena tolto se volete potete fare questo qui default font questo adesso lo faccio giusto per farlo se volete un riferimento al font default di windows questo default font qui che viene scalzato dal font che stiamo mettendo che stiamo aggiungendo è un puntatore al font precedente quindi se volete tornare al font l'altro avete sempre select object in cui potete cambiarlo di volta in volta stessa cosa vale per anche quando andremo a disegnare a schermo e quant'altro stessa cosa vale per le penne i colori e quant'altro sono tutte quante cose attivabili con select object in particolare ok questo è quanto in teoria a questo punto tutto dovrebbe tornare chiudo qui a questo punto mi aspetto che tutto quanto venga rappresentato con il font taoma ed è un font taoma estremamente piccolo il giro ok questo è il famoso font taoma va benissimo con una dimensione di 10 unità logiche sarebbe dire a 10 punti tipografici e già vi dicevo la volta scorsa quindi questa cosa qui è particolarmente leggibile perché perché non sono 10 punti tipografici veri perché allora se noi usiamo punti tipografici bisogna fare una mappatura prima per mapparli in un numero di pixel che sia accettabile per un lettore umano e quindi bisogna fare una piccola operazione prima di passare oltre e quindi in particolare calcolare quant'è la dimensione in punti tipografici del nostro font vi ricordate quanto è grande un punto tipografico è un settantaduesimo di foglia per cui la mappatura è esattamente quella quindi per fare la cioè per mappare punti punti è il numero di punti che vogliamo mettiamo che la dimensione è 10 lo moltiplichiamo per il fattore di scala che sarà che sarà fra il numero di ppi effettivi del nostro schermo che è 96 lo sappiamo però adesso facciamo finta che non lo sappiamo diviso 72 ci metto la virgola così questa è una divisione floating point questo farà 96 fratto 72 quindi sappiamo anche quanto è nato e fisso quindi è 1.33 ok quindi sarà alla fine questo qui sarà 13 ok quindi questo devo anche costarlo a interno se no poi il compilatore non è contento però alla fine dei conti quindi per avere un testo a schermo grandi 10 punti tipografici quindi che dovrebbe essere poi grande se il punto è 3.52 millimetri dovrebbe essere alto 3 millimetri in teoria 3.5 millimetri scusate faccio questa proporzione qui e dopo questo giro qui uso punti come dimensione invece di usare 10 uso punti questo sarà 13 a questo punto se compilo ed eseguo intanto somiglia un pochino più alla dimensione precedente e mi aspetterei che se avessi uno schermo da 96 ppi veri se andassi misurarlo con il metro il font dovrebbe essere alto 3.5 millimetri nel suo caso sicuramente non è vero perché sarà illegibile uguale allora se lo usiamo su uno schermo con 200 ppi o quello che è che il fatto che il fatto che Windows sta mentendo rende tutto quanto molto piccolo ovviamente quindi la sua applicazione in esecuzione il suo schermo ha 200 ppi qui stiamo dando per scontato che sono 96 ppi quindi in realtà dovremmo raddoppiare quanto meno il numero dei punti tipografici che stiamo chiedendo e altra cosa che non fa tornare nel nostro scenario in aula qui la cosa non torna perché chiaramente il proiettore cioè nel caso del proiettore la dimensione fisica non ha alcun senso che il proiettore è in base a dove è posizionato chiaramente poi i pixel sono più o meno grandi in base a quanto viene sommato sullo schermo quindi adesso non mi metto a misurare il testo lì però chiaramente può essere più o meno grande in base a al fattore di scala però in teoria se fate girare questa applicazione sullo schermo con 96 ppi in teoria il testo è grande 3,5 mm però quanto questo sia vero va visto comunque è molto poco leggibile quindi non è proprio comodo e quindi i 10 punti grafici sono pochini possiamo almeno a 12 da leggere così da renderlo un pochino più leggibile il testo di default è grande 12 mi sembra cioè 12 per fattore di scala forse anche un po' di più forse del 414 tra l'altro se volete a complicare la cosa c'è anche il fatto che i font si comportano in maniera diversa in base al font stesso quindi in realtà un punto tipografico è vero che sulla carta secondo quello che diceva Torosello nel 1400 occupa dovrebbe occupare un 72esimo di pollice e quant'altro cioè stando al standard postscript più che altro però i font poi fanno quello che vogliono quindi in genere cambiando il font cambia anche la dimensione fisica del testo spesso per cui una procedura che sulla carta c'è tutta una matematica dietro in pratica si fa occhio e si spera si incrociano le dita e si spera che tutto sia leggibile comunque qui adesso prima di uno torno perché il testo mi sembra più o meno coerente con il testo del titolo no la dimensione all'incirca dovrebbe essere la stessa quindi siamo più o meno nel regno corretto di dimensione ok questo questo è qua per il magico mondo dei fans siamo già a mezzogiorno per cui adesso a questo punto direi che chiudiamo questa sessione così poi andiamo oltre e facciamo così per i piani futuri adesso vi faccio vedere l'arrivo dei messaggi in Win32 così poi vi lascio andare e l'ultima lezione di tablatoria la facciamo la settimana prossima direi le prime tour di vederti prossimi in cui vi faccio vedere come si creano le finestre figlie con quello direi che possiamo chiudere e sbaraccare con Win32 e passare oltre passare al mondo di Windows Forms che vi presenta la stessa cosa però confezionata in un modo che non sia così faticoso lavorarci in sostanza però è una è una come si può dire è una strazione così non perfetta sì dove è qui esatto la zero memory praticamente prende il puntatore al blocco di memoria da zerare quindi end misura in questo caso e poi la dimensione di quel blocco di memoria ok perfetto sì questo è un po' in realtà ce n'è una cosa simile in standard C che è memset si può usare anche quella se non ricordo esattamente come la però fa la stessa cosa il mio memset scrive sulla memoria e migliora così byte per byte finché non è non è coperto zero memory è la stessa cosa però per le win32 però stessa stessa cosa ok allora facciamo una cosa diventamente più complessa vediamo se trovo qui quello che vorrei fare adesso è creare anzi facciamo così facciamo una pulizia copio questo lo chiamo font name faccio una copia così poi ve lo copio anche sul su blender così se volete avete il riferimento adesso creo un altro file copiato che è messages.c lascio tutto più o meno così come era salvo la warm paint dove cancello tutto e lascio soltanto la selezione del font diciamo cancello tutto forse anche se state seguendo anche le vostre case forse conviene fare questa cosa cancelliamo anche il bottom e poi qui dentro l'unica cosa che voglio fare è cambiare lo sfondo in white flash così devo fare quindi questo è vediamo se ancora funziona questo sì sì questa è una finestra vuota che non fa assolutamente nulla perfetto questo è quello che voglio fare adesso quello che facciamo è creiamo un buffer un array circolare tra virgolette in cui andiamo a stampare tutti i messaggi con mano che arrivano quindi mettiamo delle stringhe di testo che rappresentano il messaggio in arrivo sul alla finestra per vedere semplicemente che tipo di messaggi che arrivano e per apprezzare come funziona la cosa dell'area client e l'area non client che di cui parlavo prima così vediamo le varie aree delle finestre e come funziona allora intanto allora vogliamo fare in modo che ah un'altra cosa visto che la struttura fondamentale rimane sempre la stessa e se fate una finestra con il win32 effettivamente il modo di operare è sempre quella cioè qualsiasi cosa accada nella vostra finestra che sia un click che sia un movimento del mouse e così via voi dovete reagire a questo evento gestendo il messaggio fate delle cose interne qui dentro cioè aggiornate le vostre strutture date e così via e poi invalidate la finestra così che poi la WM Paint possa ridisegnarsi e riproporre lo stato aggiornato della finestra quindi se noi vogliamo proporre a schermo una lista di messaggi arrivati alla finestra quello che ci servirà è un array di stringhe cioè un array di di stringhe che rappresentano il nome del messaggio appena arrivato ok quindi per fare questa cosa qui in C possiamo fare una cosa estremamente primitiva ossia chiamare fare un array di array di strings dove il primo livello di array è l'indice delle stringhe facciamo finta che abbiamo bisogno di memorizziamo gli ultimi 30 messaggi arrivati per dire e ogni messaggio può essere lungo 100 ok quindi questo è il modo brutto in C per avere un array di 30 stringhe ognuna delle quali è lunga 100 caratteri come globale ok cos'altro magari questa cosa qui la diciamo come facciamo delle globali magari c'è delle costanti scusate quindi gli strings max è il numero massimo di stringhe che memorizziamo e il string land è quanto è lunga al più una singola stringa ok e a questo punto facciamo una piccola una piccola funzioncina che ci aggiunge una stringa nella lista quindi sarà void append string ci mettiamo addirittura la finestra magari page window e poi la stringa in C se ricordate le stringhe sono lpt quindi long pointer a stringa T come questa qui quindi non uso normalmente sarebbe conat sarebbe const char così questa è una stringa in C in in 32 usiamo questa bellissima nomenclatura che è la stringa ok quindi append string non fa altro che cioè idealmente va ad aggiungere una stringa al mio array e poi va a invalidare la finestra questa è l'idea ok per fare questo che cosa facciamo ci serve anche un un indice che è l'indice cioè l'ultima scrittura cioè dove sono arrivato nell'array a scrivere quindi lo chiamiamo i string sono nomi estremamente brutti il resto di variabile ma anzi facciamo così strings index che è più più chiara questo è l'indice di scrittura che andrà da 0 a 29 arrivate a 29 vogliamo ricominciare dal primo per cui qui adesso faremo la copia copia la stringa nell'array per una seconda e andiamo a fare aggiornare strings index in modo tale che sia coerente con l'array quindi facciamo strings index più 1 e poi facciamo un altro modulo strings max così che quando scavagliamo torniamo a 0 ok adesso dobbiamo copiare la stringa nell'array dobbiamo copiare la stringa nell'array in quale blocco nel blocco strings strings index quindi la destinazione è l'elemento strings indexesimo della array string cioè perché stiamo scrivendo una volta per uno in sostanza per copiare string in c vi ricorderete che c'è la funzione strcopy che però non va bene perché strcopy è per la via standard quindi prende dei byte e basta in realtà sulla carta potrebbe funzionare lo stesso sulla carta perché fa una copia quindi teoria potrebbe andare lo stesso però per non rischiare usiamo la versione per caratteri larghi che è underscore tcs copy perché si chiama così non lo so però si chiama così la destinazione è questa e la sorgente è str è chiaro non è codice sofisticato però è codice forse un po' convoluto l'idea che scriviamo la posizione all'inizio della posizione zeroesima chiaramente dell'array di string poi incrementiamo fino ad raggiungere l'ultimo elemento a quel punto riportiamo da zero quindi l'idea che i messaggi arrivano e vanno a scrivere sempre nella nella nel punto più recente diciamo così dell'array ok per includere questa funzione dal nome per il momento brutto serve includere anche una libreria che è tchar include tchar.h che sono le librerie di funzione di questo tchar che ci serve perché sono i caratteri quelli un po' più più larghi che è normale ok ok in teoria mi sa che c'è tutto ah non manca una cosa fondamentale quando quando modifichiamo le stringhe chiaramente a questo punto la nostra finestra deve essere invalidata perché dovrebbe dipingere la finestra quindi facciamo esattamente come avevo fatto la volta scorsa dentro vml button eccetera adesso questo mi sa che l'ha cancellato esatto però invalidate rect qui passiamo la finestra da invalidare null perché tutta la finestra non è più valida e true perché la vogliamo ripulire ok per cui forziamo la finestra e la aggiorniamo la ripuliamo ok questa è la funzione che farà le magie adesso adesso dobbiamo ancora disegnare le stringhe che sarà un'altra piccola tragedia ma la facciamo per un secondo prima vogliamo ricevere dei messaggi e scriverli da qualche parte per cui dentro l button l button app invece di fare operazioni di qualche natura andiamo a fare append string passiamo h window e poi mandiamo il testo ci scriviamo l button app magari ok questo possiamo ripetere per tutti i messaggi che ci interessano magari adesso l'aggiungiamo anche per button down che vi dicevo che esiste ovviamente esiste button up esiste anche button down ovviamente per cui qui ci aspettiamo che riceveremo prima il down e poi l'up in questo ordine per ricevere i click del mouse ma possiamo fare anche dell'altro possiamo fare anche questo non l'abbiamo visto finora ma è un altro messaggio abbastanza fondamentale le win32 vm size che otteniamo quando la finestra si ridimensiona insomma la pianto qui poi le aggiungiamo un altro paio per vederle qui chiaramente potresti per quello che voglio questa è una stringa qualsiasi e potremmo anche portarci dietro lparam e wparam però è una fatica in più che ci risparmerei in un momento perché dovremmo memorizzare anche quelli in un array e quindi è solo un lavoro in più ok abbiamo fatto più o meno e a questo punto cosa dobbiamo fare bisogna disegnare questo questa questa questa questa quindi strings qui è composto da un certo numero di string adesso puntiamo non sappiamo quante però andiamo a scrivere in maniera interattiva cioè sono massimo 30 veramente noi facciamo la cosa più primitiva che si possa fare ossia resta fino tutte quante partendo da sopra sinistra quindi andremo a stampare tutte quante una dopo l'altra e finché non si riempie il il buffer e poi si si passa oltre quindi qui qui dentro facciamo un un ciclo in sostanza un loop molto molto primitivo anzi facciamo for i che parte da zero i è minore di strings max che è il massimo numero di string e poi incrementiamo di 1 quindi loopiamo attraverso le string e poi per ogni string adesso intanto per pulizia diciamo così tiro fuori la stringa la stringa che andiamo a rappresentare è strings iesima giusto quindi str è la stringa che vado a rappresentare e qui basta che faccio draw text ah in realtà un'altra cosa più semplice facciamo una cosa ancora più banale faccio vedere che draw text è la funzione che si usa di solito per signerla schermo dentro un rettangolo ed è quella un pochino più sofisticata che permette di allineare il test e quant'altro però è un pochino più complessa perché bisogna passare un rettangolo e così via una funzione un pochino più scema per fare la stessa cosa è text out che fa la stessa cosa che scrive del testo ma lo scrive semplicemente con la coordinata in alta sinistra quindi è molto più primitiva e ci permette di essere un pochino più comodo da utilizzare e quindi usiamo questa text out quindi qui facciamo però è equivalente grazie text out passiamo hdc passiamo a questo punto le coordinate x e y attenzione che chiaramente per la coordinata x sarà 0 perché scriviamo nell'angolo mettiamo 10 così c'è un piccolo bordino a sinistra la coordinata y dipenderà dalla string che stiamo stampando quindi sarà 10 perché il bordino in alto vogliamo mettere di 10 più i cioè la iesima stringa per l'altezza in pixel del nostro font qual è l'altezza in pixel del nostro font? allora in realtà non lo sappiamo nel senso che abbiamo chiesto un font grande top punti questi punti qui tra l'altro è una variabile che non neanche ho più però è 12 per 1.3 quindi 12 per 1.3 grazie è 15.6 quindi dovrebbe essere troncato è 15 quindi adesso userò 15 come misura però vi dicevo prima che ogni font ha una dimensione un po' diversa degli altri che in realtà la cosa giusta da fare è chiedere al sistema ma scusa tanto ma quanto è alto il font veramente in pixel ed è quello l'incremento che useremo adesso lo facciamo tra un secondo però adesso per essere corretti al momento facciamo una cosa completamente a casaccio mettiamo un 15 che più o meno sarà giusto su questo schermo su altri schermi chiaramente non tornerà e poi passiamo cosa passiamo? passiamo il font la string quindi str giusto e poi il conteggio di di caratteri intanto mi sa che a questa funzione qui non possiamo passare meno uno perché sennò si arrabbia proviamoci non mi ricordo forse vero sarebbe molto bello forse non vero bisogna raccontare i caratteri ok tutto chiaro fin qui per cui ogni volta che aggiorno lo schermo cioè aggiorno la finestra vado a prendere tutte le string le stampo a schermo e le stampo partendo dall'angolo 1010 in alto e poi andando a scendere sulle y e questo in teoria dovrebbe darci la stampa dei messaggi vero infatti ci sono già degli attori mistici 17 dovrebbe essere la copia immagino vero ovviamente allora sono i parametri che noi ritornano diciamo usiamo perché ci sono varie libri di funzione che fanno la stessa cosa vediamo se troviamo una che mi piace di più allora non è molto utile il rischio è che poi la copia non vada come deve andare ecco diciamo questa qui wide csn copia dovrebbe essere la giusta quindi esatto quindi wide char l'unico problema è che questa copia qui ci richiede anche il numero di caratteri vediamo se riusciamo a cavarcela senza usiamo un copia ma togliamo n ho gabbato in questa maniera allora in c questo lo dico se no sembra delle porcherie praticamente nel c moderno string copy e così via sono state rimpiazzate da n copy che limitano il numero di caratteri questo perché era sempre un problema di buffer cioè un rischio di buffer overflow usare strcopy e così via che non hanno un limite fisso di caratteri perché strcopy e quant'altro si basano sul terminatore a zero della stringa se il terminatore a zero della stringa non c'è il vostro programma fa un errore di accesso a memoria e poi esplode o è aperto a dei bug di sicurezza per cui in genere nell'uso modello di c si usa n copy in cui la copia è limitata quindi anche qui wcsn copy è una versione con conteggio della copia però a noi la sicurezza non ce ne fece niente per cui usiamo wcsn copy senza la n che allegramente usa il terminatore a zero ok ah ho avviato il programma sbagliato era molto strano ok non vediamo nulla ancora vediamo se riesciamo a allora sto cliccando allegramente sui sulla finestra ma non vedo nulla adesso vediamo anche perché in teoria i miei messaggi stanno arrivando è una buonissima domanda e no penso che si tratta compilato si messaggi sono compilato quindi è diverso da da questo vediamo qual è il problema allora plausibilmente è qualcosa che avviene qui dentro intanto vogliamo mettere una text out generica per vedere se stiamo stampando la schermo però molto probabilmente è questo il problema cioè la lunghezza dei caratteri quindi qui sono 18 caratteri anzi sono così sicuro che è questo che lascio perdere il debug e dobbiamo quindi contare i caratteri sono i caratteri veramente lunghi quindi non possiamo usare strlen ma dobbiamo usare vcsnlen bellissimo quindi conteggiamo quanto è lunga la stringa in questa maniera str la n qui non ce l'abbiamo quindi usiamo vcsn ok quindi il text out prevede che bisogna passarle quanto è lunga la stringa se no non stampa nulla presumo e vediamo se sto dicendo cose non vere oh ok qui c'è un errore grossissimo però adesso ok funzionicchia c'è un altro ah funziona perché sto scrivendo sopra al testo sto scrivendo il primo messaggio messaggio in arrivo a correre 10-10 e poi il primo messaggio subito e dopo 10-10 ovviamente che primo ha i0 quindi va in quindi qui posso mettere i più 1 magari come bella l'aritmetica ricordiamo ok meglio quindi adesso scrivo messaggio in arrivo e poi ho stampato size perché il primo messaggio che mi è arrivato è effettivamente size questo perché quando win32 avvia cioè quando windows avvia una finestra manda una serie di messaggi standard che sono sempre quelli e il primo che abbiamo visto è create già conosciamo che è il primo messaggio in assoluto che arriva poi arriva size e move non mi ricordo in che ordine quindi move ci dice la finestra è in questa posizione e poi size ci indica guarda la finestra ha queste dimensioni sono i primi messaggi che arrivano in assoluto dopodiché arriva vm activate quando la finestra diventa attiva quindi la procedura più o meno è quella quindi adesso vediamo che è arrivato size a seguire se noi adesso clicchiamo vedete che compaiono i vari button down bottom up in questo ordine tra l'altro adesso a un certo punto quando vado scavallo i 30 messaggi ricomincia e quindi li sovrascrive che adesso size l'ho perso però per avere un nuovo size basta ridimensionare la finestra vedete che arrivano tanti messaggi size che vanno a rimpiazzare quegli esistenti non è molto chiaro perché non si capisce dove è arrivato quindi ok però capite che quindi a cascata arriva questi size i size arrivano in maniera interattiva ma man mano che l'applicazione viene ridimensionata quindi qui vedete che il fascinamento non è ancora finito però arrivano tutti questi messaggi size che ci aggiorno man mano che la finestra viene aggiornata chiudo un attimo per completare questa questa cosa perché vi dicevo prima di vmcreate e quant'altro allora c'era vmmove che era il movimento lo spostamento poi c'è vmactivate che è l'attivazione e poi c'è la create che è la prima quindi la mettiamo anche quella quindi qui dopo aver fatto le varie cose di preparazione ci mettiamo anche create quindi la registriamo quantomeno la destroyed non ha molto senso perché non facciamo il tempo a mostrarla quindi non si vedrà mai perché l'invalidazione non fa il tempo ad aggiornare una finestra che già sta per essere distrutta quindi la vmpain non ci arriverà mai poi aggiungo quelle del mouse perché sono tante le vediamo dopo ok quindi l'arrivo l'arrivo dei messaggi è create activate size in questo caso vedete in questo caso qual è l'arrivo adesso comincio a spostare la finestra e vedrete che dovrebbero arrivare dei messaggi move quindi vedete qui man mano che la finestra si muove riceve dei messaggi move esattamente come avviene per size quindi sono tanti ovviamente che arrivano man mano che la finestra viene spostata se minimizzo arriva sempre un messaggio come faccio a mostrarvelo questo faccio così quindi l'ultimo messaggio arrivato è il button up minimizzo riapro e è arrivato un po' di roba nel frattempo questo è l'ultimo messaggio arrivato move quindi la minimizzazione è comunque uno spostamento per quanto riguarda windows quindi viene spostato in una zona in cui non esiste più e size viene ridimensionata a zero quindi ha una dimensione a quel punto che non è più visibile questo activate qui sembra un'attivazione in realtà è una disattivazione è l'ultimo messaggio che arriva prima di essere minimizzati quello che segue è la riattivazione della finestra quindi activate questo qui è il click dell'utente qui sulla vara dei messaggi a quel punto la finestra viene ripresentata a schermo quindi ottiene di nuovo move come se venisse rimessa a schermo size perché viene ridimensionata e poi activate che è l'ultimo passo in cui la finestra ottiene il focus quindi ogni volta che c'è uno spostamento a schermo di qualsiasi natura arrivano una serie di messaggi di vario genere al quale voi volendo potete reagire questo avviene per la vostra finestra quindi avviene per la nostra finestra fatta a mano però avviene per tutte le finestre quindi prima vi ho fatto vedere la finestra molto complicata di notepad++ con cui si fanno le modifiche immaginate che ogni singola finestra vive di questi messaggi alla stessa maniera quindi quando vengono presentate a schermo tutti questi pulsanti ricevono WM Create WM Size WM Move e così via in base al fatto che vengono spostate all'interno dello schermo quando vengono cliccate queste finestre che non vengono gestite da noi però ottengono comunque dei messaggi è il button down e poi è il button up e grazie a questi messaggi cambiano il loro stile grafico quindi qui questo count qui si affossa graficamente perché ha ottenuto un L button down e rimane affossato fin intanto che non riceve la L button up ok quindi questo è il modo con cui elaborano i messaggi come si aggiornano con le paint quindi L button down è un paint che aggiorna lo stato del pulsante è il button up di nuovo paint e si aggiorna il pulsante e torna ad essere normale stessa cosa per questo mouse over quando il mouse passa sopra a qualcosa cambia stato grafico e questo come avviene con un altro messaggio che si chiama mouse move che è l'ultima cosa che vediamo prima di chiudere questa cosa qui vediamo lo trovo un attimo perché è abbastanza rilevante i movimenti del mouse sono in altra parte qui sono per questo eccolo qui sono i vari pulsanti qui appunto c'è il left button il right button che è il questo per bene il menu contestuale il medium button che è il pulsante medio che non tutti lo sanno e poi c'è anche il mouse guiro e così via che è la rotata del mouse e x button che è per tutti i mouse che hanno più pulsanti quindi se c'è un pulsante aggiuntivo in alcuni casi i mouse hanno pulsanti per andare indietro navigare e quant'altro questi vivono tutti quanti sotto x button e mouse move forse è il messaggio che viene inviato più di frequente nelle Windows 32 perché ne arrivano veramente tanti per ogni micro spostamento del mouse quindi questo per dare un apprezzamento a questo ok ricompilo anzi chiudo e qui vedete che i messaggi sono veramente tantissimi ancora più di quelli di size e quant'altro che ne arrivano con una gran frequenza e vi aggiorno su ogni singolo in ogni singolo istante di ogni movimento del mouse ok arrivano sono messaggi ad altissima priorità che sono i primi messaggi che gestisce la finestra e sono messaggi che vengono mangiati in alcuni casi nel senso che se la vostra finestra non reagisce in tempo a mouse move hanno una cioè sono ad elevata priorità ma non hanno rilevanza tale da essere indimenticabili per cui se la vostra quota di messaggi si ingolfa i messaggi mouse move possono essere mangiati perché evidentemente non è importante gestirli con quella frequenza è veramente importante se doveste gestire il movimento del mouse aggiornare delle cose grafiche e quant'altro questo è cosa che stiamo ignorando chiaramente per cui non è importante per cui alcuni messaggi possono non arrivare mai se il sistema prevede che possano essere persi il mouse move è il classico messaggio che può essere tranquillamente verso perché non è fondamentale anzi in genere l'ultimo movimento è quello importante in realtà quelli precedenti possono essere tranquillamente scartati perché si perdono senza grande senza grande rilevanza ok allora ultime due cose poi vi lascio liberi per questa questa carrellata di passi fondi di 52 vi dicevo prima che per capire l'altezza del font da mostrare bisogna capire quanto è alto il testo adesso qui abbiamo fatto dei calcoli completamente a mano e tornano perché sappiamo qual è lo schermo su che lavoriamo quindi 15 è un numero giusto tant'è che le stringhe sono distanziate in maniera corretta però in realtà nella maggior parte dei casi questo 15 qui non è che lo conosciamo bisogna tirarlo fuori dalla grandezza del font per cui c'è un modo per farlo in Win32 e è il sistema delle delle metriche del testo si chiama per cui possiamo ottenerlo con un modo un po' complicato non ce ne ho farlo quindi non ce ne ho farlo allora dentro WebCreate abbiamo già fatto qualche operazione abbiamo calcolato i punti del nostro schermo creiamo il font in base ai punti va benissimo così poi attiviamo il font sul nostro HTC quindi adesso questo non ignoro ma carichiamo il font dentro HDC il mio font viene attivato e a questo punto possiamo tirare fuori dalla device context le metriche del testo che ci interessano queste vivono dentro un oggetto che si chiama text metric cm sempre il classico blocco adaltro adesso mi ricordo anche di azzerarlo perché prima non l'ho fatto per essere un cittadino corretto delle Win32 lo azzero e chiedo a Windows quali sono le metriche del testo vi passo tm questo è un pattern molto classico di Win32 cioè all'occhiamo della memoria nella nostra memoria la azzeriamo e poi la passiamo a Windows perché ci popoli la struttura dati con i dati che ci interessano text metric è abbastanza grande quindi ha una serie di campi che ci possono essere più o meno utili in questo modo noi allochiamo la memoria al lato nostro e permettiamo alle Win32 di non allogare memoria cioè adesso in un mondo moderno noi faremmo in un linguaggio che non è C faremmo così no si può fare che C va a presto alto alto come? si può fare che C finalmente è alto costruzare è alto si questo è C però è anzi C moderno quando nelle Win16 non esisteva questa bella roba quindi non si può fare e bisogna sempre fare i passaggi per parametro in questa maniera ah lei dice che per bar scusi quello si può fare se il compilante si sopportasse questa cosa quindi mi sa che non è aggiornatissimo agli ultimi standard temo eh no quello volevo dire si potrebbe fare con la gestione dei puntatori automatica che è prevista in C++ però le Win32 sono così primitive che questa roba non ce l'hanno però allora se lavorassimo in C Sharp Dart altre cose moderne ci aspetteremmo che è Win32 che ci prepara la struttura d'Adi e ce la passa in qualche modo questa cosa non può avvenire assolutamente perché vorrebbe dire che Win32 deve allocare della memoria che è una cosa costosissima negli anni 80 per cui non se ne parla la memoria viene preallocata nella nostra applicazione come viene qui e noi passiamo il blocco di memoria alle Win32 che poi ci scrive dentro quindi questo avviene avviene per i Penstract avviene per per i Rect adesso non c'è più però che ho visto precedentemente avviene per TextMetrics quindi tutta questa roba è un pattern classico per evitare che Win32 debba allocare memoria per conto nostro ok a questo punto abbiamo il nostro TextMetric va benissimo qui dentro c'è un valore importante che si chiama TM Ave Char no scusate non è vero TM Tm Height che è l'altezza del font cioè l'altezza del testo del font attenzione ma il font chiaramente prevede che ci sia anche del piccolo spazio sopra e sotto del carattere per dare aria al font per cui a questo si aggiunge TM TM External Leading tutti nomi tecnici che guardano il magico mondo dei font e quindi in media i nostri caratteri nel font Taoma saranno alti tot questo average share height allora qui l'ho messo come intero qui ma in realtà ci interessa proprio che lo portiamo dietro quindi lo faccio diventare una globale perché ormai non è più questione di stile quindi questo average share height immagino che sia circa 15 o 16 e lo stampo no lo uso invece del 15 magico quindi lo uso perché l'altezza media di un carattere in Taoma è esattamente questa quindi lo uso qui sarà circa 15 per esserne sicuro magari posso anche facciamo anche questo per chiudere in bellezza questa questo massacro buffer 26 come è la funzione wss printf sì buffer messaggi in arrivo share height pixel ok questa roba qui e ci scrivo a a a a a a a a a a a a a a a a a a a a a a a a a a a ok non so se è comprensibile spero vagamente resi quindi creo un buffer con una classica stampa su buffer con caratteri larghi e così via così che a questo punto posso stampare buffer qui dentro ah sì sì sì grazie e qui stampo buffer quindi la lunghezza del testo non è più 18 che ho pescato completamente a caso ma devo conteggiarlo quindi a vcs capite perché nessuno usa le guin32 c'è un motivo ok a questo punto dovrei avere come prima riga l'altezza in pixel che poi viene utilizzata per stampare qui poi vi lascio vi lascio comunque il codice se volete se poi avete desiderio di rimare ecco l'altezza non è 15 che era quello che avevo stimato a mano prima è 16 perché in effetti in effetti nel calcolo che avevamo fatto era 12 per 1.3 che è 15.6 avevo troncato a 15 per così per semplicità però Windows personalmente calcola cioè rotonda in maniera corretta quindi l'altezza dei caratteri è 16 ok quindi quando andiamo a moltiplicare il le righe usiamo 16 come spaziatore ed è così che bisogna fare il testo se siamo così molto coraggiosi se vogliamo lavorare con il Windows 32 bisogna farlo in questa maniera quindi per quanto il testo adesso a questo punto è tutto corretto nel senso che adesso aumentando questo tutto aumenta di conseguenza quindi adesso è un testo molto più grande e tutto quanto cambia di conseguenza quindi cambia cambia la dimensione dei pixels del font cambia il chart height quindi cambia la dimensione con cui vado a spaziare e così via in genere ogni volta che usate un font custom in Windows dovete fare tutte queste operazioni qui perché lavorate in un mondo in cui non avete assolutamente non c'è nessuno che vi aiuta a posizionare i test in particolare e quindi tutto quanto va fatto rigorosamente a mano poi è chiaro che ci sono mille librerie per le Win32 che fanno esattamente questo e vi tolgono il lavoro sporco quindi insomma non bisogna necessariamente andare a fare queste operazioni qui veramente a mano però in genere per avere rimozione di quello che avviene poi dietro le quinte purtroppo è questo quindi non è non è banale ok io te che metterò un po' qui sono le 12.50 per cui basta così maniera bianca tutta questa cosa qui potete per fortuna dimenticarla quando uscite questa stanza quindi non è cioè appunto non vi sarà utile spero nella vostra vita professionale perché vi auguro di non lavorare mai direttamente con questi con questo codice a basso livello però è utile sapere che questa roba esiste perché alla fine dei conti anche Flutter cioè dietro uno stack di software molto importante quando andrà a creare dei font lo farà con queste operazioni qui quindi farà queste operazioni qui per conto vostro e voi potrete tranquillamente utilizzare queste funzioni con con molto più facilità questa è la bellezza di lavorare con uno stack un pochino più elevato dietro le quinte ci sarà sempre questo ad attendervi non è bello però questo si ricollega al discorso dell'altra volta in cui avevo visto che il terminale il terminale era il mondo determinale per quanto moderno sia viene dalla telescrivente quindi in realtà viene da delle cose super primitive in cui c'era una macchina meccanica che andava a scrivere del testo su dei fogli di carta è vero che non è più quello però le primitive con cui questo terminale qui mostra i caratteri a schermo sono le stesse con cui il telecomitore si aveva caratteri sul carta quindi alla fine purtroppo cioè prima o poi bisogna andare a scontrarsi con la realtà fisica della delle cose e nel caso specifico di un'applicazione grafica su Windows alla fine dei conti è questo che vi trovate sotto questo qua vi carico dopo a parte le registrazioni se volete vi carico anche i font.c e i message.c così avrete anche il codice se proprio volete farvi del male ok niente amici buona buona settimana e ci si aggiorna alla prossima ok