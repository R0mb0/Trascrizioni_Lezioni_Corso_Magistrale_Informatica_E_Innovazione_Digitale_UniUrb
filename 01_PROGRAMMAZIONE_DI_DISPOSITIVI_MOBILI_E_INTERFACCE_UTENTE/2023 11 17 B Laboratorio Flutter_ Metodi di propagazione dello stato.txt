ok ripetiamo da qui allora abbiamo visto la comunicazione tra widget adesso ci complichiamo un attimo la vita e le cose si faranno più complicate in maniera cioè più astruse brevemente e poi dalla volta prossima troveremo un sistema per risolvere alla radice tutti i nostri problemi con lo stato però prima di arrivare a questo punto vediamo come alcuni aspetti un po' più sofisticati che potrebbero essere un pochino così un pochino complessi quindi cerchiamo di afferrarvi se qualcosa a seguire non è completamente chiaro magari lo spulciamo insieme per essere sicuri che venga che sia comprensibile insomma quindi fermatemi quando quando avete bisogno allora finora fin qui c'eravamo no quindi la comunicazione diretta tra widget è abbastanza banale cioè è abbastanza banale l'ho già vista e si riesce ancora a intuire abbastanza in maniera diretta per cui abbiamo di widget che a un certo punto c'è dello stato di partenza che arriva da qualche elemento alto della nostra generarchia e viene propagato verso il basso ed è quello che abbiamo fatto no nel nostro esempio se riesco ad esempio abbiamo fatto con per esempio il nostro contatore il nostro contatore vive qui dentro e va bene poi viene propagato no a questo testo qui viene propagato poi a questo oggetto qui il nostro counter display che a sua volta andrà a mostrarlo no quindi abbiamo questo legame eh diretto tra oggetti questo oggetto qui è un oggetto molto molto primitivo che non fa altro che mostrare un contatore e eh lo stato vive da qualche altra parte più in alto quindi effettivamente è quello che avviene qui quindi immaginate che no il contatore è qui nello scaffold immaginiamo e lo stiamo passando giù verso un altro oggetto più in basso poi a sua volta in realtà eh counter display prende il contatore però in realtà internamente poi lo passa no a un text quindi e questo in realtà è un esempio banale ma possiamo eh avere una gerarchia ancora più complessa qui per cui il contatore in realtà può fare più strada se volessimo no se uno vuole farla più complicata si può si può eh fare e va bene ora per esplicità per rendere più evidente questa cosa qui andiamo un pochino a complicare cioè a complicare l'esempio perché vogliamo fare un'interfaccina adesso tralasciando le altre cose che abbiamo visto finora eh vogliamo fare un interfaccia eh cioè vogliamo fare scusate un blocco l'interfaccia un componente quindi renderemo cioè estrapoleremo questo text qui questo counter display e il pulsante ok lo modificheremo in modo da avere un pulsante più che aumenta il contatore un pulsante meno che decrementa il contatore e poi avremo un oggetto che mostra il contatore che è una cosa molto molto semplice però ecco una cosa che magari è già più simile a cose che potrebbe essere inutile fare tra virgolette ok perché andiamo a fare questo oggetto ma attenzione vogliamo che allora attenzione vogliamo che lo stato venga da fuori per cui questo contatore qui lo zero quello che viene incrementato qui non è interno al nostro componente ma è esterno quindi viene da home page ok questa è la differenza se fosse interno lo potremmo fare esattamente come abbiamo implementato questo oggetto qui questo contatore questo contatore questo come era il nome di questo non lo ricordo era il color switcher no questo oggetto qui è un componente a sé stante che racchiude lo stato quindi questo oggetto qui non deve passare lo stato da nessuna parte ce l'ha già interno per cui è completamente avulso da qualsiasi altro componente della vostra interfaccia grafica per cui in qualche modo il colore non riguarda nessun altro elemento e questo è ovviamente lo scenario ideale in questo caso non è quello che vogliamo fare per cui vogliamo fare un contatore che è generale e rientra in quello che prima abbiamo chiamato stato d'applicazione quindi abbiamo fatto la differenza tra stato effimero o locale e stato dell'applicazione vogliamo che il nostro contatore si rientri in questa condizione ok lunga traduzione basta così per cui giusto per tenere le cose pulite faccio anche questa ulteriore operazione faccio salvo il main qui magari così poi ve lo carico su blended senza andare a modificare le cose questo ve lo caricherò così ce l'avete adesso vado a modificare un po' lo stato così ripartiamo da da zero allora ok quindi creerò un componente che in sostanza è diciamo così la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la la counter-toggle-direct. Quindi abbiamo counter-toggle. Come sempre partiamo con SETS widget, poi andiamo a pubblicarlo, se necessario. Il ride è questo, il costruttore è questo, molto bene. Questo, come al solito, è un componente che richiede una colonna per essere contenuto, perché ha due oggetti, almeno di partenza, che sono questi qui, il maca punto e virgola. Qui adesso l'on-pressed, qui lo ripuisco tutto perché lo rifaremo da zero, che adesso al momento non farà nulla. E il contatore, chiaramente, al momento non ce l'abbiamo, quindi passiamo qui. Ah, intanto il counter-display è nel... Allora, ho creato questo, giusto per ripartire da zero, counter-toggle perché è appunto il nostro toggle, quindi è il nostro elemento che permette di switchare, di toglare il contatore. Lo chiamo direct perché per ora lo implementeremo col passaggio diretto dei parole, quindi lo implementeremo esattamente così. Non così. Col passaggio diretto, cioè col passaggio al quale siamo abituati, che sarebbe a dire questo, no? Quindi col passaggio widget a widget. Ok, ora per utilizzarlo di là, visto che l'ho creato in un file a parte, dovrò importare il file, banalmente. Quindi qui nel main andrò a metterlo dove stava prima, quindi dove l'ho tolto. Questo qui è il counter-to-direct, che ovviamente va importato. Adesso lo fa da solo il nostro Visual Studio, appena se ne accorge. Ok, importiamo. Ok, tra l'altro questo può essere cons, perché è stateless, va benissimo. Qui dentro, qui facciamo riferimento a un oggetto che è nel main stesso. Quindi di base andremo a importare il main, quello che suggerisce anche il... Nel mio senso c'è una dipendenza circolare tra due elementi che non è proprio bellissima, per cui dovrebbe funzionare lo stesso, quindi non dovrebbe dare problemi effettivi. Però a livello di codice è un po'... è un po' un accrocchio, diciamo così. Adesso chiaramente non incrementa, perché il contatore non viene aggiornato, ovviamente. Il contatore, al momento, nel nostro counter-toggle qui è sempre zero, quindi cambia poco. Solo che appunto a livello stilistico, quindi main importa counter-toggle direct, e poi counter-toggle direct importa main. Per nostra fortuna Dart questa cosa non lo offende, quindi ce la fa lo stesso. Se lo facessimo in C, come sapete, esploderebbe il compilatore, e quindi non si potrebbe fare. In questa cosa si può fare, ma è comunque non bellissimo, perché abbiamo un po' di... uno spaghetti code tra dipendenze, per cui idealmente, chiaramente, il counter-display lo tiriamo fuori, lo mettiamo dentro una classe a parte. Ok? Una classe, un file a parte. un componente che può vivere tranquillamente da solo. Quindi anche qui per pulizia. Può programmare con un proiettore, è una cosa scomoda che si possa fare nella vita. Ok? Ah, altra cosa. Qui Visual Studio importa sempre material. In realtà, anche questo non è ideale. Cioè, non cambia nulla, ovviamente. Però, se facciamo le cose per bene, possiamo importare widgets piuttosto. Cioè, qui, se importiamo material, copertino e widgets, è uguale, perché tutte e tre, alla fine, includono widgets, cioè lo stateless widget, che è lo stesso, alla fine. Quindi, però di base, se importiamo widget, non dipendiamo da materiale e copertino. Quindi è un widget che va bene per tutte le piattaforme. Se importiamo materiale, invece ci stiamo legando direttamente a materiale, che è l'aspetto androidoso. Però, scusi, in questo caso, se non è più la silica di usare, perché non sono android, è un problema più assoluto. Assolutamente no. Quindi, sì, sì, quello... È solo estetico. È solo estetico, esatto. Quindi possiamo tranquillamente usare copertino su Android e viceversa. Non è un problema. Solo che... Sì, non è un problema se non quello delle linee guida, insomma, e così via. E al momento la nostra interfaccia non dipende da Android, da material, se non nella radice proprio. Per cui, questo è l'unico elemento che dipende da material design, e basta. Material e questo material qui che adesso ho perso. Dove è? Home page, qui. Questo qui. Sono elementi e basta. Se volessimo migrare sul copertino, si potrebbe fare con pochissimo sforzo. Poi, chiaramente, più elementi usiamo di material, più rimaniamo legati al mondo di quello stile. Dove ero? Quindi questa cosa qui adesso va importata dall'altro file, quindi counter display, questo qui. Ok. E apposta. Questo qui, tra l'altro, è 0, cioè è const, quindi deve essere const. Adesso non lo diventerà più. Ok, quindi dicevo, a questo punto vogliamo legare direttamente i due elementi. L'abbiamo già fatto, per cui non sto dicendo nulla di nuovo. Vogliamo che questo counter qui venga propagato a counter-toggle direct, per cui questo nostro counter-toggle che cosa deve avere? Deve avere il contatore, ovviamente. Che sarà counter, ovviamente manca un po' il tipo. Sto facendo nulla di nuovo. Adesso facciamo cose già fatte. Le abbiamo fatte per il colore prima, adesso le facciamo per il contatore. Mostro il contatore. L'unica differenza che voglio fare è mettere due pulsanti, uno incrementa, l'altro decrementa. Ok, giusto? E vogliamo fare in modo tale che, visto che il contatore qui è finale, cioè ci viene fornito da fuori, il vero stato è dentro main, cioè lo stato è qui dentro, la variabile che può essere manipolata, che può essere modificata, per cui dobbiamo trovare un modo per modificarla da dentro counter-toggle direct. Adesso qui stiamo passando il contatore nel costruttore. Ah, va bene perché const, non è più const, perché chiaramente a questo punto può variare in base a questo oggetto qui. Come facciamo a modificarlo? Beh, con le funzioni. Quindi passiamo a counter-toggle direct una funzione che potrebbe essere una funzione che prende l'intero di partenza, cioè prende il contatore attuale, e ritorno dal contatore modificato. Quindi non è una void function, ma è una int function di int. Ok? Ok, quando clicco sul pulsante, torna. Ok? E a questo punto non voglio un singolo pulsante, voglio il più e il meno, giusto? Quindi avevamo detto che da fare il più e il meno li mettiamo affiancati magari, quindi in realtà faremo qui una riga, cioè una colonna prima il contatore, sotto una riga, a sinistra metteremo il meno, e a destra metteremo il più. il button a sinistra, qui purtroppo avremo un annedamento mostruoso di cose, ma è così. Quindi a sinistra abbiamo il decremento, e qui cosa facciamo? Andiamo a invocare modifier, quindi andiamo a richiamare modifier che ci porta a un attimo, modifier viene detto bene? In realtà, sì, nel senso che non è proprio, no, modifier in realtà non è molto utile, non deve prendere neanche int, perché il contatore già ce l'abbiamo, quindi non è che deve prendere, deve solo passare il nuovo modificatore, il nuovo contatore in realtà, perché modifier lo prendiamo da qui, il contatore, facciamo counter, meno uno, perché sappiamo già qual è il valore, chiaramente, e a questo punto questo button qui possiamo duplicarlo e farne un altro, che non fa altro che fare più uno, ok? Non è, cioè, è leggibile, non lo so, non particolarmente, però è in flattro che dovrete spesso a combattere con codice che purtroppo qua, questo aspetto, quindi, con annidamenti mostruosi di parentesi e quanti altri, ecco, bisogna farci un po' il callo, per cui giusto a livello così concettuale, sono pulsanti che prendono una funzione in input che viene invocata quando vengono cliccati, questa funzione è anonima, prende void, ritorna void, poi, internamente, questa funzione andiamo a chiamare modifier, che è una funzione che viene da fuori, è una funzione che ci passa qualcuno ed è la funzione che reagisce ai click da fuori, quindi qui dentro possiamo mettere il nostro, la nostra funzione qui, cioè, dobbiamo metterla perché era un parametro non opzionale, richiesta, questo è il nostro modifier qui, questo modifier qui, vedete qua, vi suggerisce, miso al studio, che non ha la parentesi vuote perché non ha void come parametro, ma ha un intero parametro. Prego. E là, il counter-stop in a drive, e diciamo, su on-pressed, possiamo ammoccare under-stop in file, direi, giusto? Eh, no, ah, come on-pressed? Sì, on-pressed in via. Eh, no, no, perché non è, non è lo stesso tipo. Qui possiamo mettere counter, che sarà meno uno. Non va bene, perché questo modifier qui è, ha un tipo, eh, cioè, ha parametri diversi. Vedete, è una funzione che ritorna void e prende int, mentre on-pressed vuole void e void. Cioè, non è, non è una funzione che va bene per on-pressed. Quindi, invece, se non avessi messo un presto, non è uguale, maggiore, non è. Esatto. Possiamo anche fare così, forse? No. Sì, possiamo anche fare, vabbè, sì, possiamo usare anche a queste tasse qui, perché in effetti non ha parametro e non ritorna nulla e invoca semplicemente modifier. Quindi, entrambe le sintassi in realtà vanno bene. Non so se stiamo intrecciando qui, questa è sempre una puntina anonima che ritorna void, quindi non ritorna nulla e invoca internamente modifier, counter, eccetera, eccetera. Questa ritorna void e quindi questo blocco qui può tornare void. Non so se è chiaro. A livello di tipo. Quindi è come se stessimo facendo così. Non so se sintatticamente non dovrebbe essere regale, questo no, però è come se fosse un blocco che ritorna void. Insomma, sono modi per esprimere la stessa cosa. Però in ogni caso qui onTrust vuole una funzione che ritorna void e prende void. Ok, poi internamente possiamo implementarla come vogliamo e in questa cosa la implementiamo con l'invocazione di un'altra funzione. Chiaramente qui possiamo fare altre cose. di prima e altre cose dopo. Rimane sempre una funzione che ritorna void. Ok, qui non abbiamo un ritorno di void. Ok, la funzione modifier che stiamo invocando qui andando ad aggiornare il contatore, tra virgolette, la definiamo qui dentro e sarà questa funzione, questa, sì, questa funzione anonima qui dentro che prende in input un intero, cioè il nuovo contatore e lo aggiorna. Allora, anche qui si possono fare due cose. Si può dichiarare anonimamente direttamente qui, quindi qui magari lo chiamo new counter e faccio così. Ok, quindi questa è una funzione anonima che prende in input il nuovo contatore che ci viene fornito dal widget sottostante, dalla counter.tocuit.rex che prenderà counter e o toglie uno o aggiunge uno in base al potente che spingiamo e poi qui farà degli aggiornamenti interni. Quindi o lo definiamo direttamente così oppure se vogliamo fare le cose con un po' più di pulizia del codice, se vogliamo, non che cambi radicalmente le cose, possiamo fare una funzioncina qui che si chiama update counter che in maniera un po' più esplicita prende l'input intero, ritorno void, eccetera, eccetera, quindi la passiamo direttamente qui sento. a questo punto qui possiamo passare direttamente la funzione perché è una funzione che prende int e ritorna void. Ok, ritorna. Quindi qui dentro aggiorniamo il nostro stato. Qui dentro andiamo a fare che cosa? Aggiornare lo state del nostro del nostro widget. Quindi andiamo a fare cosa? SetState. SetState, come siamo abituati ormai a fare, prevede il passaggio in un'altra funzione anonima, per cui c'è un altro anidamento mostruoso. Quindi in realtà quando clicchiamo sul pulsante stiamo invocando quattro funzioni anidate, se ci pensate bene. C'è l'onPress che è la funzione anonima. Stiamo invocando questa funzione qui, questa funzione qui. Questa invoca questa volta modifier che va a invocare la funzione che è qui, che è questa. Ok? Questa invoca setState che è un metodo di state. Ok? Questa è la terza funzione. Quella funzione per metodo lì invoca questa funzione qui dentro che è un metodo anonimo che non fa nulla se non aggiornare il contatore finalmente. Quindi ci sono tre invocazioni in ogni date che vanno a modificare questo contatore. Cioè, insomma, capite che è un po' convoluto però è un po' così. Quindi qui dentro andiamo a settare counter uguale new counter. Quindi non è che facciamo molto ma facciamo questo. L'unica cosa che possiamo fare giusto per così perché il nostro state qui concettualmente può includere anche delle verifiche come si può dire dei controlli sui tipi sui dati e così via. Quindi magari se lo stato if new counter è minore di zero allora new counter uguale a zero. Cioè magari posso mettere un check per cui se a forza cliccare meno vado nei negativi gli impedisco di aggiornare l'unica momento a zero. No? È un esempio. Ci può stare? Ok. Mi torna fin qui. È un po' un po' un accrocchio ma in teoria saremo non persi niente per strada. Io qui posso a questo punto potrò cliccare e ci sarà un increment o un decrement come pulsante e ok praticamente migliorabile ok e siamo nel punto di prima giusto? E però abbiamo questo funzionamento ok e cambia anche questo vedete che abbiamo modificato radicalmente come funziona questa parte qui dell'interfaccia però visto che Flutter è ben impostato da questo punto di vista il contatore qui continua a funzionare altrimenti come prima perché dipende sempre dalla stessa variabile quindi abbiamo cambiato le cose quindi abbiamo cambiato come cambiano come si spostano i dati e quant'altro però il resto dell'interfaccia rimane perfettamente coerente e funziona esattamente come prima ok e tutto questo per fare una cosa molto banale però abbiamo fatto questa cosa qui quindi tra home page state e l'altro oggetto che adesso ho già dimenticato come si chiama è il nostro counter toggle direct che sarebbe questo oggetto qui nel no facciamo finta che sia questo oggetto più verde abbiamo questo legame stretto e si parlano grazie al fatto che chi invia i dati passa il counter al costruttore del counter toggle direct e il counter toggle direct può segnalarci dover aggiornare qualcosa con un evento ok quindi funziona è sicuramente come un pulsante prego quando andiamo a scattare lo stato in questo modo nel nuovo page sì e noi siamo attraverso il controllo vale un campo 0 e poi abbiamo di per ottimizzare le performance dei dati di in questo caso possiamo mettere un else counter esatto possiamo fare anche if new counter uguale uguale counter cioè si può fare mille modi diversi se il contatore non viene aggiornato questo è un buon punto in realtà perché lo faremo in un altro modo anche questa ottimizzazione perché se il contatore non viene aggiornato in effetti perché devo aggiornare lo stato non devo farlo come se invalidassi inutilmente quindi adesso mi farò cioè in questo caso partendo da 0 incremento ribildo tutto decremento ribildo perché passo a 0 adesso se clicco su 0 il valore cioè tutto il flusso c'è comunque il contatore viene comunque aggiornato però set state non viene mai invocato e quindi platan non aggiornato quindi questo esatto possiamo ottimizzare questo caso qui andando a non fare set state come vi dicevo prima set state non è un metodo intelligente cioè non capisce veramente se aggiornate qualcosa o meno set state dice semplicemente qualcosa è cambiato chi ha fatto lo stato mi segnala che qualcosa sta cambiando per cui io devo comunque fare la rebuild di tutto perché per essere sicuro che tutto sia coerente se non c'è bisogno non chiamiamo set state questo al livello di programmazione diciamo così strutturata è chiaramente blasfemia però va bene così ok questo è l'esempio base andiamo a fare la comunicazione remota per cui la comunicazione tra la fa tra due widget che non si vedono direttamente cioè non hanno bisogno di legarsi al costruttore guardate questo ha senso se i widget sono molto lontani no? per esempio se i due widget non sono vicini ci può stare che si parlino comunque senza però dover come dire legare senza doversi legare con questo in questa maniera così strutturata perché se ci sono tanti widget intermedi chiaramente diventa molto faticoso passare il contatore e passare la funzione no? a più riprese per cui diventa molto molto faticoso come facciamo a farlo? allora praticamente usando sfruttando questa cosa del build context perché il widget sottostante quindi il nostro counter toggle direct in realtà quando si costruisce quando fa la build ha visione dei suoi genitori degli avi e così via attraverso il context per cui può qui dentro andare a leggere qual è il contatore non perché gli viene da fuori ma perché lo legge in maniera così dinamica a runtime ok? come si fa questa cosa? abbiamo una slide appropriata che ce la mostra adesso lo facciamo per cui diventa più più chiaro però idealmente funziona così abbiamo uno stato quindi quello che è home page state nel nostro caso qui contiene un colore nel nostro caso contiene un contatore non cambia molto contiene un sistema per accedere al contatore no? quindi è una exposing si chiama no? quindi espone in qualche modo il valore che ci riguarda i discendenti quindi i widget che dipendono da questo stato qui quindi questo qui possono andare a leggere lo stato di un ancestor quindi di un hub nella gerarchia quindi con questo metodo qui no? context find ancestor state of type andiamo a leggere il tipo l'oggetto nella nostra gerarchia e lo andiamo a leggere a propagare in maniera manuale andiamo a farlo così diventa più chiaro per farlo in pratica lo facciamo con in un'altra classe quindi qui avevamo counter toggle direct vado a fare il mio counter toggle interact counter toggle start copio completamente questo ok lo copio completamente per ora è ancora uguale a questo punto voglio togliere la dipendenza da questo contatore qui giusto? voglio fare in modo che questa cosa qui non non non non venga più fornita in maniera statica da fuori per cui lo tolgo qui come variabile lo tolgo qui come costruttore ok? a questo punto questo counter qui come me lo trovo? beh allora lo posso fare direttamente dal dentro il build perché qui dentro posso andare a leggere lo stato della mia applicazione quindi qui dentro dentro il posto lo faccio qui faccio final ops lo chiamo final perché non è una variabile lo leggo e non lo devo modificare quindi è final dentro counter context qui abbiamo vari vi dicevo prima abbiamo vari metodi che possono esserci utili in questo momento ci serve un find ancestor e vedete che qui possiamo pescare tre oggetti in realtà nell'albero degli avi il widget lo stato e il render object sono tre oggetti diversi ma che fanno capo allo stesso widget alla fine per ora prendiamo lo stato poi vi spiego qual è il punto questo metodo qui richiede richiede cioè ci chiede il tipo nel come generico quindi come generics ci chiede qual è il tipo di stato che voglio leggere a questo devo andare a vedere dentro main perché io voglio esattamente l'oggetto home page state che è un oggetto del tipo state quindi ovviamente i widget hanno uno stato interno se voglio dipendere da questo stato qui devo leggere lo stato al momento non posso farlo perché questo stato qui non è pubblico c'è l'underscore davanti perché non è visibile al di fuori se voglio esporre lo stato ad altri file in giro per il mio progetto d'art chiaramente devo togliere l'underscore qui in modo tale che di là sia visibile quindi che cambia soltanto il nome del nostro la nostra classe di qua posso dipendere da questo ancestor qui ok come? sì questo qui? sì giusto questo questo vale solo per i widget che sono stateful chiaramente cioè che hanno lo stato no allora sì stiamo leggendo stiamo leggendo stiamo cercando lo stato del widget praticamente cioè stiamo cercando un oggetto che deve essere di tipo state di un widget stateful qualsiasi ok quindi andiamo non andiamo a leggere il widget se volessimo accedere al widget se ci è utile in qualche modo possiamo farlo con find ancestor widget of exact time questo qui questo qui ci dà accesso al widget quindi qui passeremo home page ok questo ci dà accesso anzi facciamolo hp questo hp è il widget di tipo hp che ovviamente esisterà da qualche parte della nostra ah questo c'è l'errore perché non abbiamo visione di home page bisogna importare il nostro mail quindi c'è di nuovo una dipendenza circolare ma questa volta ci sta bene hp è il nostro widget per cui però ci si fa ben poco perché come widget non contiene molto vedete che però abbiamo accesso ai ai campi del widget stesso quindi qui abbiamo l'accesso a perché sono cose un po' inutili a questo qui saluto e chiami sono due oggetti pubblici di home page quindi volendo possiamo usarli volendo ma non ci interessa perché non interessa lo stato di quell'oggetto ok e quindi con questo metodo qui accediamo all'istanza di home page state che ovviamente sarà legata a questo widget qui chiaramente come vi dicevo prima questi due oggetti sono strettamente legati cioè quando si istanzia un oggetto di tipo home page una widget di tipo home page si porta dietro sempre un home page state ok sono sempre sono i dissolubili dall'altro qui quando quando flutter poi genera il widget in realtà c'è un terzo oggetto che è questo render object che viene creato per per rappresentare praticamente il nostro widget quindi in realtà c'è un terzo tipo di oggetto mistico che in realtà non ci riguarda che non devo mai toccare che è questo render object che fa riferimento al widget però adesso al momento non veramente non ci interessa non compliciamoci la vita che già lo è abbastanza per cui qui a capi state possiamo andare a lavorare con lo stack questo qui l'unico problema qui è che questo counter qui non è leggibile questo counter è sempre underscorato quindi non è pubblico mettiamoci un getter che ritorno che ritorno al contatore questo è un getter del contatore che non fa altro che ritornare il contatore e ci permette di leggere il valore a questo punto hp state ci dà accesso a counter è qui ok poi in realtà abbiamo varie altre cose che possiamo usare o meno però insomma sono più menuti c'è anche set state addirittura volendo potremmo fare set state da fuori cosa che possiamo fare tra un secondo quindi qui il contatore è counter quindi qui possiamo fare final counter faccio solo una copia del contatore così che quando qui mostro il contatore basta fare counter ah ok questo qui giustamente potrebbe tornare ok qui c'è un ulteriore così un problemino potenziale hp state qui potrebbe essere null è null se il nostro widget si trova in una gerarchia in cui non è figlio indiretto o diretto che sia cioè non è nipote diciamo così di homepage e quindi non c'è homepage state nella sua gerarchia questo potrebbe accadere cioè nel senso noi non sappiamo a tempo di compilazione se effettivamente il nostro oggetto counter toggler scusate questo è counter toggler indirect veramente quindi ribattizzarlo un attimo qui non sappiamo se il nostro counter toggler indirect è figlio o nipote di un oggetto homepage quindi concettualmente questa cosa qui potrebbe essere nullo a tempo di di compilazione a tempo di runtime per cui per dirgli guarda sono sicuro che ci sarà sempre un valore ci mettiamo il punto esclamativo e diciamo guarda non sarà mai null poi se è null veramente poi ovviamente esploderà va bene così quindi siamo noi che stiamo garantendo a dart che counter toggler indirect sarà sempre figlio indiretto diretto di homepage ok a questo punto l'unica cosa che manca è questo modifier perché qui usavamo ancora il sistema con gli eventi per segnalare il fatto che è stato cliccato l'oggetto ora visto che questo è un widget completamente indiretto vogliamo evitare di doverci portare dietro una funzione per cui anche qui il nostro modificatore lo possiamo portare via ok non lo usiamo più non ci interessa via così ok a questo punto quando clicchiamo sul sui pulsanti che cosa accade accade che bisogna andare non a invocare modifier che non esiste più ma andiamo a invocare che cosa direttamente lo stato quindi abbiamo hp state e qui c'era il metodo set counter update counter e ci e forniamo il nuovo conteggio ok sto parlando direttamente con lo stato ritorna vagamente qui comincia a diventare un po' struso immagino per cui però qui il nostro widget qui non dipende più da nulla cioè viene costruito nel costruttore senza nulla quindi non vive nel limbo semplicemente poi a runtime va a vedere ma io sono figlio o nipote di un home page se sì lo spero perché altrimenti l'applicazione esplode vado a usare i valori di home page per popolare la mia interfaccia ok questo si può fare ma non è elegante per cui si può fare ma non andrebbe fatto perché è molto è molto fragile però per questo punto a tempo di compilazione non so se l'interfaccia funziona veramente ok cioè mi sono comportato in maniera un po' dinamica tra virgolette quindi poi non faremo così però nulla ci impedisce di farlo tant'è che qui posso commentare il mio direct e posso fare qui counter toggle indirect effettivamente non è importato ok posso rendere anche const perché effettivamente è costante andiamo a ribildare l'entrafaccia e a livello grafico mi aspetto che non mi cambi nulla certo che ho fatto l'errore ok quindi graficamente ammesso che compila non cambia nulla cambia come si parlano le parti però anche anche il livello di comportamento dovrebbe essere perfettamente identico vediamo se è vero ok l'unica cosa che vedete che non si aggiorna e questo è giusto perché nessuno dice al nostro widget che è stato modificato il nostro widget è costante vedete qui il nostro counter toggle qui l'ho generato come oggetto costante per cui quando si aggiorna l'interfaccia scusate ho notato che qui il contatore incrementa quindi il contatore qui sopra cambia ok ah qui scusate cambia va a 2 ma non va mai oltre 2 perché il nostro widget qui è stato costruito con un contatore che vale 0 quindi quando clicco qui lo porta 1 ma non lo porta mai oltre 1 perché il widget qui dentro questo qui internamente è stato costruito leggendo counter e impostandola 1 cioè questa build qui è stata invocata una singola volta prendiamo più chiaro le cose con un back print building this e ci metto anche che ah no mettiamo sotto però il contatore il contatore valeva cam valeva 0 si suppone ok adesso vedremo che il nostro counter toggle indirect viene buildato una singola volta eccolo counter toggle indirect con counter from page 0 cioè quando fa la build va a leggere lo stato degli ancestor degli avi lo trova ovviamente legge il counter lo metta a 0 a quel punto questo metodo qui non viene mai più reseguito perché? perché il nostro counter toggle indirect è const quindi quando qui flutter fa set state ricostruisce tutto questo blocco qui lo vedremo quando fa building home page state eccetera ricostruisce tutto eccetto quelli che sono const quindi non ricostruisce mai indirect perché per efficienza dice questo non è cambiato che lo cambia a fare ok quindi questo funziona ma internamente ha sempre il contatore messo a 0 quindi io clicco qui il contatore viene messo a 1 si aggiorna tutto si aggiorna questo questo lettore questo oggetto qui si aggiorna tutto eccetto questo qui perché ha cost quindi cliccando qui questo lo reimposta sempre a 1 infatti visto che abbiamo ottimizzato il nostro codice grazie a questo escamotage qui e se lo tolgo grazie a quello non si aggiorna mai più cioè non si aggiorna non fa set state comunque il contatore viene sempre messo a 1 per cui non cambia niente quindi qui aggiungo va a 1 quindi il contatore qui mostra 2 qui ricostruisco ma il contatore viene sempre messo a 1 se decremento lo riporta lo riporta a meno 1 che poi riporta 0 lo seguite ovviamente diventi ok per togliere questa cosa cioè per evitare che non venga ricostruito il nostro toggler lo rendiamo non costante intanto sapendo di questo comportamento in realtà potremmo direttamente dichiararlo come non costante nel costruttore cioè noi sappiamo che questo oggetto qui visto che dipende da cose che non sono sue non può essere costante cioè ci sono delle cose che a tempo a runtime cambiano non le ho messe qui dentro non sono delle variabili qui dentro cioè non c'è non c'è nessun counter qui però è come se ci fosse a livello concettuale ok quindi non c'è qui ma lo sto tirando fuori dallo stato per cui alla fine per come la giro la giro in realtà non è imputabile questo oggetto cioè muta e muta di stato che non contiene lui quindi a questo punto non essendo più const a questo punto funziona come mi aspetto ok adesso a questo punto posso incrementare e a questo punto l'oggetto quindi il mio account al tavolo in red viene ricostruito ogni volta ogni volta che cambia chi lo contiene quindi è un page e a questo punto incrementa come volevamo e funziona esattamente come prima ok è complicato ma purtroppo è così questa cosa qui questo trucco questa lettura indiretta dello stato non si fa quindi questa l'abbiamo fatta giusto per vedere come funziona questa cosa del find ancestor però è bene non farne uso perché come vedete è una cosa molto fragile cioè dipendiamo da stato esterno che non è nostro e in più se non siamo attenti la interfaccia non si ricostruisce per cui siamo riusciti per quanto difficile fosse siamo riusciti a rompere Flutter perché a un certo punto l'interfaccia veniva aggiornata ma lo stato non era più coerente quindi questa parte dell'interfaccia non era più non rifletteva in maniera corretta lo stato generale dell'applicazione quindi siamo riusciti a fare una cosa che in Flutter è molto difficile rompendole rompendo l'interfaccia della nostra applicazione come si fa veramente questa cosa si fa con un oggetto che si chiama il widget ereditato cioè un widget che si eredita vive nello stato vive in un qualche parte nello stato di qualche avo e poi viene propagato ai figli ai ripoti in maniera diretta cioè in maniera esplicita cioè Flutter sa che c'è un widget dello stato che viene ereditato in maniera esplicita e quindi avviene questo ma lo facciamo in maniera che funzioni veramente quindi se vogliamo fare questa cosa che abbiamo fatto adesso ma per benino lo facciamo in questa maniera qui ossia usiamo un cosiddetto inherited widget quindi un widget ereditato che adesso qui ho rappresentato con questo widget verdino questo widget verde che nel nostro caso è un page che contiene il contatore il contatore non so è un valore molto importante per cui va fornito ai widget sostanti quindi viene propagato automaticamente col fatto che viene ereditato dei widget quindi la gerarchia la autopropaga come si fa a fare questo trucco ci permette di evitare la propagazione punto a punto ci permette di fare questa dipendenza diretta perché a questo punto un widget foglia può dipendere da un widget ereditato che è molto più in alto nella gerarchia ok è quello che abbiamo fatto a mano con il nostro counter token in direct solo che lo faremo con un metodo ufficiale che è molto complicato purtroppo per cui adesso lo vediamo insieme l'ultima cosa che vediamo oggi che ci disturberà nel profondo giovedì vediamo come risolvere tutta questa maradan e farla in maniera che sia un pochino più comoda però se riuscite a entrare nella modalità mentale per cui questa cosa vi sembra logica avete capito Flutter nel profondo ok per cui questo è l'ultimo scoglio di Flutter ve lo prometto quasi ok come funziona allora normalmente quando abbiamo uno stateful widget lo stateful widget come funziona si porta dietro dello stato quindi di base quando c'è un widget che contiene questo pacchetto stato questi due oggetti vivono insieme abbiamo visto prima che c'è una specie di simbiosi c'è lo stateful widget che in realtà è immodificabile vive della gerarchia dell'altro dei widget e non si può modificare in sé perché lo stato è tutto lo stato che è questa cosa che è muta che è sporca che è variabile la mettiamo in questo oggetto mistico che è lo state dell'oggetto stateful ok la build quindi il metro che crea i widget sottostanti è dentro lo state ok perché chiaramente come costruire l'interfaccia dipende dallo state lo state quindi contiene tutti gli oggetti di stato interno le proprietà e eventualmente i metodi che servono per modificare lo stato quindi è quello che abbiamo appena implementato qui dentro il name dentro la classe home page abbiamo fatto esattamente questo quindi la nostra classe home page state funziona esattamente così home page è immutabile adesso ho lasciato perdere che qui ci sono degli oggetti qui dei campi che stiamo utilizzando in qualche modo sono dei campi statici capisco dei campi finali perché non possono essere modificati quindi in realtà questo oggetto qui in sé non è non è mutabile tutto lo stato è qui dentro lo stato il nostro puntatore sarebbe a dire e infatti abbiamo il campo che è lo stato effettivo abbiamo un accessore un lettore dello stato e un metodo per modificare lo stato ok quindi di base funziona un po' sempre un po' così in sostanza quindi se avete dello stato per quanto complesso è se lo nascondete dentro uno stateful widget alla fine avrete dei metodi che permettono di leggere lo stato e di modificare lo stato chiaramente se non potete farlo l'applicazione è poco utile ovviamente quindi a un certo punto ci sarà qualcosa che permette di modificare lo stato benissimo e poi la build non fa altro che rappresentare in qualche modo lo stato ah prima di imbarcarci in questo della tavola darvi anche questo se decommento il countertokler direct e rilancio tutto giusto come ultima dimostrazione possiamo avere un un clone un duplicato del del toddler che fa la stessa cosa ma è meglio di adesso avremo un countertokler direct un countertokler indirect che entrambi sono legati allo stesso contatore e entrambi funzionano ok vedete che qui dove clicco clicco è tutto uguale ok perché se sono implementati in maniera corretta come sono implementati non cambia radicalmente ma si rifletta sempre in maniera corretta ok questo è giusto come tangente adesso li commento entrambi perché adesso faremo il countertokler inherited quindi con l'inherited widget in sostanza perché come funziona quindi abbiamo il setw widget che è il nostro home page home page state che contiene il contatore e i vari metodi per accedere al contatore e a modificarlo se vogliamo fare le cose per bene a questo punto che cosa avviene qui dentro andiamo a costruire non un widget direct come ho fatto prima neanche un widget indirect che noi abbiamo fatto un secondo dopo andiamo a creare un widget inherited che non è altro che una specie di widget fasullo che viene ereditato cioè è un widget che è sempre parte di questa gerarchia qui che permette ai figli di leggere lo stato adesso tra un secondo diventerà più chiaro proviamo a implementarlo mi direte a che serve questa roba e anch'io vi dirò a che serve questa roba è così flutter è stato inventato in questa maniera e va bene poi ha tutto un suo senso quindi funzionerà quindi fin qui ci siamo a questo punto voglio implementare quindi qui la gerarchia ho home page state state stato e a questo punto ci aggiungo un terzo widget mistico che diventerà il mio inherited counter e che deriva da un altro widget come si dice standard di flutter che è inherited widget ovviamente così questo widget qui implementa una serie di cose facciamo farlo sempre al nostro amico vedete che già diventa complicato allora non preoccupate più di tanto di questo lo stiamo facendo lo rendiamo cons facciamo sempre fare tutto visual studio ok si lamenta qui alla chiave va bene ok che cos'è un inherited widget è semplicemente un widget fasullo che incapsula lo stato che stiamo editando cioè nella gerarchia se riflettiamo se lo immaginiamo qui la gerarchia cioè se la vediamo qui come albero qual è l'oggetto che questo widget qui verde sta propagando verso il basso non è il suo stato in realtà lo stato può fare mille cose ma non ci interessa veramente lo stato può essere più o meno sofisticato però in realtà ci serve ci basterebbe un pacchetto che chiude il contatore in realtà alla fine dei conti quello che stiamo propagando qui verso il basso è un pacchettino che chiude una singola intera ed è quello che ci interessa per cui quello che andremo a implementare cioè l'inherited widget questo qui questo oggetto qui altro non è che un widget che include un contatore quindi qui ci mettiamo il nostro final int counter che può essere tranquillamente pubblico che non è underscore no perché è già final quindi tranquillamente possiamo implementarlo in questa maniera qui e l'inherited counter lo costruiamo con il passaggio del contatore ok quindi questo è in qualche modo è un è un pacchetto dati che impacchetta il contatore quindi il valore che stiamo propagando verso il tasso ok questa cosa qui per ora la ignoriamo abbiate pazienza facciamo finta che fare sempre return è true ignorate questa cosa è sempre true poi dopo vi dico cosa fa ma non è non è fondamentale ok a questo punto sotto cioè nel creiamo il nostro ultimo counter toggle che è quello che mostrerà finalmente lo stato del nostro contatore quindi qui creo un nuovo file che si chiama counter toggle inherited stavolta quindi ereditato ok lo copio sempre da quello indiretto che è quello che gli sembia di più così vado a ripulire allora quindi questo punto ora qui non esiste qui si chiama in in in ok non so che mi hanno molto per cui qui questa cosa che vi ho detto prima che non è una cosa che ci piace quindi la togliamo otterremo questo counter in qualche altro modo adesso vi ricordo tra un secondo come e anche qui per ora facciamo finta che di non reagire agli incrementi e i decrementi facciamo dei metodi vuoti che non fa un secondo e riprendiamo ok ci manca questo benedetto contatore come si fa a ottenere il contatore allora questo oggetto qui il nostro counter in direct qui deve dipendere da cosa non più da home page state no ma volendo direttamente da questo counter qui andremo a leggere questo contatore qui ok non leggiamo lo stato qui sopra leggiamo direttamente questo oggetto qua per cui ci interessa leggere questo oggetto questo widget qui per cui nel nel metodo qua che cosa andiamo a fare andiamo a fare context e attenzione adesso qui prima abbiamo fatto find ancestor no possiamo cercare un widget di un certo tipo possiamo cercare uno stato di un certo tipo adesso usiamo una cosa particolare usiamo un depend on inherited widget of exact type che è un metodo con un nome aberrante lunghissimo che però ci permette di andare a dipendere da non un widget generico ma da un inherited widget che è un widget un po' particolare qual è il tipo di questo widget è l'inherited counter ok lo leggiamo qui è un punto esclamativo perché questo potrebbe essere nudi quindi qui metto punto esclamativo così final counter sarà inherited counter vabbè sento male counter mi torno vagamente adesso sto dipendendo da un widget tipo inherited che è la cosa che differenzia questa chiamata qui per cui qui il tipo t questo qui deve dipendere deve ereditare da inherited widget che è un widget particolare perché ha questa capacità di propagare lo stato ok quindi qui dipendo da questo oggetto qua no questo oggetto qua ancora non c'è nella mia gerarchia giusto per cui come faccio cioè nessuno lo sta istanziando come faccio a infilarlo in qualche modo qui dentro bene sarà l'oggetto state qui col contatore che lo infilerà in qualche modo nella sua gerarchia quindi quando qui fa build devo mettere da qualche parte ma più in alto rispetto a counter toggler inherited quindi qui veramente counter inherited ci va ok noi sappiamo che sappiamo portarlo ok questo oggetto qui a runtime andrà a fare cosa andrà a leggere nella gerarchia del suo built context e cercherà un inherited counter al momento non lo trova perché tutti i suoi genitori e poi gli avi e così via non contengono un inherited counter per cui devo per forza metterlo in un in un punto più in alto rispetto a questo oggetto qui in genere se io lavoro con inherited widget lo metto subito dopo cioè come primo elemento nella gerarchia quindi lo posso mettere ancora prima di material quindi qui faccio wrap with widget e quale widget uso inherited counter ok ah sicuramente ok inherited counter qui mi da errore perché inherited counter ha un figlio vedete che inherited widget è un widget che prevede di avere sempre un figlio questo perché questi questi inherited widgets sono dei widget fasulli di raccordo cioè sono semplicemente dei blocchi di dati che si innestano in una gerarchia di widget quindi c'è il widget ma padre che è il nostro homepage state in realtà homepage questo include inherited widget che a sua volta poi ha come figlio diretto il resto di una sempre faccia quindi material column text e così via questo oggetto qui di raccordo appunto ha come oggetto aggiuntivo richiesto il contatore quindi qui dentro ci mettiamo il contatore qui dentro noi abbiamo il contatore perché è parte del nostro stato molto facilmente e lo passiamo dentro il costruttore ok per cui tornando alla slide che forse ci rappresenta in maniera più chiara è questa la gerarchia quindi abbiamo stateful widget che è il nostro homepage state che è homepage state poi abbiamo inherited widget che è il nostro inherited counter quindi è semplicemente è una classe molto molto semplice che non fa altro che incapsulare il contatore viene ricostruita ogni volta che il contatore cambia ok quindi inherited widget viene ricostruito in base al contatore che viene aggiornato e poi come figlio diretto contiene rest of tree quindi il resto è la nostra interfaccia è solamente quello che prima avevamo come figlio diretto di homepage state in realtà abbiamo annidato innestato un altro widget che non serve altro che a propagare lo stato a che serve tutta questa roba qui vedete che durante la build dello state passo gli oggetti di stato e ci creo l'inheritment widget ok questa è più o meno l'idea di fondo del che usiamo per cui più ad alto livello ogni volta che abbiamo una generarchia di widget ereditati cosa avviene che abbiamo la radice del nostro albero qui che può essere più o meno più o meno sofisticata poi abbiamo un widget che racchiude lo stato per propagare lo stato verso il basso ci mettiamo un widget aggiuntivo di raccordo che fornisce i dati all'albero sottostante ok ogni volta che lo stato cambia cosa avviene cambia lo state qui questo questo celestino ricostruisce tutto lo stateful widget ricostruisce un inherit widget nuovo con i dati aggiornati con il conditore aggiornato a questo punto questo widget qui propaga gli elementi verso il basso ok in questa maniera qui e tutto questo a cosa serve possiamo ottimizzare le cose perché a questo punto il nostro inherit widget qui è costante quindi non ricostruisce mai ma questo è const se il contatore non cambia questo qui non viene ricostruito ok quindi finché il contatore rimane quello che è questo widget qui non viene mai ricostruito se cambia invece si propaga la ricostruzione questo si ricostruisce e a sua volta chiaramente ricostruisce anche i suoi figli il figlio sarebbe questo oggetto qua questo oggetto qua dipende direttamente da inherited count andiamo a eseguire questo codice qui per vedere se effettivamente funziona come vi prometto che faccia se no è tutto un cavolo ah chiaramente adesso non c'è nessuno che aggiorna il contatore quindi in realtà serve a poco però vedete che qui ho costruito counter token inherited che è il nostro quello che rappresenta il che mostra a schermo il contenuto di inherited counter che è l'inherited widget che vale zero in questo momento adesso qui non c'è nessuno che lo aggiorna ovviamente però questo lo facciamo per un istante ok perché per aggiornarlo per aggiornarlo lo facciamo a mano come abbiamo fatto prima per cui andiamo a cercare lo stato e ad aggiornarlo ok quindi mentre qui in lettura quindi quando andiamo a presentare lo stato facciamo con depend on eccetera perché questo è l'inherited counter che racchiude lo stato racchiude il contatore però questo widget qui non vi offre nessun no nessun metodo per modificare il contatore il contatore è finale è quello cioè rimane fisso non può essere modificato da alcun modo per modificare lo stato bisogna andare a parlare di nuovo con lo stato esattamente come facciamo prima quindi dobbiamo parlare con un page state che racchiude il nostro stato per cui lo facciamo direttamente qui dentro qui come prima facciamo eh facciamo context find answer source state of type qui noi vogliamo on page state ok qui facciamo update o era adesso update counter e qui possiamo usare counter meno uno e poi appunto esatto qui facciamo la stessa cosa ma con il più uno ah qui chiaramente potrebbe essere nullo lo state per cui ci mettiamo lo schemativo perché sappiamo che nella gerarchia quello c'è ok ricostruiamo a questo punto l'interfaccia continua di nuovo però abbiamo fatto un sacco di giri per fare ben poco lavoro per cui mi rendo conto che è un po' è un po' cioè chi me lo fa fare di fare questo lavoro è così quindi ci siamo di nuovo e rifunziona come prima ma la dipendenza dal widget è esplicita in in maniera diretta tant'è che quando a questo punto c'è la differenza con indirect questa che qui ho dovuto fare attenzione io stesso al fatto che questo widget qui non poteva essere const no perché anzi scusate questo è const lo ho reso const non lo ho reso const prendiamolo const prima ricordate che indirect se lo rendo const non funziona avevo rotto l'interfaccia perché se lo rendo const non si accorge del fatto che dipende da altre variabili quindi non viene ricostruito qui invece posso usare const quindi questo oggetto qui può essere tranquillamente const ok nell'interfaccia qui main posso renderlo const quindi qui questo const quindi i nostri widget qui sono tutti potenzialmente const quello che non è const è questo coso questo coso questo oggetto qui che è immutabile ma non è const chiaramente dipende da un valore esterno però questo oggetto qui è const quindi quindi l'istanza è stato una volta mi costruisco qui continua a funzionare nonostante il widget sia costante quindi sulla carta è sempre lo stesso non viene mai aggiornato comunque viene aggiornato perché perché grazie a quel mezzo qui grazie a questo mezzo qui quindi questo depend qui si crea una dipendenza tra questo widget qui quindi questo counter toggle inherited e il build context in cui si trova cioè questa questa chiamata qui dice a Flutter guarda attenzione il widget in cui mi trovo counter toggle inherited dipende da questo oggetto qui per cui quando questo oggetto qui viene rebuildato tutti gli oggetti dipendenti vengono rebuildati a cascata ok Giorello fa Flutter perché abbiamo reso esplicita questa dipendenza con questa chiamata qui cioè praticamente qui se leggete la la la descrizione ve lo spiega ma è anche abbastanza verbosa cioè praticamente vi registra questo widget qui come dipendente da questo e quindi quando questo viene buildato a cascata si rebuildano tutti i widget dipendenti questo adesso in questo scenario qui molto banale non è che sia così evidente il vantaggio però se avete un'interfaccia complessa in cui alcuni piccoli elementi dipendono da questo counter toggle a questo punto possiamo aggiornarlo in maniera puntuale ok e lo facciamo tra un istante andando a modificare questo oggetto questo contatore qui che ancora per il momento dipende da direttamente dal contatore quindi questo qui viene rebuildato in maniera così brutale insieme a tutta la home page però se lo rendiamo un widget a se stante che dipende da questo oggetto qui lo possiamo aggiornare in maniera puntuale cioè se giocano soltanto lui tutto il resto l'interfaccia rimane fissa ok tutte le cose const qui dentro rimangono fisse anche questo non vengono mai rebuildate fin tanto che il contatore non viene modificato fin tanto che questo oggetto qui non viene modificato questa è l'idea quindi in sostanza non so se è una slide più chiara di questo no quindi in sostanza l'idea che abbiamo uno stato che è più o meno sofistic più o meno complesso lo stato può aggiornare vari suoi widget ereditati i figli qui dentro possono dipendere in maniera esplicita da alcuni di questi widget ereditati ah altra cosa scusate altra cosa importante perché se no non è chiaro perché cosa sia utile immaginate adesso magari non lo facciamo perché se no ci porta via gli ultimi minuti che abbiamo però dov'è il colore non l'ho messo il colore adesso l'ho pacchettizzato dentro qui dentro giusto quindi l'avevo messo dentro color switch il colore ma se il nostro stato qui avesse anche un colore ok questo colore qui potrebbe essere cioè è sempre stato di home page ok però se lo modifichiamo anzi facciamo un esempio facciamo un esempio così è chiaro randomize se sapessi scrivere è più facile qui rubo sempre il codice da qui questo qui qui ok va bene questo sicuramente devo farlo dentro set states no se no non se ne accorge ok va bene usiamo qualche parte quindi magari metto non lo so metto che qui questo qui dipende da color a questo punto ok e per randomizzarlo faccio perché non mi piace ah perché non è console ovviamente mi ha ragione e anche qui l'ho pacchettito dentro un gesture detector così posso accorgermi del fatto che qualcuno sta modificando il colore no cioè non mi piace d'accordo ok e ok se ricordate prima in un scenario del genere quando modifico set state il nostro stateful widget non ha modo per capire qual è lo stato che stiamo aggiornando per lui colore contatore altri dati o anche nessun dato aggiornato per lui è tutto uguale con set state io aggiorno tutto buonanotte per cui mi aspetterei che cambiando colore si aggiorni anche il nostro card topper inherited non so se qui sto stampando si building this con questo in questo scenario adesso io posso cambiare il colore senza ricostruire questo oggetto qui perché questo oggetto qui non dipende dal colore è const quindi non si propaga quindi adesso qui abbiamo counter toggle inherited che è questo oggetto qui giusto abbiamo questo oggetto qui che si colora si sta risolvendo comunque ah per questo ok buon esempio anche questo allora è vero di nuovo a fare un test prima di dire falsità ok si dico dico cose giuste ok ok quindi dicevo prima che quando faccio randomize color o quando faccio update counter comunque faccio set state alla fine per cui si aggiorna lo stato di home page state quindi a cascata rifaccio la build qui dentro a questo punto quando faccio la build come sapete già che tutte le cose const non si aggiornano non si propagano e invece tutte le cose non const si aggiornano per forza perché qui il colore viene riaggiornato eccetera eccetera questo oggetto qui quindi questo inherited widget ci permette cioè il fatto che questo dipenda non da lo stato questo qui ma dipende da inherited counter che è un sotto widget cioè che impacchetta una parte dello stato cioè impacchetta soltanto il contatore no? questo qui questo widget qui quindi questo oggetto qui in realtà impacchetta solo il contatore per cui quando quando si aggiorna il colore non lo riguarda in realtà per cui in realtà questo aggiornamento qui a cascata non è importante per cui qui dentro possiamo ottimizzare le cose cioè questo update shoot notify ci permette di ottimizzare e dire ma veramente vuoi che gli oggetti dipendenti da questo oggetto vengono aggiornati cioè quando il nostro account token inherited che vi ricordo questo è costante perché non si ribilda mai se può si ribilda soltanto perché ho espresso questa cosa qui anzi facciamo un esempio anche di questo così adesso si si ricostruisce quando faccio increment e decrement si aggiorna lo stato perché chiaramente ho fatto depend on eccetera quindi il nostro counter token inherited si aggiorna se io tolgo questa cosa qui e faccio in modo che il contatore sia cioè può essere anche run quindi può essere anche una cosa dinamica volendo importare questo ah non vi piace così ok a questo punto il nostro counter toggler inherited vedete qui adesso ha messo 93 quando incremento qui non si rebuilda perché non si rebuilda perché è costante non ha modo di rebuildarsi ok nessuno gli dice di rebuildarsi questo qui è sempre la stessa variante è sempre la stessa istanza qui dentro nel mio albero di widget dove siamo questo qui questo non varia mai quindi Flutter non lo rebuilda mai ok io posso farlo dipendere da inherited counter quindi farlo dipendere da questo oggetto qui che sappiamo impacchettare dello stato che ci interessa con questo metodo qui che è depend on ecc ecc ok a questo punto diventa esplice del fatto che questa build qui questo build context è legato a questo interior counter quando rebuilda interior counter a cascata rebuilda tutti i widget dipendenti tra cui questa stanza qui nonostante sia const può essere const quanto vogliamo questa build viene richiamata da Flutter perché dipende abbiamo detto noi dipende da quel valore lì se quel widget viene rebuildato a cascata si ripida anche l'altro nonostante appunto nella gerarchia il widget stesso questo qui è const nella gerarchia del main qui in head counter è quello che si ricostruisce perché container counter quindi non può essere costante questo oggetto qui che normalmente non si ricostruirebbe si ricostruisce perché è forzato dal fatto che dipende da questo ok adesso a questo punto visto che dipende da quello si aggiorna sempre questo interrarchia counter qui però può cioè può ottimizzare gli aggiornamenti e propagarli soltanto se questo metodo qui ritorna true questo metodo qui viene invocato quando viene aggiornato in head counter e gli viene passato l'istanza vecchia di in head counter ricordate che prima vi dicevo che quando fa l'altra l'alberone dei widget in realtà lo fa rimpiazzando i widget vecchi quindi in realtà parte dalla radice comincia ad aggiornare quando incontra quelli vecchi dice beh questo è uguale prima lo riciclo quindi quello è il metodo con cui lo fa nel caso degli in head widget fa la stessa cosa ma prima di farlo prima di verificare che siano la stessa cosa gli chiede ma vuoi propagare le tue modifiche e noi le vogliamo propagare certo ma soltanto se il contatore è stato modificato quindi se il nostro counter attuale è diverso dal contatore di old widget old widget qui diciamo che qui la realtà possiamo usare direttamente questo tipo qui qua dentro è una covariante quindi in realtà questo metodo qui accetta cioè accetta dei tipi derivati quindi va bene così dipendiamo da old widget counter questa qui è un'istanza di in head counter precedente quindi è stato rebuildato con un altro contatore potenzialmente se sono diversi allora ritorno true se sono diversi voglio che i dipendenti dai counter vengano rebuildati a questo punto ho ottimizzato la nostra interfaccia perché counter toggle inherited viene ricostruito soltanto se viene effettivamente modificato il contatore se modifico il colore che comunque anzi facciamo andiamo al sprecito qui facciamo una verifica counter sta verificando che counter sia diverso da old widget counter ok giusto per essere chiari nel così lo vediamo nel debug ok adesso io cliccherò su incremento decremento e mi aspetto che tutto si propaghi come al solito ok quindi qui vedete che vabbè adesso non viene invocato chiaramente adesso incremento qui vedete che il nostro inherited counter verifica se 1 è diverso da 0 1 è il nuovo valore del contatore con cui è stato appena ricostruito il inherited counter 0 era quello precedente evidentemente diverso perché quello ritorna true e il nostro counter toggler inherited che è questo qui viene ribildato con un valore di 1 se decremento lo porto a 0 e di nuovo fa 0 diverso da 1 si se decremento di nuovo vedete che 0 è diverso da 0 questo è false quindi non soltanto il contatore non viene aggiornato ma il nostro toggler non viene aggiornato vedete che come è ottimizzato a questo punto cioè questo oggetto qui viene aggiornato soltanto se effettivamente il contatore è stato modificato stessa cosa vale per il cambio di colore se clicco qui faccio set state su tutto home page quindi clicco e cambio il colore ma inherited counter il nostro inherited widget verifica che ci sia un cambio sostanziale utile se non c'è non propaga quindi questo oggetto qui non si repinta ok diverso se effettivamente qualcosa è cambiato allora io capisco la cosa più complicata dell'universo per fare delle cose che sembrano di una stupidità incredibile cioè stiamo modificando un intero con due pulsanti quindi una cosa che con le win32 si faceva in quattro righe senza tanti senza tanti crismi qui ci siamo impellicciati con 27 widget gerarchie complicatissime e così via però immaginate e chiaramente la stessa cosa vale per un oggetto più complesso quindi se qui questo vale per un contatore vale anche per un oggetto email se reimplementate Gmail avete una lista di email veramente che è una classe complessa che ha l'oggetto l'obbitente l'esternatario e così via questo oggetto qui può essere ereditato dalla vostra interfaccia se l'email non cambia a quel punto la vostra interfaccia utente ha cascato a non servibile e quindi mettendo nel posto giusto questi widget dipendenti voi riuscite a così a come si può dire a settoralizzare l'aggiornamento a rendere a comportamenti stagni l'aggiornamento della vostra interfaccia ok quindi a questo punto io so che questo blocco qui si aggiorna soltanto se effettivamente il portatore è stato modificato questo oggetto qui questo si aggiorna ogni volta in realtà questo è ancora dipendente da questo ma vabbè qui questo qui è ancora dipendente dallo stato direttamente se adesso se volessimo farlo potremmo creare un stateless widget che dipende da questo inherited counter e farlo dipendere farlo ricostruire soltanto se effettivamente quello dove sta giusto questo questo si modifica ogni volta che cambia il colore perché è qui dentro questa build viene fatta ogni volta che lo stato cambia mi si aggiorna sempre l'idea cioè in Flutter l'idea fondamentale per ottimizzare i aggiornamenti è di rendere componenti dipendenti vari sotto insiemi della vostra interfaccia utente renderli costanti e poi esporre tutti i dati che vengono modificati con degli inherited widget quindi con dei widget a cascata che rendono che vi permettono di ascoltare soltanto un aggiornamento di quello che è lo stato dell'applicazione quindi la stata l'applicazione è questo è complesso per modo di dire cioè contiene un colore e un intero immaginate che contenga mille liste variabili classi e così via questo può essere veramente sofisticato chiaramente ogni volta che faccio set state qui si aggiorna tutto per evitare questo creo una serie di inherited widget che si aggiorna soltanto se voglio ultima cosa per renderlo veramente coerente in genere per rendere veramente il pattern il design pattern classico con cui si usa questa si usa l'inherited widget è questo ossia non si usano questi oggetti qui brutti cioè queste chiamate qui dentro il context nel negli widget che dipendono dall'inherited widget ma si mettono a disposizione degli oggetti cioè dei metodi così ausiliari dentro l'inherited counter direttamente quindi il pattern classico è questo static inherited color quindi l'oggetto stesso off come? come? ah si ci stavo già immaginando di aver fatto anche il colore ma lo saltiamo context questo qui racchiude semplicemente context depend on quella roba che avevo fatto prima inherited counter punto sclamativo quindi questa chiamata qui questo off è l'accessore con cui accediamo all'inherited counter del contesto da cui veniamo per cui qui nel counter token inherited invece di fare questa bruttura qui andiamo direttamente a fare cioè se ci interessa il contatore facciamo direttamente inherited counter off context il contesto in cui mi trovo e poi accedo al counter il pattern in genere è questo questo ci nasconde quello che avviene nella retroscena però è anche più leggibile quindi io sto accedendo all'inherited counter del mio contesto in cui sto per essere costruito e leggo il contatore ok? così è più è più leggibile diciamo così stessa cosa vale per queste operazioni qui che se se dobbiamo andare a manipolare lo stato chiaramente daremo delle funzioni statiche di così d'aiuto ai nostri utilizzatori quindi qui potrebbe essere update no? e ci metto sempre il b e il context e il nuovo valore questo qui non ho fatto che racchiudere queste cose brutte qui che hanno fatto qui mettiamo qui come scusi? allora lo state ce l'abbiamo ma è nascosto qui adesso quello che non sto facendo è che questo state qui adesso non posso farlo perché counter top in direct dipende da state però a questo punto state lo posso nascondere finalmente cioè questo qui home page state posso rendere di nuovo nascosto ok? quindi il mio stato interno può essere brutto complesso con mille variabili può fare delle cose nascoste perché lo gestisco soltanto io lo stato lo nascondo cioè diventa privato al mio file io sto esponendo soltanto il mio inerial counter che è molto pulito cioè fa soltanto questo cioè esponendo una variabile e se vogliamo ci dà accesso al metro per aggiornarlo ok? questo è semplicemente un mezzo dello statico che lo stato è questo e ci nasconde un po' di cose che non vogliamo che chi utilizza il mio stato debba debba vedere ok? la bellezza con con l'inherited widget possiamo esporre parti del nostro stato più complesso e lo possiamo esporre in maniera più elegante più bella più ripulita e soprattutto la cosa importante lo esponiamo in maniera statica cioè questo è un oggetto che è const finale non è cioè più const non è perché in realtà poi qui lo usiamo in maniera non const quindi è const in modo di dire però è immutabile cioè quando io utilizzo questo oggetto qui questo qui non può essere modificato lo state invece per sua natura può essere modificato per cui se non sono se non sono attento qualcuno che legge lo stato potrebbe andare a modificare i dati se io lo rendo pubblico così come adesso qualcuno potrebbe tranquillamente andare a modificare il counter modificarlo e quant'altro e causare dei problemi l'immutabilità è sempre quello che noi vogliamo ottenere per cui in questo caso facciamo usiamo questo pattern quindi in questo caso di là cosa facciamo è andiamo a fare la stessa cosa quindi con un po' più ripuliti facciamo inherited counter of no pro task update sarebbe update context e qui ci metto counter ok questo ci nasconde quei vari metodi che non vogliamo che siano pubblici ok e qui e questo è quattro questo pattern è onnipresente in Flutter per cui abbiamo implementato da zero una cosa che troviamo in tante salse in Flutter per esempio un internet widget proprio classico di Flutter è è il tema questa roba qui quindi il nostro material app è un classico esempio il material app è un widget state full andiamo a vedere come è fatto questo è un widget state full vedete che è come fosse un page internamente ha dello stato ma non non sapremo mai come è fatto perché è privato lo stato quindi non lo leggiamo questo oggetto qui che cosa espone espone un internet widget che è theme data questo oggetto qui dovrebbe essere direttamente no in realtà non è si chiama theme mi sa sì l'inherited widget che espone si chiama theme che ci permette di leggere cosa il tema dell'applicazione perché è importante questo perché a cascata dentro i nostri altri widget sottostanti potremmo aver bisogno di il colore il font e altre cose che sono definite qui ad altissimo livello e vogliamo che tutta l'applicazione venga ricostruita se qualcosa qui cambia cioè se qui io cambio il colore lo faccio e lo rendo non più di purple ma lo rendo rosso a cascata vale che tutti i widget fanno lo costruito come fa a farlo questo qui il platter con un inherited widget quindi qui dentro questo è stateful perché internamente deve poter gestire il cambio di stato un altro caso più classico è se usiamo il colore no lo stile light dark quindi adesso c'è dark mode ormai non è presente per cui spesso capita di doverle prelontare se siamo light o dark questo è una proprietà del tema non sa che però c'è un campo se non vado errato no va bene non è esposto qui però esiste ok per cui possiamo switcharlo poi alla bisogna e dentro il nostro codice andiamo a ripescare questi valori esattamente accedendo all'inherited widget per farvi un esempio di questo magari come facciamo a farlo per esempio il saluto magari ci piacerebbe averlo cosa facciamo un mondo qui più grande per cui text per esempio mi permette di specificare uno stile lo stile qui style è del tipo text style quindi qui in realtà possiamo definirlo in maniera così custom potremmo crearlo noi specificando una vagonata di proprietà che possiamo andare a pescare qui però comunemente in realtà noi andiamo a usare i temi cioè gli stili dei font della nostra applicazione per cui quello che si fa è team punto off questo lo riconosciamo l'abbiamo appena implementato team off context questo ci va a pescare se andiamo a vedere come è implementato è fatto esattamente come il nostro cioè magari è un po' più sofisticato ma alla fine cambia poco vedete che fa dipende all'inherited widget of set type in hered theme che è l'oggetto che andiamo a leggere e poi ci dà accesso al theme qui fa un po' di operazioni accessorie ma alla fine il concetto è lo stesso questo oggetto qui contiene i text style text esatto deve essere questo esatto e qui abbiamo una selezione di text style che hanno vari nomi adesso per esempio headline large è il titolo grande per esempio deve essere fare la casa nostra lo rilancio a questo punto il ciao mondo dovrebbe essere decisamente più grande perché usa lo stile headline large ok vabbè può essere più bello di così e lo usa con lo stile classico dell'applicazione stessa ora se io aggiornassi il tema dell'applicazione e lo posso fare perché è stateful quindi basterebbe basterebbe mettere un oggetto stateful più in alto del tema e ricostruirlo magari come ultimissima cosa di questi 13 minuti lo facciamo così vedete che si propaga il colore e qui per esempio riga colorata qui invece di usare il rosso statico posso usare un tema theme of context ci metto primary color esatto questo dovrebbe essere diventare deep purple sì in questo caso non ci darà anche le opzioni diciamo dark e prime lo fa da solo esatto esatto lo fa da solo nel senso che i theme data lì ha vari costruttori volendo si può anche creare tutto da zero però con from seed si parte da un colore di base di riferimento insomma che è cosa di purple e poi il tema viene perché il tema internamente contiene una serie di colori in realtà quello primario quello secondario quello dell'accento l'ombra eccetera eccetera che tu dovrebbe si viene generato in base dal colore di partenza fa tutto in automatico per nostra fortuna per cui però potrebbe essere carino avere qui una variazione per cui per fare questa cosa bisogna complicarci un attimo la vita perché bisogna prendere questo oggetto qui e renderlo uno state for un widget bisogna inglobare tutto questo in un widget che tiene traccia dello stato cioè del colore attuale della nostra interfaccia per cui per farlo facciamo colorized app per dire parto sempre da quella state così mi fa la conversione e faccio prima ok qui non faccio ritornare la cosa un secondo fa quindi questa cosa rimane così come era ok perfetto ora l'orendo state full ok perfetto a questo punto qui ci mettiamo il colore quindi qui ci mettiamo no non ci usate nello stato ovviamente qui mettiamo il colore questo diventerà theme color e parte da colors di purple ok perfetto a questo punto qui dipende da questo stato lo passo qui dentro non è più statico ok fin qui ritorna ok adesso devo in qualche modo fare in modo che cliccando si aggiornino lo stato per farlo riciclo questa magnifica funzione che stavo passando a home page quindi vi ricordate che qui stavo passando questo metodo qui a home page che è questo chiamami qui lo riciclo un attimo per far presto e qui dentro facciamo set state grazie ok e facciamo theme color vediamo se ce l'ho ancora nella nella clipboard eccolo ok questa prima casuale e va bene a questo punto questo chiamami qui non mi ricordo dove chiamavo lo chiamavamo dentro da nessuna parte lo mettiamo qui per comodità ok anzi mettiamo mettiamo qui un così è ancora più chiaro non avete button che ci dà text cambia colore tema e unpressed che sarà chiamami giusto non posso passare direttamente perché è void void mi piace non mi piace ah beh si mi è perso così ah chiamami non esiste qui ma è del widget ok ok perfetto ah beh sì ok in assenza di questo mi sa che non parte molto ok adesso la radice è questa valorize app che non è altro che un oggetto tra l'altro const che impacchetta il colore e ci permette di aggiungere l'applicazione della sottostanza che vale sempre il principio per cui più è alto il dato cioè più è utile a parti più vaste dell'applicazione più è in alto nella nella gerarchia deve essere per cui adesso se cambio qui il colore cambia questo colore qui che è il primary color e cambiano anche i pulsanti in realtà che dipendono da theme off eccetera ok adesso è detto verde no oliva verde scuro uguale rosso e così via e vedete che allora si aggiorna un po' tutto ma visto che abbiamo vari const quello che non si aggiorna è sempre questo blocco qui quindi questo blocco qui non viene rebuildato perché il contatore non è stato modificato quindi grazie al fatto che questo blocco qui dipende soltanto da linearity widget non si aggiorna mai cioè qui non vedo qui l'aggiornamento perché dipende solo dal contatore nonostante ci sia uno set flow widget di altissimo livello che viene aggiornato questo esatto esatto esatto quindi questo qui si aggiorna perché dipende da primary color e così via poi in realtà questo blocco qui non si aggiorna ma i pulsanti che contiene sì esatto per cui il blocco in sé dipende da inherited counter i pulsanti ovviamente devono dipendere da team punto off eccetera perché quando clicco qui cambia anche il loro colore però è un colore della foglia quindi questo è un pulsante che è l'ultimo elemento della del widget divergirà super forza perché il tema è cambiato e quindi ci sta però l'aggiornamento è rapido ed è indolore e cambia soltanto sugli elementi che ci interessano poi rotta attenzione perché l'ultima cosa che vi dico poi vi lascio liberi questa cosa qui qui quando esprimo questa dipendenza qui sto legando questo context qui al tema ok per cui questo text qui che dipende dal dallo stile del testo sta legando questo text qui a questo context qui quindi quando si aggiorna il tema si aggiorna tutto questo context qui quindi si ribida tutto il nostro home page state ok una cosa chiara quindi in realtà nonostante qui si debba aggiornare soltanto il text questo text qui è legato a questo contesto qui che è il contesto di my home page per cui quando io clicco lì si aggiorna tutta la pagina che non è veramente ottimale idealmente io prendo questo oggetto qui che dipenderà theme ci crea un altro widget stateless stateless const che è legato al text quindi sono sicuro che si aggiorna soltanto questo e non si aggiorna a cascata tutto il blocco se non serve ok questo adesso ve l'ho accennato soltanto adesso vi lascio liberi però è fondamentale capire che quando stiamo legando un oggetto che si aggiorna a cascata fare attenzione a qual è il context a cui ci leghiamo ok qui ci stiamo legando al context di home page che è un context molto elevato e quindi per questa piccola dipendenza che in realtà poi in realtà non serve mai perché questo non cambia mai in realtà quindi è una dipendenza completamente inutile però stiamo ricostruendo tutta l'interfaccia ok questa è una cosa non ottimale per evitarla questo va pacchettizzato in un widget a parte riso const e a quel punto solo quel widget dipende dal testo ok questo poi abbiamo modo di vederlo in più occasioni perché questo è fondamentalmente quello su cui si deve lavorare per ottimizzare gli aggiornamenti di flap basta pietà questo abbiamo visto tutti i modi di aggiornamento classici per i widget adesso vi lascio il codice poi sul blender se volete andare a esplorare ancora meglio queste dipendenze da giovedì prossimo vediamo un sistema che ci permette di fare quelle stesse cose con molte meno difficili ok con molto meno codice per cui sarà molto più facile però il principio è questo per cui è importante vi lascio e buon fine settimana se avete dubbi chiaramente vi potete chiedere ora oppure vi lascio il codice poi caricato per cui se avete poi dubbi a insomma a fine fine settimana iscrivete e ci sentiamo giovedì vediamoci vediamoci altrettanto anche a voi grazie grazie grazie grazie grazie grazie grazie grazie