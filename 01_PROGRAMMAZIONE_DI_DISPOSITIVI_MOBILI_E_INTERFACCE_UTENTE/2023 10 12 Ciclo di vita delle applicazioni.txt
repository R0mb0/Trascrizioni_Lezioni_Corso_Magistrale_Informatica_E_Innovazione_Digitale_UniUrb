Rimostrando. Ok, allora, la volta scorsa abbiamo parlato di applicazioni in generale, abbiamo parlato di che cos'è un'applicazione, di cosa differenzia un programma classico da un'applicazione vera e propria, e abbiamo visto con un livello di dettaglio non eccessivo alcune piattaforme possibili che ci permettono di sviluppare applicazioni. Abbiamo visto la storia di Windows, la storia di MacOS, e ci sono fatti un'idea di quali sono le piattaforme che potenzialmente potreste decidere di utilizzare per sviluppare applicazioni. Abbiamo visto anche il web, quindi abbiamo citato il web per la piattaforma possibile di sviluppo, e abbiamo visto anche che scegliere una piattaforma non è una operazione banale, perché chiaramente determina in maniera abbastanza radicale quello che poi potete fare, e anche le speranze, le ambizioni, anche volendo monetarie, che la vostra applicazione potrà poi avere se si rivolge a un pubblico potenzialmente pagato, che non è detto, ma è possibile. Ora entriamo qui nel tecnico finalmente e parliamo del cosiddetto ciclo di vita dell'applicazione. Vedremo cosa distingue il ciclo di vita di un processo, quindi di un programma classico, non eseguibile, che viene mandato in esecuzione sulla macchina e poi esegue e poi termina a un certo punto, che è una ciclo di vita standard, normale. E poi vedremo che cosa si intende di un ciclo di vita applicativo, perché può essere simile a quello del processo, ma può essere anche molto più complesso. Vi dirò poi degli accenni su cosa lo rende diverso e cosa lo rende potenzialmente complesso. Soprattutto poi quando si va a parlare di piattaforme mobili, dove il ciclo di vita dell'applicazione diventa in alcuni casi molto sofisticato, a differenza di quello che ci dipide l'applicazione su una macchina classica, cioè una macchina a testa o similare. Quindi partiamo dalla pre-storia, come al solito, e vi citavo prima che una delle mie piattaforme veramente popolari per lo sviluppo di software applicativo era attualmente il PC-BM, lo standard definito dall'IBM all'epoca, che poi aveva origine a tutti i PC-BM compatibili, cosiddetti, e che nella loro prima fase erano programmabili, aveva un sistema operativo che era quello di presso la licenza da Microsoft, che era il cosiddetto MS-DOS, quindi Microsoft DOS, che sta per Disk Operating System, quindi un sistema operativo che si occupa prevalentemente di gestire dischi, che era già il nome, lo lasciammo intendere che non è che fosse un sistema operativo particolarmente complesso, e in effetti faceva molto molto poco, tant'è che permetteva di gestire i dischi, quindi i floppy collegati alla macchina, e altri dispositivi di memoria, e per il resto offriva una superfaccia molto scarica, che era la riga di comando e basta, e in questo ambiente molto molto semplice poteva eseguire un singolo processo, quindi praticamente questo sistema operativo, sebbene sulla carta fosse concettualmente già ispirato ai segni operativi poi che stanno potendo in tutti i moderni, qui poteva eseguire soltanto un'applicazione, o meglio un processo per conta, quindi era una macchina singola, singolo processo in un'esecuzione parallela, simultanea, e soprattutto la memoria disponibile era di 640k, quindi era limitata col mondo, poi successivamente sarebbero stati inventati varie estensioni e quant'altro, però potete immaginare che è un mondo estremamente limitato, memoria molto ristretta, capacità molto ristrette, sistema operativo molto primitivo, e appunto un processo in esecuzione che quando terminava, chiaramente poteva essere impiazzato da un altro processo, però insieme non era possibile eseguire più impiazzato, quindi è un cosiddetto single task, perché c'è una singola operazione che la macchina può eseguire, perché in effetti accade quello che vi accennavo la volta scorsa, ossia quando il seno operativo, che è residente di memoria, ottiene, riceve il comando di mandare in esecuzione un eseguibile, quindi il punto ex, nel punto di MS-DOS, lo fa, lo carica a memoria, e poi si scalza, cioè il seno operativo lascia la macchina, per esempio, lascia il manubrio al processo di esecuzione, perché non tornerà ad avere il controllo della macchina, finché il processo non è finito, perché in sostanza è un processo, lascia piazza libera al processo, che a quel punto avrà accesso, praticamente diretto, all'hardware, quindi avrà accesso ai rischi, allo schermo, a scala video, e così via, e potrà fare un po' quello che vuole, perché, soltanto quando il processo termina in maniera, così, come previsto dai programmatori, torneremo alla riva di comando di MS-DOS, quindi questo è, questo è qua. Nelle versioni successive di MS-DOS, non ricordo esattamente quale versione, però sono state diverse, poi è stata introdotta un'opzione che si chiama Terminate and Stay Resident Option, ossia un'opzione che permetteva di mandare l'esecuzione a un processo che non fosse un processo principale, sospenderlo, e lì lo chiamava già, cioè, terminarlo in realtà, quindi terminare la sua esecuzione in maniera forzata, e il processo rimaneva residente in memoria, quindi il processo rimaneva parcheggiato da una parte, non poteva eseguire comunque, non poteva mandare codice in esecuzione, chiaramente le macchine dell'epoca, comunque, non è sempre una CPU, aveva un tratto di esecuzione, quindi comunque era sempre single task, ma il programma, il processo rimaneva in una parte della memoria dei famosi 640K disponibili, occupava quella piccola memoria e poteva essere richiamato alla misogna, in particolare questo serviva proprio per estendere in genere la memoria di MS-DOS, quindi c'erano i cosiddetti memory extender che venivano lanciati, prima di lanciare altre cose, rimanevano residenti in memoria e davano accesso a altre memorie, se richiamati da altri programmi che sapevano che ci sarebbe stato un memory extender in memoria, comunque degli accrocchi abbastanza terrificanti, se ci pensate, però ecco, questo era il modello al memoria. Quindi in questo scenario, per farlo breve, il processo, quindi un programma, un programma poteva essere o non eseguito, cioè poteva essere presente sulla macchina, magari ma non in esecuzione, oppure in esecuzione, non c'erano altri motivi, quindi o on-off, ok? E in questo scenario qui poteva essere mezzo on, nel senso che era bisogno di memoria, ma non era in esecuzione comune, quindi c'erano tre stati possibili dei processi. Veramente questo modello funziona fino a un certo punto, però è molto primitivo, per cui poi i sistemi operativi successivi avrebbero tradotto quello che si chiama modello a tutti il processo. Quindi l'idea che la macchina potesse essere utilizzata da non tanto più utenti in contemporanea, ma almeno da più processi in contemporanea. Quindi il stesso utente magari potrebbe avviare due processi in contemporanea per fare due cose in parallelo, anche perché spesso la macchina poi mentre esecuzione del processo in realtà è in attesa di input, di utente e altre cose, e quindi tanto vale che faccia qualcos'altro. E allora tutti i sistemi operativi che riconosciamo adesso come modelli, diciamo così, fanno, introducono questo modello, che in realtà non è un modello, già all'epoca non è un modello nuovo, penso che già i mainframe negli anni 60 avevano delle capacità almeno progettuale di lasciare, eseguire processi in contemporanea da più utenti. Quindi in realtà è un'idea già vecchia che viene reintrodotta e in varie esanze. Quindi comunque c'è il concetto che il nostro sopravvivo per essere lanciato deve in qualche modo avviare il primo processo, il processo, il protoprocesso, che è quello che dà via di là alla macchina e giustisce un po' tutto quanto. In ambiente Unix, Unix, è il processo Init, che forse avrete chiesto di tornare a se si avrete, che è quello che viene avviato durante il boot e rimane in esecuzione finché la macchina è in esecuzione. Questo qui, l'Init è sempre presente e sulla carta tutti i processi che vengono lanciati sono in qualche modo, anche se magari è la lontana, sono parenti di Unix che vengono lanciati a cascata da qualcosa che è stato lanciato da Init. Da Init parte tutto e tutti i processi sono figli diretti o nipoti. Mac OS, ah, altra differenza qui dico di Mac OS 10, Mac OS 10, che giustamente deriva da Unix in realtà, quindi è lo stesso modello, solo che hanno ribattezzato il processo, il proprio processo che è LaunchD, sempre il Launch Demon. Di solito quando in ambiente Unix un processo, un nome di un seguito definisce con la D è perché è un silenzio di sistema, quindi sta per Demone, per Demon di sistema e quindi però fa la stessa cosa in sostanza. Su Windows la stessa cosa si chiama SMSS.exe ed è il Session Manager Subsystem che, non so se vi ricordate la volta scorsa avevo accennato che la Windows è un sistema operativo abbastanza convoluto che è sotto a vari sottosistemi che sono tra di loro equivalenti e Win32 è soltanto uno di questi, quindi effettivamente avviene questo, SMSS gestisce i sottosistemi, avvia tutto il baraccone che è Win32 che vive qui dentro, Winlogon. Winlogon è il primo processo del sottosistema Win32 che parte e prende con la macchina e vi dà il classico pannello di login, quindi la schermata di un utente e password. E Winlogon, poi da Winlogon in poi partono tutti i processi dell'utente in qualche modo. Però è così. SMSS è quello che semmai se il sottosistema parte ed è supportato dalla macchina avvia anche il sottosistema BOS2, il sistema Cosics, il sistema Linux e così via. Quindi questo è il processo padre e gestisce i vari sottosistemi. Però ecco, l'idea è questa. Ora, su questo modello qui, chiaramente ha costruito la macchina. Quindi la macchina è condivisa da più processi in esecuzione che possono fare un po' quello che vogliono, ovviamente, possono andare in esecuzione, possono essere in pausa, possono aspettare il tutto utente, possono fare varie cose e per limitarci al modello dei processi Unix, è quello più comune, vediamo la curva che avviene. Anche questo l'avete già sicuramente visto a senoradini, per cui non mi dico nulla di nuovo se non arriva a dire quello che già sapete, ma questo rinfrescara la moria. Nel modello Unix Un processo può avere tre stati fondamentali, poi in realtà alcuni ha dei sottostati anche, però fondamentalmente sono tre e sono molto simili ai processi di MSLOS, concettualmente comunque un processo che ne manca in esecuzione è quale è fine e quindi questo è quanto. I tre stati fondamentali sono new, cioè il processo è stato appena allocato, quindi l'utente ha scritto la riga di comando e scritto punto slash nome dell'eseguibile, quindi il seno prodivo ha allocato la memoria per il il programma ha copiato il programma in memoria, una parte di esso in memoria, ha preparato i vari blocchi in memoria che servono, quindi se ricordate lo stack, lo hit e tutte le cose che dicevo prima, le variabili d'ambiente, la copia di riga di comando, cos'altro, l'exit code, tutti questi blocchi in memoria che il seno di un'attività deve preparare prima che il processo possa eseguire veramente, appena è pronto il processo può passare da new, quindi appena partito, a executing, quindi può essere mandato in esecuzione, in executing significa che il vostro processo vuol dire che ha il controllo di almeno un thread di esecuzione e quindi una delle CPU sta eseguendo codice che fa capo al vostro processo eseguibile, una delle CPU sta lavorando nel binario del vostro eseguibile, quando ha finito, quindi quando termina, viene terminato e quindi va terminato, attenzione, qui terminato significa che il processo è ancora residente in memoria, noi sono terminato e poi è sparito, questo stato è uno stato in cui il vostro processo può rimanere anche in diverso tempo, volendo, perché in questo stato il giornalismo sa che il processo ha finito quello che deve fare, quindi in qualche modo c'è per farvela, per essere pratico, il vostro processo, il vostro programma ha chiamato exit, e ha terminato l'esecuzione oppure ha fatto return numero a caso dalla main, quindi il processo ha finito di eseguire, viene marcato con terminato, però rimane presente in memoria perché il sovrativo deve andare a smistare e a gestire il processo prima che possa veramente buttarlo fuori dalla memoria e quindi in genere fa una serie di cose tipo ripulisce la memoria, chiude il file descriptor che ha aperto il processo con accesso alla rete e così via, libera tutti i buffer delle socre, tante cose che deve fare per ripulire tutto quanto che il processo può aver fatto e soprattutto rimane in attesa che qualcuno si prenda la briga di leggere l'exit code per il vostro processo che è la cosa più importante per chiudere tutto tutto quello che si fa è il processo perché tutti i processi di Unix fanno questo eseguono e poi ritornano un numero e quel numero deve essere elettorato quindi il processo che ha lanciato il vostro programma deve essere qualcuno deve andare a leggere il numero e dopo magari non ci fa nulla nella maggior parte dei casi viene questo il numero detto viene letto ah benissimo e poi viene lontato nel cestino però a quel punto il vostro processo può essere deallocato e messo in cestino anche qui per puro nozionismo quando questo non avviene questo non avviene in alcuni casi quando il processo padre che ha lanciato il vostro processo il vostro programma è troppo impegnato a fare altro quindi magari non ha il tempo lo sto umanizzando un po' però non ha il tempo di andare a leggere questo exit code e quindi terminare il processo allora il processo sebbene terminato rimane in memoria ed è quello che in gergo si chiama un processo zombie che rimane lì in attesa che qualcuno se no lo accadde ok ok quindi questi sono fondamentali blocchi di esecuzione ma in dettaglio in realtà quando siamo in esecuzione il processo può fare delle cose più complesse quindi in realtà sotto abbiamo tre sottostati che fanno comunque capo all'esecuzione quindi il vostro processo è formalmente in esecuzione cioè è in coda è in coda dello scheduler dello stesso operativo e potenzialmente può eseguire però internamente può essere in tre sottostati diverse allora anche qui riassunto gli sistemi operativi quindi lo facciamo brevemente se possibile il primo è ready quindi pronto con l'esecuzione ed è il primo stato in cui ci arriva da nuovo quindi si viene allocati il sistema operativo fa tutte le varie cose che deve fare prima che possa effettivamente eseguire il processo quindi alloca lo heap parlare con lo stack se lo stack lo heap e tutte le variabili non fossero pronte chiaramente non potremo eseguire perché al primo accesso lo heap chiaramente lo heap eseguirebbe e quindi non è il caso di eseguire quando il servitivo ha fatto tutte le varie operazioni di preparazione siamo ammessi all'esecuzione e diventiamo andiamo nel security e siamo dentro ready quindi siamo in attesa ma non siamo ancora in eseguire quando il servitivo ha tempo quindi quando lo scheduler dice beh io lavoro finora l'ho fatto c'è tempo per fare dell'altro c'è la lista dello scheduler finalmente lo scheduler decide quale processo di eseguire se pesca il nostro processo il nostro processo è sparato da ready a running e dentro running finalmente c'è la macchina è lo stato di cui parlavo prima a quel punto un processore sta eseguendo qualcosa qui dentro uno o più questo questo va avanti finché non si interrompe e può essere interrotto in due modi uno il modo per interrompere l'esecuzione del nostro processo è se il nostro processo in maniera volontaria dice io però l'ho finito puoi andare oltre e quindi ci mettiamo in uno stato che si chiama waiting perché magari avevamo iniziato a fare delle operazioni che hanno una scadenza lunga e quindi per esempio la cosa più classica è leggere un file scrivere un file aprire una socket fare delle comunicazioni remote o scrivere su una scheda in cartica cose che riguardano qualche modo l'hardware in quel caso appena l'hardware viene coinvolto in qualche modo l'hardware come sapete è lento è quello che è verità che è molto lento della CPU veramente quindi quando questo avviene rimaniamo in attesa infatti qui vedete che qui c'è scritto che il prossimo stato è l'io complice quindi la terminazione dell'input che ha la dimensione in questo processo una volta che la scrittura lettura quello che è termina torniamo in ready perché a questo punto il nostro processo è di nuovo pronto per eseguire e poi può tornare in grande questo può essere un ciclo il nostro processo di eseguzione ha una scrittura molto letta a questo punto il processore lo lascia perché il TAPA non può eseguire per fare un esempio per ricollegarci la volta scorsa ricordate che parlavo dell'esecuzione asincrola la volta scorsa nel mondo classico di Unix c'era la famosa write per scrivere write or read sono operazioni sincrone bloccanti ed è esattamente lo che viene quindi immaginate che avete un programma in C e se qui arriva la fatidica write per scrivere su un file a questo punto ovviamente la chiamata write è bloccante e dice guarda devo scrivere questi file qui dentro questo file lì il processore anche se volesse non potrebbe andare avanti non può andare avanti finché quella write non ha chiuso le sue operazioni e ritorna per spiegarvela in cose che c ovviamente poi la c diventa però immaginiamo in cose che nel linguaggio di alto livello finché la write non termina non possiamo eseguire perché il processore non può andare avanti e a quel punto andiamo in wave perché aspettiamo che quella write termini l'esecuzione appunto il seno gradivo ha un sistema interno per tenere traccia di quella scrittura appena quella scrittura finito il programma torna ready e poi viene eseguito e a quel punto riprende appena sotto la write cosa è è che ok quindi è bloccante in quel senso perché effettivamente il nostro processo va sospeso l'altra notativa se il nostro processo non fa operazioni di questo tipo magari sta facendo operazioni numeriche calcoli spostamenti di memoria quindi è sempre running quindi a quel punto finisce lo slot esecuzione del nostro processo e questo avviene tramite il render hardware quindi è un processore che ha delle scadenze tipo il segnale orario che scatta ogni tanto quando finisce il tempo allocato al processo il processo viene forzata lenta e rimesso in conta anche se potrebbe eseguire e a quel punto non va in wave perché non c'è niente da aspettare potrebbe eseguire subito ok quindi paradossalmente se c'è solo un processo di eseguzione il nostro sistema potrebbe rimbalzare anche dietro sulla ready e running e potrebbe andare in eseguzione ogni volta perché è il primo processo che è sempre voluto eseguire però quello che avviene in pratica è che c'è tutta una quota di processi di eseguzione e poi una alla volta questi prima o poi li seguono ok in realtà poi questo diventa ultimamente complicato a dire la verità se vogliamo complicarci la vita perché se il nostro sistema ha anche della memoria virtuale facendo solo per complicarvi il modello ambientale il processo può essere swept out quindi può essere se c'è poca memoria può essere preso in blocco e buttato nella memoria virtuale quindi su disco in sostanza e a quel punto è fuori dai giochi perché per essere ripreso cioè a quel punto vuol dire che tutto il processo sul blocco di memoria viene spostato sul disco fissi è una cosa che si fa solo se c'è una emergenza pochissimo spazio nella RAM chiaramente per processi che sono poco in esecuzione sono poco importanti e a quel punto il processo viene copiato sul disco che richiede tantissimo tempo per quanto riguarda il CPU e quindi quel processo per un tempo non è ripreso perché bisogna eseguire bisogna ritirare fuori tutto il processo e caricarlo in RAM prima che possa eseguire quindi questo complica un po' le cose però immaginate che oltre a questo in security c'è lo stato ralleno fuori che è swapped out che significa che quel processo è in stasi finché non viene ripreso e ritirato nella RAM ok questo è quanto chiaramente questo è il modello di Unix però potete immaginare chiaramente che qualsiasi stato è lavorativo anche Windows ha un modello che dire che è uguale per il pop quindi è proprio identico cambia questa è l'esecuzione ora c'è questa è l'idea il mondo di 1995 che questo è il 95 per l'opzione storica il 95 è ancora prima di Windows NT quindi questo qui è un vecchio Windows super obsoleto che usava già le Win32 però viene da Windows quello vecchio poi con Windows XP avremo un Windows che si basa su Windows NT che è il moderno che in realtà usiamo come modello poi parlando di Windows con i vecchi non ci interessa più tanto che sono veramente obsoneti non hanno memoria retta un sacco di limitazioni che i nuovi Windows non hanno però è che alla fine cambia poco perché l'idea che volevo smettere con questo screenshot della prehistoria è che ovviamente come si può intuire questi oggetti qui su schermo queste finestre ovviamente a questo punto devo far capo a un processo ok dietro a come si chiama capo minato capo minato il lettore cd che tanto mi ha esistito anche più e il trickstore che anche questo è rimasto troppo campo minato ma a parte questo dietro a queste applicazioni ovviamente c'è un processo che fa tutto come deve fare scopere le bombe manda le cd che legame c'è tra il processo di esecuzione e la finestra quello è quello che vedremo adesso parlando di ciclo di video dell'applicazione perché questa appunto consideriamo un'applicazione ma potrebbe nascondere più processi di esecuzione sotto sotto potrebbe esserci uno che gestiscono questa schermata con campo minato non è questo caso è solo un processo più realisticamente con explorer o con l'autocid si può immaginare sia una questione di processo ma improbabile comunque non è importante l'importante è vedere come adesso il lavorativo appunto prende il concetto di applicazione e in qualche modo lo proietta in quello che è il processo che è l'esecuzione è terminato in attesa perché tornando alla schermata l'idea è questa immaginate un moderno o quasi moderno insieme a quello che come utente come utente finale del sistema voi sperimentate è che in qualche modo voi avete l'applicazione installata sulla macchina campo minato la lanciate cliccando su icone lanciando la lanciando da un menu start o lanciando la lanca da riga di comando è uguale in qualche modo voi date il comando al segretario di lanciare l'applicazione a quel punto mentre in esecuzione avvengono alcune cose e in qualsiasi combinazione il programma può fare delle elaborazioni di qualsiasi senatore eseguire una logica può aprire le finestre di dialogo le finestre di dialogo poi le vedremo parlando l'interfaccia dentro le finestre di dialogo già lo sapete immagino sono le finestre interattive che vi bloccano quindi sono bloccanti e vi costringono a scegliere un'opzione in genere o a spingere quanto meno ok l'applicazione in genere apre una finestra applicativa quindi una finestra una o più ho messo almeno una al solito cerco di interagire questa è quella con cui voi lavorate la maggior parte del tempo può creare delle icone nella cosiddetta taskbar che è questa roba qui sotto nel mondo Windows chiaramente se immaginate il macOS sarebbe il doc una cosa che deve disimilare e poi chiaramente può elaborare degli eventi di interfaccia utente che sono movimenti del mouse clic del mouse non so impulsare la schiera sono tre cose che possono generare degli eventi vengono gestiti nel vostro processo quindi idealmente il processo è l'esecuzione l'applicazione è l'esecuzione gestisce queste cose riceve questi comandi e poi a tutto punto voi vi scusate cliccate sulla X andate a destra sul fizzantino rosso e gommoso e a quel punto l'applicazione è l'idea ora chiaramente questo modello qui è effettivamente quello che accade in un mondo come questo quindi lanciamo capo pinato giochiamo vinciamo perdiamo poi chiediamo sulla X e noi sappiamo che dietro le scene il processo di capo pinato sarà terminato e l'applicazione non è più in esecuzione e questo modello questa cosa qui che è molto astratta ancora va benissimo con un mondo in cui lavoriamo con dei workstation vecchia scuola abbiamo dei pc fissi che sono collegati all'area elettrica che hanno sono molto potenti per quanto riguarda le risorse sono energy hungry quindi sono affamato di energie comunque i fissi in genere non hanno parte da riguardo per il consumo energetico perché non devono avere la CPU in genere non lavora mai a livelli bassissimi all'esecuzione come sarebbe un portatile o altri dispositivi che adesso citeremo per cui in genere il consumo è abbastanza elevato e soprattutto siamo sempre connessi quindi in sostanza se qui questa macchina è collegata alla rete usa la rete senza risparmiare perché tanto sa che è collegata via internet alla DSL scarica e fa quello che vuole e lo fa con grande spreco di risorse è una macchina multiutente in genere quindi a partire da Windows NT e poi con danni Unix da molto prima ancora i separativi moderni sono multiutenti potenzialmente sono più utenti collegati a questa macchina è multiprocesso come ne ho detto prima sono processi in esecuzione a una volta e di nuovo l'attrizione è per la performance quindi l'utente è lì deve fare qualcosa di estremamente importante di poter giocare con capominato fondamentale e lo fa senza tutta l'attenzione focalizzata nel dare i risultati prima possibile all'utente ora questo modello qui che è mobilissimo ovviamente per il mondo del desktop è possibile concettualmente spostarlo su delle macchine mobili quindi che hanno dei limiti molto più stringenti ma non funziona bene nel senso che se applichiamo lo stesso concetto a questo oggetto qui vedrete che è l'esperienza dove sono molto molto poco carino sono tentato con questa cosa quindi vedete che è Windows CE credo Windows Compact Ed è che si chiamasse e prima che nascesse l'iPhone e tutti i suoi derivati e Android e così via molti cellulari più o meno intelligenti funzionavano così difficili da creare mai ovviamente così c'era un Windows ridotto sopra che permette di fare bene o male quello che uno voleva quindi potrebbe seguire dei seguibili che non erano programmati per le min 32 di nuovo quindi uno stand di programmazione che non c'è nulla con il mondo mobile veramente quindi qui potenzialmente c'è vari programmi che vi deve riconoscere che sono per esempio un po' altro comunque si può collegare la rete per cui chiaramente c'era chi era un top manager dell'epoca aveva un oggetto del genere che aveva una batteria che durava circa tre ore quando andava bene e chiaramente si poteva collegare a tutto però era estremamente inefficiente l'interfaccia era estremamente poco chiara ad esempio se ne parla parla da solo quindi immaginate di dover cliccare col pennino con queste congine o qualità molto piccole e quindi non funziona perché appunto la batteria finisce subito e l'esperienza è estremamente estremamente riscanza ok qui serve una cosa di nuovo e rivoluzionario per cui quello che c'è stato in qualche modo è vero che è difficile dare i neti all'iPhone di Apple perché non è giusto perché ci sono vari precursori prima dell'iPhone però in realtà il primo dispositivo per il consumatore finale che ha veramente rinunciato a queste stesse idee è effettivamente l'iPhone è il primo cellulare veramente molto diffuso che ha preso questo modello moderno e lo ha reso popolare per cui l'idea qui è che abbiamo uno smartphone infatti che avremo adesso un dispositivo elettronico molto piccolo molto lento quindi un processore che è migliavoli più lento di quello di un ciclista per questo non è più vero naturalmente nel mondo del 2023 qualsiasi iPhone moderno è molto più veloce del mio PC ma questo è particolare soprattutto però a parte questo all'epoca il professore era molto più veloce molto più lento aveva molto almeno cioè ovviamente ha una batteria molto limitata per cui può fare alcune operazioni ma deve litigare per il fatto che a un certo punto la batteria finirà e quindi l'utente deve avere almeno un giorno di autonomia se no poi lo lancia contro il muro e quindi l'idea è che i video sono molto molto scarne però è vero che anche il modello d'uso è molto molto semplificato per cui in genere è un singolo utente ok il cellulare ovviamente lo usano una persona alla volta è difficile lavorare cinque persone è singola attività questo è un altro un fattore estremamente limitante però che ha senso quindi questo modello c'è all'uno concettualmente c'è soltanto un po' come il MS-DOS c'è soltanto un'applicazione di esibizione veramente è l'applicazione che governa lo schermo quella che vedete in prima in prima pari ma anche qui non è più vero l'iPhone di quando è stato lanciato lavorava così effettivamente quindi a differenza di questo questo prendeva il modello di Windows con tutti i processi di esibizione tutti in maniera concorrente quindi la parte della S2X ha scippato la seconda di esibizione la S2X è stato un in fase economico un processo però immaginata di prendere il PC e buttarlo sulla macchina non può funzionare ovviamente qui avete tanti processi di esibizione tante applicazioni in parallelo è chiaro che è più potente sulla carta però se la batteria finisce da un'ora è potente ma ci fa molto poco in questo caso l'iPhone del primo iPhone e quelli subito dopo è una singola attività che in esibizione alla volta ma ovviamente basta per esempio l'ultimo l'utente fa o legge messaggi o telefona o fa qualcosa altro non è che fa tutto per cui l'attenzione per l'efficienza per le risorse e la reattività quindi l'idea che il cellulare debba reagire in maniera interattiva e immediata soprattutto e questo è un fattore non secondario soprattutto perché il modello di interazione è con il touch quindi l'iPhone è di nuovo il primo tra virgolette dispositivo largamente diffuso con un touchscreen interattivo non relativo quindi il touch capacitivo che è fluido è affascinante e così via e quindi è quello che ha reso popolare questa materia di utilizzo in sostanza e lì soprattutto perché l'utente tocca con mano gli oggetti sullo schermo servono all'attività in via deve essere relativo subito e non può reagire dopo milisecondi di attesa perché se no la potente è frustrata l'utilizzo cosa ben diversa da questo dove invece il touch era reattivo col pennino che si è spingere forzatamente sullo schermo per fargli capire che il tocco veniva fatto e poi la faccia data era molto più lenta quindi reagiva con molta più lentezza all'interazione quindi appunto questo è il grande scoglio che ha cambiato il modello di utilizzo e per farvela questo questo fosse l'iPhone 3 si l'iPhone 3 che ha anche l'altro giro l'iPhone 3 che appunto ha questa modalità di utilizzo a singolo schermo che qui mi sembra che ho fatto delle slide animate molto affascinanti forse si clicca su un'attività compare attività si fanno delle cose con questa applicazione quindi io sto guardando quel calendario e potete immaginare che tutte le cose di prima non ci sono più quindi c'è i messaggi le foto la borsa il metro non sono esecuzione non fanno nulla ok perché io sto plegando del calendario faccio lavoro solo con questo gli altri processi non sono in memoria neanche allontanamente quando ho finito clicco qui sotto e torno sulla schiena principale su quello che si chiama la springboard nel mondo ok quindi il modello il modello di funzionamento è soltanto questo poi nel 2023 le cose sono alcune più diverse ma prego una cosa certo quando siete in questa versione certo assolutamente sì sì sì assolutamente sì quindi qui sotto comunque già all'epoca molto fiero il fatto che sotto c'erano le fondamenta di macOS 10 quindi c'è il stesso kernel alla fine però questo è molto vero quindi sotto in realtà ci sono i processi di esecuzione chiaramente lì diciamo così hanno fatto pulizia quindi sicuramente hanno ridotto i loro processi ma così come sono ridotti anche nel mondo di Windows 10 non è che perché sono competenti hanno lasciato le cose in giro quindi questo è sicuramente il minimo numero di cose di esecuzione che si poteva fare per farlo funzionare quindi non è un problema tecnico però le applicazioni quindi parlo proprio di applicazioni utenti quindi proprio nel nostro mondo di applicativi che sono per lo famoso per lo end user quindi per l'utente finale qui l'applicazione questo è il task manager però sembra già che sia auto-muc un applicativo che fa operazioni per gli utenti manda i mail ricevere messaggi e così via auto-muc task manager e in qualsiasi altro applicativo in esecuzione è in esecuzione in maniera concorrente per cui auto-muc qui è aperto sta eseguendo la grande differenza per cui magari non lo vediamo perché l'interfaccionante non può ragionamente mostrarla però qui auto-muc è in esecuzione mentre in questo mondo qui è vero che se non lo dico si porta indietro ovviamente una vagonata di cose che fanno operazioni del sistema già basta immaginare i messaggi il servizio è donare ci saranno mille processi di memoria in esecuzione però delle applicazioni ce n'è sempre una per conto in questo caso il calendario e le altre sono tutte disattive finché l'utente non esce e ne attiva un'altra infatti il ciclo di vita dei qui questo processo in realtà non è proprio tanto vero il ciclo di vita dell'applicazione iOS è questo ed è un po' diverso da quello dei processi standard di Ubix nel senso che anche se ritrovati gli stessi gli stessi concetti la differenza fondamentale già si vede a occhio che c'è il simile tra program e background cioè il fatto di essere in primo piano o non in primo piano è fondamentale per iOS perché è ottimizzato in base al fatto che l'applicativo è visibile o meno quindi in partenza immaginiamo di aver installato il nostro calendario che era sentito prima un'applicazione calendario installato sulla macchina quando installiamo il processo non l'ho mai eseguito visto che qui è installato c'è il binario sulla macchina ma nessuno lo ha mai lanciato a quel punto il tutente lancia l'applicazione quindi c'è in casa la sua sostanza e a quel punto l'applicazione va subito in programma quindi diventa subito occupo subito dello schermo e quindi c'è la famosa transizione del lancio e così via è inattiva finché ancora il sistema operativo al presente quindi sta facendo l'animazione con la fluida che lancia l'applicazione su iOS e quant'altro è inattivo a quel punto per l'animazione tutto il resto tutti i processi di lancio sono terminati quindi il lancio intendo tutta l'attività di sistema che fa il sistema quindi caricare il processo di memoria mandare l'esecuzione preparare la memoria blocare le varie cose che deve fare a quel punto passa la palla all'applicazione attiva ok e in qualsiasi momento l'applicazione può da attiva che è l'unica applicazione attiva in quell'insultato può tornare attiva e questo avviene in genere con delle transizioni appunto di interfaccia tecnica nel senso che l'unico modo per togliere le pietre un'applicazione su iOS vecchia vecchia maniera è se c'è qualcosa che va a coprire in qualche modo di taccare il fatto che l'applicazione è in tempo piano ossia la cosa più comune è il tap sul santone che non mi ha messo in pensato quello torna almeno principante è stato quello in fondo che ti rispedisce sulla schermata principale che è in modo più classico quello fa sì che l'applicazione da via poco perderà l'accesso allo schermo ok quindi diventa in attivo ancora è un problema però fa un punto fatta l'animazione che non decollassa l'applicazione a quel punto l'applicazione rimane in background questo poi vi dico a cosa serve e a un certo punto verrà sospeso e terminato quindi il processo in genere è questo un'altra cosa che può mandare un'applicazione da attiva a inattiva è per esempio se è ricevuto la chiamata questo è un altro modello classico se qualcuno richiama la chiamata copre tutto quindi compare la classica interfaccia trascina qui per rispondere a chi sta chiamando a quel punto l'applicazione rimane in programma che si è coperta dalla chiamata e rimane in attiva finché la chiamata non termina poi avventurato dopo tornare attiva o meno ok ora l'applicazione sta per cioè viene scalzata dalla prima parte dal nuovo piano rimane con l'esecuzione e va in background ossia immaginate di essere in questo show qui quindi il calendario adesso è attivo no quindi sta facendo tutte cose reagisce all'input e così via se l'utente clicca qui sul pulsantone la questo svanisce e l'utente torna qui a questo punto il processo del calendario quindi l'applicazione è ancora attiva e si trova qui dentro è il background però è ancora attivo infatti se volete mapparlo sul processo quindi attenzione questo è il modello dell'applicazione come visibile l'utente dietro le quinte c'è un processo che è il processo del calendario che può essere attivo come nel processo di unix che lo potete utilizzare qui il processo quindi l'oggetto che può eseguire del codice sulla vostra macchina è ancora attiva e può fare le varie operazioni di gestione della memoria e quant'altro in preparazione del fatto che verrà sospeso ossia quando l'utente clicca sul pulsantone e la schermata svanisce non è che subito il processo viene ammazzato per questo è abbastanza brutale soprattutto se il processo sta facendo delle operazioni complesse sta scrivendo su file sta mandando informazioni sul web sta facendo qualsiasi cosa che sia un pochino complicata è anche poco educato a terminare il processo che potrebbe corrompere corrompere i file non si può terminare in maniera radicale il processo ma l'applicazione background sa che a un certo punto nel prossimo futuro c'è un timeout solito verrà sospeso verrà sospeso quindi in questo momento qui il processo sotto riceve l'evento guarda se in background guarda via deve chiudere quello che sta facendo cominci a chiudere il database smette di inviare messaggi verso la rete così via in preparazione di questo stato qui che significa che al punto il processo non esegue più quindi il processo viene terminato e il processo viene messo in sospensione e non va più in ready per farvi il parallelo se riesco siamo qui ok è come se il vostro processo del calendario da running e ready che era rimane qui e non viene mai più messo in data rimane qui è ancora in memoria è ancora concettualmente vivo quindi potrebbe ancora eseguire la sua carta ma è sospeso e non viene più scelto per essere in esecuzione ok quindi lo scheduler in sostanza lo scavalca lo salta lo ignora perché non viene sospeso ok quindi da qui a qui c'è appunto c'è la sospensione del processo il vostro codice il processo della vostra applicazione deve prepararsi la sospensione in genere qui a meno delle prime versioni di ios c'erano se ne ricordavano le 10 secondi di tempo dopo 10 secondi alle 10 secondi per chiudere come stai facendo e mettere in ordine le cose e a quel punto è sospeso e il tuo thread quindi il secondo non veniva ripreso anche se in questo caso a quel punto l'applicazione sospesa è ferma il processo non viene eseguito a quel punto dopo un tot se il calendario non viene più riapperto fino a poi se si stufa e si accorge che serve nella round a quel punto termina l'applicazione e lo fa senza neanche avvertirti perché per avvertirti dovrebbe rieseguire il processo dovrebbe lasciarti eseguire per dirti guarda stai per essere terminato no sei terminato il processo viene distrutto e finiamo ok l'applicazione viene terminata in maniera senza senza grandi senza grandi avvertimenti perché già qui deve essere pronta a essere terminata perché già qui deve essere pronta per essere tutta fuori dalla memoria per sempre sulla carta perché non verrà più rieseguita non tornerà più memoria finché l'utente non la rilancia ok questo è il tema come l'utente se voi immaginate questo trasferito nel mondo di Windows CE è come se qui adesso il task manager è un'esecuzione il processo che controlla questa finestra immaginate questo non avviene su Windows CE non avviene anche su Windows normalmente se voi verificate se la vedete sopra non c'è la possibilità di allora facciamola immaginate torniamo qui ok è come se sto qui sto giocando a capominato felicemente sto quasi vincendo non so minimizzo l'applicazione immaginate questo non avviene che possa finire se la minimizzo questa va giù non è più visibile diventa va in background e poi potrebbe essere terminata se facessimo come facciamo su iOS ok quindi se la minimizzo non è più visibile a quel punto da 12 secondi l'applicazione si ferma il processo viene buttato fuori perché la finestra non è più possibile questo su Windows non viene fatto perché finché c'è la finestra attiva finché il processo è attivo questa finestra può andare avanti per tutto il tempo che vuole nessuno le darà mai fastidio ma su iOS basta che vai in background una volta e poi hai 10 secondi per essere terminata questa è l'idea per cui non c'è mai più non ci sono mai più di due a massimo massimo tre processi di applicazione utente in esecuzione perché c'è sempre soltanto una che è il programma chiaramente una cosa che può venire che se l'utente magari torna sull'escalate e poi torna nella vostra applicazione da background quale eravamo possiamo tornare nel programma finché siamo qui o finché siamo ancora qui il processo è in memoria e sulla carta può tornare a seguire e se l'utente torna a seguire la nostra applicazione a quel punto torniamo qui sul programma ok senza che ci sia nessuna interruzione percepita quindi questa terminazione qui avviene sicuramente quando la RAM serve quindi quando i processi hanno esaurito RAM disponibile per le applicazioni a un certo punto iOS comincia a scegliere in genere le applicazioni più vecchi quindi quelle che hanno esaurito per più lontane del tempo vengono terminate per lasciare spazio a quelle nuove ok stessa cosa ma per UWP o il reverse Windows platform che sarebbe a dire la nuova piattaforma di Windows che è stata prodotta con Windows 8 nella speranza di rimpiazzare il mondo del Win32 comunque il modello è veramente molto simile quindi questo è quello che farebbero le applicazioni moderne per Windows anche sul PC Windows quindi questa è una cosa particolare quindi qui stiamo parlando di Windows da 8 in su che supporta queste applicazioni modelle che appunto hanno un modello che è molto simile per non dire platalmente rubato a iOS per cui l'applicazione appena è installata è not running quindi non è mai eseguito è sul disco ma non è memoria viene attivato dall'utente in qualche modo a quel punto va in esecuzione in background quindi va in esecuzione ma non è ancora visibile a quel punto passa il programma diventa attiva e visibile quando l'utente l'abbassa lo nasconde in qualche modo va in background quindi si prepara la sospensione direttamente come su iOS quando sei in background puoi essere sospeso in qualsiasi momento quindi puoi aspettarti e poi vi spiego come funziona su Windows ma è simile a quanto riguarda a quanto funziona su iOS su iOS qui c'è un taglio di 10 secondi come dicevo poi questo cambia di versione in versione ma più o meno è quello e poi si fa in sospensione qui non c'è la mariccia però la sospensione poi si può essere terminato per il sito quindi se l'applicazione attivo è in questo stato qui significa che può essere terminato perché il processo non è in esecuzione sulla carta può essere terminato quando vuoi fare da qui può essere ripreso se il cliente torna a eseguire ok quindi c'è questo ciclo abbastanza semplice e quando è giallo può essere terminato ma non c'è neanche la fariccia perché in effetti questa è una una distruzione immediata del processo che non viene neanche segnata ok la differenza qui è che questo avviene per le applicazioni che vivono dentro di un'interfaccia complessa con una di Windows PC quindi qui è quello che dicevo prima con campo minato se il campo minato fosse implementato come applicazione di WP potrebbe fare questi passi quindi potrebbe essere lanciata essere in background perché non è ancora visibile lanciare la finestra di gestione di gioco appunto perché l'utente gioca è in foreground appena l'utente minimizza l'applicazione la finestra si nasconde e va in background a quel punto se l'utente si dimentica della finestra e della sua partita il gioco può essere sospeso e poi la sospesa può essere terminata in qualsiasi momento se poi l'utente si ricorda a quel punto ah stavo giocando a campo minato e stavo quasi per vincere se la rilancia l'applicazione riparte da qui quindi parte va in background si ricorda che la sua spesa prima quindi se l'applicazione è fatta bene avrà memorizzato lo stato del gioco da una qualche parte questa è una cosa molto importante perché io parleremo a Vlgit o più avanti ripristina lo stato dell'applicazione e ritorna ad seguire il programma la difficoltà nel passaggio al mondo classico in 32 dove tu finché eri in esecuzione sapevi che nessuno poterà toccarti finché non ti terminavano questo è un mondo molto più complesso per chi sviluppa applicazioni perché noi sappiamo che possiamo essere terminati in maniera in maniera così aspettata in qualsiasi momento noi bisogna essere ronti a sospendere immediatamente l'esecuzione e soprattutto se stiamo facendo operazioni complesse o comunque che sono pieni di stato cosiddetto quindi gestiamo come se informazioni il calendario ci si scende i nostri appuntamenti cosa altro ovviamente outlook ci si scende le nostre email e così via tutte queste informazioni qui devono essere memorizzate in maniera cioè cristallizzate e salvate in maniera sicura quando erano sospesi perché da qui in poi possiamo essere terminati e quando si riparte bisogna ripristinare esattamente come era l'applicazione quando si è sospesa ok per dare l'illusione all'utente che l'applicazione è sempre stata in esecuzione questa è un'altra delle differenze di iOS introdotto l'illusione è che l'applicazione non sia mai veramente quando voi tornate sul calendario vi aspettate di trovare le cose esattamente una della chat perché se voi stavate creando un evento sul vostro calendario avete compilato a metà l'evento magari cercando la data l'orario e così via uscite dal calendario viene sospeso il calendario andate sull'email cercate un email in cui la persona ha parlato l'appuntamento lo cercate nel frattempo passano 10 secondi il calendario viene terminato ovviamente trovate finalmente l'orario rilanciate il calendario e voi vi aspettate che il calendario sia ancora lì pronto a ricevere l'orario che stavate cercando se così non fosse dovresti ripartire da zero e rincare l'evento e sarebbe una cosa estremamente frustrante ovviamente per cui qui la difficoltà è di risultare l'applicazione perché quando viene sospesa deve memorizzare lo stato attuale dell'applicazione ricordarsi che quando verrà rilanciata deve dare l'illusione di essere ancora una schermatina di rincarezione dell'evento perché l'utente stava in un momento digitando l'orario e si è in un momento e questo può essere appunto che dicevo la sospensione è così può capitare uno è perché l'utente esce dall'applicazione classicamente uno è perché un'applicazione prende il controllo in maniera istantanea il classico esempio è la chiamata telefomica che copre tutto e sospende tutte le applicazioni sotto e poi una chiamata normale in un momento di 10 secondi possiamo immaginare per cui in genere le applicazioni sotto vengono anche terminate ovviamente ma poi questo non è sempre vero e così via quindi ci sono mille modi e motivi per cui un'applicazione può essere sospesa in maniera in maniera ok qui erano abbiamo visto apple windows che sono simili ora andiamo in un mondo ancora più complesso ossia android nasce per fare le scarpe a apple ios più o meno e quindi riprende molti concetti da quelli che sono i concetti di ios poi in realtà android è nato dicendo ma è discutibile se sia nato prima o dopo comunque più in parallelo per cui ovviamente molti concetti sono simili però android ha sempre avuto un modello molto più sofisticato per quanto riguarda le applicazioni già dalle prime versioni già da prime versioni le applicazioni erano potevano essere composte da tanti sottocomponenti questa è una cosa che ha sempre distinto android e può essere sempre molto impotente in termini di cose che si possono fare come sviluppatore intendo perché supportano varie componenti che fanno cose diverse dentro la stessa applicazione quindi per ora vi ho parlato di applicazioni che sono applicazioni di interfaccia utente alla fine quindi abbiamo parlato di campo minato come applicazione universale windows e così via che alla fine è una schermata con le mine e bisogna cliccarci a farle scopere abbiamo visto il calendario soprattutto per essere molto semplici però in android già è previsto che è una prevista che possa fare molte altre cose sofisticate la prima cosa più banale che possa fare un'applicazione android è mostrare un activity l'activity è il componente che viene mostrato agli utenti l'activity è il corrispettivo di una finestra windows o una finestra macOS o una schermata ios e così via quindi l'activity è quella che se vuoi risolto dal vostro cellulare fanno aprite qualsiasi applicazione quella cosa che viene animata a messa sullo schermo è l'activity poi un'applicazione nella maggior parte dei casi può essere composta da più activity quindi può avere più activity che si mettono una sull'altra sono vari modi con cui questo si può rendere complesso ma fondamentalmente ogni applicazione ha almeno un activity che è la cosa che vedete quando lanciate l'applicazione poi opzionalmente la vostra applicazione può includere un servizio il servizio è un oggetto che vive in background che può eseguire in background e fa delle operazioni ma non ha interfaccia a tempo che è importantissimo ma il servizio di suo non può mostrare nulla a scuola non è che ci può dire vive in un mondo con un metri diverso può fare elaborazione in background quindi può lavorare senza che ci sia interfaccia ad ente sullo schermo e in genere activity e servizi si parlano e si impallano delle informazioni per far funzionare tutto qua programmare su android può diventare complesso soprattutto perché c'è questo modello molto sofisticato che chiaramente vi dà una potenza sulla carta molto grande perché potete fare cose che su iOS non sono neanche lontanamente possibili di immaginarle però è più complesso che dovete a mano sincronizzare attività quindi cose a schermo e servizi che fanno cose in carto la cosa bella è che visto che c'è questa distinzione tra cose visibili e cose non visibili sulla carta potete avere dei servizi in secolazione che fanno tre cose in sottofondo senza che l'utente ne abbia tutto questo quindi c'è c'è un comportamento la libertà diciamo così rispetto a quello che avete su iOS è molto più così è molto più sbrigliati insomma di quello che potete immaginare perché su iOS come avete visto prima no il ciclo delle applicazioni se l'applicazione ah ho visto adesso un messaggio che però risale a il secondo punto vedrò un messaggio per il nome d'Italia se mi dici quale punto lo spiego molto mi senti professore sì prego non ho capito service ah questo qui sì sì service credo che il broadcast è quello che sto spiegando adesso sicuro però non l'ho citato ancora quindi mi scuso se ho sbagliato scriverle prima eh le voglio parlare lei mi scuso ah non scusate quindi ok ricapito l'activity è qualsiasi oggetto che compare a schermo quindi se abbiamo applicazione nel senso classico faccio esempio se apriamo Gmail l'interfaccia che compare che mostra Gmail è l'activity dell'applicazione Gmail e finì va bene ed è la stessa cosa che dimostravano anche Windows e iOS concetto la schermata o la finestra e così via che parla con l'utente il service o servizio è un componente di background quindi di sottofondo che non può interagire con l'utente quindi non può essere non può rendersi visibile in alcun modo non ci si può comunicare eventualmente può essere l'applicazione che lancia questi servizi in background e per fare delle operazioni che sono più lente o più lunghe in esecuzione quindi richiedono del tempo oppure fanno delle cose delle esecuzioni occasionali sporadiche e così via sempre per fare l'esempio di Gmail per essere più chiaro Gmail l'applicazione ovviamente è composta da più activity e più servizi in background e activity è come dicevo prima l'interfaccia che compare a schermo il servizio cioè uno dei servizi che si può immaginare che Gmail abbia il background è il servizio che va a scaricare l'email ovviamente per cui ci sarà un servizio di sincretazione dell'email che va in esecuzione ogni tot minuti o più plausibilmente quando riceve le notifiche dai server Gmail più probabilmente va in esecuzione e quindi cosa esegui sul vostro cellulare riscarica l'email riscarica il corpo dell'email di concina dei vostri contatti e così via così che quando vuoi lanciare l'activity quei dati sono già pronti e disponibili ok quindi il servizio in questo caso è sempre pronto l'esecuzione e può eseguire se arrivano delle mail o delle comunicazioni che sono attive stessa cosa per fare sempre ancora più concreta forse Whatsapp che fa la stessa cosa cioè l'activity che mostra le conversazioni chat e quant'altro e poi c'è un servizio il background che rimane in attesa delle notifiche in arrivo dal server in Whatsapp ok per cui e quello che avviene è che il bello di questo mondo è che queste cioè l'elenco delle chat di Whatsapp o di Gmail è sempre aggiornato grazie alla presenza di questo servizio quindi quando voi aprite l'activity il stato dell'applicazione è sempre perfettamente in linea con quello che è avvenuto sotto dietro l'equilibrio qualche modo anche l'invio delle mail e l'invio dei messaggi Whatsapp chiaramente è su un servizio a parte grazie a questo modello diviso quando poi inviate un messaggio magari inviate un video di 37 giga su Whatsapp per dire a quel punto la comprensione del video e l'invio del video avviene sul servizio dedicato perché poi potete chiudere l'attività cioè non dovete rimanere lì sulla schermata aspettare che il bambino carichi tutto perché c'è il servizio che ce ne ho corretto questa è una cosa che su iOS classico non si poteva fare in nessun modo quindi in iOS classico bisogna aspettare che l'applicazione terminasse l'esercizio e mandasse l'email mandasse un messaggio completasse l'esecuzione perché chiudere la schermata in quell'istante significava dare 10 secondi di tempo alla vostra attività per computer nel proprio posto chiaramente per mandare un video per esempio non sono sufficienti in genere ok? quindi questa è la potenza che Android sta nel fatto che già nelle sue fondamenta prevedeva la distinzione tra qualcosa che interisce l'utente e qualcosa che invece non ha bisogno di interagire l'utente e sta residente in memoria e fa delle operazioni questo rende Android molto potente ma lo rende anche molto più complesso per lavorarci e a suo punto lo rende anche un pochino meno reattivo se avete mai visto uno dei punti di forza degli iOS e degli appoggiamenti è la reattività delle operazioni che riescono a fare proprio perché non hanno questa attenzione alla presenza di servizi perché in genere tutte le appoggiazioni su iOS sono determinate con una certa brutalità per lasciare interfacciamente molto eretto questo su Android non lo viene sempre anzi su Android poi spesso queste cose vengono più sfruttate e vengono un po' poco giusta spesso avete mille servizi nelle disequizioni perché fanno mille cose in metro che avete installato applicazioni poco trasparenti che fanno varie cose e quindi occupanoci più senza senza con ritegno questo è uno dei motivi perché poi a un certo punto sulla carta andrò in serie di servizi che chiaramente hanno pari diritti di essere in esecuzione e quindi il sistema deve destreggiarsi tra servizi e attività forse più meno comprensibile e l'ultimo punto questo qui in realtà non lo vedevo perché poi non ci lavoreremo neanche per cui le attività le vedremo proprio in pratica quindi faremo su android servizi che vedremo così tangenzialmente questi qui non lo vedremo per niente perché sono un uso un po' più particolare ma i broadcast receiver sono degli oggetti ponenti della vostra applicazione che possono ricevere degli eventi di sistema per cui l'evento del sistema può essere l'utente ha sbloccato lo schermo l'utente ha avviato il servizio l'utente sta facendo una chiamata l'utente ha ricevuto una chiamata l'utente questa cosa di sistema che c'è un elenco abbastanza sterminato in android se la vostra applicazione vuole reagire a queste queste cose che avvengono sul sistema lo possono fare con un broadcast receiver che si registra e riceve questi messaggi broadcast quindi questi messaggi che vanno a tutte le applicazioni e tutte possono reagire a questi eventi questo è un altro motivo per cui android spesso si incarta perché appunto sono eventi sistemali estremamente generici tipo appunto schermo sbloccato schermo bloccato non ho grandi idee che veramente la torcia la triasparga si esatto è bellissima cose così che riguardano un po' tutti e quindi tutta la applicazione possono reagire al stesso evento sulla carta poi non tutti lo fanno però immaginate che se tutte le applicazioni sono installate la nostra macchina deve reagire al fatto che la batteria scarica la batteria da 20% che era va a seguire da 10% perché ha dovuto caricare tutta la applicazione memoria lasciarle eseguire e poi riscarcarle sul tuo prodotto per fortuna in genere poche apprezzioni reagiscono a questi eventi però sulla carta potrebbero farlo però anche qui è una cosa che un'applicazione iOS non può fare l'applicazione iOS non avrà mai la visione del fatto che la batteria sta finendo a meno che non sia in esecuzione con l'istante su android invece può ricevere l'evento e fare delle operazioni in maniera proattiva e agire in qualche modo al i servizi sono un altro motivo per cui su android è possibile fare per esempio cioè fare bene dei client dei client e dei server addirittura di vari protocolli di comunicazione quindi si può installare un server ftp su una macchina android comunque sia utile cosa si può fare su un server ssh tutte queste belle cose che sono che riguardano il 0.0001% di utenti che sono interessati si possono fare solo su android perché solo android ti permette di fare questo su iOS che si possono fare perché appena l'applicazione va fuori dalla sfermata viene terminata ok per concludere questa lunga lunga descrizione dei cicli di vita ultima cosa sull'activity perché allora quindi le applicazioni hanno un ciclo di vita molto complesso a questo come ho detto perché le attività i servizi e i receiver possono essere attivi e terminati in maniera indipendente da dei loro quindi l'applicazione è un servizio attiva che si attiva che lancia il servizio e poi l'attività termina il servizio termina dopo poi arriva un costo di receiver che si attiva lancia il servizio quindi tutti i componenti possono essere lanciati e spenti in maniera indipendente da dei loro quindi c'è una specie di concerto di componenti che possono attivarsi e attivarsi in maniera completamente libera che contribuisce alla complicazione quindi il ciclo di vita che ci interessa non è tanto quello dell'applicazione che è molto molto vario ma è quello dell'attività quindi la singola activity ha un ciclo di vita di nuovo ovviamente complesso per cui può attraversare varie fasi questo qui descrivo ovviamente però concettualmente sono sempre quelle di iOS comunque la fine è sempre un po' che l'attività viene annunciata quindi l'attività viene avviata in qualche modo questo in genere avviene quando usate clicca sull'icona ovviamente però su Android ci sono anche altri eventi che possono lanciare attività le notifiche i servizi possono lanciare attività quindi i servizi non possono interagire con l'utente ma ovviamente possono lanciare un'attività che possa farlo per loro quindi i componenti si possono parlare dietro le quinte e possono fare cioè per esempio se un servizio si accorge che c'è qualcosa dei dati d'arrivo non so un'utile molto utile una notifica importante e così via questi servizi possono volendo lanciare attività che vanno qualche più insieme quindi la titolazione è lanciata quindi la persona è attiva e in programma se l'utente la scalza del programma viene messa in pausa qui si è esattamente uguale alla sospensione di IOS e anche se su hanno delle due fastidie una la pausa e l'altra lo stop quindi c'è la presospensione e la sospensione la presospensione quindi la pausa dire l'attività è ancora visibile potrebbe essere ripresa quindi in genere cosa avviene se c'è un dialogo o qualcosa che copre in qualche modo l'attività un'altra attività esatto quindi qualsiasi cosa che copre l'attività ma fa sì che l'attività sotto ci sia ancora almeno concettualmente quindi questa è la pausa quando l'attività non è più visibile e se la carta non ci dovrebbe tornare rapidamente è sospesa a questo punto siamo in una fase simile a quella della sospensione su IOS chiaramente l'utente può comunque sempre riprendere l'attività perché ci torna navigando e ci tornare in lancia a quel punto si riprende con restart e start se questo non lo viene cioè non destroy che è la preterminazione quindi è quello che dice all'attività guarda sei stata terminata l'utente non tornerà più qui l'attività per essere distrutta fai come devi fare perché a breve verrai nel rimasto della memoria a questo punto è terminata a questo punto se e questo è importante ricordarlo se l'applicazione vostra non comprende più nessuna attività attività attiva nessun servizio e nessun podcast receiver a quel punto il processo può essere permesso quindi un singolo processo su Android che alla fine è un processo di Unix ovviamente può comprendere tante n activity n servizi n receiver e tutti possono essere in parallelo o soltanto uno di essi quando sono tutti disattivi a quel punto finalmente Linux il kernel può terminare il processo prego e quando un activity va in un ondoso oppure onstop nel caso non ci dovesse essere bisogno di distributere passano per un destroy o il processo viene direttamente terminato perché è il press a sinistra sì sono due modi per essere distributi sono Android per fare una completa allora di norma si passa per quando sei attivi si passa per on post fermo lì on stop l'attività in teoria non viene prevista on destroy effettivamente andare a cosa doveva e ti sto distruggendo provare a sinistra se però il sistema sta in panico il memoria che ha bisogno di memoria rapidamente può questo nessuno può per dirlo terminare subito il processo questo lo può fare in alcuni casi quando la rama è quasi finita comunque c'è in silenzia di poter via non essere chi a quel punto dall'ultima cosa che vediamo è on post in realtà dall'invoi possiamo essere terminati sulla carta ci sono on post che è un stop che è un destroy ma è buona norma se se non è un post che è l'ultimo evento veramente importante che la nostra applicazione vede perché da qui in poi in qualsiasi standard sulla carta potremmo essere quindi è solo per carineria e se mai on stop non ne so vedi chiamate poi da parte di casi questo viene però bisogna essere consapevoli che androvi un po' terminaci anche prima se per qualsiasi motivo c'è bisogno di risorse sì esatto esatto lì dipendo in genere dicono sempre che allora sono un po' in genere simulizza soltanto lo stato di quell'attività quindi per esempio ci si ricorda del fatto che l'utente aveva scritto ciao in quel campo per esempio su on stop si prepara a terminare l'applicazione per cui si mette parte di tutte le informazioni si chiude il database si iscrive sul web le informazioni e così via e poi si lascia perdere e si in genere questo è il processo sulla carta è vero perché l'altro problema è che downpost e on in su questi eventi possono essere abbastanza ravvicinati in genere perché come dicevamo prima qui basta che c'è un'altra schermatina sopra e si vanno subito e poi si vanno in risultato e dopo qui chiudere il DB e fare cooperazioni impattanti non conviene farlo solo questo però è buona norma essere sempre contro il precedente che che che sono qui però mi rovina un po' le uova nel paniere per sapere che in questo momento non bisogna essere molto conservativi nel gestire le risorse sapendo che in momenti purtroppo Android ha priorità altra cosa che vi accenno anche qui in genere tutte le operazioni a lungo termine su file su database su scrittura remota e così via la cosa bella è che su Android si possono delegare ai servizi ovviamente per cui è per questo che su Android questa cosa può essere finita via rapidamente perché in genere si consiglia che era una linea guida di fare queste operazioni più lente sui servizi quindi in qualche modo se noi avessimo un'attività che lavora con dati complessi su database idealmente se facessimo un'applicazione per Android fatta bene qui dentro noi non scriveremo i dati direttamente né lo faremo in redone stock ma lanceremo un servizio che lo fa per quanto non il servizio poi rimane in memoria più o meno è chiaro che se il processo è determinato tutti i componenti vengono fisi insieme quindi se tutto va male va male anche il servizio non si salva chiaramente lì se vogliamo anche questo lo dico giusto perché il mondo Android è molto complesso sulla carta sono i lois sui lois si può fare ma pochi lo fanno su Android si può specificare come suddividere un'applicazione in componenti e poi in più processi questa è una cosa che si può fare su Android per cui si può avere un sistema molto sofisticato un percente di applicazioni faccia in cui i reactivity vivono in un processo e i servizi in un altro oppure un servizio in un altro processo in cui a quel punto avremo una suddivisione logica di componenti di azione e processi e a quel punto magari intracciatente che in genere è molto pesante può essere uccisa in maniera arbitraria sapendo che il servizio vive in un altro processo che magari rimane residente di memoria per esempio questo non c'è speranza che si riesca a vederlo al laboratorio sappiate che cosa che si può fare nel vostro manifesto che vi ho accenato la volta scorsa nel file che dichiara come è fatta la vostra applicazione su Android voi dichiarate quali sono gli activity quali sono i servizi quali sono i progressi e così via lì volendo potete specificare se far eseguire alcuni pezzi in processi separate quindi potete richiedere poi un Android può anche non farlo però potete chiedere la cortesia di farlo girare in processi diversi a quel punto chiaramente diventa ancora più complesso c'è un costo diventa complesso far comunicare i pezzi ovviamente perché a quel punto non condividono la memoria sono processi separate e quindi per passare informazioni dall'activity al servizio dovete fare una chiamata in tre processi mandare informazioni da un lato al lato del sistema attraverso i vari sistemi costrutti che vi dà Android però banalissimo non è quindi in genere si fa proprio quando c'è una esigenza di stabilità incredibile che raramente c'è in questo però si si fa in genere se gli activity servizi e professionisti per cui non è stesso processo la cosa bella è che condividono la memoria e quindi chiaramente potete passare informazioni con una certa liberità tra attivi separate e servizi separati sapendo che poi saranno comunque dello stesso blocco di run e quindi si possono parlare ok un'altra di questo anche perché poi lavoreremo cioè con Android lavoreremo su Flutter e quindi su Flutter avremo una visione un po' distorta di questo perché Flutter quello che fa ma Flutter è un po' adesso parliamo più in dettaglio l'altro ma Flutter fa una cosa un pochino brutta nel senso che per fare le cose facili e belle tutta questa cosa qui dice questo è un mondo bellissimo complicatissimo ma non ci interessa per cui quello che fa la Flutter è lanciare una soluzione di e dentro l'Activity gira il modello grafico di Flutter e poi dentro c'è tutto quanto la vostra applicazione per cui in tutto questo magico mondo si sospendono non vedete assolutamente per cui può essere bello può essere brutto però sia tra l'altro su qualsiasi piattaforma su cui gira sia su Windows che sia Android che iOS e così via quello che vedete è sempre soltanto una schermata e poi internamente potete fare quello che volete però in genere è un modo un po' alieno per vivere su quella piattaforma per cui è vero che c'è modo per giostarsi in attivi di parlare con servizi su Android sono tutte cose che si possono fare anche in Flutter però in genere è un po' nascosto da quello che è Flutter perché è multicattaforma ma chiaramente per essere multicattaforma al 100% tutte le catforme sono uguali ovviamente per tutto per cui sia Windows che Android per poi una schermata fine con il titolo lì dentro vantaggi in questo ok siamo quasi è anche molto caldo oggi mi sa soffrendo moltissimo chiudo con questa con la filosofia di fondo del ciclo di vita moderna dell'applicazione l'idea è che in nessun caso mai l'idea di dover gestire le applicazioni cioè non deve mai essere necessario costringere l'utente a riflettere su quale è l'applicazione in esecuzione e quindi determinarle esplicitamente cliccando sulle X o terminando le applicazioni Android e iOS ok le applicazioni esistono se fanno internamente si vengono cura del loro stato interno quindi se sono database con nessun reporter eccetera eccetera lo fanno in maniera completamente isolata il sistema operativo esiste queste applicazioni che sono presenti si attiva o si disattiva magari lo terminate ma in maniera completamente trasparente per il tempo ok per cui il sistema operativo attiva e disattiva e termina i processi che sono parte delle applicazioni però in maniera invisibile all'utente e in alcuni casi anche invisibile a chi sviluppa l'applicazione ok per cui il fatto che sia un processo di esecuzione alla fine è un dettaglio implementativo della nostra protezione questo è il modello che iOS ha cercato di proporre in primo luogo e poi a cascata anche da testi operativi perché è vero che alla fine dei conti il processo è lì il punto ex è in esecuzione viene da una macchina a fare le sue operazioni ma il fatto che ci sia in realtà non vi riguarda mai cioè voi non dovete mai pensare in termini di processo di istituzione dovete solo pensare in termini di applicazione che si sceglie la macchina e quindi il fatto che ci sia un processo e delle risorse della macchina c'è ma è tutto gestito nell'autonomia è un po' come il paramone è un po' come la garbage collection dei moderni di programazione in cui voi allocate la moria su RAM ma non vi occupate mai della deallocazione perché ci pensa i 30 anni Java Net Myron quello che volete fanno questo quindi per conto vostro gestiscono la RAM immaginate che il sovrativo per conto vostro gestisca il processo ok quindi voi fate un'applicazione non fate il processo il fatto che il processo esista e venga terminato in realtà è una cosa che il sovrativo fa per conto vostro e voi non dovete mai prendere il negozio e per concludere l'idea per l'end user quindi il punto di vista finale è che appunto l'end user dovrebbe usare l'applicazione per quello che deve fare l'utente quindi devo mandare un email devo mandare un messaggio devo andare su internet devo andare su web e così via ma questa operazione qui appena l'utente in qualche modo deve ragionare sul fatto che c'è un'applicazione in memoria che sta eseguendo e sta occupando il trash più e quindi il cellulare si muove in maniera poco fluida a quel punto è un problema insomma proprio perché non fa quello che sta a provare tempo ok perché in qualche modo appunto l'utente è conscio del fatto che la macchina ha dei limiti cosa ovviamente inevitabile e il servizio lo sta facendo il suo lavoro per offrire l'utente con esperienza accettabile ok questo è il motivo per cui se leggete qualsiasi guida a separativi moderni per smartphone vi incoraggiano vi suggeriscono di non gestire neanche i task delle vostre finestre quando è una cosa abitudine spesso quando finisce di fare qualcosa poi magari va sul task switcher di android delle finestre e termina l'applicazione che ha appena seguito è un modello mentale che proviene da windows ho fatto come devo fare e la sto terminando perché ho finito in realtà in quel modo stiamo facendo un dispiace un totto all'istitoporativo in qualche modo perché in istitoporativo deve preoccuparsi della gestione dell'applicazione terminando in anticipo in realtà stiamo facendo un lavoro in più e in realtà stiamo compromettendo all'istitoporativo di ottimizzare l'applicazione perché se l'applicazione l'ha terminata in maniera esplicita non ho una slide propria non so se nessuno è stato chiaro la terminazione è quella in cui compare questa questa roba qui non lo vedo con le schermatine così se tirate su la prima viene terminata su tutti i sistemi quindi anche su su windows e così via in quel caso l'istitoporativo è costritto a terminare l'applicazione che avete detto termina tutti i processi di applicazione e a quel punto se vuoi rilanciare l'applicazione un minuto dopo deve rilanciare tutto quanto qui in realtà stai consumando più batteria perché il supermercato fa più lavoro ed è ancora peggio se lo fate per lo whatsapp per esempio lo whatsapp è un carrozzone che è composto in una attività e 8000 servizi in un background quando voi terminate lo whatsapp dovrà terminare tutti i servizi di whatsapp che comunque sono sempre residenti quindi ricevere le notifiche e quindi al primo messaggio riceverete tutto whatsapp viene rimesso in memoria per cui state ram così al nastro per terminare un'applicazione che in realtà dovrebbe rimanere residente del mondo per cui l'idea è che tutto questo che decisivo dal separativo l'utente deve soltanto pensare a quello deve fare lui o lei e clicca sull'icona e finisce questa era l'idea dell'iPhone 20 anni fa non mi ricordo qualcosa del genere l'idea di parte di parte era questa e tutti i moderni con applicazioni sopra di essi hanno questo stesso modello oggettuale quindi ok direi che possiamo chiudere qui perché è spossante non sapete dubbi su questo ancora molto generico veramente per cui poi lo vedremo più in pratica lavorandoci domani mattina ci vediamo di là e proviamo a lavorare con Windows 32 Windows 32 chiaramente è un serrativo che tutte queste cose qui non ce n'ha ok c'erano tutti scusate Windows ce l'ha qui e Win32 non me lo sfumano quindi Win32 avete un unico modello che è apola finestra chiudola finestra e vende avviato con la via la finestra quindi vedrete che è molto primitivo poi arriveremo anche a questo questo è scusi