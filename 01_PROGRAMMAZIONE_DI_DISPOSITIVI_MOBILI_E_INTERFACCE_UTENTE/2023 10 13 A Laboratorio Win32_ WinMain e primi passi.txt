Perfetto. Allora, buongiorno intanto, oggi facciamo la nostra prima azione di laboratorio, con la sventurata idea di farlo con The Win32, per cui oggi impariamo a litigare con quello che è il magic phone di interfacce per Windows. Prima di iniziare in realtà, insaliamo prima l'ambiente di sviluppo, possiamo chiamarlo in questa maniera, quindi il compilatorino e tutti gli strumenti che servono per compilare un programma per The Win32 e poi vi faccio una vera introduzione su quello che sono le interfacce, quindi come si usano. Allora, per iniziare, quello che ho detto ieri di fare, non so se voi avete avuto il tempo di farlo o meno, comunque sulla pagina del corso nella sezione laboratorio di Win32 c'è un pacchettino che si chiama CIR, Win32 Compiler e librerie, che sarebbe TCC e le librerie Win32. Se cliccate qui e se tutto funziona, in teoria vi dovrebbe far scaricare un zip. E qui adesso metterò tutto quanto in una cartella, qui mettiamo PDM U223, scarico. E anche nel vostro caso questo è un ambiente di sviluppo, cioè un ambiente di sviluppo, è uno strumento molto molto primitivo, per cui basta veramente copiarlo su una cartella qualsiasi del vostro PC. A questo punto qui dentro avrete il vostro zip. Nello zip ci sono un paio di oggetti, vediamoli qui. E quello che ci interessa in realtà è tcc.exe, che è il compilatore, quindi il linker è tutto l'oggetto che ci permette di fare gli eseguibili per le Win32, e non solo, e la seconda cosa importante è il include, quindi il pacchetto di librerie standard che TCC si porta dietro. Adesso dobbiamo fare un'occhiata. Quindi qui nella cartella creerò una sottocartella che si chiama tcc. E appena il mio pc molto rapido reagisce. Qui dentro ci mettiamo tutti i file che sono nello zip. Nulla di più banale, quindi un'installazione molto primitiva e facile. A questo punto bisogna semplicemente ricordare a Windows che ci interessa quel tcc.exe, quindi dobbiamo aggiungere il percorso della directory al path, quindi al percorso degli eseguibili. Adesso lo facciamo per un secondo affine completa la copia. Questo potete farlo anche su pc laboratorio, perché visto che non stiamo toccando nulla di sensibile, dovrebbe funzionare ugualmente. Ok, a questo punto abbiamo tutti si disinzippato. Dentro il menu, non so se sto facendo qua, se sto facendo qui, nel menu start, se cercate variabili d'ambiente o... L'area bot potreste trovare questa opzione qui che vi permette di modificare le variabili d'ambiente del vostro sistema. Se lo aprite si apre una finestra sbagliata, qui la finestra è questa. Qui sotto in fondo c'è un pulsantino che vi permette di modificare le variabili d'ambiente del vostro sistema. Aprendo qui, vedete questa interfaccia abbastanza complessa, che suddivide le variabili d'ambiente dell'utente, quindi le vostre personali e quelle del sistema. Visto che TCC lo stiamo installando come utente, quindi non vogliamo che tutti gli utenti del sistema abbiano accesso a TCC, sinceramente, lo aggiungiamo a questo path qui. Ci sono due path in realtà, quindi ce n'è uno per il sistema e uno per l'utente. Poi, diciamo così, al tempo di esecuzione i due percorsi, i due path si fondono e avete accesso a entrambi i percorsi. Ma questo va soltanto per voi come utente collegato, per cui modificheremo questo. Qui vedete che ce n'è già un marasma. Non so che possiamo aggiungere di nuove. Quindi qui prendiamo il percorso della directory TCC, quindi qui cliccando sulla barra otteniamo l'indirizzo dove ho messo il file TCC.exe, copio e poi aggiungo qui con new e qui in fondo aggiungo la cartella. Non si vede. Sotto quindi l'idea è che tra tutti i percorsi che ho già aggiunto e sono diversi, in questo caso aggiungo la cartella in cui si trova TCC.exe. Vedete? A questo punto, se tutto va bene, dovrei riuscire a fare. Ok qui, ok qui e ok qui. A questo punto le vari ambienti sono state modificate e i processi che verranno avviati da adesso in poi, da l'ambiente Windows, nasceranno con queste vari ambienti. Se vi ricordate, come abbiamo detto nella prima lezione, le vari ambienti sono fisse, una volta che il processo è avviato non possono essere modificate, per cui tutti i processi già attivi non hanno ancora quella vari ambienti modificata. I processi che adesso avvierò da adesso in poi avranno invece il nuovo percorso, per cui se avevate già aperto un terminale o un altro programma precedentemente, questo non avrà visione del percorso aggiornato. Questo è uno. Capita spesso dimenticarsi di questo, poi sia la sensazione che vi paremmo che non vengono aggiornate. A questo punto, se apro il terminale, se apro il terminale di Windows, in teoria da qualsiasi cartella in cui vi trovo, posso lanciare TCC. Se tutto funziona, se tutto va bene, voi dovreste riuscire a lanciare TCC-version e ottenere una cosa di questa gente. Se questo avviene, siete a posto, siete pronti per il magico mondo delle quinte interviste. Ok. Altra cosa, nel caso in cui il percorso funziona e quant'altro, a volte è utile il comando where, che vi permette di risalire a dove si trova l'eseguibile che state lanciando da riga di comando. Una cosa abbastanza utile, quindi se fate where TCC, la riga di comando vi dice dove ha trovato TCC in questo caso. scartabellando nei mille percorsi che potete aver aggiunto al... Ok, in questo caso potete capire se ci sono dei conflitti o se qualcosa non va come deve. Where non vi tornerà l'informazione. Ok, perfetto. Allora, giusto per poter dire che tutto funzioni. Adesso provo anche a fare... Vediamo se vi riesco a farlo. L'idea è che qui dentro vediamo i nostri esercizi. E qui i file che andiamo a modificare potete modificarli come volete. Quindi come Eldor potete usare ovviamente qualsiasi strumento che preferite. Io adesso qui sarò... Studio Code, ma voi potete usare chiaramente blocco note, notepad++, o cosa studio, quello vero. Insomma, quello che vi pare. È importante che vi riusciate a modificare dei file, dei test, semplicemente, aspetta che questo qua, renderlo più leggibile. Grazie. Grazie. Andiamo. Forse. Ok. Grande. Perfetto. Per provare faccio un mail.c. Vediamo se ricordo abbastanza. dai rudimenti di C. Giusto? Era una cosa del genere. A questo punto vado nella cartella appropriata. Qui c'è il mail.c. Se ho fatto le cose correttamente dovrei riuscire a fare mail.c-o-mail.ex. Incredibilmente pare che abbia compilato correttamente. L'imposte c'è. Adesso lo eseguo. Magia. Ok. Quindi vi ricordo ancora il C. Ok. Questo adesso l'ho fatto con un ricorso, giusto per vedere se è tutto compilato. Se volete farlo anche voi, appunto, questo è il nostro programma, ad esempio, in C. Adesso, a partire da questo, quindi vi ricordo che chiaramente qualsiasi programma con le Wien 32 in C parte da questo concetto di base, in sostanza, e poi andiamo un po' a complicarci la vita, facendo cosa? Andando a interagire con le librerie di sistema, con le chiamate di sistema esposte dalle Wien 32. Printf è la chiamata, quella standard, per stampare il suo standard output da libreria standard in C. E poi, chiaramente, uso ancora da libreria standard in C, però poi andremo a includere una serie di interfacce che invece appartengono alle Wien 32. Ah, altra cosa che vi faccio vedere, giusto prima di partire, veramente. Nella directory di TCC, quindi TCC vive qui dentro, no? Abbiamo il nostro compilatore, il nostro filo compilatore, ma abbiamo anche gli include qui. Questa è la cartella, la directory in cui TCC va a cercare tutte le header, quindi le definizioni degli include che potremmo utilizzare noi nel nostro coppice. Quindi, in particolare, se andate a cercare più in mezzo, trovate anche standard.io.h. Quindi qui standard.io.h c'è, ovviamente fa parte dell'abriera standard di C, quindi deve essere disponibile in qualche modo a TCC che ci espone il runtime C. Se lo apriamo, possiamo dare un'occhiata a come è fatto standard.io. Questo non è utilissimo, però può essere interessante. Qui in mezzo, dobbiamo veramente la nostra printf e tutte le varie definizioni. Qui vedete anche come sono definite veramente queste funzioni di libreria, perché qui sappiamo che il printf prende una stringa, cioè il formato e poi dei parametri opzionali, ritorno all'intero che dovrebbe essere l'ordis di byte scritti, e poi c'è questo cdecl che troveremo spesso anche nelle guizzer 2. Questa è una specifica al compilatore che non ci interessa moltissimo, che gli dice, guarda, questa funzione qui è una funzione standard, quindi è una C declaration, e poi va linkata in un certo modo che è quello del C standard. Quindi in realtà a noi non ci interessa moltissimo. Al compilatore invece sì, perché determina, cioè definisce qual è poi la ABI, cioè la interfaccia binaria da usare per andare a collegarsi a quella funzione lì, tra le varie altre cose che fanno. In questo caso troverete in vari punti, e a maggior ragione poi nelle guizzer 32 sarà pieno di specifichi di questo genere che a noi non interessano molto, ma al compilatore sì. Ok, questo lo diamo e lo buttiamo via, perché adesso andiamo a vedere in dettaglio che possiamo fare. Allora, le WIN32 nascono, come vi risultate, abbiamo detto in più occasioni, però sono la fusione tra due linee disoperative in realtà, quindi sono una specie di grido strano, perché sono il risultato della linea, per così dire, classica, vecchia, di Windows 1, 2, 3, 3.11, 95-98, e anche la malaugurata poi Millennium Edition, la ME, che era l'ultima della sua linea, l'ultima del vecchio Windows, diciamo così, e del nuovo Windows, che è nato come Windows NT, che poi sarebbe diventato XP, come linea commerciale, diciamo così, per cui le WIN32 sono la fusione di questi due sistemi operativi, e sulla carta me lo permettono di fare programmi che valgono per entrambi. In teoria, un programma che adesso noi andiamo a fare potrà girare ovviamente sulle macchine moderne, come Windows 10, quello che c'è sui PC del laboratorio, su Windows 10, sulla mia macchina, ma in teoria, se la ricompiliamo, gira anche su Windows 10, anche se il kernel è compatibilmente diverso, il sistema operativo è compatibilmente diverso, però le API sono le stesse, per cui a meno che, a meno che non facciamo delle cose veramente strane, i programmi sono compatibili. Quindi un'unica API che gestisce tutto il mondo Windows dall'inizio alla fine, in realtà, meno male, per quanto poi abbiamo tentato di rimpiazzarlo più volte. Windows classico è un sistema operativo molto molto semplice, molto primitivo, chiaramente, come era anche un SQS classico, come i sistemi operativi commerciali di quell'epoca. NT invece è un sistema abbastanza moderno, che appunto è Demptive, Multitrader, Tutte le Bit, quindi ha tutte queste nuove novità, in realtà è stato fatto in questo momento attuale, chiaramente, ma le librerie nascono a Tentorio Pit, e quindi ha tutte queste cose positive che faranno per loro, e l'interfaccia si basa su una serie di paradigmi di sviluppo che in realtà vedremo meglio, poi in teoria, nell'altra aula in cui vedremo più o meno la storia dell'interfaccia grafica, che adesso per ora non ci interessa, però quello che cercheremo di fare in questa sessione è arrivare a questa cosa, quindi fare una finestra, una cosa molto poco gloriosa, veramente, però vedrete che già soltanto per fare questo si verrà una marea di codici, questa è la bellezza del Win32, quindi fare una cosa così, che il Hello World di Win32 richiede almeno due creatori di codici, per qualche motivo. Ok. Siamo abituati a avere un programma C che ha questo aspetto qui, quindi prima ho fatto un int name con void, senza parametri, se voglio anche avere accesso a una riga di comando posso usare questo strumento qui che ci espone questa formula con cui noi accediamo alla riga di comando, vi ricordate, la riga di comando è composta da la stringa con cui abbiamo lanciato il nostro processo, in genere è composto dal nome del programma e poi eventualmente i parametri che sono stati passati al programma in C per come standard ce lo espone in questo formato qui in cui abbiamo la lista, il numero di argomenti che sono separati da uno spazio e poi un array di puntatori a string che sono caratteri che sono delle stringhe con cui leggiamo i paratteri perché questo è il formato con cui C ci espone questo dato qui però ricordate sempre che la riga di comando vive nel seno operativo ce lo da ce lo memorizza nel seno operativo poi è il runtime C che va a spiluccare in questa stringa la va a interpretare la suddivide in blocchetti separando gli spazi e ce la dà in questo formato qui però non è cioè questo è il runtime C che ha deciso o meglio la libreria che ha deciso che questo fosse il modo di usare per farlo altri linguaggi possono farlo in generale come una differenza poi è vero che per coerenza molti fanno delle cose simili quindi per esempio in C sharp avete una array di string ed è la stessa cosa quando la programma con le Win32 la prima cosa che bisogna dimenticarsi è il main perché il main non c'è più perché viene rimpiazzato dal WinMain ossia main specifico per l'applicazione di Win32 non perché il main non ci sia più veramente ma il main viene nascosto diciamo così dal compilatore che prevece che riconosce che la vostra applicazione è per le Win32 e quindi tutto durante il time viene esteso da un piccolo runtime per Win32 quindi quello che noi andremo a fare è una funzione che non è questa la dimentichiamo anche se esiste ancora andiamo a usare un WinMain che già è un aspetto molto più brutto però non cambiamo il main dentro Win32 è questo perché almeno congettuale immaginate se il compilatore va a preparare il vostro servibile da qualche parte c'è il main classico del runtime C che viene ovviamente invocato però quel main lì poi fa tutte le preparazioni per le Win32 quindi fa tutti i processi di lavorazione contatta il sistema eccetera cioè prepara il vostro esegibile perché possa seguire dentro le Win32 dentro Windows e poi quel codice lì che è nel runtime chiama il vostro WinMain quindi il main c'è ma non lo vedete perché non lo state scrivendo voi sta scrivendo il compilatore per voi e poi il compilatore a un certo punto va a chiamare il WinMain quindi è un annidato dentro il main se andate a estorare il compilato voi potete vedere che il main esiste ovviamente però voi non lo avete scritto voi vedete questa funzione qui che verrà chiamata anche tutto il main una volta che il vostro runtime ha preparato tutto il tutto ora diamo un'occhiata a questa questa cosa qui quindi già vedete che è un po' più ostile alla vita questa definizione rispetto al main ma vediamo perché allora intanto la prima cosa importante è questa WinApp quindi questo è è andato a vedere il header dentro PCC poi lo vedremo tra un secondo se vedete queste definizioni delle delle librie Windows spesso troverete questo WinApp davanti alle funzioni questo sono andato a vedere come definito le definisce come standard call la standard call di nuovo è una dichiarazione per il compilatore che gli dice guarda questa è una chiamata standard quindi definisce qual è la API l'interfaccia binaria per chiamare queste interfaccia quindi la standard call è quella classica che passa gli argomenti sullo stack e fa una serie di cose quindi di nuovo non ci interessa ma per saperlo è il modo che ha il compilatore C per capire come invocare quella funzione per farla funzionare come viene invocata quella funzione perché in realtà viene invocata dal sistema che invocano noi in realtà ok allora poi altre cose misteriose queste H instants come si chiamano sono come tante altre cose nel mondo Win32 sono delle handle quindi dei puntatori delle manopole dei punti di contatto che ci permettono di interagire con degli oggetti nelle Win32 si usa spesso questa strana questo strano standard per dare il nome alle cose per cui molto spesso i tipi iniziano con una lettera standard tipo H che sta per handle e P che sta per pointer e poi dopo segue l'oggetto a cui puntano a cui fanno la contatto perché in questo caso H instance sta per handle to instance e instance è distanza della vostra applicazione ok quindi già quindi di nuovo c'è questa distinzione tra il programma in esecuzione e l'applicazione come concetto dentro le Win32 che sono due cose distinte nel Win32 c'è l'idea di un'applicazione che è in esecuzione poi in pratica ci sarà un processo in esecuzione che dà vita a questa applicazione però l'applicazione è concettualmente quello che l'utente vede come iconcina sullo schermo e poi ci clicca e si avvia l'applicazione quindi quell'oggetto lì è la famosa instance dell'applicazione quindi a voi a cosa serve questa queste parametri qui sono il puntatore alla vostra applicazione cioè quando voi venite avviati il programma viene lanciato e il Win32 vi dice guarda tu sei stato lanciato questa è la distanza della tua applicazione in memoria a cosa serve serve perché in tanti casi bisogna avere un riferimento alla nostra applicazione per poter caricare risorse della nostra applicazione poter fare cose per conto della nostra applicazione collegare cose alla nostra applicazione e così via quindi questo oggetto qui è abbastanza importante perché ci serve in tanti casi quando andiamo a interagire con l'utente finale per conto dell'applicazione altra cosa che risale alla preistoria del risale alla preistoria di Win32 ce ne sono due estremamente cioè instance e hprev instance quindi il puntatore alla istanza precedente questo risale al mondo delle Win16 in cui un'applicazione poteva essere lanciata soltanto una singola volta cosa che non esiste più quindi all'epoca un programma poteva essere lanciato l'interfaccina quella classica di Win32 prego è una casella per essere void sì sono due tipi per lo stesso oggetto allora sì per definire meglio questo allora hinstance è definito come handle e handle è definito come questo oggetto qui per cui handle è un puntatore a void non so se ricordate quando va letto questa definizione orribile cifra ma letto così quindi questo questo è il tipo e questo è il nome del tipo quindi handle è un puntatore a void un puntatore a void e hinstance è una handle quindi in realtà a cascata hinstance è un puntatore a void e quindi questi qui sono dei genericisti di puntatore a void tra l'altro questo lo vedremo travertutto perché tutte le handle di Win32 sono di puntatore a void quindi sono dei puntatori me così come in c quando non sai bene cosa fare un puntatore a void va sempre bene è tipo il prezzemolo per cui è la soluzione a tutti i vostri problemi però da cioè per me sono dei puntatori così senza senza un tipo vero e proprio per cui sono anche non si portano dietro nessuna informazione per il compilatore neppure voi ecco sono da leggere in questa maniera poi vedete anche altre handle più avanti c'era poi quando faremo delle opzioni grafiche avrete un puntatore a pennello un puntatore a colore un puntatore a font queste belle cose sono tutti hfont hbrush hcolor eccetera eccetera e sono tutti quanti alla fine sono dei handle e sono letteramente a quel punto quindi alla fine tutto è un puntatore a void e poi arrivo all'altro l'altro tipo che non rastringa sto dicendo appunto questo risale a una una cosa vecchia del win32 in cui nel win16 in realtà in cui poteva essere solo un istanzo con un programma proprio anche graficamente si lanciava il programma dall'intervincinato del win3.11 e quella potrebbe essere solo una singola volta adesso questa cosa non esiste più possiamo lanciare un'applicazione più volte se vogliamo e quindi questa cosa qui dalle win32 in poi è sempre null quindi questa qui sono andato a leggere è sempre null perché l'istenza precedente non esiste ok poi l'ultima cosa questa qui è a parte il nome è orifile che è z comma line è un puntatore a stringa f è un puntatore a char quindi è una una stringa ovviamente altra cosa char questo è un char in maiuscoletto attenzione non è il char minuscolo di c quindi non è il tipo standard c ma è il char delle win32 poi vi chiedo perché serve un char specifico però serve perché windows è un sistema unicorn quindi ha supporto ai caratteri estesi l'agico gli emoji e tal chiaramente non negli anni 90 però adesso sì e quindi il char standard di win32 non è il char standard c perché il char standard c è un byte a 8 bit e che un byte a 8 bit non può contare tutte le informazioni che servono per cui questo char qui in disolito è a 16 bit ma anche questo dipende da come compiere non è un mondo facile ve lo assicuro è una stringa vediamo poi come fa ok e mi sa che è tutto cos'altro sui nomi dei parametri intanto già i tipi non hanno non sono belli ma i nomi dei parametri sono ancora peggio perché sono ispirati cioè poi hanno tutto un loro senso per cui sicuramente c'è anche una certa eleganza in maniera molto astratta però l'idea è questa che visto che uno dei programmatori delle win32 era questo char simoni che appunto in quanto cioè un programatore ungherese e questa notazione si è limitata a lui e questa notazione quindi si chiama notazione ungherese in suo onore e a che serve? Serve perché se lavoriamo in un mondo appunto di 30 anni fa in cui non c'è il vostro editor di testo non vi aiuta non vi dice di che tipo sono i parametri perché non riesce a farlo perché ancora non c'è l'intelligence queste magie che gli editor moderni riescono a fare voi non avete idea di cosa siano questi oggetti una volta che li usate nel codice quindi qui sono dichiarati i tipi ovviamente ma poi nel codice magari la definizione è sette pagine più in alto e non vi ricordate che tipi sono per cui anche le variabili anche i nomi dei parametri includono il tipo stesso ok? quindi questo oggetto che si chiama hinstance nasconde il fatto che si tratta comunque di una handle quindi inizia con h minuscola e la command line è una sz command line perché è la riga di comando ovviamente ed è una string zero terminated quindi è una stringa terminata con zero che potete leggere come una stringa c stack che termina classicamente con lo zero che indica la p quindi il nome del parametro stesso cioè non serve a niente che sapete può chiamarsi anche pippo come spesso in realtà in una lezione di c se gli danno nomi altrimenti buffi alle variabili questo va benissimo però in questo caso i numeri variabili servono a qualcosa perché hanno un nome che indica il tipo o anche come vanno usati quindi a se z sappiamo che è una stringa che finisce con zero e quindi di nuovo questo qui è una stringa questa qui è di nuovo la riga di comando questo è il modo in cui le p 32 passano la riga di comando e vedete che è diverso quindi non c'è più l'array con i parametri quei parametri spittati per spazio questo è una riga di comando così come arriva quindi è tutta la stringa perché le win 32 in genere non hanno bisogno di una riga di comando quindi serve a un certo punto da cui non ve la pre-processa ne che ve la passa così come in blocco se poi volete se volete farci qualcosa dovete autonomamente andare a scrittarla in pezzi e così via c'è l'ultima cosa che è un intero che adesso vedremo ok fine adesso cominciamo a lavorarci e il punto d'arrivo per ora sarà questo oggetto proveremo ad aprire un dialogo e scriverci dentro qualcosa vediamo se se riusciamo a farlo sì ah sì allora io qui ho stato visto sui conti dovrebbe essere cioè non so se ce l'avete già installato o meno e cosa ho fatto ho fatto una cartella con esercizi e niente ho aperto qui ho visto sui conti direttamente la cartella e poi a questo punto creo i file qui dentro voi potete fare veramente cioè potete fare anche non so se avete notepad per esempio che va benissimo potete creare il file c da così come file semplicemente e poi lavorarci con notepad qui da questo punto di vista siete purtroppo totalmente liberi quindi vedete voi cosa vi è più comodo e qui tra l'altro vi sto sui conti mi sa che non ho neanche installato niente per c o altro per cui è proprio così com'è cioè intanto non lo usiamo in maniera molto molto scarna non so se avete se vi è difficile di aprire sul computer non si scrive a a sul computer ah cioè sul sulle scuole ah della quale per da Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Facciamo ancora... Condivido. Ok. Quindi adesso, nel vostro caso, magari conviene fare dei file, no, main2, c.c, e queste via per avere tutte le varie cose che faremo, però è differente. Adesso qui cancellerò senza riguardo. Allora, la prima cosa che faremo è includere Windows.h, che ovviamente è il punto d'ingresso alle Win32. Quindi di base si include soltanto questo file qui, che a cascata include tutte le Win32. È un file abbastanza esteso, che poi va a includere tutte le librerie che vi servono. Ok? Quindi questo, in genere, serve sempre. E a questo punto, come vi dicevo, il main diventa int Winapi, Winmain. Questo lo scrivo e poi me lo faccio copiare. Purtroppo non è comodissimo. Ok. Questo è il nostro magico. Quindi di nuovo i parametri che dicevamo prima, quindi le hIntense. Questo qui, che è sempre null. Questo è quasi sempre zero. Ma non sempre, poi vedremo perché. andiamo a compilare. Se non ho fatto errori, perché funziona. Ok, quindi pure quando l'ho fatto, peraltro qui si fa tutto. Non si fa ancora nulla di utile. Se volete provare a vedere se funziona, potete compilare il file. E se tutto va bene, dovrete compilarvelo e fare un exe. Che di nuovo non fa nulla, chiaramente. Lo fa nulla, ma è agganciato alle Win32 adesso. Perché c'è il Winmain, non c'è più il main. Il main viene magicamente aggiunto dal compilatore a tempo di compilazione. Prego. Per compilare, allora ecco. Per compilare è tcc, il file, il main.c. Se volete vado a rimettere anche come... C'è l'output di main.exe in questo caso. Però di default poi usa... Dovrebbe farlo da solo. Questo è per compilarlo. Per lanciarlo basta dare il nome dell'esercizio. Ok, torna. Ah, altra cosa che devo subito apprezzare. Se non vorrei... Un tentativo lo facciamo subito. Proviamo a stampare da standard ASB dentro il Winmain. Adesso se... In realtà non l'ho provato da un po', per cui non sono sicuro dell'effetto. In teoria, in realtà non stampa nulla. Non so se avete... Adesso ho messo la printf classica Hello World dentro il mio eseguibile. Prima stampava su riga di comando. Ricordate che prima avevamo... C'è questo eseguibile qui che stampava su riga di comando e ci dava il nostro Hello World. Adesso che sono entrato nel mondo del Win32, ho compilato un programma che fa printf, ma printf non ha alcun effetto pratico. Quindi nonostante venga eseguito, non stampa nulla. Quindi questo è il nostro eseguibile adesso. Perché non stampa nulla? Perché lo standard output, quindi il canale di output Unix classico del nostro eseguibile, il nostro eseguibile non viene collegato alla riga di comando. Ok? Per cui il terminale Windows, quando lancia gli eseguibili, non si prende la briga di collegare il canale, perché in genere non c'è bisogno. Un eseguibile che vive per le Win32 di solito non comunica sui canali standard import output ed error, e quindi non vengono collegati. Quindi le nostre printf cadono nel luogo. Quindi stampiamo dei bytes sul canale output, ma nessuno li leggerà mai. Poi c'è comunque modo per agganciarli, ma non è molto utile. Ok. Ci siamo? Ci sono problemi? Penso di no. Per cui adesso, come facciamo a comunicare col mondo con le Win32? Allora, il modo più semplice che abbiamo è usare i message box, che sono i dialoghi di avvertenza, quelli che ho usato nelle slide poco fa. E come si invocano? Allora, c'è una funzione delle Win32 che si chiama message box. Nulla di particolarmente strano. Message box ha quattro parametri, anzi, facciamo così. Prima vi faccio vedere anche... Perché le Win32 sono molto estese e... Come si fa a vedere la documentazione? Basta cercare il nome della funzione con Win32 e, in genere, il vostro motore di ricerca vi dà subito l'accesso alla pagina giusta. Come risponde. E' qui. Quindi vive dentro winuser.h E questa message box ha quattro parametri e adesso vediamo quali sono. Questa è la documentazione. La documentazione è fatta molto bene, anche molto vecchia, quindi è molto completa, però se non altro, come un punto a favore delle Win32 è che sono documentate molto bene. Ok, come funziona quindi? Message box ha quattro parametri. Vedete qui c'è anche scritto come se sono opzionali, se sono parametri in input e output. In C spesso i parametri vengono usati come output aggiuntivo, se è un parametro di puntatore e così via. Quindi in questo caso tutti i parametri input. Allora, il primo è una H window, e quindi qui si capisce subito che è una handle a una finestra. Quindi un puntatore a una finestra. Poi c'è una cosa illegibile, è una LPCT str, quindi che cos'è questa roba? È un long pointer char t, cioè quindi char type sono i caratteri lunghi, str, quindi una stringa di caratteri larghi, quindi la caratteri unicorn, puntatore a. Ok? Quindi tutto questo per dirvi un puntatore a stringa. Il secondo pure è il tipo di box che vogliamo evocare. Il text è il testo che va nel box sotto, la caption è il titolo che va sopra nel box, e poi il type, come andiamo a vedere, è un intero senza segno e può assumere una serie di valori che sono documentati qui dentro. Ok? Quindi possiamo avere varie cose che possiamo mettere nel nostro master box. Spesso, e Win32 sono fatte così, quindi spesso abbiamo una serie di costanti magiche che sono queste qui, che vanno combinate a livello binario con l'or binario per creare il tipo di oggetto che vogliamo creare, che vogliamo usare. In generale, qui adesso vi faccio vedere un paio, il message box più banale che si possa fare è mb ok, cioè message box ok, tra l'altro vale anche zero, quindi l'intero è zero perché è il message box di default, e sarebbe il dialogo con il puntato ok, e basta. Il dialogo più banale che si possa fare è questo, poi c'è quello con ok cancella, ritrova cancella, si no, si no cancella, o annulla in realtà in italiano. Ok? Poi, insomma, specificare un'icona e così via, quindi queste cose adesso andiamo a fare. Allora, nel nostro codice qui abbiamo quattro parametri, il primo era una handle to window, questo qui una edge window non ce l'abbiamo ancora, cioè non esiste, perché non c'è nessuna finestra, a che serve quello? Serve perché per poter specificare che il nostro dialogo è figlio di una finestra già esistente, cioè va a annidarsi su una finestra già esiste, ma in questo caso non è il nostro scenario, quindi basta passare null. E poi passiamo due string, la prima è il testo e il secondo è la caption, quindi il testo ve lo ammigo un po' meglio così si legge meglio sullo schermo. Quindi questo è il dialogo. Buonissimo. Ok, e tutto. Poi come intero, come specifica del dialogo ci mettiamo, dicevo prima mb ok, e poi possiamo aggiungere un'icona, ci mettiamo una icon information che dovrebbe darci quel cerchietto blu con la i, perché è un message box non di errore. Chiaramente se volete mettere un message box che segnala un errore, c'è mb error, credo, icon error, che invece è quel classico icona rossa che vi segnala un errore, poi c'è il warning, quindi potete segnalare varie cose con gli stessi strumenti. Quindi, punto e virgola che avevo dimenticato, ok, a questo punto se tutto è a posto dovrei riuscire a compilare questo. Ho compilato. Ah, allora, chiaramente adesso la finestra l'ha aperta, ma l'ha aperta su questo schermo, quindi adesso l'ha sposto di qua. Allora, ok, funziona. Non è bellissimo però, adesso vediamo subito perché. Quattro tanto vi faccio provare e mi date conferma se funziona, se riusci a lanciare, avere un dialogo su schermo. Chiaramente devi liberi di cambiare l'icona, il tipo di messaggio, il tipo di pulsante e questo qui. Lascio questo qui sotto a memoria di quello che deve uscire e qui vi farò scippare il codice. Bene, provate anche voi a mettere una lettera accentata o una lettera speciale nel testo. Quindi io ho messo la E del verbo essere e perché non viene letta correttamente. C'è scritto questo è un dialogo bellissimo. Vedremo perché. C'è scritto questo è un dialogo bellissimo. Vedremo perché. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie. Se lo vediamo eseguire, per favore. Se ha le preferenze. Ok, mi spiace, saprei come risolvere. Allora, ammesso che a tutti meno uno compare il dialogo, allora che cosa avviene qui? Allora, è... Sì? Allora, è... Quello... Quello è... Allora, perché questa cosa non funziona? Allora, le Win32, che vi dicevo prima, sono nata in un ambiente a 16 bit, quindi abbastanza vecchiotto, però già da subito c'era il supporto alla localizzazione, ovviamente, per cui il software deve poter girare sia in inglese americano, sia in altre lingue, tra cui giapponese, lingue, insomma, che hanno codifidi di caratteri anche abbastanza diverse, per cui Windows è sempre stato... ha sempre avuto il supporto per Unicode, per i caratteri, per cui i caratteri possono essere standard C, quindi a 8 bit classici, oppure possono essere a più bit. In questo caso le Win32 le chiamano wide characters, quindi lettere ampie, larghe, insomma, che hanno più spazio. Se conoscete un po' di codifica Unicode, saprete che la codifica più larga Unicode è a 4 byte, quindi è molto larga. Windows usa una codifica media a 16 bit, quindi ogni carattere in Windows ha 16 bit, per cui è quello che si chiama in verbo UTF-8... UTF-16, scusate, che permette di codificare tutto quello che volete, in realtà però ogni carattere è sempre composto da 2 byte almeno, che può anche allungarsi in più. Per cui tutte le stringhe sulla carta sono da 16 bit, però normalmente, quando comprate un'applicazione per Win32, si usa la modalità standard C, in cui tutte le stringhe in realtà sono composte da caratteri a 8 bit semplici. Per cui queste stringhe qui che abbiamo scritto con le lettere accentate sono stringhe che vengono interpretate come stringhe a 8 bit standard, ma non lo sono in realtà, perché nel nostro sorgente, se diamo un'occhiata a come è scritto, qui sotto, vi sono sui code, se riuscite a leggere, sotto a destra, vi dice come ho codificato il file e tradisce anche l'errore che adesso vi spiego. Questo file qui è scritto in UTF-8. Non si vede, dubito. Qui sotto sarebbe a dire. Questo file è UTF-8, che significa che è unico 8, nel senso che tutti i caratteri sono a 8 bit, salvo quelli speciali che possono prendere più byte. Ed è quello che accade proprio nella nostra bellissima E accentata, che qui è stata codificata con due byte. Una A con la tilde in alto, e poi una di RSI random ungherese, perché insieme, se leggiamo correttamente, danno la E accentata. Però Windows non lo sa, perché ti ha prescontato che il nostro programma è un programma standard C, che ha tutti i caratteri, ha tutte le stringhe a 8 bit, cosa che non è vero. Per cui, possiamo risolvere questa cosa in vari modi. Il modo più primitivo è codificare la nostra, il testo, quindi proprio il sorridente C a 8 bit, quindi innanzi C. Per farlo, possiamo cliccare qui su... Adesso mi sa che non si vede molto bene questo punto, il progettore. Però sotto a destra, in viso su Revolt, si può cambiare la codifica. Qui, qui possiamo fare Save with Encoding, e qui vi compare tutte le opzioni possibili e immaginabili. Qui vedete che UTF-8 è quello di Revolt, che si usa ormai dappertutto. UTF-16 è quello che usa Windows, quella nativa, però è sempre due byte. Oppure quella a un byte sarebbe la Western ISO o la Central European ISO, e così via. Queste codifiche qui sono codifiche che permettono di scrivere caratteri centro-europei, cioè dell'Europa centrale in sostanza, quindi le tracentate, le tre collegiere, e così via, soltanto con un byte. Quindi potremmo, volendo, usare uno di questi sistemi qui, e possiamo provare a farlo, per esempio. Quindi possiamo fare Western Windows 1252, questo va bene, proviamo. Salvo il file. Adesso se io compilo il programma di nuovo, e ne seguo, la speranza, infatti funziona, la speranza è che il dialogo abbia finalmente una E accentata. E qui, allora, il programma adesso è un programma che ha tutte le stringhe a 8 bit, stringhe semplici C, ma il trucco è aver compilato il nostro sorgente, quindi questo file qui, aver salvato il nostro sorgente qui, codificando questa E qui con un singolo byte. Quindi in realtà è bisognito codi il colpevole, perché prima codificava questa E con due byte, ovviamente, come fanno tutti di norma. Adesso abbiamo detto, guarda, codifica con un singolo byte, dando per scontato che chi eseguirà il programma lo eseguirà su un PC che è occidentale, per usare questo termine un po' così, perché la codifica è quello occidentale. Se noi prendiamo questo file qui, questo eseguibile, scusate, questo file ex qui, lo spostiamo e mettiamo in Giappone, per dire, questo e tutto il resto viene letto correttamente. Quella E lì viene letta migliore completamente diversa, immagino con un ideogramma o qualcosa del genere, perché lì la codifica di default, quindi a 8 bit soltanto, prevede chiaramente la codifica dei ideogrammi o una parte di essi, ok? O in Cirilli, con altre codifiche che abbiamo visto brevemente qui. Per cui, quando qui cambiamo modifica di salvataggio, stiamo dando per scontato, però che il programma che interpreterà il nostro eseguibile saprà come farlo, quindi che non ci sposteremo mai fuori dall'Europa centrale, in qualche modo, ok? O appunto in ebreo, turco e quant'altro. Ok, per cui la soluzione vera, diciamo così, non è tanto usare questo, ma usare UTF-8, come fa tutte le soluzioni normali di questo mondo, e per cui UTF-8 è la soluzione. Torniamo UTF-8, qui, se codifico questo file qui, appunto, rivelisco, il problema è che questo carattere qui occupa due byte, quindi Windows non lo sa, bisogna convincerlo, o meglio, bisogna dire al compilatore che questo avviene. Chiudo il dialogo, quindi adesso se non faccio nulla, lo ricompilo, lo ricompilo, e non ho sbagliato, perché Windows non lo sa, bisogna dirgli che usiamo la codifica Unicode, e per fare questo bisogna passare meno di Unicode, sembra che era così il comando, no, era senza spazio, scusate, meno di, ah, non si vede, scusate, per esempio la finestra, il comando diventa tcc meno di tutto maiuscolo Unicode main.c meno o main.exe stiamo dicendo al compilatore, guarda, tutte le mie stringhe possono essere codificate in Unicode, per cui abbi la la carineria di creare un eseguibile che è un eseguibile con caratteri larghi, che supporta caratteri ampi, per fare il cassetto di periodo con un fatto di regolore diverso. Esatto, esatto, esatto, esatto, perché di default tcc compila in modalità classica C, che è quella diciamo preistorica, per dire, no, cioè quella che non supporta le codifiche più complesse, con questa specifica qui che è semplicemente una modalità diciamo così di compilazione, tutte le quinte 32 prevedono che si vada a passare delle stringhe che sono composte in realtà da più caratteri potenzialmente. Per cui se cosa fare esattamente di unico di unico si ve lo spiego praticamente di questa di qui è una è una define in C, no, se ricordate in C si possono definire delle costanti, no, quindi si può fare questa cosa che non so torni dell'anima, non so, sì, una cosa del genere, no, questa è una costante dove in realtà non è una costante perché è semplicemente il compilatore che dice ok, questa stringhe dell'anno è 365, no, cioè è una forma di costante un po' primitiva, però si usa in tanti modi, in questo caso noi stiamo usando questo modo, possiamo definire una costante da fuori, quindi questa è una define definita dal compilatore che definisce unicode come simbolo, per cui è equivalente a fare questo, è equivalente a fare unicode uno, ok, quindi potrei fare anche questo, potrei fare questo e toglierlo dalla riga di comando, sono due cose identiche, ok, una volta specifico la define da fuori e una volta la definisco dentro il sorgente, ma l'effetto è lo stesso, quindi da qui, solo che qui unicode viene definita da qui in poi, quindi dalla riga uno in poi, è come se fosse la prima riga, da qui la define è messa, vale per tutto il programma compilato, chiaro che più o meno siamo lì, quindi non cambiamo, però è la stessa cosa, a cosa serve questa cosa qui? Serve perché, se volete proprio vedere i dettagli più truci delle qui in 32, vediamo se riesco a farvelo vedere in qualche modo, adesso è qui, capite chi è stesso? Devo vedere dov'è, non ricordo dove è definito il message box, vediamo dove è definito, non è definito, molto bene, ah no, perché, sì, perché se no, scelmo io, devo fare, find, grep, molto lento, ok, ecco, shell API, ah no, non è questo però, ok, quindi user h, vedete che le API di Windows sono enormi, ovviamente, sono tantissimi, ok, vediamo, non così, come si fa? Ok, ok, no, message box, ok, ok, ecco la magia, come viene, dietro le quinte, quando noi usiamo la funzione message box, in realtà la funzione message box non esiste, questa è la verità, la message box è una, è una, come si dice, una cosa, al professore C, che in base, alla presenza del simbolo unicode, o meno, punta a una funzione diversa, quindi il magheggio è questo, il 90% delle funzioni di Windows, che prendono string come parametro, non esistono veramente, sono in realtà una direttiva del processore, che punta a due funzioni diverse, una accetta string anzi C, l'altra accetta string larghi, quindi questo è il trucco, e lo fanno in base alla presenza del simbolo unicode, per cui, adesso abbiamo compilato finora, senza questo simbolo unicode, per cui message box era definito come message box A, cioè anzi C, sarebbe dire, quindi string A8B, e quindi non riescono a interpretare, il nostro carattere accentato, perché prendono tutto quanto come una C, string A C standard, quindi non riescono a leggere, con il carattere unicode, invece puntiamo message box W, che sarebbe a dire message box wide, quindi caratteri ampi, e qui tutte le string vengono prese come caratteri a 16b, questo è il maggiore, ok? La maggior parte delle funzioni che prendono string, fanno questo, quindi questo è il trucco che si usa nelle Win32, per cui qui, cambiando la direttiva, questa non è questo, ma è la terminale, che non riesco più ad evocare, dov'è? Aggiungendo questo, adesso punto a message box W, non più a message box A, il mio programma rimane uguale, quindi adesso, la funzione che andrò a richiamare, supporta i caratteri esotici, quindi potrei mettere caratteri di qualsiasi tipo, ma se posso farlo con il magico selettore di caratteri di Windows 10, quindi mi conoscevo qualcosa di veramente senza senso, questo, mi piace, bello, questo occuperà sicuramente del 24 bytes, perché la codifica, va bene così, e adesso lo compiliamo, e non funzionerà uguale, però lasciatemi sperare per un istante, è andato molto molto male, perché è successa questa cosa, adesso ve lo spiego subito dopo, allora, va bene, abbiamo tentato di fare questa cosa, avrebbe funzionato, se solo non mancassi tutto l'elemento, adesso mi è arrivato, questo non è mai successo così, non è mai stato così grave, è qualcosa di molto molto giapponese, va bene, perché viene tentato in questa maniera, perché ho fatto tutto in maniera corretta, ma la stringa non è ancora giusta, questa stringa qui, è una stringa C, ancora, non è una stringa a 16 bit, cioè ogni carattere qui occupa, anzi no, è complicato, questo carattere qui, è un carattere a 8 bit, questo a 8 bit, questo a 8 bit, questo è a 16 bit, possiamo immaginare, questo è a 4 byte, non lo so, ma posso immaginare, sto inventando, quindi sono tutti diversi, chiaramente la funzione di destinazione messageboxw, prende tutto quanto a blocchi di 16 bit, e quindi fa un grandissimo macello, perché è tutto codificato in maniera sbagliata. Come si risolve questo? Con una direttiva al processore, perché le Win32 fanno tutto così, per cui tutte le nostre stringhe, in Win32, devono essere messe dentro delle funzioncine, che sembrerebbe, delle pseudo funzioncine, che si chiamano text. Ok, quindi metterò tutte le stringhe, tutte le stringhe costanti intendo, quindi tutte le stringhe che vengono scritte nel codice proprio, vengono messe dentro la direttiva professore text. Perché? Perché text, in base alla presenza di Unicode o meno, andranno a ricodificare la stringa, nel giusto numero di 5. A quel punto finalmente chiameremo message box con la stringa codificata in maniera contente. Non è facile. Io questo appunto ve lo dico, non tanto perché poi vi tornerà utile, io spero vivamente di no, ma perché, cioè in qualche modo, per apprezzare il fatto che poi, nel passare delle decadi, si sia arrivati a un sistema come Flutter, dove le stringhe non sono più un problema, perché sono tutte stringhe a UTF-8, e per cui noi dobbiamo mai preoccuparci di queste cose qui. Per farvi apprezzare questa differenza fondamentale. A questo punto proviamo a compilare il programma di nuovo. Tra l'altro, il fatto che non funzionasse, che sarebbe uscito del giapponese, era già tradito dalla presenza di questi warning, che suggeriva il fatto che, guarda, attenzione, stai usando dei puntatori diversi, cioè stai passando a dei puntatori non compatibili, perché già il compilatore aveva capito che questa è una string, questa era un puntatore a caratteri C, 8-bit, e la funzione accetta un puntatore a caratteri larghi. Quindi già il compilatore aveva capito che qui qualcosa non torna, e quindi aveva già avvertito. Adesso, con la direttiva text, questa cosa dovrebbe essere risolta, provo a ricompilare, l'errore è sparito, a questo punto posso incrociare tutte le valangi, e... funziona, sì, il carattere è estremamente leggibile e brutto, però è il carattere che ho messo, questo per cui torna. Il carattere è una scelta infelice, magari, però procede. Ok. Questo era, per complicare la vita, ovviamente, però era per farvi vedere tutto il procedere. Ok. Facciamo un'ultima cosa, poi se... Anzi no, forse salto la parte del... La facciamo la volta prossima, intanto parliamo di pixel e byte la volta prossima, quindi la schippiamo. Andiamo subito a come si crea una finestra, a questo punto, che è l'ultima cosa che vediamo. Richiede un po' di tempo, per cui adesso ci... abbiamo quella mezz'ora che ci serve per provare a farlo. Vediamo se riesco. Per cui, io ripartirò da... Ah, poi chiaramente il codice di questi programmi, poi vi ricarico su Blender, per cui se volete avere accesso a questi file, potete farlo quando volete, senza che seguite direttamente. Qui quindi io tolgo... Ripartiamo da zero, a questo punto non facciamo più un dialogo, facciamo una finestra vera e propria. La differenza tra un dialogo e una finestra è abbastanza sottile, diciamo così, è comunque un riquadro dello schermo. La differenza fondamentale è che il dialogo ha un formato fisso e possiamo metterci soltanto del testo e delle icone tra quelle previste. Una finestra vera e propria, quindi quello che si chiama Windows, proprio nel senso generale, è una finestra di cui abbiamo il controllo completo nei suoi contenuti. Quindi la differenza è questa e quindi anche la quantità di codice che si deve definirla sarà molto più importante, insomma. Ok, iniziamo. Prima di iniziare, cioè prima di... La prima cosa che va fatta è definire una classe di finestre. Questo sembrerà una cosa molto strana, però la prima cosa che va fatta è definire una tipologia di finestre. e quindi prima ancora di poter aprire una finestra dobbiamo definire una tipologia di finestre, perché concettualmente almeno è possibile aprire più finestre della stessa classe. A che serve questa roba? Al momento mi sembrerà una cosa estremamente astrusa, più avanti vi spiegherò meglio qual è l'idea di fondo di questa cosa. Adesso per ora, è come se in C++, prima di poter allogare un oggetto, dobbiamo definire che tipo di oggetto è. Quindi prima definiamo la classe e poi possiamo fare new nome della classe, a quel punto abbiamo un oggetto che è di classe al dettaglio. Quindi l'idea... Il concetto è lo stesso. Ovviamente va fatto in codice, per cui è tutt'altro che banale. Intanto iniziamo con definire una variabile, uno struct, quindi una struttura dati in C, che si chiama window class. la chiamerò così. Questo anche... Questo si fa spesso anche... Cioè in Wind & Rue spesso si fa una cosa del genere. Si hanno questi struct molto grandi che contengono varie informazioni, dei pacchetti di dati, che vivono in questi struct. Ah, qui vedete, peraltro, vedete qui che vi dà varie varianti. Wind class A è la variante ANSI. Wind class W è la variante ANSI. con le stringhe larghe, peraltro non è veramente rilevante. Quindi Wind class A è la struttura che ci interessa. Contiene, cioè uno struct che contiene una serie di informazioni qui, che adesso vedremo una per una. Però in genere, quando bisogna passare un oggetto di questo tipo a Windows, è perché bisogna passare tanti dati insieme alla funzione, alla funzione di sistema. E quindi il modo con cui si fa, invece di avere mille parametri nella funzione, si crea, si passa un singolo oggetto che contiene una serie di... di variabili al suo interno. Quindi qui cosa facciamo? Definiamo un oggetto di tipo uno struct Wind class e poi possiamo andare a modificarlo. Facciamo Wind class, punto, le varie variabili che è composto. Vediamo il secondo, qui dice style, window proc, e così via. Allora. Allora, qui la storia è lunga, quindi se... qui a questo punto arrestatemi se cosa non è chiara, perché è molto facile che diventi non chiara molto rapidamente. Allora, il primo parametro è lo stile di quella classe di finestra. Se vogliamo definire, dire a Wind 32, guarda, tutte le finestre di quel... la tipologia di quella classe si comporta secondo un certo stile. Cosa intende per stile a Wind 32? Una varietà di cose, di comportamenti in realtà. Vi possiamo vedere. La lista completa, lo vedremo forse. Non tanti, sono stati aggiunti negli anni del... delle... Insomma, le Wind 32 hanno una lunga storia, per cui hanno vari significati e così via. Di veramente utile non ce ne è molte. L'unica che ci è veramente utile in realtà sono queste qui, hredraw e vredraw, che adesso vi mostrerò. Vredraw. Ah, ti no. Ignorate questa cosa, facciamo finta che sia. Non ci tenerebbe, nessuno stile. Ok. Poi, cbcls extra, lo mettiamo a zero. Poi mi spiego tutte le singole cose che ci sono. Quindi questo qui e questo oggetto qui. cbwindow extra, ugualmente, non ci interessa, lo mettiamo a zero. Poi mi spiego cos'è, ovviamente. E in senso, questa è la prima cosa importante. Quindi, la nostra classe dobbiamo definire per quale istanza di applicazione vale, per cui bisogna fornire a window class, hinstance, e gli passiamo cosa? La nostra istanza. A che serve questa cosa? Serve perché le Win32 devono registrare quella tipologia di classe, di finestre dentro un applicativo, dentro un'applicazione e deve sapere quale è l'applicazione che contiene quella tipologia di classe, di finestra. Non è facile da dire. Poi, in window class poi c'è hicon, vedete qui c'è hicon, hcursor, hbrush, e così via. Sono tutte handle, quindi puntatori a qualcosa di grafico. Quindi in particolare hicon è, che cos'è? È l'icona che identifica la finestra a che serve? Se usiamo una finestra più banale che si possa immaginare del blocco note, blocco note che è proprio la propria finestra delle Win32, hicon è questa icona qui sopra a sinistra, l'iconcina qui del blocco note è la hicon della finestra blocco note che è di una classe finestra del blocco note. Cosa vi spiego? Ok, quindi prima ci definiamo la classe delle finestre blocco note e poi creeremo una finestra blocco note che a quel punto avrà l'icona del blocco note. Ho detto molte volte blocco note. Ok, come si fa a fare questa cosa? Ora non caricheremo un'icona specifica nostra, useremo l'icona di default delle finestre generiche e usando una funzione che si chiama load icon, load icon ci permette di caricare le icone ovviamente, possiamo fare in vari modi, seguiamo un'icona generica, passiamo qui null e qui usiamo id application, qui sono tutte stringhe magiche che adesso usiamo ma sono delle costanti che troviamo dentro il filtro da due e l'icona quella di default delle applicazioni che non hanno un tipo specifico. Poi c'è h cursor, quindi il tipo di cursore, a che serve questa cosa qui? Questo è il cursore del mouse, quindi il puntatore del mouse, sarebbe a dire in italiano, che il mouse assume passando sopra a una finestra di quella classe. Per cui ogni volta che il mouse passa sopra una finestra di quel tipo, il cursore cambia aspetto e prende il cursore lì. Ora chiaramente la nostra finestra è la finestra standard e vogliamo caricare il cursore standard, quindi load cursor, null, idc, arrow. Arrow è il cursore standard del mouse, quindi è il puntatore questo, quello che vediamo. Questo puntatore qui, questo classico è idc, arrow, quindi freccia. Ah, altra cosa, perché questa cosa è importante? Perché è importante poter definire, guarda, questa finestra cambia sempre il puntatore in quest'altro puntatore, perché è una cosa che avviene, non ce ne accorgiamo neanche in realtà, quando passiamo sul sottofinestra in cui scriviamo dentro il blocco note, avviene proprio questo, quando entriamo qui diventa l'inserimento del testo come puntatore. Questo avviene grazie a questo sistema qui, quindi nella classe di finestre inserimento del testo dentro il blocco note, da qualche parte qualcuno ha creato questa classe che prevede il puntatore alternativo, quindi Win32 in automatico appena si passa su quella finestra cambia il puntatore e quando si torna su una parte della finestra in cui lo standard è idc, arrow, torna il puntatore. Quindi questo è il meccanismo con cui il puntatore cambia in sostanza in Windows. Però di base questo è quello classico. Ok, Windows Class poi c'è HBR, questa è una Handle to Brush, quindi è una Handle a un pennello background. Questo perché ogni finestra in Windows può avere un colore di background di sfondo ovviamente e a noi interessa il pennello bianco, quindi useremo il pennello quello classico che fa la finestra bianca e la otteniamo non con Load Brush, stranamente non c'è una funzione di Load Brush, misteriosamente c'è Get Stock Object, come direte perché il nome cambia ma scelte e carichiamo un oggetto White Brush. Questa costante qui è il pennello bianco, ce ne sono vari altri, c'è quello nero, c'è quello grigio, vari altri colori standard. L'unico problema di questo tipo qui è che Get Stock Object ritorna un handle generica quindi per rendere felice il compilatore bisogna castare questo a Edge Brush, se no poi dà dei warning brutti. Ok, poi Window Class abbiamo quasi finito, però avevo promesso che era molto orgoglioso e poteva essere da meno. LPS Z Menu Name, questo è il modo con cui andiamo a specificare il menu della nostra finestra e il menu poi vedremo più in dettaglio ma il menu in Windows è questa cosa qui sopra. Questa serie di opzioni nel menu della finestra e quindi per aggiungere un menu serve passarlo qui, non lo faremo però, questo è null vuol dire senza menu e poi per concludere tutto questo giro è LPS Z Class Name, questa è una cosa importante, bisogna dare un nome a questa classe, quindi come si fa a identificare la classe poi una volta che è registrata dandole un nome e questo si fa passando una stringa, quindi qui faremo text, attenzione è una stringa costante per cui va messa dentro text sempre, questo vale per tutte le stringhe in Win32 e la chiameremo la mia finestra, o non è la mia classe perché sennò la mia classe, ho chiamatola come volete tanto, l'importante è che poi quando creerate una finestra usate la classe giusta con il nome giusto, quindi Win32 identifica le classi di finestre in base al loro luogo. Adesso vi lascio il copernato che mi rendo conto che è tanto codice per fare molto poco, quindi quando vedete la finestra sarete molto delusi purtroppo, ma così. E sapete anche che per fare la stessa cosa con qualsiasi altro sistema chiaramente serve molto meno codice, però è giusto per farvi capire da dove si arriva e dove si è arrivato in questo caso. in realtà ho lasciato in sospeso un'altra ultima cosa, perché qui sono andata a vedere la lista degli oggetti, ce n'era uno che ho saltato amabilmente, che è questo lpfn window pro che adesso copierò e metterò qua dentro, ma non ci metterò ancora nulla perché questa è forse la cosa più importante. Questo è la variabile, il campo più fondamentale, a parte il nome della classe che ovviamente è fondamentale per poter usare la classe, quello è quello che veramente dà vita alla vostra finestra, poi vedremo che cosa è. Già dal nome potreste intuire è un long pointer to function window pro, quindi è un puntatore a funzione che è la procedura di finestra. Che cosa questo sia lo mettiamo da un secondo. Ok, a questo punto se siamo stati bravi questo struct è tutto bello popolato di informazioni utili adesso bisogna registrare la classe presso Win32 quindi bisogna dire a Windows guarda questa classe qui la voglio usare a breve la registro si fa con un punto che si chiama registro class e passiamo per per puntatore l'oggetto quindi puntatore a Windows class ok se in qualsiasi momento qualcosa è non cristallino fermate perché è un attimo confondersi di entrare nel maratron del perché sto facendo questo è una domanda legittima grazie ci siamo vi lascio ancora ok a questo punto abbiamo una classe di finestre ma non è ancora non c'è nessuna finestra perché se noi compiliamo questa cosa dovrebbe compilare senza problemi in teoria se ne esegliamo non avviene niente abbiamo recito una classe ma non abbiamo mai creato una finestra di quella classe quindi il prossimo step chiaramente è creare una finestra lo faremo con una funzione che si chiama create quindi niente di più banale create window è un'altra funzione che prende 8000 parametri come cioè 8000 variabili per parametri e ritorna un oggetto di tipo h window quindi una handle a window che è la nostra sono chiamate in vari modi h finestra quindi questa sarà la nostra finestra che finalmente poi diventa viva e rendisce agli input potente però per poterlo fare bisogna passare queste 9 11 parametri nulla di più semplice allora la prima cosa da passare è la classe della finestra quindi come dicevo prima la cosa importante è la il nome della classe della finestra per cui è questo oggetto quindi adesso lo copio e incollo questo potrebbe renderlo una variabile una costante se volessimo non è importante l'importante è che sia la stessa stringa quindi Win32 sappia riandare a pescare la classe che avevo registrato chiaramente questo nel nostro scenario di creare una singola finestra è chiaro che è completamente inutile stiamo facendo una fatica in mane per fare un risultato molto ristretto però se abbiamo un programma molto complesso immaginiamo Photoshop estremamente sofisticato può capitare che alcune finestre siano molto simili da loro quindi in quel caso ha senso questo meccanismo in cui abbiamo varie classi comuni di finestra e tante istanze nella stessa finestra oppure immaginate un programma un esempio è un browser web è un classico esempio di un programma che ha tante finestre che però sono uguali nel comportamento questa finestra qui è una classe di finestra browser di Firefox se faccio ctrl l e ne apro un'altra questa finestra che è un'altra finestra non è la stessa finestra di prima però si comporta esattamente come l'altra quindi sono due istanze di finestre della stessa classe quindi a un certo punto a un certo livello di complessità in poi questo aggiornamento può aver senso però per ora è soltanto molto ragnoso poi altro parametro la caption quindi quella che ricordata su message box era il terzo parametro la caption era il titoletto che compare in alto sulla finestra qui lo passiamo come stringa e qui ci mettiamo ciao mondo ok poi c'è un intero che è lo stile della finestra qui per completezza vado a cercare window styles perché ogni finestra può avere più stili prima c'erano i stili della classe ora sono i stili anche delle finestre vediamo che cosa si può definire qui storicamente ci sono un sacco di cose che rimangono un po' nell'alba dei tempi e quant'altro però l'unico veramente veramente importante è AWS overlapped window però a che serve questa roba qui questo serve per definire l'aspetto della finestra quindi come vogliamo che la finestra compaia all'utente alcune cose potete anche riconoscere possono aver senso per esempio AWS border vuol dire la finestra deve avere un bordino la finestra deve avere una caption cioè un tisolo caption è in gergo di winter 2 è il tisolo della finestra quindi vogliamo che la apre una finestra un titolo vogliamo che sia disabilitata questo poi per esempio se la finestra deve essere spenta deve avere uno uno scroller orizzontale in questo caso poi c'è anche V scroll veramente verticale iconic è il modo in gergo per dire finestra minimizzata quindi una finestra che ha questo aspetto qui cioè non è visibile è una finestra icona minimize è la stessa cosa vedete qui same as AWS iconic anche questo compare spesso perché in win 3.11 quando si minimizzava la finestra diventava un'icona e quindi si chiama lo stile si chiama iconic poi con win 95 è diventata la barra del task bar per cui è diventato minimize però è la stessa cosa minimize box è voglio che la mia finestra abbia questo pulsante sopra per minimizzare in alto e così via un'altra cosa interessante è AWS tiled voglio una finestra che sia segmentata questo valeva per windows 1 addirittura dove non c'erano le finestre sovrapposte ma quindi era solo suddivisioni geometriche della finestra quindi la finestra di default 0 quindi tutto tutto a 0 è la finestra che divide lo schermo a sezioni questa cosa c'è storicamente ma non funziona più per cui adesso equivale a overlap che è l'alternativa che è tratta con windows 2 ossia una finestra che posso trascinare quindi una finestra sovrapposta come questa sovrapposta alle altre quindi da questa costanti si intravede un po' quello che è la storia di windows e overlapped window include una serie di cose di default quindi una finestra overlapped con blocco note avrà un titolo un menu di sistema che è questo questa roba qui un thick frame quindi un bordo spesso anche questo è un nome un po' strano perché viene da windows 95 e qui il bordo era tridimensionale blocchettoso che si potava afferrare bene con windows 8 in poi il thick frame non esiste più quindi sono tutti frame molto sottili in realtà e minimize maximize quindi abbiamo la finestra possiamo minimizzare e massimizzare quindi queste cose vanno attivate richieste specificatamente per cui nel nostro caso prendiamo questo costante qui e la passiamo al parametro quindi di default andremo a creare una overlapped window però potremmo fare delle finestre molto diverse se volessimo poi adesso abbiamo quattro parametri che sono posizione x y e larghezza e altezza della finestra quindi qui andiamo a definire in pixel attenzione la posizione della finestra quindi 0 0 sarà in alto a sinistra e così via e la larghezza e l'altezza di solito non si passano mai dei valori predefiniti qui perché perché possono non aver senso sullo schermo dell'utente questo poi ne parleremo dopo in teoria perché a meno che non andiamo a vedere come è fatto lo schermo dell'utente in realtà non sappiamo né quanto è grande né come disposto né sappiamo se lo schermo la coordinata 0 0 che immaginare che c'è sempre ci sarà per forza non è detto che ci sia uno schermo in quella posizione poi vedremo perché però quindi in genere usare qui dei numeri è sempre sbagliato per cui si usa una costante che è c w use default per tutti e quattro i valori quindi questa roba qui la copiamo quattro volte quindi vuol dire alla x default y default larghezza default altezza default ok fai tutto quindi windows ci darà per conto nostro dove posizionare la finestra ed è la cosa più sensata che si può fare di solito ah tra l'altro un'altra cosa ed è il motivo per cui se ho blocco note aperto se io riapro blocco note se avete solo una finestra non sono così fortunato e avete blocco note e aprite più blocchi note i blocchi di note vedete che si aprono lievemente spostati l'uno dall'altro no? e questo lo fa il sistema di finestre perché sa che avete appena parlato un blocco note prima e ve lo sposto un po' rendervi evidente l'apertura di più blocchi di note e questo avviene perché hai usato il default se non usaste il default dovresti farlo a mano del comportamento ok siamo quasi prometto che è quasi fatta a questo punto serve una qui servirebbe una h window quindi una handle alla finestra madre perché ovviamente ogni finestra può essere figlia di un'altra finestra in questo caso non c'è nessuna finestra madre quindi null poi serve una handle al menu se la nostra finestra ha un menu che è diverso dal menu della classe di finestra che appartiene scenario apocalittico che potrebbe avvenire possiamo passarlo non ci interessa quindi qui anche qui è null distanza al nostro programma di nuovo perché la finestra vive dentro un programma quindi ovviamente passiamo age instance e poi alla fine c'è un parametro magico che considera tutto il resto che non rientrava negli undici parametri di prima e quindi qui si può usare non si usa mai quindi si passa nulla e con questi così in 4 e 4 8 abbiamo creato una finestra credo lo faccio no? poi quando useremo Windows Form vedete che questa cosa qui si fa con una singola chiamata con new form e hai fatto tutto è un po' più gradevole ora questo allora abbiamo la classe di finestra abbiamo appena fatto la classe di finestra abbiamo registrato abbiamo creato una finestra questo non significa che la finestra sia però visibile perché le finestre che abbiamo chiamato è che create uno stato che ancora non è visibile sono tutte invisibili in partenza per cui la prima cosa da fare è fare show window e che cosa? la finestra che abbiamo appena creato che è di age window e poi qui possiamo passare un intero che anche qui vi faccio vedere la la dei parametri se riesco a trovarla perché abbiamo vari interi che possiamo fornire a show window per dirgli come mostrare la finestra della finestra è questo common show e ci sono varie opzioni che abbiamo quindi c'è show normal, show minimized show maximized eccetera ve la faccio breve, si usa show normal che mostra la finestra così com'è potremmo anche fare show maximized che significa mostrala a tutto schermo ossia avverrebbe quello che avviene per Firefox qui quindi qui Firefox è massimizzato questo è show normal, questo è show minimized questo è show maximized ok, tre modalità della stessa ok, ora potremmo immaginare che tutto funziona in realtà non funzionerà però vedremo perché compiliamo ah, l'ho chiamato age window age finestra, scusate ok, quindi qui chiaramente il punto di vista è la finestra giusta no, la chiudo lo farò compiliamo la compilazione è andata a buon fine main nulla via anzi, è andato in crash sotto adesso avrete visto brevemente la classidretta il programma è andato in crash perché? perché ancora non abbiamo fatto tutto quello che si devia fare sembrava facile ma invece no ok, ora c'è due cose che mancano in realtà una cosa che manca fondamentalmente perché tutte le finestre in win32 qui si capisce quasi un po' in autonomia perché nessuna di queste funzioni qui che abbiamo chiamato tra cui register class e show window è bloccante sono tutte sono tutte chiamate cioè sono bloccanti però sono chiamate asincrone quindi in realtà non bloccano l'esecuzione del nostro programma quindi in realtà quello che avviene è che registriamo la classe creiamo la finestra mostriamo la finestra e poi subito dopo nanosecondi dopo ritorno in zero e l'applicazione il processo viene terminato quindi Windows tira giù il processo il processo è andato l'applicazione viene distrutta e tutte le finestre dell'applicazione quindi la finestra è esistita ma veramente per pochi millisecondi perché non c'è nessuno che abbia atteso che l'utente faccia qualcosa con la finestra ovviamente per cui da qualche parte bisogna metterci un'attesa adesso se vogliamo provare a fare le cose molto male possiamo fare anche una cosa del genere anzi vediamo se funziona mai provato in teoria adesso il main.exe è in esecuzione che posso immaginare vado anche ad accoparlo se no poi non riesco a a ricompilarlo e in esecuzione per la finestra non c'è traccia della finestra ovviamente e qui parte vedrete che però main.exe a meno che il compilatore non abbia ottimizzato via quel main ma io dico che sia autonomo abbiamo il nostro main.exe che sta allegramente eseguendo senza fare no in realtà non è ok quindi ha fatto errore e qui l'ha previnato in ogni caso non è questa la soluzione evidentemente però bisogna fare qualcosa di molto simile perché bisogna cosa bisogna fare bisogna processare gli eventi di sistema cioè bisogna processare quello che fa l'utente con la nostra con il nostro programma quindi bisogna in qualche modo reagire all'input dell'utente e fare in modo che l'utente possa gestire la finestra spostarla interoperare e così via come facciamo? allora con l'ultimo parametro che non avevo specificato quindi con questa LPFN che sarebbe la procedura di finestra che è fondamentalmente la cosa più importante che si può dare alla nostra finestra alla nostra classe di finestra è una funzione che gestisce tutti i messaggi che arrivano alla finestra quindi è la callback se avete fatto un termine moderno una funzione richiamata da Win32 ogni volta che il sistema deve dirci guarda il mouse è passato qui l'utente ha cliccato questo l'utente ha scritto il task l'utente ha boh ha fatto qualcosa e deve darci un'opzione di questo per cui andiamo a popolare anzi no ovviamente il programma è escloso perché avrà richiamato questa funzione qui era un puntatore a voi quindi non poteva funzionare va una speranza per cui che aspetto ha la nostra window proc allora ha un aspetto la definiamo qui la predefiniamo qui che possiamo poi dichiararla sotto questo è la dichiarazione della funzione un window proc anzi facciamo le cose che vediamo facciamo la mia procedura e facciamo direttamente senza fare tanti makeggi facciamo direttamente la funzione qui purtroppo vi devo far copiare anche questo che è molto brutto ma è così message un po' meglio ok allora questa è la funzione allora intanto il result è un tipo classico di win32 ed è un risultato lungo quindi è un intero che può racchiutere una serie di risultati è una callback quindi è una funzione che windows chiama cioè quindi venite chiamati voi cioè non siete voi che chiamate windows ma windows che chiama voi da fuori e ha quattro parametri uno è appunto alla finestra a cui cioè per cui quella funzione viene chiamata l'altro è il messaggio adesso poi vi dico che cosa è un messaggio e poi sono due misteriosi parametri uno è wide e l'altro è long anche questo è un altro oggetto preistorico di win16 all'epoca wide e long erano due cose diverse erano due interi diversi adesso in realtà sono entrambi interi quindi non ce ne prega niente sono due parametri perfettamente uguali quindi wide e long sono uguali quindi che cos'è questo oggetto questo oggetto viene ricamato ogni volta che win32 ci invia un messaggio e i messaggi sono il sistema con cui win32 comunica con i suoi componenti quindi è un sistema effettivamente a message passing come si dice quindi a passaggio di messaggio win32 ad ogni finestra in cui di quel composto in cui si interagisce passa dei messaggi e i messaggi sono veramente migliaia tutti diversi alcuni segnalano la finestra è stata creata uno segnala il mouse è stato cliccato uno segnala il mouse è stato spostato e così via ci sono messaggi per ogni tipo il messaggio è identificato dall'intero da questo intero qui quindi i messaggi sono identificati da una costante da un numeretto e poi ogni messaggio si porta dietro due di questi parametri sono due interi che possono essere usati per conferire dei valori alla finestra quindi in realtà la finestra riceve ogni volta che riceve un messaggio riceve tre informazioni uno è il tipo di messaggio e gli altri sono questi due parametri il cui valore cambierà in base al tipo di messaggio che c'è questo è il modo con cui Windows ci comunica le cose per cui questo è ora la mia procedura questa è la funzione che ho appena dichiarato la passo qui dentro quindi dico a Windows guarda questa è la funzione che devi richiamare è nulla di magico è un puntatore a funzione effettivamente giusto? per cui a questo punto tutte le istanze della classe la mia classe quando ricevono un messaggio vanno a chiamare la mia procedura che è questa funzione qui che vi ho detto ovviamente questa funzione deve ritornare qualcosa e di default può allora di default potrebbe fare return 0 però in realtà visto che molti messaggi non li gesteremo immaginate che qui i messaggi arrivano ne arriva veramente una valanga per cui poi vediamo in dettaglio quanti sono ma sono tanti per far gestire da Windows il messaggio per dire io ignoro questo messaggio fai tu c'è una funzione che si chiama def window proc window proc alla quale possiamo passare i messaggi che abbiamo ricevuto quindi se non ci interessa un messaggio noi semplicemente lo inoltriamo a questo def window proc che è una funzione di default di Windows 32 che gestisce cioè il modo comune per gestire i messaggi quindi la maggior parte delle finestre quando non vogliono gestire un messaggio semplicemente lo inoltrano a def window proc che poi non fa nulla ok ci siamo quasi ci siamo quasi ora ora Windows sa cosa chiamare Windows sa che deve chiamare la mia procedura la mia procedura sa cioè non fa nulla quindi stiamo stiamo ignorando i messaggi però l'importante è farlo perché se nessuno lo fa la finestra non funziona quindi però a questo punto va bene manca qualcosa che ci blocca qui quindi ci manca qui qualcosa di bloccante questo while true no che se scriveste bene per funzionare meglio questo while che fa in modo che i messaggi cioè che che l'esecuzione del programma si interrompe finché non è ora di chiudere questo quindi bisogna in qualche modo fermarsi lì che come come si fa allora si fa con una cosa molto simile al while true che dicevo prima ma un pochino più carino ed è quella che si chiama in gergo si chiama message pump quindi la la la la la pompa dei messaggi quindi è la la procedura che fa un ciclo infinito in sostanza che non fa altro che pompare i messaggi dalla coda d'arrivo e li manda alla procedura standard delle vostre finestre quindi è il meccanismo fondamentale che fa girare le finestre in un win 3x2 che cosa fa questo oggetto allora va a gestire un messaggio quindi di base definiamo messaggio perché ci serve una struttura data in cui accogliere il messaggio nel nostro programma sto andando troppo lungo mi chiedo scusa avrete più tempo che il caffè dopo ora faccio while non faccio while true perché a tutto punto il programma dovrà terminare no? sennò poi non termina mai e non va bene così quindi faccio while get message get message è la funzione win 3x2 per ottenere un messaggio dalla coda dei messaggi qui prendete per buono come scrivo perché poi ve lo spiego meglio puntatore msg che è l'oggetto che riceverà il messaggio per copia e poi una serie di misteriosi valori che prendete per buoni ok quindi questo non fa altro che finché ci sono messaggi in arrivo della coda questo while non terminerà mai ok quindi finché la coda dei messaggi è attiva prende un messaggio lo carica e poi fa dispatch message message sempre puntatore puntatore lo farò a message quindi cosa fa questo questo blocco di codice ottiene un messaggio dalla coda e ne fa il dispatch lo invia a chi deve gestirlo quindi lo invierà a chi alla mia procedura di di finestra qui perché non lo fai in autonomia perché in realtà questo blocco qui di codice potrebbe gestire messaggi per tante finestre quindi in realtà qui ancora non sappiamo a chi appartiene quel messaggio cioè dovremmo andare a scoprirlo veramente però dispatch message lo fa per noi dispatch message va a prendere il messaggio va a vedere che tipo di messaggio è a che finestra fa riferimento va a pescare la classe della finestra e poi in base alla classe della finestra va a pescare la window procedure e poi invoca la window procedure quindi fa una serie di operazioni che dobbiamo fare noi a mano per conto delle Win32 a questo punto se siamo fortunati ovviamente non lo saremo se compilo questa roba e la mando in esecuzione ottengo questa magica finestra miracolo ok quindi abbiamo una finestra e questa finestra finalmente compare perché? perché c'è una window procedure che gestisce messaggi quindi messaggi di creazione di istruzione messaggi di spostamento questi sono tutti i messaggi che arrivano che la finestra sta gestendo la finestra se non riuscisse a gestire i messaggi in tempo poi se si impuntasse se fosse un bug eccetera eccetera neanche lo spostamento della finestra riuscirebbe a funzionare questi qui sono tutti i messaggi che arrivano e che vengono gestiti dalla coda dei messaggi e passano attraverso questa questa message pump qui ok? quindi ogni singolo microscopico spostamento ma anche se tanto il passaggio del mouse questi sono migliaia di messaggi che arrivano perché ad ogni pixel spostato arriva un messaggio il mouse è qui perché la finestra deve poter reagire in qualche modo a questi eventi chiaramente quindi i messaggi sono veramente tanti e a questo punto però la finestra funziona però c'è un ultimo bug io chiudo chiudo l'eseguibile qui cioè chiudo la finestra chiudo la finestra la finestra si chiude ma il mio main.exe è ancora in esecuzione qui questo main.exe è rimasto la message pump è rimasta attiva quindi il mio programma è ancora bloccato qui dentro perché non ha colto il fatto che la finestra è stata chiusa bisogna farla a mano anche quindi adesso lo facciamo la prossima volta perché già vi ho tediato abbastanza con le Win32 però ecco sappiate che tutto va fatto a mano con le Win32 nulla è gratis perché è così bisogna fare tutto quanto per filo e per segno anche la chiusura della finestra va gestita quindi adesso il fatto che la finestra sia stata chiusa non è stata recepita dalla message pump ok e quindi qui il nostro programma è ancora fermo qui su get message che aspetta speranzoso che arrivi un messaggio ma non arriverà mai nessun messaggio perché non c'è nessuna finestra che possa generare messaggi ok i messaggi sono sempre collegati a una finestra se non c'è nulla sullo schermo nulla cioè nulla della nostra applicazione chiaramente nulla può generare messaggi che poi vengono interpretati adesso qui siamo bloccati qui e l'unico modo per terminare l'applicazione è ucciderla ok si get message è dato supporto al time out quindi in realtà se andremo a vedere si potrebbe essere un'idea adesso però in fronte a noi get message c'è modo per dire get message guarda se non arriva niente per tot tempo lascia perdere cosa si può fare mi sembra di ricordare almeno c'è modo di farlo no quindi c'è modo di fare questa cosa qui ma in generale per gestire la chiusura no non è vero non è vero non si può fare no è bloccante anche se sono abbastanza convinto che ci siano altre c'è peak message che permette di guardare un messaggio e rimanere in attesa breve ci sono vari altri oppure c'è anche wait message comunque si può fare quello che dice lei se volendo potrebbe rimanere in attesa per un secondo dici secondi quello che ritiene accettabile e semmai può andare in errore però in realtà quello che si fa veramente è semplicemente rimanere in ascolto del fatto che la finestra sia stata chiusa quindi quando la finestra è chiusa a quel punto in maniera normale perché l'applicazione termina posso uscire in maniera tranquilla da get message ritornare dal while e fare ritornare quindi in genere si fa si fa questo perché noi sappiamo che quando la finestra viene chiusa l'utente ha finito di interagire il nostro programma quindi di solito è questo si avvia il programma il processo crea tutte le classi le finestre cioè poi va nella message pump rimane nella message pump finché deve gestire eventi quando gli eventi non sono più importanti perché le finestre sono state chiuse a quel punto termina il processo e il neesugibile va a casa viene terminato questa è l'idea manca questo ultimo pezzo ma adesso di dobbiamo migrare di là per cui interrompiamo e poi lo vediamo la prossima grazie a tutti