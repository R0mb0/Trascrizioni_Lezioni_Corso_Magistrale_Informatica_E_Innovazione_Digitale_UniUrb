Perfetto, allora come attenzionavo ai colleghi, in presenza c'è stato un piccolo problema tecnico per cui volevo cominciare a parlare di Flutter, però non ci sarà l'occasione oggi perché non riesco tecnicamente, però questo significa soltanto che ne parleremo di una settimana a questo punto, l'inizio di Flutter, perché anche domani, domani da adesso che salterà, quindi te lo preannuncio poi anche su Blended perché non riuscirò a formalizzarmi per tempo, per cui ne parliamo giovedì prossimo, più compiutamente di Flutter. Però c'è questo problema, questo tipo, in topo tecnico, che vi darò l'occasione di riparlare di quelli che sono gli elementi di interfaccia grafica o di interfaccia utente in generale. Alcune cose che ho già visto, per cui in realtà è un rivedere alcuni elementi già noti, però gli arriviamo più in generale, più in dettaglio, così poi tutte le nozioni di base che vi servono per capire a fondo come sono fatte l'interfaccia utente per quanto riguarda le Viettelta2, che è il punto di partenza, cioè il punto di vista che prenderemo iniziando questa carrellata e poi arriveremo ai vari paradigmi di programmazione di interfaccia utente, di nuovo partendo da Viettelta2 e arrivando a Flutter, quindi la speranza che le cose si combinino bene, adesso potremo dare un'idea generale di quello che andremo a vedere e l'anno prossimo inizieremo veramente a lavorare, a mettere le nozioni in pasta con Flutter e a lavorarci. Per cui ricomincio proprio dall'inizio, abbiamo visto questi elementi fondamentalmente lavorando con le Viettelta2, abbiamo visto che l'interfaccia utente nel mondo Windows e in realtà tutto il mondo che si appoggia a quelli che abbiamo definito i paradigmi Windows, Icons, Menu, Pointer, in questa categoria di interfaccia utente, alla fine dei conti vivono principalmente delle finestre sovrapponibili che l'utente può manipolare, tant'è che appunto la W di YouTube è proprio la stata di finestra e in Windows e finestra hanno questa forma qui, come ovviamente sapete, e quello che abbiamo fatto finora in laboratorio, lavorando con l'Internet2 e 32, è creare delle finestre così dette overlap, delle finestre sovrapponibili che sono le classiche finestre di primo rango, diciamo così, nel mondo Windows. Ciò non toglie che ci sono anche altre categorie di finestre sulla carta, alcune le avevo viste, sono i dialoghi, i messaggi di dialogo, quindi il classico ok, il dialogo di conferma, il dialogo di ok a nulla e così via, li abbiamo creati, li abbiamo utilizzati usando la funzione message box in W di 32, quindi quella è una tecnologia di finestra e oltre a questo c'è la finestra di finestra che abbiamo visto, ma che esiste, che è la finestra degli strumenti, la cosa chiamata tour, quindi, che si differenziava tanto poco in realtà dalla finestra primaria, però ha un aspetto grafico un po' diverso, quindi ha una barra più piccola, non ha l'icona, ha soltanto la X per la chiusura, non ha tante varie strumenti per la manipolazione della finestra e in genere serve per avere delle tavolozze d'appoggio, delle finestre d'appoggio che contengono strumenti accessori rispetto alla finestra principale. Se la nostra interfaccia è composta dalla finestra principale e poi una tour window con gli strumenti aggiuntivi, quello che si fa è creare due finestre nelle W di 32, la prima ha lo stile overlap, che abbiamo visto, e la seconda ha lo stile un window, che è un altro, è semplicemente un flag, è un valore che passiamo agli stili della finestra quando andiamo a creare la classe della finestra, sempre parlando di WFB. Questo è quello che ho visto, quindi chiaramente quando ragioniamo nelle coordinate dello schermo, Windows prevede che le coordinate avranno inizi, l'origine delle coordinate degli schermi, in alto a sinistra nell'angolo dello schermo primario, che è molto vicino al sistema, ogni finestra si porta quindi nel termine di questo fatto di coordinate, quindi questa finestra di type of bar per titolo avrà una coordinata, diciamo, 150-100, perché a occhio e croce, nello spazio dello schermo e poi interna, non fa lus delle coordinate generali dello schermo, ma fa lus delle coordinate locali della propria finestra, per cui quando si ragiona in coordinate locali della finestra, si ragiona in termini di coordinate della cosiddetta area client della nostra finestra. La client area è la zona in cui voi governate in qualche modo quello che vi viene messo a schermo, e quindi potete disegnarci sopra e potete interagire chiaramente con mouse, tastiera e per titolo. Questo l'ho accennato le volte scorse, non l'ho fatto ad esempio grafici, adesso è l'occasione per farlo. In genere, quando creiamo una finestra overlap, quello che accade è che noi deleghiamo a Windows, in questo caso il compito di occuparsi di alcuni componenti della finestra, che noi vogliamo presentare a sé. Per esempio, la cosiddetta che ha in barra, la cosiddetta barra, la cosiddetta barra dove si afferra la finestra, l'icona, le icone per i pulsanti per governare la postura finestra, e gli angoli per il dimensionamento sono elementi non client, quindi non fanno parte della client area, sono parte della non client area della finestra, e quindi si occupa Windows e quindi non bisogna ristirlo. Tra l'altro abbiamo visto nell'ultimo esempio, fatto la volta scorsa, la settimana scorsa, che in realtà intercettando uno dei messaggi, di un'interazione dove possiamo far comportare altre parti dello sistema come se fossero parti della non client area, se vogliamo. Questo viene ancora più lungo al massimo esempio di questo comportamento che tra e quando una finestra invece decide di renderizzare interamente i suoi contenuti occupandosi sia dell'area client sia dell'area non client, che in questo caso si chiamano client only Windows, in gergo, perché sono interamente composti dalla client area, perché non c'è una zona in cui si occupa Windows in particolare, l'applicazione deve occuparsi di presentare a schermo tutte le sue componenti. Per cui un classico esempio è il vecchissimo lettore multimediale Winan, che è andato per la maggiore degli anni 2000 più o meno, e adesso è abbastanza caduto in discusso, anche se si è finita ancora, questa finestra appunto è interamente disegnata in maniera autonoma, per cui non ci sono elementi grafici di Windows. Sessa cosa viene per Spotify, per esempio, ma un altro esempio che abbiamo fatto l'altra scorsa era Visual Studio Code, che in realtà è un'interfaccia grafica tutta complessa, statisticata in cui per esempio la barra del titolo riprende lo stile di Windows, ma poi ha dei comportamenti molto diversi, perché ha la barra di ricerca e così via. e quindi la stessa cosa va anche per Spotify in questo caso. Ok, allora, entrando in dettaglio, qui abbiamo visto come funziona per domare, cioè come è struttura della interfaccia di base, quindi la zona non client e la zona client. Dando per questo dato che la zona client non è visto come funziona, quindi in sostanza è uno spazio bianco, in un'altra parte delle case in cui il programmatore può disegnare, è bianco perché in genere quando si crea l'interfaccia a zero si usa il background brush messo a white, però è chiaro che può assumere qualsiasi colorazione, qualsiasi effetto grafico, perché siamo noi a occuparci di presentare a schermo qualcosa che adesso. Quindi siamo noi a gestire il famoso messaggio paint che ci invita a presentare a schermo qualcosa. Qui adesso vediamo le funzioni di base non clienti, che ci sono le feature che ci offrono Windows nella zona della finestra nostra, ma di cui comunque non ci occupiamo direttamente. Per cui il primo elemento, già visto, è il capture time, che si è detto che è il titolo della finestra, che è presentato nella barra in alto. I capture buttons, di nuovo questi qui sono tutti opzionali, ecco la X che c'è sempre, ma la massima di funzione e la minimizzazione della finestra sono opzionali e se ricordate c'erano dei flag quando andiamo a creare la classe, della nostra finestra con cui potevamo attivare o disattivare i funzanti, quindi è ragionevole avere delle finestre che non hanno, per esempio, i funzanti di massimizzazione, perché nel nostro caso magari non ha senso averla. E tra l'altro, io qui adesso parlo di Windows, chiaramente però queste stesse cose vanno anche per me queste e gli altri. Quindi tutto sommato i concetti sono esattamente gli stessi, cambia un po', cambia la rometratura ovviamente, i nomi delle cose cambiano, ma i concetti sono esattamente. Hai due cose che cambiano veramente, questo è giusto per dirvi, i Mac OS, i Carson Buffbonds, i pulsanti di sistema, sono simili, hanno l'andamento inverso, quindi la X è più a sinistra, quindi il pulsante rosso, e il comportamento è livemente diverso, nel senso che il pulsante rosso chiude la finestra e, quindi già lo minimizza, quindi lo nasconde la finestra nel cosiddetto dock, che è il prospettivo della tasta di Windows, mentre il pulsante verde non mette a pieno schermo, a differenza di quello che viene con la massimizzazione di Windows, ma cerca di allargare la finestra per fare entrare tutti i suoi contenuti, quindi lo fa una massimizzazione, ma cerca di adattarla a suoi contenuti in modo da che i contenuti siano comodi. spesso questo coincide con la massimizzazione, ma non necessariamente, quindi questo è un comportamento diverso sul mercOS, quindi spesso clicca sulla puntata verde, uno si spetta che la finestra viene da tutto un servo, ma questo non avviene. L'icona, di cui abbiamo già parlato, questa, ricordate, l'icona si imposta con la classe della finestra, poi rimane l'icona per tutte le finestre di quella classe, e poi abbiamo i menu, diciamo così, contestuali della finestra. Questo menu qui compare, se spiegate una volta, sul l'icona della vostra finestra, e compare questo aggiuntivo che vi permette di manipolare di nuova. Trovate alcune delle opzioni classiche, invece l'icona, l'immigrazione, che grandisce la massimizzazione, perché lezione e le risposta sono delle funzioni accessorie che vi permettono di manipolare la finestra senza avere accesso al mouse. Questo non sembra una cosa veramente banale, ma per chi utilizza Windows senza mouse, c'è un supporto alla sera molto pervasivo per Windows, tant'è che si può fare quasi tutto senza doveri specialmente muovere il cursore, tant'è che se volete, adesso no Windows, sono storicamente, però se usate le scosse di dimensione, vedete che potete rimensionare e spostare la finestra, specialmente con la tastiera, che in alcuni scenari può essere comodo o può essere utile per appunto chi ha bisogno di accessibilità aggiuntiva per usare il PC. Poi c'è chiudi, chiaramente, e questo chiudi corrisponde allo shortcut Alt-H4, che forse è utilizzato per il shortcut che chiude la finestra, tutti che si comandano in particolare, perché questo è un mantra molto classico dei Windows, quando alcune funzioni vengono state in vari modi diversi, ma hanno la stessa efficacia, da solo stesso effetto, alla fine significa che inviano lo stesso comando, lo stesso messaggio, per cui sia un doppio pericchio di cona, che vi va da chiudi, clic qui, a partire del reno, qui vi va da chiudi, Alt-H4 vi va da chiudi e in finali adesso in finali, quattro modi standard per chiudi la finestra, in più ci sono i modi per chiudi la finestra dalla taskbar, quindi se nella taskbar chiudi la finestra col tasto destro o fatto operazioni simili, ha un tempo del stesso scopo, che cosa accade? La finestra viene distrutta e viene raggiunta dal messaggio window message destroy, di base, quindi il comportamento al lato posto è completamente uguale, però ci sono vari modi per generare lo stesso effetto. se la vostra finestra ha un menu, questo è opzionale, può esserci, il menu, anche in cui, fa parte della zona non client. E qui accade una cosa particolare, voi, se la vostra finestra ha un menu, la zona client si riduce per far spazio al menu, perché è questo comportamento che appunto non avere un menu ha un impatto sulla finestra senza finestra che non potete controllare, perché veramente in base alla pressione di Windows e alla varia di programma e quant'altro, quanto sono grandi i scopoenti non-try, voi non potete sapere, perché di base questo fatto fatto su Windows 8 o 2 o 2 di extension, quindi aveva dei valori di dimensioni che hanno standard per quella versione di Windows, sul Windows 12 si può immaginare che le altezze, le dimensioni della zona non client sono cambiate, chiaramente è il cambio del silografico del sistema e quindi non dovete mai fidare di una delle dimensioni o delle dimensioni dovete mai immaginare che le dimensioni siano fisse e che non lo saranno mai, basso alla versione che avete e al sistema che viene aggiornato, la zona non client può cambiare sia nelle dimensioni sia nell'aspetto grafico, quindi in genere è sempre buona norma non andare a toccare la zona non client perché se no è tutto il sistema. Questo è il menu, anche qui come vi ho detto in un rigolo, il menu è effettivamente è una finestra, adesso traspare poco però è una finestra che si sovrappone alla finestra principale, perché in realtà l'effetto grafico è quello della l'inventa che viene aperta ma in realtà è l'intenzione se ci parlate bene, il menu è una finestra con un'oppergiatura che si sovrappone alla vostra finestra principale, viene visitata l'intervento dal sistema dove lo occupate e anche questa genera dei comandi, quindi invia dei messaggi tipo command, quindi quindi message command alla vostra finestra che poi dovrà distribirli in qualche modo. E come vi dicevo l'altra volta, il link qui equivale alla combinazione di tasti che ugualmente invia un messaggio con noi. Altra cosa, questo viene assolutamente non è riuscito a farlo anche vedere, questa volta il prodotto che si definisce parla per la questione di tempo, però se attivate le rispondate nelle varie rispondimenti, la cosa un po' strana è che le varie rispondimenti occupano la zona non clare per la vostra finestra, quindi nuovo è l'elemento che si può appuntare, chiedere, in realtà mi servono le scrollbar dentro questa finestra, perché se scrollbar combagliano internamente alla zona cioè l'apparenza è scopata per la zona clare della vostra finestra, però in realtà tagliano la vostra taglia sia per il user che per il dono perché in questi servizi per quello che sono tagliato la zona clare che appunto ha meno spazio per disegnarsi e la scopata si occupa interamente di nuovo quando la scrollbar viene manipolata quando il tente di un caso di un'altra lecce scopata l'oggettino per sforzarti da un patio che cosa avviene? Alla volta che la principale che controlla la scopata arrivano i messaggi di scorrimento di base e voi dovete reagire per presentare questa cosa. Gli anni scorsi ero riuscito a fare nel senso in cui andavo a leggere la lista di messaggi arrivati alla nostra finestra era riuscito a leggere la domanda per assorbere la lista dei messaggi che è una cosa che si potrebbe se ho il tempo di carico almeno ad esempio su Blender se non siete curiosi come funziona. Come fa Windows a capire quali parti della finestra sono parti del client e parti della zona non client? Allora di base lo fa cioè chiaramente Windows sa quali sono le parti client e client ci pensa a lui a distinguere le due zone in cui sarebbe ragionevole immaginare che sappia cosa sta facendo però in realtà Windows se lo chiede da solo cioè quello che avviene è che invia dei messaggi che avevo già chiesto da sotto di test di non try di test questi messaggi continui ogni volta che si sposta al mouse sulla finestra e va a chiedere alla finestra mi puoi dire scusa dove mi trovo in questo momento sulla finestra e la finestra risponde con una serie di parole che dicono adesso sei sulla zona client adesso sei sul titolo adesso sei sulla pulsante di chiusura e così via in questa maniera è possibile fare degli effetti un po' avanzati andando a ridefinire quelle zone come non sono oppure che ne so estendendo la zona non client dentro la zona client per esempio e fare altri effetti in questo momento però di base se voi delegate della la la procedura di finestra standard di windows se ne occupa windows quindi decide in maniera autonoma dove inizia la parte client e dove inizia la parte non try ok questo appunto è tutto avviene tramite le guida di messaggi di base se voi nella vostra procedura di gestione dei messaggi delegate alla famosa default window procedure quindi mandate il messaggio a windows perché se ne occupa in sostanza state delegando nessun di questo messaggio al sistema perché chiaramente poi il sistema decide dove inizia la client se volete potete intercettarlo e fare quello che è proprio chiaramente vi assumete poi i rischi del fatto che le cose possono funzionare in maniera un po' un po' inusuale chiaramente ok il menu vi ho già visti recentemente vengono creati durante la creazione della prima di sono agganciati alla finestra come dicevo prima poi generano questi messaggi di comando immagine esatto questo è quanto e questo può fare un raffronto tra i sistemi avviene anche su macOS e la differenza fondamentale è che il menu non appartiene alla finestra questo avrete fatto a caso di un comportamento diverso tra i due sistemi il menu in windows è agganiciato alla finestra in cui è indissorbilmente regalata la finestra stessa il menu è sempre in alto quindi la barra del menu in alto è fissa lì però appartiene alla finestra attiva quindi cambia di volta in volta quando cambiate l'applicazione attiva che adesso qua porto il focus zoom vedete che la barra è in alto non è vero perché l'ha cambiato sull'altra finestra ok questo ha senso perché sono finestre separate si sposta la finestra di qua la barra in alto che prima era di Safari viene presa nel piano di controllo la finestra quindi sono comportamenti un po' diversi però non cambia fondamentalmente l'idea per cui ad ogni finestra corrisponde dove viene mostrata non cambia radicalmente la questione questo è legato appunto al concetto di focus prima l'avete visto è cambiando il focus cambiando la finestra attiva cambiava qualcosa di fondamentale come una barra per più del sistema operativo e perché appunto gestire il focus è uno dei tanti punti importanti che fa in questa partenza questo perché il sistema deve capire a chi inviare i messaggi solitamente quando c'è una finestra attiva che sta dialogando lavorando questa viene messa in risalto e quindi si distingue da tutte le altre quindi appare colorata in più piano e quant'altro mentre le altre hanno uno stacco più sdiavito proprio per far capire che la finestra attiva è quella e quindi in quell'istante tutto il input dell'utente viene consegnato a quella convogliata quello avviene quando è selezionato un campo verso dentro una finestra la finestra madre prende il controllo che detiene il focus diventa attiva e diventare attiva che significa essere in risalto aerografico e soprattutto essere la finestra più in cima nella pila delle finestre quindi quando immaginate di avere le varie finestre più elaborate la finestra attiva è sempre quella che è più vicina all'utente quindi è quella più visibile che sovrasza con altre altre quella finestra lì ha il colletto focus quindi c'è una finestra per volta che ha questo focus del separativo e significa che appunto tutti gli input che potete impartire con la tastiera vengono notrati alla finestra e basta nessun'altra finestra può avere il focus al tempo stesso e quindi quando scrivete su blocco note che è in primo piano il input della tastiera che sono utilizzato in due istanze non viene consegnato alle altre finestre che sono invece il secondo di attiva questo per la tastiera è abbastanza effettivo però vale la pena pensarci secondo come viene gestito quindi è banale però va apprezzato quello che è per quanto riguarda invece l'input del mouse il mouse si comporta in maniera un po' diversa perché viene consegnata non soltanto la finestra attiva ma tutte le finestre che sono visibili proprio quando il mouse passa sulle finestre lo spostamento del mouse viene comunque segnalato a tutte le finestre per cui le finestre possono reagire allo spostamento del mouse anche se non sono più più più più più questo non era sempre così tra l'altro è vero nelle ultime versioni di Sessantra di Sessantra come parliamo perché nelle versioni più vecchie quindi che avevano meno risorse con cui elaborare l'input questo non era in niente così in le vecchie versioni l'input del mouse anche arrivava soltanto la finestra attiva in quella della staglia voi ricevete i messaggi del mouse per tutto il mouse in tutti i messaggi per tutta la zona della vostra finestra quindi quello che si chiama in genere il window la cornice della finestra sia la zona non client in detection i pulsanti così via sia quella della zona client quindi quindi Windows non si non si per due aree per quanto riguarda l'input del mouse potrete gestire tutte le zone del mouse appena si entra nel rettangolo coperto dalla vostra finestra qui ci sono un paio di esempi di messaggi che possono arrivare in realtà ci sono molti altri che abbiamo già visto che dice activate che vi segnala la presa coscienza l'attivazione quindi in realtà lo spostamento della finestra è il primo piano l'attivazione in gergo su Windows è lo spostamento della finestra la presa del focus in sostanza e poi sono anche set focus che è il messaggio con cui imponiamo la finestra di prendere il focus che è una cosa che si può fare cioè possiamo costringere la finestra ad attivarsi e ottenere il focus questo è utile in alcuni casi quando vogliamo per esempio postare la presenza dell'utente a una finestra che non è la nostra o più comunemente se vogliamo per esempio se abbiamo vari campi di testo che può compilare in alcuni casi può essere utile spostare il focus a un campo al prossimo quando l'utente ha fatto il nome si passa al cognome in un windows si fa con il set focus quindi si manda un messaggio alle varie finestre dicendo puoi prendere il focus e la finestra ottiene l'input della tastiera nel caso di un windows in particolare l'input della tastiera viene segnalato la presenza del carrot la stanchetta l'antaggiante che segnala dove arriva l'input della tastiera in altri sistemi e la presenza del focus in tastiera è segnalato in altre maniere insomma ecco S il campo di testo in genere ha un bagliore bluastro e insomma i modi che segnalano la stessa in genere è una cosa abbastanza innocua come effetto grafico però aiutano senza capire dove sta la difficoltà cosa che non è banalissima ovviamente ci sono direi c'è fine anche a questo nel senso che vi dicevo prima che il mouse vi arrivano gli input quando il mouse passa sulla vostra finestra quindi quando passa su wheel of frame questo non è sempre vero perché è possibile fare la cosiddetta mouse capture quindi l'applicazione la finestra può prendere il controllo del mouse anche al di fuori dalla sua data frame anche al di fuori della sua zona di controllo per dire e a quel punto si ricevono i messaggi di spostamento di interazione e così via per tutta la finestra quindi per tutta l'area gestita dal sistema a che stanno questa cosa si usa per per applicazioni di accessibilità quindi si deve programmare un'applicazione che aiuta il vento a interagire con il sistema perché magari ha bisogno di aiuto semplificare l'accesso al mouse in quel caso dovete capire cosa sta avvenendo su tutto lo schermo sull'automobile sulla vostra applicazione oppure per esempio per gestire il trascinamento degli oggetti il drag and drop tra le poette in quel caso cosa viene quando trascinavano gli oggetti una finestra all'altra all'interno da venire c'è una mouse capture e nel gestire il trasferimento di un oggetto all'altra finestra in genere la finestra che emette l'oggetto trascinato cattura il mouse che si scelta l'oggetto che è sforzato fuori dalla finestra per avere modo di consegnare l'oggetto sulla finestra dal vivo in quel caso bisogna per tracciare lo spostamento al cavolo dal vivo altrimenti appena si va oltre la barra di grandimento della finestra non si ricevono più i messaggi del giornale altra cosa alcune finestre cioè alcuni sito possono bloccare l'arrivo dei messaggi di spostamento quindi per esempio quando compaiono dei dialoghi quindi delle finestre di dialogo modali modali si intende il gergo che sono bloccanti quindi dei dialoghi che sono bloccanti quindi quindi il mutato non può scavalcare non può cliccare sotto la finestra di dialogo in quel caso quando sono presenti queste finestre l'input per la finestra sottostante è chiaramente bloccato quindi a quel punto la finestra non riceve gli elementi perché tanto non riuscire che abbiamo lavorato in questo caso abbiamo visto anche questo laboratorio che ovviamente se ricordate avevamo aperto un message box in relazione che do agli utenti dell'utente in quel momento quando la message box è aperta la message box è una chiamata bloccante una chiamata connessione bloccante per cui non c'è modo per la finestra di continuare a processare i suoi messaggi quindi la message found si blocca perché non c'è modo di lasciarla correre ancora finché quella finestra le diagola rimane aperta ok il cursore il cursore allora il momento che il carrot l'indicatore di tastiera è quello che lampeggia il cursore è il punto del mouse quindi è la prestazione la articolazione dell'attenzione dell'utente in termini di spostamento del mouse ok e appunto io ho già visto che la forma che ha un cursore su una finestra dipende da qual è il cursore attivo per la classe della finestra se più si passa ok è una frase che ha tenso sì quando creiamo una finestra prima di creiamo una classe di quella finestra e nel farm dobbiamo specificare qual è il cursore per quella classe di finestra in genere è la cosetta freccia però non deve essere un dinosseramento possiamo tranquillamente definire una classe diversa certo da una cursore diversa per alcune classi di finestra perché sono a senso e a quel punto il mouse cambierà aspetto passato questo è il giusto letteralmente dal sistema quindi non bisogna fare nulla di attivico per fare queste cose ma è possibile sovrascrivere il cursore attivo di una classe di finestra questo si fa con un messaggio che è messaggio tutto con un messaggio sempre quello si dia un messaggio step first alla finestra di cui si vuole cambiare il puntatore una volta con questo si manda insieme al messaggio un riferimento al tipo di cursore che si vuole utilizzare e da un momento di poi quando un utente passa su quella finestra per ricordo quel messaggio comparirà un cursore che è legato alla finestra su cui si passa e questo significa anche che in genere ci sono vari cursori che Windows propone di default il più classico ovviamente sono la freccia la mano che abbiamo visto la volta scorsa provando a fare il tris se vi guardate poi ci sono le varie freccine di dimensionamento sulla finestra che sono quelle che vediamo più frequente però in realtà storicamente esistono anche cose più tessi di cursore di attesa di sono occupato in qualche modo che sono il sistema più vecchio che ha i vari stambi per segnalare che il sistema sta facendo qualcosa e non è pronto per reagire questi sono sempre meno popolari sono sempre di meno infatti forse si vedono anche nel uso pratico in genere che si scontrano chiaramente perché adesso si preferiscono altri sistemi per traccia del caricamento di attese e part'altro si crede di non segnalare ma storicamente questa cosa esiste e si può tuttora usare quindi in particolare se volessimo segnalare all'utente che la nostra finestra sta facendo qualcosa di importante e lui può reagire rapidamente ai click per l'utente si può impostare il pulsore della nostra finestra tutta la nostra finestra che sta lavorando impostando il pulsore per esempio il 5A che corrisponde a una sfera per i cerchi è tuttavia luminoso che in realtà è la versione moderna della vista e poi non so se poi in Windows non è cambiata però storicamente era la quest'interacchie di Windows 6.11 che era la strada che girava e mentre per me questo c'è quello che si chiama beachboard la spiaggia come viene chiamata l'effetto è lo stesso quindi l'effetto è un cursore che indica una data che non può identificare perché sto facendo la roba questo punto si può fare lo stesso quindi si può fare tuttora quindi basta impostare il cursore per la finestra che sta lavorando e a quel punto comprerà uno di quei cursori lì però non si è utilizzato perché diciamo storicamente in un ambiente non in cui fare operazioni in background non era tanto facile da fare quindi era più complesso fare operazioni a lungo tempo e al tempo stesso mantenere l'interfaccia utente responsiva e quindi classicamente quello che si faceva dentro il vostro messaggio di gestione del click il vostro L button app in relazione a quel messaggio lì potremmo iniziare a fare un'operazione molto lunga che richiede in media un paio di secondi per segnalare in quell'istante non posso fare altro perché sto già gestendo questo messaggio qui potrò impostare il cursore fare qualcosa in maniera sincrona in maniera bloccante ok e poi appena fatto rimpostare il cursore alla freccia standard ok nel fare questo se questo codice qui lo immaginate dentro la window procedure quindi dentro la procedura di gestione dei messaggi è chiaro che intanto qui esegge questo metodo che richiede un paio di secondi la finestra non può gestire il messaggio in arrivo se c'è un appostamento di mouse un click aggiuntivo e così via non può gestirlo e quindi il potente rimane frustrato perché la finestra non può neanche essere spostata chiaramente perché non reagisce ai comandi di spostamento e qui si usa anche il cursore adesso nel mondo moderno e magico e figuristico in cui viviamo adesso fare un background è molto più semplice perché hanno linguaggi che fanno questa cosa con una semplicità imbarazzante cosa con le 22 con C non era il caso per cui classicamente si fa così ad esempio in realtà gli indicatori di attesa non saranno più perché l'interfaccia dell'entr è sempre responsiva e al più si può mettere un cerchio di caricamento dentro l'interfaccia che mostra il fatto che sta apparendo qualcosa però l'interfaccia in sé rimane restissiva quindi l'utente che è gestito la finanza di gestita e così via e quei di quel cursore hanno un po' perso la ragione di esistere perché appunto l'interfaccia dell'entr non potrebbe essere mai non responsiva perché veramente è un'esperienza tende completamente non più accettabile nel 2023 in genere ok quindi l'idea è proprio questa qui è puramente singolo usiamo quegli scamotage lì il cambio cursore e poi il cambio di nuovo che ne ha fatto però chiaramente dà il costo di avere l'interfaccia che qui è effettivamente volata ok questo era giusto un ricatto di quello che ho già visto che un po' fosse intuito la parte del cursore e quant'altro vediamo brevemente controlli standard dentro di un osservativo perché anche quelli li abbiamo visti brevemente lavorando con il pulsante dell'interf2 adesso vi do una carrellata di controlli standard che in genere possiamo aspettarci mettendo per tenti sullo stesso sistema operativo allora controlli standard intendiamo una serie di finestre oggetti controlli elementi di interfaccia dente in generale che sono nativi della rataforma cioè la persona stessa che ve li offre in qualche modo e utilizzarli permette di agganciarvi a chiunissia rendendo il tuo M-S-T-E la parte di apparenza e la parte di comportamento del sistema operativo in modo tale che la vostra applicazione si imbriga un membro a tutti gli effetti di design per cui l'importante l'idea di fondo è che se usiamo una vita di la di la nostra applicazione il nostro programma sembrerà coerente a livello di comportamento semantica delle operazioni di quello che accade se sentiamo e così tutto poi chiaramente tutte queste cose per Flutter per Android per IOS e così via ma poi ci limitiamo al mondo di Windows che è quello da cui proveniamo di laboratorio in Windows questi controlli standard vivono dentro una libreria a parte che è questo comctl 32 che è questa libreria che è in versione di Windows contiene appunto i common controls 32 sta per win32 quindi è edizione a 32 bit di questi controlli potete chiaramente immaginare che ci fosse un comctl .exe nelle vecchie versioni di Windows che conteneva veramente i vecchi pulsanti di Windows 1,2,3,1 11 e 12 questi controlli cambiano di edizione edizione per poi piano piano vengono cioè hanno un'evoluzione tutta loro anche se abbastanza lenta in genere e come ho detto qui l'ultimo grande passo in avanti dei controlli si è avuto con vista che ha introdotto una serie di controlli aggiuntivi che prima non esistevano proprio anche livello proprio grafico e di comportamento come abbiamo già visto se la vostra applicazione non contiene riferimenti particolari alle edizione di Windows che conosce e con cui è compatibile in genere la vostra applicazione quando poi parla con il strato l'applico e chiede di fare il controllo standard ottiene il controllo standard di Windows 3.11 o di Windows 95 ed è quello che è successo a noi usando il pulsante che nella sua prima versione aveva l'aspetto grigetto in rilievo e il phone standard di Windows 3.11 proprio perché in sostanza stiamo parlando con il Common Control 5.2 della versione di 30.9 se la nostra applicazione si dichiara pronta e compatibile con le versioni più nuove quello sarebbe parleremo con dedizione moderna del Common Control della versione di Windows per cui siamo stati compilati preparati quindi questo è semplicemente collegando l'applicazione con versioni diverse di questa DL praticamente magico però potete immaginare che ogni versione di Windows si porta dietro una serie una palestra di Common Control se poi può agganciare cosa giusta alle varie applicazioni che stanno in esercizionale i controlli si compostano come delle finestre figlie quindi le decriamo esattamente come abbiamo fatto le finestre figlie per gestire la X il cerchietto nel caso di un tris e lo abbiamo fatto per il pulsante si creano facendo una chiamata a C e passando come classe di finestra un testo predefinito che sappiamo essere predefinito dalla documentazione e quindi in genere è tutto meglio scoletto per la coerenza interna dei nomi e ad ogni controllo standard quindi ad ogni classe di finestra standard per Windows di data di posizione ci sono una serie di stili specifici che possiamo passare allo stile della finestra quando la andiamo a creare e una serie di messaggi specifici che sono i messaggi che la finestra piglia cioè il controllo può emittere come per segnalarvi cose o che può ricevere per reagire ai vostri domani quindi ogni controllo si comporta in maniera un po' diversa perché chiaramente voi è una cosa che è instanziato il controllo indicando la classe che vi serve e quindi a quel punto siete voti per usarne i stili e ricevere dei messaggi nella maniera più appropriata quindi c'è l'esempio vediamo che in base ogni terapia che la vita avrà lo stile child quindi sarà visibile perché vediamo che si era sul tempo e poi in questo caso c'è uno sfide speciale del controllo static che vediamo tra un secondo quindi c'è static sign che può intuire quello che andrà a determinare e poi cambiando controllo cambiando stile cambieranno anche cambiando solo i class cambiando i stili supportati dalla stile ok lo static è il controllo più passidare che si possa immaginare è uno spazio vuoto che presenta il testo quindi è proprio il controllo più banale che si possa immaginare e può mostrare del testo di lunghezza basata pedraria un'icona un'immagine o una combinazione di questi tre quattori quindi può mostrare un'icona un testo un'immagine un testo un testo da solo nella maggior parte dei casi si deve mostrare soltanto testo quindi lo static control serve per mostrare del testo su schermo a che serve una cosa così primitiva serve perché in realtà abbiamo visto la volta scorsa lavorando che presentare del testo a schermo non è complesso però non è neanche così banale in realtà bisogna fare delle operazioni di calco del rettangolo del testo andare a paginarlo se serve paginarlo presentarlo bene calcolare il diario cambiare il testo così via e poi finalmente renderizzarlo quando Windows invia il messaggio a pain quindi c'è un po' di operazioni da fare veramente per presentare del testo e quindi raramente uno lo fa a mappa cioè raramente poi inventerete una minestra che poi reagisce a pain presentando il testo a schermo più frequentemente in realtà direte ok questa zona è sempre il testo allora ci metto un controllo static che non fa altro che presentare il testo per conto quindi è una finestra è una finestrella figlia che si occupa di questa finestra il testo che presenta è il testo della finestra quindi è esattamente si passa il testo sempre come secondo parametro alla fine quindi è il testo che se creare sempre la finestra overlap di un po' livello è il testo che comparirebbe come titolo della finestra nel caso della serie del controllo quel test è il testo come contenuto della finestra ok quindi ad ogni finestra il windows corrisponde sempre un testo esenzialmente anche se poi il testo viene presentato se c'è il testo la finestra può decidere come presentarlo le finestre madri presentano nel titolo le finestre figli tipo static presentano come contenuto della finestra il testo può essere cambiato ovviamente inviando un messaggio che cambia il testo quindi questo è un pane per tutte le finestre di nuovo quindi basta cambiare un messaggio set text a una finestra qualsiasi e si può cambiare o il titolo della finestra se parliamo di una finestra di primo ordine una finestra madre oppure il contenuto della della network il contenuto dello static control si può cambiare basta inviare dei messaggi set text a una finestra figlia di tipo static e questa cambierà il testo di nuovo di questo vale anche per i pulsanti che vediamo tra un secondo che abbiamo già visto inviare un messaggio set text a un pulsante le cambia il testo che compare su il testo cosa c'è anche set icon come dicevo prima può avere delle icone quindi o icona o testo o testo icone insieme può avere anche delle immagini e poi sebbene si è un stamp quindi in realtà non ha un comportamento di nanto cioè non è un controllo reattivo il altro di scenari può riuscire agli input dell'utente può se non altro notificare che il smartphone di essere specificato quindi se volete potete agire qui sul testo quindi non ha molto senso però se volete può avvenire quindi in questo caso cliccate su una in extra static e metterà alla madre un messaggio static notification il secondo controllo banale che si possa immaginare è l'edit controllo che è il controllo che permette di inserire nel testo o cioè visualizzare il testo questo è un altro controllo che ovviamente classicamente può prendere il focus della tastiera in particolare per cui mentre lo stato del controllo può avere il focus ma non ci fa nulla veramente perché non è fatta per gestire l'input l'utente l'edit controllo invece nasce poi questa finestra qui quando ha il focus riceve il l'utente della tastiera e chiaramente va a manipolare il testo che sta mostrando il testo che sta mostrando di nuovo è lo stesso testo che si manipola con get text e set text quindi è sempre questo ogni minestra ha un suo testo un suo barco del testo interno in questo caso viene mostrato nel campo di testo e se lo mette ci si vede dentro questo get text viene modificato in tempo reale e quindi se voi fate get text ottenere le versioni aggiornate del testo mano a mano che l'utente scrive ci sono poi gli stili che facciamo più appare a questo edit control e sarà per esempio edit style mutilare se potremmo avere un controllo con le più righe lo scrolling automatico intervisuale se vediamo che si possa valicare intervisuale da dare a scrivere testi più lunghi sempre anche una password che si converte tutti i caratteri in asserissimi se vogliamo che possa essere inscritto dei numeri in questo caso il nostro supply number il nostro controllo accetta su tanto dei numeri può essere il controllo di nomine io ti può essere in grigetto impedendo all'utente di scriverci e così via e la notifica che hai mettere il controllo è edit notification update quando avete aprieto di scrivere qualcosa arriva lo subdate qui e noi dalla finestra madre possiamo andare a ricevere in testo inviare il messaggio che è text cioè questo update qui non ci segnala che è testo da scrittura ma ci segnala la stanza che è aggiornato il contenuto per cui dobbiamo ottenerlo inviando il messaggio che è text che poi la finestra ci fornirà quindi è tutto un rimballamento di messaggi che fanno funzionare le cose in sostanza la listbox già entriamo un po' da un po' più sofisticato la listbox è una lista di oggetti che a loro volta potrebbero essere oggetti di tipo testuale di tipo icona o entrambi che possono essere delle stringhe o delle inconcine vicine e il compagno di tener trance la selezione di uno o più elementi di questa lista quindi ecco qui se volete poter attivare la multiselezione quindi l'utente può selezionare più oggetti che vuol usare con il tasto controllo e in questa maniera seleziona le varie varie varie entri e peraltro potete che questo controllo qui è con Sandra per il mio se presentare le immagini di una lista però è un controllo molto primitivo quindi spesso quando pensiamo qui troviamo questo tipo di controllo perfetto però ha pochissime opzioni grafiche in realtà per cui è veramente un oggetto molto semplice che permette la distensione del testo per qualche cosa che sia livellamente più sofisticata di quello serve creare il controllo da zero e farlo in casa per esempio bisogna presentare oggetti complessi con una città grafica oppure per esempio per assenti e per dire di durare complessi tutte queste belle cose che il controllo di stocks non veramente li fare anche qui ci sono poi gli stili che possiamo fare e sintonizzare ad esempio l'exbox style no sell per impedire di tradizionare un oggetto all'utente lbs sort di auto ordine artistualmente e così via e poi ci sono dei messaggi ad string e find string per aggiungere di di altri messaggi che possono essere inti per lavorarci ma è importante adentarsi di tanto il combo box è un altro esempio molto classico che si vede molto spesso e che è molto utile però ha comportamenti molto etrogeni in realtà spesso è la fusione si chiama combo box perché è la fusione tra un un un campo di test in cui si può scrivere e un un box quindi è esattamente la fusione tra questo e quello insieme fanno il combo box tra virgolette e ha un sistema di cui di nuovo compare come edit box quindi è il primo per esempio l'elemento di un altro è l'edit box in cui si potrebbe continuamente scrivere e poi appena ci si scrive oppure appena ci scrive si apre una lingua in cui si può selezionare dei valori in pre-dicino poi in realtà questo di base è praticamente questo chiaramente poi si può scegliere vari comportamenti lievemente diversi però concettualmente è anche selezionare del test o vigilare il test sulla base di alcuni elementi che voi proponete tramite la risorsa tra l'altro è anche particolarmente complesso come oggetto in realtà per cui questo combo box è il prototipo standard di windows però visto che è un particolare complesso in realtà nella parte dei moderni interfacci attenti che valgono per l'ambiente mobile per l'ambiente di dispositivi il combo box non c'è più cioè è un elemento di interfacci attenti che è popolare in ambienti desktop che è molto potente chiaramente però è anche molto complesso come oggetto in genere non si trova più o almeno Flutter non ce l'ha nativamente non lo diciamo però è chiaro che si può replicare mettere insieme dei pezzi chiaramente fatto appunto di livelli di controllo e di listbox chiaramente in Flutter combinare questi elementi e fare un vostro combo box fatto in casa altro controllo molto banale è la focus bar che se la focus bar permette di esprimere una percentuale di avanzamento su un'operazione che viene svolta di base permette di esprimere qual è il range operativo quindi dov'è qual è il numero che corrisponde all'inizio dell'avanzamento e il numero che corrisponde alla fine dell'avanzamento e di default questi numeri sono 0% per la percentuale e poi impostare a che punto si è arrivato in set box in set range in cui dice ok inizio vai a 0 vale 100 con set box in cui adesso siamo a 50 e quindi da non stare schede fino a 50 o 100 proprio per indicare il range di valore di caratteristica e la posizione deve essere trovati all'interno di assolimento poi in alcune versioni di più in quinto successiva poi ci sono stati vari aggiornamenti per cui adesso è possibile io da vista in voi cambiare il colore per la margine che può essere verde gialla rossa e poi la margine ossia una indica di progresso ma indica il fatto che qualcosa sta avvenendo non si sa a che punto si si trovano dell'operazione quindi set save permette di impostare il colore verde la monosso se dicevo set mark imposta questa modalità qui di stato indefinito però di operazione in questo qui non mi fermo ad attaccare un altro oggetto classico però è tanto un po' indiscusso nelle versioni nuove di windows quindi questo è uno slider che scrive di nuovo un valore numerico su un range quindi funziona in maniera molto simile al set range del progress bar però sono diversi quindi ppm è un message per impostare il range della bar di progresso ppm set range progress bar message set range mentre per quanto riguarda la track bar si ha un track bar mess se fosse set range ad ogni controllo corrispondono messaggi e stili diversi che non hanno interazione non hanno intersezione l'ultimo esempio che ci interessa è il push button che noi abbiamo visto questo è stato button liberatore ma è un button chiaramente e questo è uno degli eventi più onnipresenti chiaramente di qualsiasi interfaccia utente e anche questa può assumere vari aspetti grafici in base allo stile che il push button è quello lì il command link è questa nuova che si è in base il box questo è il button questo qui poi neanche lo split button che è questo qui quindi è il pulsante che fa la pulsante patenente poi ha in più una linguetta la linguetta in sé non ha alcun effetto ma rimanda un messaggio rimanda una notifica attenzione è che la linguetta e a quel punto la visione può stare a comparsa sotto il pulsante per avere altre opzioni e queste qua mi sembra ok a questo punto quindi l'idea è questa che una volta che abbiamo un'ebriga di controllo di stamp possiamo andare a assemblare la nostra interfaccia utente senza dover fare le cose a mano senza dover andare a dipingere lo schermo dentro il messaggio paint perché quello è molto noioso e molto faticoso anche bisogna fare tanto operazioni complesse per fare delle cose anche piuttosto banali è molto più facile fare un interfaccio utente combinando per composizione mettere insieme controlli standard quindi classicamente si fa esattamente questo blocco note è il classico esempio di questo approccio per cui blocco note è un esempio magari un po' banale perché fa molto poco però nella sua banalità in realtà blocco note è proprio l'esempio di quello che si può fare con i controlli standard in windows perché la sua zona è interamente occupata da un edit control che è il control di cui parlavo prima che permette di digitare testo questo dato lo si vede anche questo è lo string di il stack che è il vocabino che abbiamo visto la volta scorsa per ispezionare l'interfaccio utente se riuscite a scartabellare nelle finestre figlie di blocco note raggiungete questo blocco qui che effettivamente è la finestra figlia di tipo edit quindi la classe di edit è veramente edit quindi è una finestra di classe edit che corrisponde al classicissimo campo di testo editabile in questo caso veramente avrà serie di stili che permettono a i cioè a blocco note di mostrarlo come deve essere mostrato quindi chiaramente sarà multiline perché può passare più in linee avrà una scroll bar interna che permette di scrollare internamente però blocco note non fa molto di più tant'erica tutto il suo comportamento a edit control quindi implementare blocco note in realtà potrebbe essere un esercizio abbastanza banale perché veramente basta distanziare un edit control e poi gestire al più il caricamento dei file e il salvaggio dei file quindi basta poi mettere il testo dentro il control e a quel punto avete implementato blocco note che è chiaro che ne fa qualcosa di più ma però per semplicare molto queste qua anche questa bar è un altro controllo standard e quindi in realtà combinando questi esempi avete già ottenuto l'interfaccia funzionale e questo vale un po' per tutte le applicazioni classiche di Win32 che vengono create componendo determinati dei pezzi di controlli standard e questo tipo proprio per questo motivo c'è dopo il slide che vi aspettavo appunto quindi se se volete veramente disegnare su schermo bisogna gestire il messaggio pain come vi ho già detto e questo avviene sempre su ripienza quindi in sostanza vogliete marcare come non più valida una regione del posto alla nostra finestra e poi Windows quando vorrà quando va a tempo di farlo vi chiederà di disegnarci sopra per ripresentare la schermo di valido però in genere è aiutato quanto possibile meglio che non avete un'interfaccia parte con sofisticata da fare o dobbiate carte di finestre interattive molto specifici che fanno esattamente quello in quel caso potreste gestire la vostra applicazione reagendo ai messaggi tempi però nella maggior parte dei casi si cerca di evitare perché non c'è bisogno di andare così in dettaglio a meno che appunto non potete fare applicazione di natura grafica in quel caso è inevitabile che potiate renderizzare presentare a schermo manualmente questo è un altro esempio anche questo è un approccio all'applicazione che nel caso è un altro esempio che è un altro esempio nelle versioni questo penso che sono un altro esempio che sono un altro esempio circa nel senso adotto a un certo punto anche il sistema a multidocumento quindi la cosiddetta è mediale che permette di avere sotto finestre dentro la finestra quindi l'idea all'epoca era questa di avere delle applicazioni che si comportano da finestre quindi hanno una loro finestra che magari è composta da vari controlli e così via ma internamente potessero avere altre finestre come come come come come come come come come come come come come come come come come come come come come come come come come come come come come come questa cosa anche questo c'è diciamo così anche esiste ancora si può ancora fare alcune applicazioni si comportano ancora in questa maniera però in genere si si evita come la bestie perché è particolarmente sofisticato e è molto facile con diversi in realtà i decking editor di testo con più documenti facevano esattamente questo anche le versioni di world facevano esattamente questa maniera però quelle più moderne invece presentano ogni singolo documento di una ora come finestra testata in questa maniera mentre editor testuali per programmatori come studio code e così via in genere adottano un funzionamento un po più semplificato quindi è vero che internamente possono avere più documenti ma non si comporta una finestra perché è troppo complesso e al più si può tagliare lo schermo in più parti in più sezioni e effettivamente a livello paradossalmente storico è come un ritorno alle origini perché il studio code internamente adotta questa separazione a sezioni esattamente come veniva con il 2 su 1 e i vecchi sovrativi che tagliavano i vari schermi e basta quindi paradossalmente in alcuni scenari può avere più senso avere interfaccia semplificata che potrebbe fare operazioni di gestione dello spazio molto molto banali per non rendere la cosa troppo complessa all'utente questa interfaccia qui appunto negli anni di 1998 andava abbastanza per la maggiore però poi mano a mano questi progetti sono andati svanendo ma chiaramente rimandano a disposizione quindi se volete tutte queste interfacce in un documento per le finestre esistono ancora e se proprio volete potete trovare con il 22 potete creare delle finestre che sono sia ping che documenti all'interno della vostra stessa non sia un scenario molto in mente utile però esiste questa è la stessa cosa spiegata a mano per esempio la TAR per esempio la TAR che presentava è un'altra cosa di questo funzionamento a multico documento che però penso che non sia supportato nelle versioni modelle altra cosa molto comune le schede qui le schede le TAR sono una versione non recente queste comparivano le versioni di Windows e quindi sono il modo con cui sembrano che vi presentano una serie di schede di una filestra quindi le TAR sono delle sottofinestre che possono essere aperte dentro una cartella in qualche modo la scheda di sopra è la scheda che vorremmo come dire sono la città delle serie di cambiamorie in qualche modo è un aspetto molto semplice che poi è stato portato avanti e persiste tuttora prevalentemente nei browser che i browser notoriamente hanno questo chiaramente una schede e chiaramente questo dovrebbe essere o Chrome o Edge o Google e Google e Google e Google e Google e Google e Google e Google e Google presentano le schede ma non hanno fatto l'uso delle schede di tutto molto ovviamente per evidenziare più di stile grafico perché in questo caso le schede sono tutte internamente dall'applicazione e tutta la parte grafica viene disegnata in maniera autonoma senza avvalersi delle parti già che sono distribuite in tutta il sistema dato che non vado che questo dovrebbe essere Edge su quali errato questo è un po' che è un po' che è un po' significato perché le schede vivono dentro la barra del titolo in realtà c'è una doppia complessibilità perché il titolo la parte non client viene a mano applicazione e ci segna dentro le schede dell'applicazione in questo caso le schede occupano il corso della barra del titolo standard un comportamento abbastanza atipico che però è molto efficiente perché chiaramente permette di condensare titolo e schede in un unico modo c'era una salvia di più forse che vi ho perso ma non è importante tornerà è più avanti ok allora vi ho raccontato questa cosa non tanto perché fosse utile per la vostra vita non scopatori ma perché molte delle cose le interromeremo poi parlando di flutter perché flutter funziona alla stessa maniera ovviamente di flutter in un sistema che vi darà accesso a una serie di strumenti standard che sono nel gerbo di flutter i cosiddetti widget quindi i widget di flutter il widget è in rispetto di una finestra che è in modo flutter il widget è l'elemento unitario che si può dividere l'interfaccia in flutter e tra l'altro ovviamente offre una serie di standard che potete usare per combinare la nostra faccia di unitario quindi vedremo diversi alcuni si occupano del testo alcuni si occupano dell'icona alcuni si occupano di altri elementi di interazione mettendoli insieme in un modo che abbia senso otterremo un'interfaccia che sia quella che vogliamo esattamente come si fa con Windows cambia solo il modo come si fa e cambia ovviamente poi l'aspetto grafico che hanno qualche elementi quello che cambia vivemente è che in Win32 i controlli standard sono in genere più complessi rispetto a quelli di Flutter nel senso che in Win32 appunto il pulsante il static contro la combo box in particolare e così via sono tutti oggetti molto complessi internamente che fanno tante cose in Flutter in genere il widget in base che abbiamo bisogno che utilizziamo prevalentemente sono un pochino più semplici più di base quindi c'è il testo c'è l'icona c'è il modo per mettere in fila in colonna e riga gli oggetti però non diventano complessi come quelli di Win32 proprio perché tra l'altro ci dà l'opportunità di creare cose complesse mettendoli insieme altri pezzi c'è questa idea di modularità per cui se è qualcosa di sofisticato ce la costruiamo a mano mettendoli insieme e intrecciando i vari componenti di cui abbiamo usato qui adesso facciamo giusto per chiudere la termine facciamo un po' su quello che sono i paradigmi del gruppo per la previsione in desktop perché abbiamo visto finora ben poco in quello che riguarda come si sviluppa una previsione in desktop perché veramente è una cosa molto sofisticata quindi non è che ci perderemo più di tanto tempo però abbiamo visto finora quello che si deve definire il paradigma imperativo a invio a passaggio di messaggi quindi è il sistema che viene in port cioè che è stato adottato gli effetti da da da da da da da da da da da da da da da da da da da da da da da da da programmazione in c o in c più o anche in c sharp e così via in cui comunque vige ancora cioè vige un approccio puramente imperativo procedurale dalla programmazione quindi io ho un main appunto parte io dichiaro le mie variabili poi volta in volta in mezzo ad utente clicca qui e fa le sue operazioni di me arrivano i messaggi ma i messaggi perché il lavoro può non essere fatto quindi può comunitare quel sistema e in base a questi messaggi io vado ad alterare lo scato del sistema vado a modificare le variabili in termini del programma e poi in qualche modo poi andranno a cambiare il modo in cui mi presento a noi questo è un approccio che funziona ovviamente per cui mi permette di lavorare a molto basso livello e in genere in caso di particolare mi danno una visione integrale per questo accadema visto che io vedo i simili messaggi che arrivano dal disegno operativo reagiscono in sicuro messaggio e quindi mi comporto in maniera molto concio di quello che sto facendo però c'è molto poca astrazione quindi devo lavorare a bassissimo livello e per fare delle cose anche molto semplici ci si mette molto tempo e c'è un altissimo rischio di fare di fare gli errori che ho visto anche una volta scorsa gli errori anche molto molto piccoli che cambiavano completamente il funzionamento del sistema a volte l'applicazione non funzionava per niente per un piccolo errore di indice di intero e così via quindi è molto facile rompere le cose con piccole di ottenzione quindi questo è quello che abbiamo visto finora con le 2032 però è chiaro che è possibile fare di bene qui ancora per rimanere in questo tema le 22 avvengono cioè che cosa vengono esattamente così con questo passaggio di messaggi sincroni e asincroni che hanno questa struttura fissa quindi i messaggi sono imporso da un intero e poi due interi che si preparano dal messaggio e noi ci passiamo queste strutture date in modo da segnalare cose modificare interazioni e ricevere eventi da altri messaggi è un mondo molto complesso in maniera molto complessa e il fatto che tutti i partecipanti si comportino in maniera più o meno corretta permette anche di interagire in maniera corretta e permette a noi di reagire in maniera voluta cioè come vogliamo agli intermitenti però è un balletto molto complesso appena qualcosa cambia anche o qualcosa si comporta in maniera non ortodossa le cose si rompono in maniera abbastanza rapida quindi basta interpretare una differenza uno dei bar del messaggio per dire che le cose veramente non funzionano quindi è una cosa abbastanza fragile e ecco sull'ultima cosa sincrono perché è importante perché alcuni messaggi sono effettivamente asincroni faccio l'esempio del spostamento del mouse quindi quando il mouse è spostato sul nostro window frame a noi arriva una serie di messaggi mouse move che ci insegnano questa cosa quei messaggi sono asincroni perché il sistema quindi il gestore delle PS ce ne invia ma non è che sa aspettare i nostri comodi per far continuare l'utente e lo spostamento del mouse ma è una notifica sincrona del fatto che il mouse è passato e questo per alcuni di messaggi funzionano tutti per altri messaggi invece il funzionamento è sincrono quindi il messaggio che citavamo per chiedere alla finestra quali sono le zone client e non client quindi la non client test quel messaggio molto particolare che vi sovo da scorsa quel messaggio visto che esige un risposto da parte della finestra Versaglio la finestra destinazione è un messaggio sincrono quindi il messaggio viene inviato e chi l'ha inviato aspetta finché la recensione del mese del rischio quindi in alcuni casi questo messaggio diventa sincrono e questo condiziona radicalmente il sistema praticamente in alcuni casi il sistema deve aspettare che alcune finestre si regiscono per poter funzionare in maniera corretta questo potrebbe appena se voi fate se su windows partire fate drag and drop di icone di tile da una finestra all'altra potrebbe essere successo di aver provato a trascinare un'icona un file o qualcosa del genere su una finestra che non reagisce forse vi è capitato quindi magari l'esempio è un browser caricato di file quindi c'è Chrome magari che sta che sta facendo su un sito in cui dovete caricare un'immagine da una parte avete le sue risorse quindi registri i file trascinate i file su Chrome Chrome l'accetta e la carica in teoria se Chrome si impunta per esempio tecnico se Chrome rallenta per un altro motivo quel trascinamento blocca altre le sue risorse forse se è capitato o se no se Chrome rallenta in quel distante fuori le sue risorse dipende da Chrome appunto perché i messaggi che sta inviando le sue risorse a Chrome non viene gestito e lo risorse si blocca di conseguenza e quindi entrambi sono impuntati perché Chrome non si schiota in qualche modo e quindi entrambi rimangono potenzialmente blocati quindi in questo caso la scena 2 è una strada fragile perché se un componente ha dei problemi poi a volte si porta una serie di componenti aggiuntivi che in teoria non hanno nessun legato diretto con quell'urgenza non è altrimenti altri esempi di questo genere ma lavorando con Windows potrebbe capitare tranquillamente di trovare problemi di questo genere ultima cosa nonostante niente o due nascono in ambiente cifili se non sono fatte per lavorarci in cifra e internamente adottano uno stile che è subito a quello degli oggetti quindi in genere si lavora con queste Hangul che sono dei puntatori degli oggetti complessi quindi si ottiene appuntatore a the nice context e poi rilasciare i live context poi la stessa cosa vale per i cursori e i goal e le cerce quindi sono questi oggetti che vengono allocati dentro il sistema e bisogna tenerli tracciarne l'uso esattamente come gli oggetti in un linguaggio che supporta gli oggetti ah ecco mi aspettavo questo visto che visto che in Win32 o in Windows in generale spesso quando andiamo a fare interfacce utente in realtà le combiniamo mettendo insieme altri controlli standard quindi le static label e button e così via quello che è avvenuto va abbastanza rapidamente è che invece di farle nel codice come non è fatto finora quindi con create window e con la fatica per tracciare le varie finestre esiste un linguaggio standard che è quello delle risorse e l'intensature che permettono di dichiarare i componenti di una finestra testualmente quindi questo è una finestrella di dialogo grande 180 e alto 100 che si comporta come pop-up e così via un font standard che è composto da quattro controlli che sono finestre standard uno era il deaf boost-up un altro boost-up c-text sarebbe la label static control quindi la finestra che era la static con questi testi con questi id con queste coordinate quindi in questa maniera è possibile definire in maniera appunto dichiarativa come sono fatte le finestre senza doverlo fare quindi questo semplifica un po' la vita e questo si poteva fare già in Windows 2 derivato quindi in qualche modo l'idea di farlo in maniera dichiarativa senza che invece dovesse andare a implementare ogni singola finestrella era abbastanza presto quindi questo semplifica un po' l'approccio perché funziona in maniera dichiarativa perché io dichiaro quello che voglio e poi sarà il sistema a tradurre questo in finestre che sono composte da altre finestre che sono dei controlli standard ok questo riguarda il mondo Windows chiaramente poi nel mondo di macOS ricordate il macOS classico quindi il macOS prima della versione dei 10 veniva da un mondo programmato in pascal in pascale poi o poi c col passaggio a macOS 10 quindi macOS X il linguaggio che viene aggiuntato il linguaggio principale è l'objeto C che è questa questa cosa qui ed è un C quindi un fio pezzo di un fio pezzo ma con delle le sezioni che praticamente integrano quindi il message passaggio dentro il linguaggio stesso quindi è come se per lavorare in 32 si fossero inventati un linguaggio speciale quindi 32 C che funziona esattamente come il C però quando c'è il progetto con il messaggio invece di fare chiamare la funzione send message e passargli i parametri del messaggio noi possiamo mandare il messaggio proprio con delle primitive del linguaggio quindi il linguaggio permette di il linguaggio peraltro è un linguaggio stranissimo e molto alieno di cui io non lo conosco assolutamente però è possibile esprimere l'invio di un messaggio nella sanità si stessa del linguaggio stesso ok quindi il linguaggio vi aiuta per questo continuamento a passaggi messaggi è proprio integrato nel linguaggio stesso quindi molte cose che in un'iniziatura bisogna fare a mano con i costrutti molto primitivi del C inoltre con più semplicità perché se ne occupa il linguaggio stesso e poi ci interessa in maniera praticamente secondaria perché non lo vedremo in dettaglio chiaramente nei programmi di linguaggio di programmazione più moderni poi il concetto di orientamento agli oggetti è stato inventato abbastanza presto per cui i linguaggi moderni quasi tutti lavorano proprio il concetto di oggetto dell'oggettuale sono poche linguaggi moderni in cui organizzate che non hanno scopo del linguaggio di il concetto di oggetto l'unico rimasto forse è javascript che non ce l'ha però per il resto in genere questa idea di avere degli oggetti che sono i propri dati in cui il funzionamento al livello di linguaggio proprio è una cosa che ci possiamo dire da da ricenni per cui chiaramente l'idea a questo punto è di integrare queste funzioni a livello di linguaggio e offrirle a chi lavora con il prefaccio utente in modo da semplificare molta programmazione perché a quel punto i singoli componenti di prefaccio utente possono essere rappresentati da delle classi del linguaggio stesso non bisogna più fare il palletto di internet 2 di c per creare oggetti e gestire di qualche modo perché già l'oggetto stesso nell'ingaggia può fare molto di lavoro più più più più però non hanno avuto modo di fare questa cosa e continuano a offrire delle interfacce molto semplici in serie c quindi che vanno bene per c senza oggetti per compatibilità quindi sia internet 2 che macOS 10 usano ancora l'idegrazione con c o altri oggetti fc nel caso di macOS ciò non toglie che sono stati fatti vari dettativi per cercare di offrire dei costrutti semplificati ai programmatori per creare del spazio di con relatività semplicità un esempio di questo sono le ffc le Microsoft Foundation Class Libraries le librerie fondazione per Microsoft che è una libreria in C++ quindi per C++ completamente lavorare con gli oggetti e non fa altro che in caposurare degli oggetti in C++ quindi in qualche modo è una libreria che potete utilizzare per lavorare con gli oggetti proprio direttamente con in C ma lavorando con delle classi che sombillino alle classi standard che potreste inventare in C++ quindi invece di avere invece di fare create window e creare la finestra per portare dietro la angle window quindi la window handle nel usato NFC andate ad allocare un progetto di window che internamente farà tutti i suoi vari maneggi per creare la finestra e gestire le classi e così via però è tutto il lavoro che fa la libreria per conto vostro e offre un'interfaccia orientata pienamente agli oggetti in modo da semplicarvi la vita NFC è questo approccio per il mondo Microsoft Windows quindi si usa esclusivamente lavorando per Windows e l'MFC esistono ancora quindi è possibile ancora utilizzarla anche se sono anche loro cadute abbastanza in disuso se volete lavorare in un architettino di multivettaforma una cosa molto simile la fa WX Widgets chiama ed è un toolkit per interfaccia di multivettaforma che è compatibile con Windows X11 e Microsoft e WX è effettamente la stessa cosa di MFC però multivettaforma quindi è un'ebreria di 1992 che esiste ancora giornata che permette di lavorare con le finestre in un ambiente multivettaforma che non c'è stato una piattaforma e lavorando in situazioni di dati costrutti che permettono di specificare le vostre finestre in maniera più astratta quello che è possibile fare con C per darvi esempio non so quanto siete compilando con XO Spero molto poca per la vostra struttura mentale ma questa cosa poco leggibile è come si crea una finestra con WX con questo sistema qui si crea and varie a vario los che si è ben occupato, ma si trova un altro che mi chiamano, vaga, che somiglia molto ai parametri di gate window, se ci fate caso, quindi delle gate window, somiglia moltissimo perché parella messa, questo è il dito da destra, questo è il dito che viene passato, è come il testo che poi figura il dito da finestra, questo è il contenitore momento, questo è il dato che nel window c'erano questi quattro parametri, la gavnetta, questi sono in cielo, questo è lo stile, questo è lo stile, è il stile, la periastra viene creata e potete immaginare che internamente si traduca questa che è il modo da confruttore a una chiamata che è il window, quindi si faccia una traduzione in qualche modo della chiamata qui e a voi i programmatori non rimane altro che usare le finestre con questo approccio orientato pienamente agli oggetti senza dover andare a interagire con le interfacce di basso livello del Windows 2 e quindi questo spesso risolva un po' di mal di test potenziali e soprattutto poi questo qui vale per Windows, ma vale anche per MQS, in questa maniera poi la traduzione avviene in entrambi i sistemi. Questa è la stessa cosa per l'applicazione di dialogo, questa è molto simile, ricordate, al message box, la chiamata di Win32, questo è la chiamata di Win32, questo è il motore del dialogo, questo è il titolo di dialogo e questo è il di cora che vogliamo, se ricordate come era message box di Win32 è praticamente identico, quindi dietro me qui, integramente qui, verrà fatta una chiamata message box, che lo fa su Win32 e sul macOS avrà la stessa cosa per il corrispettivo sul macOS. Questo è il modo in cui stiamo gestiti gli eventi, quindi anche qui ovviamente siamo lavorando con C++, per cui C++ è un ricadro molto brutto, però quello che mi permette di fare da BX Widgets è dichiarare una cosiddetta tabella degli eventi che mi permette di registrare alcune funzioni per reagire ad alcuni messaggi, quindi mi permette di dichiarare questa tabella degli eventi che diventerà, possiamo immaginare, la nostra Windows Procedure, quindi la funzione che gestisce i messaggi della vostra minestra diventerà questa tabella qui, quindi quello che avviene qui ci sarà un grosso switch, come abbiamo fatto in laboratorio, un grosso switch che gestisce vari messaggi d'arrivo, questo messaggio qui che è questo perché reagisce alla selezione di un oggetto dentro una lista, dentro Xbox, e lo fa invocando la funzione di una grillo del sistema handler, che è quella di una potenza di click. Per cui è tutto un paneginico per avere un modo per dichiarare in maniera astratta come gestire messaggi in arrivo dalle finestre, per fare un personaggio da una Linux Box, e reagire con questa funzione. Però, se ci pensate, facciamo la stessa rettica cosa in Win32, avendo il grosso switch, poi con i vari case andavamo a selezionare il messaggio che ci interessava, e poi con quel messaggio reagivamo con delle operazioni qualsiasi. Stessa cosa che abbiamo. Appunto, questa cosa qui ci dipende un po' la vita, ma non è che risolve radicalmente la... è comunque una forma di programmazione abbastanza di basso livello e abbastanza complessa, che bisogna un po' venire a fatti con WX Widgets per quanto può essere più comodo in Win32, però tanto più bello... questo lo ignoriamo, questo pure... questo pure... questo pure... questo in realtà forse è il caso di... giusto parlare due secondi... perché quando... finora abbiamo lavorato con sistemi che in qualche modo parlavano C, cioè parlavano con interfacce di tipo C, quindi... mi ricordavo che parlavamo della API, dell'Application Binary Interfatti Binaria, era quello del C, per cui le nostre applicazioni sia che siano scritte in C, come il laboratorio, sia che siano scritte così in C++, alla fine comunicano in C con le Win32 e le cose funzionano così come devono. Quando lavoriamo invece con sistemi a runtime un po' più sofisticati, come per esempio .NET o Java o Python e così via, tutte queste piattaforme, questi runtime più complessi, possono comunque parlare con il sistema sottostante ovviamente e le sue funzioni in stile C. E lo fanno con vari sistemi più o meno ortodossi che permettono al programmatore, il .NET o il Java o il Python di interagire e fare delle chiamate al sistema di basso livello. In quel caso è il runtime del .NET, in questo caso, che si occupa di convertire i vari parametri in modo tale che tutto torni, quindi che i parametri vengono trasferite migliori e corretti e che tutto abbia senso. Questo è un'attività di un'attività di un match, quindi il passaggio da un mondo più sofisticato come .NET o Java a un mondo più di basso livello come il C, attraverso il marshalling il runtime si occupa di passare parametri in una direzione dell'altra e vi permette di invocare le funzioni di basso livello. delle Win32 o di Mac OS o di quello che è. Quindi in particolare se ricordate lo struct RECS che abbiamo usato a livello di otorio, lo abbiamo usato un po' di volte per chiedere il sistema a parte grande della finestra o per fare il rettangue e così via. Il RECS delle Win32 è uno struct che è composto da quattro literi da un next, top, item, bottom. Questo truc lo possiamo ridichiarare in .NET, questo è C Sharp, e specificando al marshallert, quindi a Pesop and Marshallert che il reality del software deve essere secundizionale per mantenere l'ordine dei campi, in questo caso questo RECS qui corrisponde esattamente al RECS che si aspetta le Win32. intergetture. A questo punto possiamo parlare di Win32 passando questo RECS al sistema sostanzialmente. E quindi anche in .NET, facendo un po' di marketing del marshallert di .NET, possiamo quello di definire, no, il sito da KID, quindi, usando i .NET, o di Java, o di Python ovviamente, per cui nulla ci impedisce di usare anche in ambiente .NET, Java, Python, i elementi sotto sostanzialmente della piattaforma su KID. Per cui l'idea è che anche se siamo .NET, alla fine dei conti possiamo parlare con le Win32 e fare la stessa cosa, creare finestre, creare messaggi di dialogo, creare, interagire con i messaggi e così via, questi questi sono i messaggi, l'abbiamo visto che si dichiarati dentro il header C delle Win32, possiamo parlare stessa volta anche in social per avere dei messaggi che si fa per le Win32. Giardini, no, è un dialogo che sfonde veramente un valore intero e quindi basta ridefinirli e abbiamo accesso anche a questi valori. Per cui, grazie a questo meccanismo qui, per arrivare a Windows Forms, Windows Forms è la libreria offerta da .NET per andare a a creare delle finestre in ambiente Win32. Quindi quando se dovessi creare l'interfaccia utente per Win32, su .NET dovete salutare Windows Forms che alla fine vi offre tutta una interfaccia che nasconde, ma che era più efficace, che se poi è ribattibile, nasconde la natura delle Win32. L'oggetto che si occupa del Win32 è il campo di Windows Forms, se il modulo si potete applicare il campo confinabile, questo form qui corrisponde alla finestra di Overlap, quindi la finestra Overlap che abbiamo creato in Win32, in Win32 corrisponde a Win32. Quindi ricordiamo che in Forms e .NET, quello che abbiamo avvito le quiz, è che Windows Forms per conto nostro va a creare una classe di finestra e poi crea una nuova senza che corrisponde al nostro form. La cosa bella è che, non è importante, forse anche questo, la cosa bella è che in Windows Forms abbiamo accesso a un cosiddetto designer che ci permette di creare interfacce con drag-on. Quindi è possibile in un studio non music-quot, il studio però cugino quello vero, che ha tutte le varie dimensioni produttivi, per identificare delle interfacce rascinando gli oggetti dalla finestra e mettendoli graficamente. In questo caso andiamo comunque a creare la finestra che dietro alle quinte è fatta con le quinte su Windows. Adesso si impravede anche perché lo stile grafico è esattamente quello che è interessante con Windows, con Windows, con Windows, con Windows, con Windows, con Windows, c'è la combo box che mi citavo, c'è Box, l'altro, e così via, poi ci sono molti altri, veramente. Però, appunto, traspare questo mondo sostanziale, perché alla fine dei conti tutti questi soggetti qui sono implementati in termini di cui si è da qui. E non c'è molta distanza. Quindi vi nasconde in maniera molto parziale la natura sostanziale del mio oggetto. Però tra l'altro lo fa in maniera così parziale perché le finestre, quindi della form, quindi che ho scritto qui, la classe base controlli per esempio lo direi, controlli in Windows Forms, espone un metodo eventuale che s'è il Windows Proc, proprio. Quindi il Windows Proc si è portata, no? È la figura di finestra, quindi internamente proprio la Windows Forms, in Nordnet vi espone in realtà le stesse serie, quindi cosa che trovate, troverete in Windows. Ci sono i messaggi, sono punture a finestra, c'è l'interno che scende il messaggio, i parametri è positivi. Quindi, se andate a scavare anche di poco dentro Windows Forms, troverete le quinte due nuove. La sorpresa non è particolarmente gradita di solito, però è così. Quindi questo è quanto. La cosa positiva di tutto questo approccio qui è che appunto il design è chiaramente molto più debole che fare le cose a mano nel Cosmos. Una banalità è ovvia, per cui basta trascinare, ridimensionare, cambiare i parametri degli oggetti in vario modo e si può fare tutto direttamente da questo, è il mio testo qui. Quando avete creato la vostra chiesa a vostro piacimento, quello che avete preso alla fine è una classe che è completamente pulita, questa classe qui è composta, cioè il forum, è composta solo da un metodo misterioso che è initialize the power. Questo initialize the power, in realtà, nasconde tutta la proposta della virtual. Quindi, se voi andate a vedere questo metodo qui, che vi so studio qui per carineria nasconde, questo initialize the power, se lo aprite dopo la certa metà, è composta da tutti gli elementi base, quindi crea i reggetti, riposizione di una statica, il codice, in realtà è tutto codice autogenerato dal designer. Quindi questo designer qui, altro non fa che andare a generare questo codice in maniera automatica, per conto posto. Quindi, alla fine dei conti, quello che cade dietro il grid è esattamente qui, senza due, così, però con un supporto abbastanza utile. Tra l'altro, il supporto è tale, per cui quando voi andate a manipolare l'oggetto sul schermo, come se voi ascoltate qui, troverete tra gli eventi che il codice autogenerato può generare una serie di messaggi, nel gioco del grid of data, che si chiamano eventi, quindi eventi che potete gestire in qualche modo, e al quale potete agganciare un metodo, che in questo caso al click del pulsato può agganciare una funzione MyCringHandler, quindi a livello pratico, nel vostro caso avverrà anche la form, che appunto viene fatta in automatico dal designer in questa maniera qui, poi avrete un messaggio, un messaggio di metodo, che viene invocato quando qualcuno finisce su su su su su su. Però, di avere quindi di nuovo, più dentro c'è qualcuno che fa specificare che nella quinta posizione della vostra form, quando arriva il button notification, click, che dovrebbe essere, quindi dietro click, il messaggio arriva, corrisponde di tipo, risponde a queste funzionate, a quel punto il sistema, nascosto qui dentro, invoca questo momento. Quindi dietro la quinta viene esattamente quello che avete fatto a mano finora, però fate molta meno fatica, perché c'è molto meno codice da scrivere chiaramente, con queste poche righe di codice, ottenete un risultato che può essere anche abbastanza congresso. Quindi questo è un, diciamo, questo passaggio, è il passaggio da imperativo a dichiarativo, nel senso che, pian piano, grazie al designer, stiamo cercando di spostarci nella nostra linea temporale da un approccio puramente imperativo a un approccio che è un pochino più facile da utilizzare, grazie al fatto invece al designer. Il designer ancora nasconde, in realtà, la cultura dell'approccio imperativo, perché qui dentro c'è qualcuno che imperativamente dice ok, adesso crei il pulsante, adesso lo sposti qui, adesso lo metti così grande, adesso crei un checkbox, lo sposti qui, così via. Quindi è puramente imperativo, ma è camuffato da un po' di stucco, in questo caso, però è, diciamo, sulla strada, insomma, per arrivare ad un approccio che è diverso e quindi perde la parte imperativo e diventa dichiarativa. Come esempio classico delle applicazioni dichiarative, ci sono le applicazioni web che proprio per la natura stessa sono in genere dichiarative, perché nel web noi abbiamo questo mondo composto da HTML, CSS e DAB, HTML è il document editor, CSS è l'appertografia del document editor, il document editor, il document editor è quello che reagisce all'interazione dell'utente, a parte il comportamento che è essenzialmente già, quindi è codice che funziona in maniera imperativa ovviamente, il resto è puramente dichiarativo, HTML e CSS vanno dichiarati nella statica, e una volta che sono dichiarati hanno quella forma e quella struttura e quello di un asset grafico che non viene più modificato. Quindi cambia un approccio, cioè noi dichiariamo le cose come le vogliamo vedere e poi sarà il sistema, il browser ovviamente, che ne presenta schermo per come le vogliamo. Quindi cambia l'approccio del programmatore, il programmatore non c'è cosa più di dire cosa fare, quindi programmare, ti scelto, sposta la penna in alto a sinistra, la traccia verso il basso, fai un cerchietto rosso, cioè abbiamo fatto quello in 32, non avendo questo, ma diciamo al sistema, oltre a se in questo caso, voglio qui un, cosa vuol dire, un box colorato in questa maniera, occupa del web, che a me non interessa come lo fai, e quindi cambia proprio il paradigma. Adesso per farla breve, non voglio rubarvi da che possiamo tenere del tempo, per farla breve, prima ancora di UWP, quindi Universal Windows Platform, era stato introdotto la Windows Foundation, che in realtà poi è stata, il produttore è stata, una parte è stata riciclata anche in UVP, quindi in realtà stava parlando della stessa cosa. Comunque l'approccio moderno per l'applicazione, da vista in poi, prevedeva lo del video delle WPF, di Information, che permetteva di dichiarare appunto le interfacce, usando un linguaggio derivato da XML, che si chiama XAML, esattamente come viene su web, quindi nel web viene con HTML, nel mondo delle WPF viene con lo XAML, lo XAML permette di esprimere in maniera dichiarativa un'interfaccia grafica come questa, questa interfaccia grafica che normalmente faremmo, creando un group box, creando quattro check box, grande pulsante, queste cose qui vengono dichiarate in XML. Non detto che sia più del civile, quindi in base alle vostre preferenze personali questo è o meglio o peggio delle altre alternative, se vuoi decidere se vi piace più o meno, però in questo caso non siamo dichiarando che c'è una riglia, e poi siamo inserendo un pulsante, un group box, uno stack panel che potrete diventare in stack, e mettere in fila le cose, e poi quattro vedete un altro, che sono così, quindi stiamo dichiarando l'aspetto dell'interfaccia dente. Poi l'interfaccia dente viene gestita veramente dal sistema WPS, quindi se ne occupa il sistema, non dobbiamo più gestire i singoli pulsanti, i singoli controlli, perché una volta messi al schermo dichiarabilmente, se ne occupa il sistema. questo è un po' il cambio di ricordazione. Poi quando bisogna aggiornare l'interfaccia dente, la WPS utilizza un sistema che si chiama data binding, che permette di connegare alcuni elementi di quello schermo a valori che vengono dalla vostra applicazione, però non è importantissimo. la stessa cosa avviene per Android, se avete esperienze di Android classico con Java, avviene sicuramente la stessa cosa, dove l'interfaccia dente viene schiarata sempre con un linguaggio che si chiama AXML, quindi Android XML. somiglia molto a quello che avviene per WPS, quindi è una dichiarazione. In XML, che se lo sappiamo, un linear layout che permette di mettere in pila degli altri oggetti, c'è una FASTDURB, il mostro del test, un linear giro di massima di immagine, un battle che reagisce a tutti gli eventi. Quindi anche in questo caso, anche in Android, già le prime versioni, c'è questa idea di avere l'interfaccia che viene schierata a XML e poi è il sistema che si occupa di mostrarla a schermo. quindi sappiamo tutto quello importante. Perché arriviamo all'ultimo step, non so, a parte di due minuti, per cui chiudo questo, perché l'approccio dichiarativo è un approccio intermedio che ha degli dubbi vantaggi rispetto all'approccio imperativo, perché chiaramente questo è un po' più chiaro con il programmatore rispetto a faccio una finestra, la sposto di qua, la sposto di là, perché chiaramente se noi facciamo un interfaccia di da, in maniera puramente dichiarata, è imperativa, la spostate, è facile perdere traccia di quello che sta per niente. Se io a un certo punto sposto una finestra in reazione a un click di qualcosa, se non mi ricordo che l'ho spostata, la finestra poi rimane in visita, in visita da qualche parte. Qui dichiaro una singola volta quello che voglio che venga mostrato lo schermo, a quel punto so che l'interfaccia utente è composta di diversa magnetica. Questo è il mandato. L'ultimo step, quello a cui arriviamo con Lapp e i suoi parenti, quindi SwiftUI, ma anche React e così via, è l'interfaccia utente che è interamente basata sul codice, cioè un'interfaccia utente funzionale, se voglio dire, perché ci sono delle funzioni del linguaggio, del vostro programma che si occupano di presentare al schermo l'interfaccia, per cui l'interfaccia utente che noi andiamo a presentare al schermo, che non è, se stiamo perdendo, ma vabbè, un po' più in questo esempio, però viene dichiarato direttamente nel codice. Quindi qui già avete un piccolo preview di quello che andremo a fare. Quando dobbiamo creare l'interfaccia utente in Platt, quello che andremo a fare è direttamente dentro il codice andiamo a dichiarare, praticamente statica funzionale, quello che poi ne accompagna a S. Quindi a quel punto diventa tutto, collassa tutto dentro il codice, non c'è più il codice imperativo che va a creare, a spostare, a gestire elementi, non c'è più l'XML imperativo che è un linguaggio intermedio che permette di significare l'aspetto che voglio tenere, è direttamente il codice che si occupa di presentare gli oggetti a schermo. Quindi non è più imperativo perché non c'è nessuno che crea oggetti di risposta, non è proprio possibile farlo, non c'è nessuno di codice che va a manipolare gli oggetti, ma il codice stesso esprime proprio come fatta l'interfaccia utente. Non so se vedete qui, quindi c'è questo metodo BIM qui che va a costruire l'interfaccia utente, e vedete che ci sono vari oggetti, che al primo ho citato che si chiamano il gergo widget, in flap, e quindi c'è l'oggetto center, l'oggetto row, l'oggetto container, l'oggetto text, e così via, che sono tutti gli elementi di base di cui è composto l'interfaccia utente e che vanno a concorre con i saguari che vi hanno detto. Questo approccio qui è abbastanza radicale rispetto a quello che abbiamo visto finora, richiede da vostra punto di vista un salto, un cambio di paradigma abbastanza importante, perché bisogna ripensare come funziona la costruzione dell'interfaccia utente, e in genere non è completamente intuitivo, perché se venite dalla programmazione in C, o C-Shark, o Java, e così via, siete abituati a un mondo imperativo, a oggetti chiaramente come lo ero anch'io ovviamente. In questo caso, chiaramente c'è ancora il mondo di oggetti imperativo, però quando si lavora con l'interfaccia utente si cambia completamente approccio e si fa in questa maniera. Quindi è il codice stesso che il programma descrive l'interfaccia utente. È come se avessimo messo XML e codice insieme, a cui è un singolo elemento che descrive il codice direttamente nel linguaggio e programmazione che stiamo utilizzando. E questo è il fatto. Da qui in poi parliamo di Flutter. Prima di parlare di Flutter, quindi lo faremo non domani, per l'anno prossimo, ne parleremo il giorno di prossimo. Prima di parlare di Flutter in specifico parleremo di Dart, quindi del linguaggio e programmazione di cui faremo uso, perché è importante sapere come funziona il linguaggio e poter poi poterlo sfruttare con cos'altro. Per cui il giorno di prossimo inizieremo con le basi di Dart e poi da qui iniziamo il vivo della programma. Ok. Buona vera e buona giornata. E a buona giornata. A buona giornata. Grazie. Grazie. Grazie. Grazie. Grazie. Grazie.