E riprendiamo subito con il nostro amato Flutter, prima di due perché siamo qui. E allora, apriamo un attimo. Ok, prego una cartella Flutter. Allora, lavorando con Flutter, vedrete che è tutto, cioè la procedura di creazione del progetto è molto simile a quella che abbiamo fatto finora con Dart. Quindi qui siamo in una cartella Flutter, vediamo che cosa ci offre Flutter. Qui la cosa più sofistica, cioè più complessa di Dart, ovviamente, che le opzioni sono di più. Molto di questi non ci interessano perché di base la cosa che ci interessa è stato creare un progetto dentro una directory tal dettaglio. Ok, quindi fatto create. Lo chiamerò hello1. Man mano che andiamo avanti, però lo dico, è crescendo così poi vi ricarico. Su Blend li trovate in varie versioni da fare riferimento. La creazione di un progetto Flutter è un pochino più lenta in teoria perché deve scaricare tutte le varie dipendenze, tra cui Flutter stesso e i suoi vari componenti, perché a questo punto abbiamo il nostro progetto. Ok, già vedete che c'è una somiglianza con un progetto di Dart, ma c'è qualcosa in più. Adesso vediamo di cosa ne trovo. Eccolo. Allora, così. Allora, il progetto di base è sempre uguale, quindi abbiamo un pubspec come tutti i pacchetti Dart. Non si apre. Ok, quindi le cose sono le stesse. Name è il nome del pacchetto, descrizione è la descrizione. La versione funziona alla stessa maniera. Environment pure. La cosa che cambia praticamente è la dipendenza. Qui c'è la dipendenza dall'SDK di Flutter, ovviamente, perché Flutter ci serve per far tutto quanto. E qui c'è già un primo pacchetto aggiuntivo misterioso, che è questo cupertino icons, che è un pacchetto di icone. E tra l'altro, anche qui, la pena perdere un secondo, Flutter è appunto la multiplattaforma con cui può generare applicazioni che girino su iOS, su Android, su web e così via. Nel gergo di Flutter, quando qualcosa è ispirato a iOS e comunque il mondo delle applicazioni mobili per il mondo Apple, si chiamano cupertino. Cupertino perché era la sede di Apple e il cupertino in California. Quindi per fare simpatica ci vediamo in questa maniera. Mentre tutto quello che fa riferimento al mondo di Android, in genere, fa riferimento a quello che si chiama Material Design, che è il linguaggio di design standard per Android. Material Design ha trattato una serie di versioni nella sua vita finora. Adesso siamo alla versione 3 del Material Design. E quindi quando facciamo riferimento invece a qualcosa che ha l'aspetto di un pulsante, di un'interfaccia, di un componente che somiglia a qualcosa che troveremo su Android, quello in genere ha il prefisso Material. Quindi Material Android, cupertino iOS. Poi, se volete, chiaramente potete includere altri pacchetti che vi danno interfacce e stili di design diverso. Quindi in particolare se volete fare delle applicazioni che sembrano native su Windows, lì l' linguaggio di design si chiama Fluent. Un tempo si chiamava Metro, si chiamava in Windows 8 e in Windows 10. Adesso si chiama Fluent Design e quindi ci sono dei pacchetti che iniziano con Fluent che fanno riferimento a pulsanti, icone, eccetera, e stili che sono a casa su Windows. Questo però va a intaccare soprattutto la parte 7, no? Esatto, esatto, solo la parte estetica, esatto, giustissimo, perché in effetti nulla ci impedisce di usare le classi cupertino su Android, quindi avere un'applicazione che somiglia, cioè a tutti effetti all'aspetto di un'applicazione iOS su Android e viceversa avere un'applicazione che usa Material su iOS. Poi a nostro giudizio, la nostra sensibilità estetica, evitare che cosa accada, magari perché poi l'applicazione sembra un pochino estranea sulle piattaforme di estrazione, però nulla ci impedisce di farlo. Perché Flutter non dipende dal sistema operativo su cui gira, cioè molto poco, per cui la parte grafica quasi per niente, internamente, poi ve lo faccio vedere magari la prossima volta, internamente c'è un renderer che non dipende dal sistema operativo, per cui tutti gli elementi interfaccia che andremo a utilizzare sono reimplementazioni del material design di Android, del linguaggio design di iOS e del linguaggio design di Google. Non è nulla più nativo. Tutti i pulsanti sono reimplementazioni, per cui in alcuni casi sono anche un po' diversi, quindi in particolare su iOS alcune cose sono molto simili, ma hanno un comportamento di elementi diversi. se uno sta veramente molto attento, può notare la differenza, se proprio vuole. Ok, quindi il PubSec finora non è nulla di così esoterico. Ah, tra l'altro, ultima cosa, scusate. Le dipendenze appunto includono i pacchetti aggiuntivi, tra cui Flutter, poi il fatto che ci sia Flutter ci permette di avere una sezione aggiuntiva del PubSec che è dedicata a Flutter proprio, dove possiamo configurare il nostro Flutter, quindi a tempo di compilazione del progetto, tra cui alcune cose che vedete che specifichiamo se usiamo material design oppure no. Questo adatta un po' il comportamento delle icone di vari altri oggetti di Flutter. Possiamo specificare se includere delle immagini, delle risorse, dei font, e così via, varie cose che poi verranno utilizzate poi durante, cioè da Flutter in qualche modo, per l'aspetto grafico. Adesso non ci interessa, però sappiate che qui c'è una serie di configurazioni che potete esprimere. Qui dentro noterete che non c'è BIN. Qualcuno, ah, giusto, qualcuno di voi, prima mi chiedeva BIN, LIB, qual è la differenza. Allora, nel... LIB contiene tutta la libreria di supporto della vostra applicazione. Quindi nella maggior parte dei casi create un eseguibile standard o una libreria, un pacchetto, o riservate da altri. Il vostro codice in genere è tutto dentro l'inito. Se create un pacchetto Dart che è anche eseguibile, quindi è anche un programma da righe di comando, avete anche una casa da BIN dove c'è in genere il main e poco altri supporti. Quindi lì in genere sono i punti d'ingresso della vostra applicazione che vengono lanciati da righe di comando. In questo caso, stranamente, non c'è il BIN, nonostante noi poi vorremmo creare una cosa che somiglia un eseguibile, perché effettivamente il nostro pacchetto Dart non è un vero eseguibile, cioè non avrà un vero, cioè no, avrà un main in realtà, però il punto d'ingresso è di Flutter in realtà. Quindi è Flutter che è eseguibile, cioè il pacchetto viene lanciato da Flutter, poi Flutter a sua volta andrà a passare la palla a noi in qualche modo. Quindi in realtà è un po' come con il W32, se ricordate, non c'erano il main, ma c'era il win main, è simile, quindi il main c'era comunque, era solo camuffato, poi il main, il runtime W32, ce lo invocava, ce ci invocava tramite il win main. Qui avviene una cosa vagamente simile, perché partirà Flutter, farà le sue varie operazioni di inizio, e poi passa la palla a chi ha la nostra libreria, quindi il nostro main è qui dentro. Poi si chiama comunque main, però concettualmente è questo l'approccio. Ok? Un'altra cosa che vedete qui, che ci sono delle cartelle per ogni piattaforma di destinazione. Quindi c'è Android per Android, ovviamente iOS per iOS, Mac OS, Linux e Web e Windows. Quindi per ogni piattaforma di destinazione, potenziale di Flutter, potete avere un, diciamo, un sottoprogetto che contiene il codice di supporto per quella piattaforma. Adesso, giusto per perdere un altro po' di tempo, magari ve lo faccio vedere, perché lì si nasconde proprio le cose di basso livello di Flutter che fanno partire le applicazioni, quindi che poi passeranno la palla al nostro main qui, che vale per ogni piattaforma. Diamo un'occhiata magari a Windows, perché già lo conosciamo. Android poi lo vediamo più avanti quando andremo in Italia di Android, però dentro Windows qui, ci sono le fungine, c'è il codice che fa avviare Flutter su Windows, quindi in particolare ci sarà un main, WinMain, qui vedete che ci sono delle cose che già conosciamo, già ho visto. Questa è la API entry WinMain, che viene lanciata da Win32 all'avvio. Qui fa delle cose che sono un po' atipiche, qui perché è implementato in C++, quindi questo in realtà non è C, però fa comunque uso delle Win32 sotto sotto, perché vedete che qui fa Win32 in Winpoint, Size, e qui fa esattamente le cose che abbiamo fatto noi prima a mano, ricordate dal laboratorio scorso, quindi fa... Crea una... Come? Fa le cose brutte. Fa le cose brutte, quindi crea una finestra, quindi registra la classe della finestra, imposta dove viene creata, la crea, imposta che quando quella finestra viene chiusa si chiude tutta l'applicazione, quindi era il classico gioco, ricordate, Windows Destroy, che poi causa il messaggio di Windows Quit. Questa è la nostra famosa message pump che conosciamo benissimo, sempre lo stesso aspetto, e questo è quanto. Quindi sotto sotto, quando compiliamo Flutter per Windows, in realtà stiamo andando a creare un'applicazione Win32 che internamente crea una Flutter Window che non è altro che una finestra, magari sono anche l'amorziata come è fatta la finestra, la finestra ovviamente viene creata, distrutta, e poi ha un suo message handler che non è altro che è la Windows Procedure che già conosciamo con la Win32 e la Windows Procedure è implementata qui dentro da chi ha fatto Flutter, quindi qui Flutter l'ha fatto, in qualche modo va a gestire i vari messaggi, vedete che in realtà i messaggi non gestisce molti, c'è soltanto il cambio di font, ok? Poi altre cose sono delegate ad altri livelli e così via, quindi la... Però in realtà il codice di base che fa partire tutta l'impalcatura di Flutter è abbastanza, abbastanza semplice, quindi non fa chissà quanto, quindi anche qui ci sono un paio di classi di supporto che gestiscono, vedete qui la classe della finestra, tutte cose che abbiamo già visto che vorremmo dimenticare con... così, con felicità, però ecco, questo per dirvi che le Win32 sono ogni presenti purtroppo e quindi sotto sotto se compiliamo Flutter per Windows alla fine troviamo un'applicazione che è fatta con le Win32. Ora, infatti, se facciamo Flutter Flutter Run Help vedrete che possiamo specificare a Flutter Run come far girare l'applicazione. Questo magari era un po' proprio... Ok, perché qui le opzioni sono tante, però quella che ci interessa in realtà è dire a Flutter dove farlo girare. Questo se lo trovo magari... un'applicazione che è fatto per quanto si si chiama ospite. E dovrebbe... Poi cosa dipende... Poi non è stato vero su Linux o dire che è compilato come applicazione o che era per il mio listo. Ah, adesso era così. È il device, ecco, avrai l'opzione meno D che ci permette di specificare dove far girare la nostra applicazione. Quindi, su quale dispositivo far compilare e far girare l'eseguibile. Per sapere che device abbiamo disponibili possiamo fare Flutter, Devices, mi sembra, e ML. Quindi, dacci la lista dei dispositivi. Non era quello che vede? Se ricordassi le cose di volta e volta sarebbe molto più facile. Ah, assolutamente niente. Ok. Quindi queste sono le opzioni che abbiamo. Che io ho, quindi nel vostro caso potrebbero essere diverse, ovviamente. Per cui, che cosa succede? Abbiamo Windows, quindi può compilare l'applicazione Win32. questo in realtà non è vero, questo è un errore, cioè immagino di poterlo fare, ma non sa che non funzionerà perché non c'è l'Sdk quindi in realtà questa cosa qui potremmo tentare di farla ma non dovrebbe funzionare. E poi c'è Chrome ed Edge. Questo codice qui, questo è il valore che dovete passare a meno di su Run per farlo girare su quel dispositivo. Se avete andato su un installato e configurato la corretta e il dispositivo collegato alla macchina di debug, poi lo faremo insieme comunque, potreste già avere qui il dispositivo Android di output collegato. Quindi se avete un dispositivo di debug attivo qui compare il nome e potete già fargiare Flutter sul vostro dispositivo se volete. In questo caso non lo facciamo ma facciamo tirare l'applicazione su Flutter. Sì, prego. si, esatto. ADB poi vediamo insieme però quando installate le SDK di Android quello si può tenere una serie di strumenti ADB è il piccolo servizio che comunica con l'espositivo esatto e permette di fare delle opportunità di debug come anche caricare dei pacchetti e installarli. Per cui quando fate Flutter Run meno D nome dispositivo Android che adesso non so perché cambia ogni volta collegato al dispositivo poi vi genera una stringa che lo identifica qui esatto cioè compila la pick up che è il pacchetto compilato sulla macchina lo installa sul vostro dispositivo e poi lo esegue direttamente e si collega in debug al dispositivo per cui con ADB fa anche il debugging interattivo del pacchetto se facciamo o Chrome o Edge è abbastanza differente o Edge che ah beh sì mi sono sbagliata dovete essere una cartella che sia un progetto Flutter se non funziona in questo caso lanciandolo per Edge o per Chrome che cosa avviene? che il nostro pacchetto Dart viene compilato in JavaScript quindi qui vedete che questo è la la piattaforma di output quindi Windows 64 se compilassimo con Windows e Web JavaScript se compiliamo in questo caso per web per browser quindi adesso farà una transcodifica del Dart in JavaScript come abbiamo già visto una volta su Dart può essere sempre compilato in JavaScript perché nasce con quell'intento lì quindi creerà del JavaScript ottimizzato che contiene tutto il runtime Dart contiene tutto Flutter e poi ci darà accesso al browser tramite Flutter adesso vedremo l'applicazione di default di Flutter quando facciamo Flutter Create è un'applicazione molto semplice che ci permette di avere un contatore e un pulsante che lo incrementa appena qui la compilazione ha successo dovremmo vederla a scherzo se nel vostro caso già è comparsa guarda mi sa che non si è colorato un'epidogna ci per più non mi sta bisogno per niente poi passiamo a Chrome però in teoria ma c'è anche però stavano anche compilando non so se stava ripoghiamo ma prima ho provato Chrome che dice se vuoi compilare ah sì sì sì è la prima è la prima è la prima è la prima è la prima sì sì poi la cosa molto gradevole di Flutter è che una volta che avete compilato il pacchetto Flutter e l'avete fatto girare nel browser o avete installato il pacchetto su Android una volta che si è installata questa comunicazione tra il compilatore Flutter e il dispositivo di Output potete modificare la vostra applicazione in tempo reale quasi andando a fare quello che si chiama Hot Reload o Hot Restart dell'applicazione adesso appena da un segno di vita ah ok quindi qui si parla di mezz'ora ma è perché il vetro no è un appartamento sì no però l'avete non aiuta sicuramente però no ho lasciato Edge perché nella speranza che fosse diventare più leggero di Chrome però è una speranza vana quindi aspettiamo intanto vediamo cosa ha fatto il codice perché il codice è un po' strano nel senso che allora allora il punto di resto ovviamente è il nostro binamatissimo main quindi main è dove inizia la nostra applicazione questo è un metodo sincrono quindi non è asincrono e che cosa fa? fa un'unica chiamata che è run app che è un metodo di base di platter al quale passiamo un widget il widget è l'unità minima diciamo così l'oggetto fondamentale dell'interfaccia utente fatta con flutter quindi l'interfaccia utente fatta con flutter per quanto complessa essa sia è alla fine dei conti è una composizione di tanti piccoli widget quindi ci sono widget che mostrano il testo widget che mostrano come? ah c'è la fatta ci sono dei dei segni positivi ma ancora non ce l'ho fatto ok adesso ha avviato Edge adesso questo Edge qui è in modalità di debug vedete che questa roba che scorre qui è la comunicazione con il con la shell qui sotto ok adesso sono in contatto infatti vedete che in realtà c'è un server locale attivo che questo localhost c'è eccetera che è stato lanciato da platter ok vedete che a questo punto sono collegati ok adesso lo ridimensiono così che sia coerente con uno schermo di un cellulare ovviamente però chiaramente un browser può avere un aspetto qualsiasi però questa applicazione qui nasce un po' con questa idea e ah tanto posso anche vediamo se riesco con la magia di di di di di di di di di di di di di di di di qui ovviamente torniamo qui ok per cui l'applicazione è attiva ed è cioè finché gira l'applicazione qui noi siamo in realtà bloccati dentro Run app che è se volete sempre un parallelo con Win32 per avere un punto di riferimento Run app è la vostra message path ok quindi message path è quel ciclo infinito che hanno fatto che processare i messaggi Run app la stessa cosa per la vista ha lanciato un widget che l'oggetto schermo l'interfaccia in una fratta sono tutte composizioni posizioni ad albero di qui per cui la finestra principale è a sua volta un widget che è composta di tanti che la loro volta possa essere quindi una cosa a cascata anche potenzialmente molto complessa però è bello perché è molto coerente quindi ecco è come con le guinte da due che alla fine una finestra un edge window è equivalente a un pulsante che sono comunque due finestre per quanto riguarda concettualmente per le guinte da due su fra 3 sta interessa cosa ovviamente tutto è un widget infatti noi adesso stiamo eseguendo questo mai è un che è questa interfaccia che vediamo qua come fatta mai app è fatta in questa maniera qui per funzionare estende un oggetto base di frattere che lo status widget quindi widget senza stato poi adesso vedremo chiaramente cosa si intende con questa cosa qui che al suo interno fa una serie di operazioni potenzialmente anche molto complesse per semplificare un attimo ci mettiamo la semplificiamo un attimo per togliere un po di queste cose qui quindi la riduca proprio all'osso così partiamo proprio da zero senza avere queste queste cose di base perché di base perché fondamentalmente un widget di flutter ha un singolo metodo di cui fare la vera ed è il metodo build quindi ogni widget ha come capacità fondamentale quella di sapersi costruire cioè poter costruire i suoi componenti tra virgolette e quindi qualche modo andare a preparare il sotto widget di quel composto e ritornarli a chi ha chiamato il widget stesso quindi la nostra my app che è il nostro widget così generale quando si deve costruire non farà altro che fare delle operazioni interne di qualsiasi natura esse siano e poi ritornare un widget che è l'oggetto che la rappresenta ok quindi stranamente un widget costruendosi genera un altro widget cosa è un po strano bisogna portare una modalità perché questo perché un widget quando si costruisce in realtà va a costruirsi componendosi con altri widget quindi chiaramente quando faccio build di un widget ottengo un altro widget che è un widget più complesso come talmente ok diventa più chiaro strano facendo chiaramente semplificiamo un po qui il codice togliamo questa roba qui che non ci interessa e la lasciamo ancora qui materiale per un secondo la home qui la semplifichiamo con l'accetta e ci mettiamo semplicemente un text e facciamo ciao ok salvo e adesso notiamo che ho appena salvato posso fare hot restart nel grafico intornando nella nella console se faccio r minuscolo o r maiuscolo si rilancia tutto e a destra il browser si aggiorni al secondo mettendoci il testo testo molto brutto però è pur sempre un testo questo hot restart funziona perché nel browser qui c'è tutto l'eseguibile cioè c'è l'ambiente di esecuzione di debug di flutter e al suo interno carica in pancia tra virgolette quello che è flutter il l'applicativo vero e pronto per cui con hot restart stiamo semplicemente riaggiornando il pacchetto che il flutter sta mostrando qui ok in questa maniera possiamo debuggare molto rapidamente la nostra applicazione qui il browser ci permette soltanto rifare hot restart se quando dovremo usare android vedete che ci sono ci possiamo fare realtà due operazioni hot restart e hot reload che sono due operazioni simili ma un po diverse adesso non è importantissimo la differenza è hot restart però la cosa importante è che fa ripartire l'applicazione da zero ok quindi nonostante la persona rimanga attiva qui vede l'ambiente di debug rimane nel browser rimane attivo flutter nella sua cella nella sua applicazione viene rilanciata e come se fosse rilanciata da qui ok quindi è proprio hot restart che riparte da zero ok allora a questo punto che cosa viene qui quando mai qui viene viene rannata viene lanciata da run app che cosa avviene che mai diventa il widget di primo di primo ordine della nostra applicazione e quindi quando andrà a presentarsi a schermo quindi se vogliamo fare un parallelo sempre quando avviene viene chiamata la quando arriva il messaggio web paint tra virgolette se lavorassi con quello di 32 flutter deve presentare a schermo l'applicazione e quindi cosa fa fa build di my app build va a costruire una serie di ad sotto elementi in particolare crea una material app che tra i secondi di cosa cosa cos'è che come componente più importante a la home che è la home page la pagina che viene mostrata che contiene un altro widget che è un widget di tipo text text è un altro di widget fondamentale di flutter che permette di mostrare del testo questo è il costruttore di cintex che vedete che è un costruttore molto molto importante insomma perché ha tanti ovviamente tanti tanti tanti parametri tutti opzionali sono tutte tra tra grafica quindi possiamo specificare o meno questi parametri se ci servono l'importante è passare una stringa perché text veramente deve presentare a schermo una stringa e quello è l'unico parametro posizionale che è obbligatorio ok perfetto a questo punto noi in realtà abbiamo creato un la nostra build che cosa fa la nostra build fa sì che quando c'è a livello di di albero flutter ha questo concetto che la widget di primo livello è maia maia quando viene quando viene costruito crea a sua volta un altro oggetto che si chiama material app che è un widget a sua volta quindi questo material qui veramente è ovviamente un widget magari è difficile trovare la definizione però vedete che material app è uno stateful widget quindi alla fine è un widget con stato questo non ci interessa adesso la distinzione tra stato e non stato quindi un widget che a sua volta può contenere altri widget quindi home è appunto un widget che può anche non esserci chiaramente in assenza di questo widget qui chiaramente a schermo non vedremo molto perché manca proprio quello che viene mostrato ok quindi in questo caso sparisce anche la scritta ok il fatto che qui ci sia soltanto la scritta in realtà è una delle cose che possiamo fare ma possiamo anche complicare questo oggetto qui faccio subito una prova perché un altro widget fondamentale per costruire interfacce utente è per esempio la colonna la colonna è un widget molto semplice che permette di impilare in colonna più widget quindi creeremo una colonna qui poi vedremo con più dettagli ovviamente vorrei solo per darvi un anche con la C in maiuscola ovviamente Column prende una serie di di oggetti quindi più importanti è che è la lista di oggetti che deve mettere in colonna che è chiaramente la lista di widget a sua volta quindi children in questa maniera è una lista quindi un array in sostanza ci mettiamo ciao mondo e poi ci mettiamo anche una seconda riga salvo anche qui l'auto formattamento fa un po' quello che vuole ok abbiamo fatto due righe tutte estremamente brutte però poi vedremo perché perché non c'è ancora un widget che dà lo stile grafico alla nostra applicazione però poi lo vedremo però già vedete in qualche modo basta combinare gli elementi e e e e e si crea un'interfaccia grafica abbastanza in maniera abbastanza intuitiva diciamo così notate che questa build qui quindi quindi non ha uno stato interno cioè nel senso stato interno intendo proprio dei campi in cui memorizzare dei dati quindi qui non c'è non c'è un i uguale 0 non c'è ci sono dei campi dove mettere dello stato che la nostra applicazione quando è in esecuzione dovrà a certo punto per essere utile all'utente dovrà in qualche modo mostrare qualcosa a schermo che sia interattivo no si può supporre per essere interattivo qualcuno deve prendersi la briga di memorizzare lo stato dell'applicazione cioè avere in qualche modo un oggetto una classe una stringa un qualcosa una variabile una creatura dove mettere le cose rilevanti per l'utente lo state test widget non permette di farlo cioè lo state widget per sua natura si presenta all'utente sempre la stessa maniera cioè non può essere alterato perché a state list quindi in assenza di stato il suo aspetto il suo aspetto per l'utente è sempre lo stesso quindi questo widget qui ogni volta che lo creiamo ogni volta che possiamo build sarà uguale perché questi due testi qui non cambiano mai giustamente sono fissi tant'è che in realtà ve lo suggerisce anche il nostro amico frattere il nostro amico frattere il nostro amico dart in realtà vi suggerisce di usare const perché questi stream qui sono già note a tempo di compilazione per cui perché non pare prima e definire tutta questa lista come costante se c'è anche la colonna può essere costante sì tutto questo blocco può diventare const questo quindi non serve più ok adesso ho creato una colonna costante di testi costanti ok usando il const di dart perché sono sicuro che questa colonna questo testo e questo testo non cambierà mai quindi ogni volta che presento ma io ho parlato di schermo ogni volta che il flutter fa build non dovrà fare assolutamente nulla perché quella quella finestra ha sempre lo stesso stesso non so perché sia allargato in questo caso esploso del tutto bene ops beh, è esposto bene eseguiamolo ok, torniamo un attimo all'esempio di base della nostra che ci ha dato che ci ha dato il flutter ripulisco un po' il tempo è poco per cui un po' di commenti per chiarezza vedete che adesso poi vediamo in dettaglio cosa sta venendo però la la il codice diventa annidato in maniera abbastanza importante e abbastanza rapidamente ok, aspettiamo che qui vi segua di nuovo e vediamo che cosa avviene qui dentro allora prima abbiamo fatto un esempio con una colonna con due testi chiaramente era un esempio molto molto banale eh l'esempio di base che crea flutter create è lievemente più sofisticato perché ehm maier che è il vostro la finestra in qualche modo include una my home page che è il widget che contiene la home page questa home page qui è diversa dalle altre perché è uno stateful widget quindi è un è un widget che contiene lo stato quindi ignorate un attimo questa cosa qui eh fate finta che non ve l'ho detto niente eh comunque anche questo widget qui questa questa questa questa my home page quando dovrà presentarsi schermo dovrà fare dovrà eh eh cioè verrà chiamato il metodo build il metodo build di my home page creerà interfaccia utente e no se interezza questa interfaccia utente è un pochino più sofisticata del di prima perché è composto da tanti piccoli elementi che è un po' come parte perché usa uno scaffold lo scaffold è un oggetto di base del material design ed è quello che vi dà l'interfaccia di base di android in sostanza quindi la barra la cosiddetta è bar in alto colorata e poco altro in realtà in questo scenario la prima parte la vediamo meglio l'ho fatto senza ricompilare vediamo se ce la fa cosa di molto strano che ci dà errori a profusione riserviamo il numero zero mi dispiace questa cosa è ho fatto qualche errore profondissimo ma visto che sono tornato all'esempio di base in questo video ci vediamo per compilare e dovrebbe farcela ok, mentre aspettiamo allora come è fatto il nostro scaffold scaffold è l'imparcatura di base che ci permette di avere un'interfaccia di base di android è composta da una serie di costocomponenti abbastanza ampia purtroppo quindi ha mille parametri quello più importante è body che è il corpo della finestra app bar che è la barra in alto protein action button è il pulsante sotto a destra che galleggia soprattutto il drawer è il pannello laterale che viene tirato dentro col dito col trascinamento poi c'è button action bar che sono i pulsanti sotto e così via quindi sono vari componenti che potete utilizzare ma sono tutti opzionali quindi potete anche tralasciarli se volete in questo caso abbiamo tre componenti in realtà della nostra che sono l'app bar che è la barra in alto che è composta da un tiso fondamentalmente poi il corpo che è body che mostra del testo a schermo appena parte lo vediamo di nuovo e il floating action button che è un pulsante che appare sotto a destra e ci permette di interagire con la nostra applicazione questo va di qui il corpo della finestra proprio è a sua volta composto da una serie di widget di base alcuni quali già conosciamo quindi il body è a contiene un widget center il widget center non fa altro che espandersi per quanto possibile e poi centrare al suo interno il widget che contiene quindi è un accentratore di altri widget in cascata chiaramente il center avrà un singolo child quindi l'oggetto figlio che sta centrando il suo schermo child è una colonna colonna è un widget che mette in colonna altri widget lo sappiamo già per cui colonna avrà un elenco di children che è un array di widget qui sono due testi esattamente come prima uno è un testo fisso e l'altro è un testo che mostra un contatore che adesso non ci interessa come fatto però ho ripartito ok perfetto quindi questo è questo lo scaffold questo è il titolo il text questo qui questo è body ok ah tra l'altro possiamo anche testare stogliessimo center qui Android Studio ci da una serie di di strumenti di supporto e lo fa anche questo studio code per cui se vogliamo togliere center come widget con control spazio il secondo fa l'ha fatto per cui ok possiamo fare remove this widget ok e ce lo toglie dalla pila di widget e rimane il widget che è contenuto quindi rimane la colonna ok quindi ha tirato fuori la colonna non so se avete visto center è stato rimosso come anche child che è quello che compone il widget e siamo arrivati a colonna se ristarto questo avviene che che il contenuto non è più centrato ok come effetto quindi giusto per prendere conferenza un po' con i widget poi li vedremo in dettaglio chiaramente però per farvi vedere un po' come funziona se tolgo il center cosa avviene che il widget è ancora perfettamente valido semplicemente non è più spostato al centro dello schermo quindi il center non ha altro effetto se non prendere un widget e mostrarlo in chiave ovviamente diversa rispetto a prima stessa cosa vale per vabbè colonna anche a varie opzioni che ci permettono di impostare come gestire i vari i vari sottoggetti e così via Sì, io posso sapere che dovessimo ricaricciare se dovessimo ricaricciare il quadro avremmo esatto lo vediamo un secondo dovrebbe essere esattamente così e cioè in realtà ah giusto alla colonna allora questo poi vediamo meglio la prossima volta però l'asse di avviamento in realtà è quello verticale perché la colonna ha linea su quell'asse lì per cui l'avviamento adesso è centrale in termini verticali in realtà per cui questo togliendolo vale in quel senso però sì, ha effetto in un'ina e la colonna si espande in automatico su tutto lo spazio disponibile però quello poi ne parleremo meglio abbiamo ancora 7 minuti per cui sono andati lunghi anche questa volta vediamo rapidissimamente come funziona la costruzione perché questa applicazione per quanto semplice in realtà fa delle operazioni già non banalissime per cui se clicchiamo qui sul nostro floating action button effettivamente si incrementa quel quel numeretto di adesso è estremamente lento quindi lo fa con estrema retrosia ok, retrosia ma ce la fa ok, come funziona questa cosa qui? allora funziona perché da qualche parte nella nostra applicazione c'è qualcuno che tiene traccia dello stato cioè lo stato in questo caso che cos'è? è quante volte l'utente che clicca alzo è utilizzante e quindi qualcuno deve tener traccia di questo dato e metterlo in memoria lo fa la nostra My Home Page la nostra My Home Page la nostra My Home Page in realtà è composta da due classi e questo è l'elemento che confonde un po' perché My Home Page è uno Stateful Widget che ha una classe, diciamo così, sorella per virgolette che è lo stato una classe fratello, diciamo così che è lo stato di My Home Page ok, quindi immaginate che c'è il widget che si presenta a schermo che ha come compagno in qualche modo il suo stato quindi è una classe pacchetto che non fa altro che tener traccia del contatore quindi qui il contatore viene assegnato a zero inizialmente quindi quando avviamo l'applicazione quando faccio hot restart lì compare ovviamente zero perché ho ripartito da zero quando clicco sul pulsante qualcuno fa in modo che l'interfaccia si aggiorni che cosa avviene in particolare? che quando clicco sul pulsante il pulsante ovviamente ha una serie di opzioni varie il tooltip che è quella cosa che compare incremento sullo schermo l'icona che è il più e va bene ma soprattutto c'è on pressed quindi c'è una funzione quindi una function a qualcosa che è quella che viene invocata quando clicchiamo sul pulsante questa funzione qui è implementata dentro la stessa classe che è dentro lo stato che cosa fa? non fa altro che incrementare il contatore quindi incrementare il porto a contatore a uno, poi a due, poi a tre e così via e segnala a Flutter che qualcosa è cambiato perché lo fa dentro un metodo che è setState setState è un metodo della classe state vediamo un attimo setState è un metodo più o meno mistico di state ed è praticamente uno dei pochi che state espone che segnala allo stato guarda mi sto aggiornando dopo che setState è stata invocata e conclusa ti puoi aggiornare l'interfaccia utente perché qualcosa è cambiato nello stato dell'applicazione è cambiato in particolare il contatore che cosa viene in particolare? quindi quando il contatore viene aggiornato e setState ha concluso la sua esecuzione a quel punto Flutter sa attenzione, lo stato di MyHomePage è stato modificato per cui mi tocca ricostruire MyHomePage quindi MyHomePage viene ricostruita come viene ricostruita? beh, chiamando il metodo build la differenza è che mentre uno status widget ha il metodo build direttamente nel widget quindi questo è il status widget che già ha il suo metodo build direttamente al suo interno perché? perché non ha stato quindi non avendo stato viene costruito sempre alla stessa maniera quindi ogni volta che invoco build di questa classe qui mi aspetto lo stesso risultato questa cosa non avviene per un widget che invece ha dello stato perché ovviamente l'aspetto del widget dipende dal suo stato interno banalmente se il contatore può essere modificato qui devo mostrare il contatore aggiornato ok? quindi quando faccio build dello stato a questo punto quindi la differenza fondamentale è che il metodo build non è sullo stateful widget direttamente ma è sullo stato legato allo stateful widget ok? quando faccio build su questo metodo qui ricostruisco tutta l'interfaccia grafica e lo faccio portandomi dietro il valore del contatore ossia quando vado a creare qui center la colonna e così via nell'ultimo text di questo blocco qui in sostanza vado a metterci il valore del contatore ok? quindi quando clicco sul più avviene una serie di operazioni tutt'altro che intuitive perché io clicco qui viene invocato questo metodo qui questo entra dentro state state e quindi dice a platter attenzione sto per chiamare lo stato platter si inchioda completamente per dei nanosecondi chiaramente qui posso ho l'opportunità di chiamare lo stato quindi posso metterci quello che voglio chiaramente potrei fare cose molto complesse di questo è qui incremento il valore quando se state ha completato platter si riprende e dice ok riprendo ad eseguire cosa è cambiato? è cambiato ricostruisco myon page state evidentemente il suo aspetto non è più coerente con il suo stato interno e quindi faccio build a questo punto ricostruisco tutta l'interfaccia grafica quindi ricostruisco lo scaffold, la bar, center, column, text e così via fino ad arrivare a questo qui che in realtà è l'unico text che è stato modificato veramente e quindi l'effetto finale è che qui io clicco e qui si incrementa l'1 ma se immaginata cosa avviene sotto banco è che tutta l'interfaccia viene ricostruita nella sua interezza eccetto myon questa classe qui non viene rebuildata perché non c'è bisogno perché questa qui è stateless, non dipende dallo stato di myon page quindi non c'è bisogno di fare build viene fatto build soltanto di myon page soltanto come vuoi dire perché in realtà myon page copre tutto lo schermo quindi in realtà facciamo un... ridipingevo in maniera integrale però è esattamente quello che facevamo con le Win32 le Win32 quando cambiava lo stato interno dell'applicazione perché cambiava, non so, messaggio, il pet cliccava e così via cosa facevamo? facevamo, se ricordate, in maniera molto brutale facevamo invalidate rect di tutta la finestra quindi era hwindow null perché non passavamo un rettangolo in particolare e poi true perché volevamo ridipingere tutto quindi facciamo esattamente questo diciamo fra l'altro il contenuto del widget non è più valido, è invalidato ridipingilo la ripittura quindi la gestione del messaggio paint è questa cosa qui se abbiamo dei paralleli con Win32 sono paralleli un po' azzardati perché non è che funziona la stessa maniera però concettualmente siamo siamo un pochino lì quindi abbiamo invalidato il widget e il widget va ricostruito e lo fa Flutter per noi invocando il metodo è l'una per cui già è troppo tardi questa è una cosa molto molto arcana se non avete esperienza con cose che hanno un pochino questo aspetto quindi magari react, swiftui e Flutter stesso quindi è un po' spiazzante immagino come meccanismo però dalla prossima volta in poi vedremo sempre più in dettaglio come funziona e farrete a conoscere i tagli più scapulosi di Flutter e capirete in dettaglio come funziona e come gestisce questo atto di ricostruzione della sua interfaccia grafica questo è molto inefficiente perché chiaramente quando fa rebuild qui ricostruisce tutto quanto il blocco qui il nostro scopo andando avanti nelle prossime settimane è di farlo in maniera efficiente andando a ricostruire soltanto i piccoli elementi di interfaccia che veramente cambiano perché vorremmo fare in modo che soltanto questo blocco qui venga modificato perché effettivamente quel valore lì ovviamente cioè questo questo count qui caso counter scusate ha effetto soltanto su questo blocco di adesso qui in questo momento io sto bellamente ricostruendo tutto quanto l'interfaccia ma lo posso fare perché chiaramente è un'interfaccia abbastanza primitiva e quindi mi costa pochi millisecondi quindi non è un problema però poi per rendere cose efficienti dovremmo fare in modo che l'interfaccia si aggiorni in maniera efficiente e precisa però questo è quanto direi che vi lascio così con questo template di base e all'altra prossima andremo a vedere più in dettaglio come funziona se avete dei dubbi così amletrici su questo immagino tanti nel suo dettaglio e quindi vi lascio alla prossima però ecco qui rimaneremo con il dubbio per il weekend con il dubbio per il weekend si lo presento? si no che in pratica è un errore di persone qui al posto di andare a scrivere le tecniche di fai lo detto della graffa della cui e in pratica è un'interfaccia di perché però è proprio un progetto ah si? ok non ci sta anche per Flutter no allora sarebbe bello no allora Flutter non ha non l'abbiamo visto abbiamo visto rapidamente una lezione di teoria però per arrivare a Flutter cioè si è passati con un periodo in cui si è andato a farla maggiore l'uso dei designer per fare le interfacce con drag and drop ed è quello che si fa tuttora con Windows Forms e così via e anche con WPF, UVP per Windows e così via su Flutter non esiste questa cosa per cui l'interfaccia si crea integralmente in codice ma tu pensavo perché diciamo che no avremmo tanto dei covettari e si sa che non credo che lo vede ecco si allora no in realtà questo è parzialmente vero perché esistono dei convertitori è possibile fare interfaccia in gli strumenti design tipo Figma e Adobe quindi si cioè Figma e c'è anche Adobe XD per la stessa cosa quindi ci sono vari si Figma è supportato anche Adobe XD per cui lì potete fare interfaccia reale dente con drag and drop con strumenti design umani e non questi no in realtà il problema di fondo è anche questo che se date in mano a un designer che giustamente non sa programmare non sa programmare poi l'interfaccia grafica con Flutter non è possibile farlo per cui se la parola è intime uno si occupa del design l'altro si occupa del codice come fai a fare il codice questa roba qui serve uno strumento che permette di esprimere in maniera astratta per un designer queste cose qui e lì si usa appunto Figma o Adobe XD che poi hanno un pulsantino per convertirlo in codice che non è che fanno un lavoro eccezionale però di solito è quanto basta per avere qualcosa che funziona poi si può adattare ovviamente però sì esiste una base su cui volendo si può fare però adesso noi quando faremo fra l'altro te lo tu andiamo a mano tanto pensavo di essere più somigliato a un designer non come in un paramento dei vari blocchi però la realtà è una cosa che non è in realtà non tanto no? c'è qualche somiglianza vaga c'è volendo però si ferma lì si no in realtà qualche somiglianza c'è con con Flexbox perché il tratamento Flutter una cosa che somiglia a Flexbox quindi se una esperienza di Flexbox in CSS quello se lo ritrova quantomeno però ecco lì si ha la bella suddivisore in HTML, CSS e JavaScript qui è tutto d'arte è tutto d'arte quindi da questo punto di vista è un po' si si quindi usi d'arte per la logica e anche per la guida di direttamento quindi è proprio un solo linguaggio per tutto in sostanza questa è un po' l'idea altrettanto se la due attività no no no adesso vedremo non è così arcano come sempre adesso però è un salto bisogna prendere un po' confidenza perché ma anche perché è un lavoro di unico e lavorare con le due con le cose perché è un gioco ok ok ok allora in tal caso sì sì sì non bisogna fare nulla di nulla di incredibilmente sfavillante basta che scrivo cosa a schermo insomma alla fine che poi non è un salto ok io chiudo e saluto anche online che è rimasto buona fine settimana sì sì sì