l'ambizione. Allora, riavitoliamo un attimo quello che abbiamo visto fino adesso per quanto riguarda la Win32, vi ricapisolo un paio degli elementi fondamentali di come funzionano il message passing e tutte le altre procedure fondamentali di Win32, così appunto come dicevo riusciamo a concludere tutta la carrellata entro stamattina con gli ultimi esercizi, dopodiché ci spostiamo verso lì di ben più gradevoli e appunto bisogna lasciarci dietro a queste cose un po' obsolete, diciamo così. E prima di passare a questo, eravamo arrivati a questo punto qui, in sostanza, adesso che eravamo riusciti a, cioè siamo riusciti a creare l'elemento fondamentale delle Win32 che sono le finestre, ovviamente, per cui l'elemento primario con cui interagiamo sono le finestre, abbiamo visto come si creano, abbiamo visto che la cosa particolare è che ogni finestra appartiene ad una classe che la identifica in qualche modo e che la descrive in una certa misura, per cui alcune cose appartengono alla classe di finestre e alcune cose invece appartengono alla finestra nello specifico. Se ricordate, la classe della finestra determina l'aspetto del cursor del mouse quando ci passa sopra, lo sfondo, l'icona, il funzionamento, quindi in realtà determina la funzione che andrà a gestire i messaggi di quella classe di finestre. Poi, indipendentemente dal numero di finestre che abbiamo, tutte hanno la stessa cosiddetta window procedure, quindi la stessa procedura che processa i messaggi. E invece le simboli finestre, ognuno chiaramente ha una sua posizione, ognuno può avere una sua dimensione sullo schermo, ognuno può avere un titolo diverso, questo perché la caption, una cosiddetta caption, il titolo in alto è determinato alla creazione della finestra, non appartiene alla classe, ma alla simbola finestra. E poche altre cose che abbiamo visto in realtà. Quindi questo è dove siamo arrivati, poi chiaramente abbiamo sdiranzato un attimo, abbiamo visto come si, quali sono i messaggi che arrivano, come si interdisce con il mouse reagendo ai messaggi che ci arrivano, e questo lo vedremo ancora in dettaglio oggi. Però per parlare un po' su quello che abbiamo visto, abbiamo visto appunto come si crea una finestra, come si elaborano i messaggi, quindi come si affronta il cosiddetto message pumping, quindi proprio quel paradigma di Wint32, per cui c'è un thread che rimane in attesa in un ciclo infinito, che non fa altro che andare a leggere la cosa dei messaggi e poi lavorarli ad uno ad uno. Questa message pump cosiddetta permette al nostro programma di vivere, permette al programma di ricevere messaggi dal sistema e di riflettere questi messaggi nel comportamento delle finestre. Quindi per ricapitolarlo in generale, ogni finestra che creiamo è legata necessariamente al thread che l'ha creata, quindi quando noi lanciamo il nostro processo, il nostro programma, abbiamo un singolo thread di esecuzione in genere, e quel thread andrà a creare le varie classi di finestre e poi andrà a creare le varie finestre di cui hai bisogno. Ogni finestra quando viene creata, quindi al momento del lancio della funzione create window che abbiamo visto, quella finestra è legata al thread che l'ha creata. Quindi c'è un legame di univoca in qualche modo e quindi quello stesso thread è responsabile per l'elaborazione dei messaggi, quindi deve mettersi a tutto punto a elaborare i messaggi e a reagire a questi messaggi con questo sistema della message pump. Se il nostro thread si impunta per una ragione qualsiasi, abbiamo fatto la prova nel laboratorio la volta scorsa con una sleep buttata lì dentro la window procedure, quindi quella sleep bloccava il thread della message pump e quindi la finestra diventava non più responsiva, quindi a un certo punto Windows la identifica come non più attiva e quindi la gestisce in un certo modo per renderlo evidente all'utente, perché quella finestra non è più capace di reagire agli eventi del sistema. Quindi a livello concettuale questo è il grafico che rappresenta questo concetto. Questa situazione per cui c'è un thread che gestisce una serie di finestre e gestisce una coda dei messaggi, tutta questa impalcatura in Win32 si chiama apartment, quindi è l'appartamento della finestra, per la metafora della finestra che in qualche modo è collocata in un appartamento molto concettuale, quindi il thread si occupa di un edificio che ha più finestre, se vogliamo una metafora un po' approssimativa, e quindi quello single thread gestisce tutta la casa in qualche modo e deve occuparsi dei messaggi di una o più finestra, potenzialmente. Gli apartment in Win32 sono quasi sempre single thread, quindi Win32 sono nate in un ambiente in cui il multi-threading era ancora abbastanza, dovrebbe ancora venire in qualche modo, essere ancora concettualizzato molto bene, per cui tutte le Win32 partono dal presupposto che è chiaro che le applicazioni possono avere più thread, più processi di esecuzione, però per quanto riguarda l'interfaccia utente, se ne occupa sempre e soltanto un thread. Quindi lavorare con gli oggetti della Win32 da più thread è sempre una pessima idea, perché poi le cose si rompono con una facilità molto, insomma, con grande facilità, quindi da evitare assolutamente. E questa cosa è vera per la Win32, ma è vera per la maggior parte dei framework di interfaccia utente. La maggior parte dei framework parte dal presupposto che ci sarà sempre un singolo thread che si occupa di interfaccia utente, perché è molto difficile rendere un framework di interfaccia utente compatibile con un approccio multi-threaded. Per cui in genere si ha un singolo thread che fa tutte le operazioni di interfaccia utente, poi se c'è bisogno di fare qualcosa in background o in maniera concorrente, ci saranno dei cosiddetti worker thread, dei thread di lavoro, che si occupano di altre cose, ma non andranno mai a interagire con i interfaccia utente. Per cui se dovete delegare il lavoro a un thread secondario, in genere questo fa il suo lavoro e poi rimpalla eventuali messaggi, eventuali notifiche al thread principale che poi si occuperà di mostrare la schermo. Questo vale anche per Flutter, quindi anche Flutter nasce in un ambiente single thread, perché in realtà Flutter ha due thread principali, però non cambia molto la sostanza, quindi c'è un numero di thread ben definito che si occupa di aggiornare l'interagio utente e poi tutti i dati che volete che si occupano di fare il lavoro. Però c'è questa distinzione fondamentale per evitare che si rompano le cose, cosa che capita molto rapidamente senza che non si accorge il programmatore, perché magari gli errori possono capitare a runtime in base alle famose race conditions che non sempre si notano. Per evitare questo problema alla radice si evitano questi contatti tra il thread. La coda di messaggi che vi citavo la volta scorsa, quindi c'è una coda di messaggi per ogni thread di interfaccia utente, quindi per ogni apartment del Win322 c'è una coda di messaggi, quindi in genere per ogni processo che lavora con le Win322 c'è un apartment e quindi c'è una coda di messaggi. E la coda di messaggi è una semplice coda a priorità. Vi citavo la volta scorsa che alcuni messaggi hanno priorità più elevata rispetto ad altri, questo capita in particolare per i messaggi di interazione dell'utente, quindi se l'utente clicca o l'utente scrive qualcosa con la tastiera o fa delle attività, quei messaggi in genere sono più importanti ovviamente rispetto ad altri messaggi di sistema che possono essere elaborate con più comodo. Però in generale si comporta come una classica coda FIFO in sostanza. E la vostra message pump, quindi questo ciclo infinito che poi va a invocare la window procedure, non fa altro che andare a prendere i messaggi ad uno ad uno e poi gestirli in qualche modo. Una volta che sono gestiti vengono scartati dal sistema. Il messaggio che abbiamo già visto ha questo formato qui. In realtà abbiamo già visto in parte, abbiamo visto i primi quattro parametri che sono quelli più rilevanti in sostanza e sono i parametri che arrivano alla vostra window procedure. Quindi se ricordate la window procedure ha una firma, una signature che sono quattro parametri, il punto sulla finestra, il messaggio, quindi l'intero che codifica il messaggio e poi due parametri così, jolly, uno è wide, l'altro nonche, però appunto sono degli interi che poi possiamo gestire in base a quello che ci interessa. In più ci sono due campi in più che non avevamo visto ma esistono, quindi se volete andare a vedere poi il blocco messaggio, ci sono anche questi, c'è la timestamp del messaggio quando è stato spedito e poi un punto che identifica dove era il cursore nel momento in cui quel messaggio è stato inviato. Questo non è molto rilevante, però c'è per ragioni storiche, quindi potete vedere dove era il mouse nell'istante in cui quel messaggio è stato inviato. Attenzione che sono due cose distinte perché ci sono alcuni messaggi che vi segnalano il click del mouse, per esempio, avete visto l'altra scorsa c'è WM, L button up e L button down per segnalare il click del mouse. Lì le coordinate del mouse sono dentro, detto Wparam, uno dei due parametri contiene le coordinate X e Y del mouse che potrebbero essere diverse dal punto sotto, nel senso del messaggio, perché le coordinate che ci sono segnalate sono il punto esatto di click del mouse nel formato che interessa la nostra applicazione, soprattutto nelle coordinate della nostra applicazione, quindi all'interno dell'area client della nostra applicazione. Il punto sotto, invece, può essere un post-fasato, perché il messaggio magari viene elaborato successivamente, quindi il cursore si è già spostato al frattempo, e soprattutto quel punto è in coordinate di schermo. Quindi sono coordinate globali dello schermo che dovreste rimappare sulla vostra schermata. Ok, qui in realtà rivediamo cose da vista, quindi questa è la faccio breve, quindi queste sono le classi della finestra che abbiamo visto che sono le categorie di finestre che possiamo registrare e poi creare. La window procedure, appunto, è questa funzione di procedura, questa funzione che elabora tutti i messaggi di tutte le finestre di quella specifica classe, quindi lo specificiamo una volta, e poi tutte le finestre vengono gestite di quella classe, chiaramente vengono gestite tramite questa callback, questa funzione, che poi farà il suo lavoro interno. Questo meccanismo qui, cioè l'idea di avere tante finestre che possono appartenere alle stesse e medesime classi, ci permette di componentizzare la nostra interfaccia. L'idea è che il programmatore che lavora con le 1532 può destrutturare la propria pubblicazione in tante piccole finestre che si comportano alla stessa maniera perché appartengono alla stessa classe fondamentalmente. Per cui finora abbiamo sempre fatto classi principali, classi di finestre, principali, quindi occupano lo schermo e fanno tutto il lavoro internamente, però potete immaginare appunto di, non so, avere dei pulsanti, dei sottocomponenti e così via, che magari potete delimitare in delle sottofinestre della vostra finestra principale. Questo ancora non l'ho ancora fatto, ma vi avevo accennato anche questo in qualche lavoratore precedente, possiamo, almeno c'è l'idea di creare delle finestre figlie, delle finestre principali, che si comportano esattamente come delle finestre principali, però occupano uno spazio minore all'interno delle finestre che già esiste. Quindi comunque si comportano esattamente alla stessa maniera, cioè sono finestre di effetti, hanno una loro classe di finestra, hanno una loro window procedure, perché c'è una funzione da qualche parte che gestisce gli eventi, però appunto sono dei piccoli componenti che poi possiamo riciclare. Un esempio di questi componenti classici, gli UI, sono i pulsanti, o tutti gli altri elementi di base, di un'interfaccia già visto, insomma, da Q32, quindi il combo box, text box, tutti questi elementi che poi vedremo in dettaglio, che vi permettono di interagire con l'utente senza dover programmare a bassissimo livello l'interazione con l'utente. proprio perché abbiamo una classe generale di componente UI che possiamo riciclare, a quel punto possiamo creare tante istanze della stessa classe, quindi possiamo creare tanti pulsanti, tanti componenti simili, ma poi chiaramente diversi in runtime, perché sono istanze diverse, però condividono lo stesso comportamento, grazie al fatto che hanno lo stesso window procedure. Un'altra cosa che si può fare, e questo non lo vedremo in realtà, perché è un po' sofisticato come approccio, però in effetti è possibile, se immaginate, voi conoscete i livelli di programmazione a oggetti, quindi sapete il concetto di classe, che è la definizione di un'interfaccia, di un oggetto, e poi della stessa classe potete instanziare tante istanze diverse, quindi tanti oggetti diversi che vivono in maniera a sé stante e però condividono lo stesso comportamento, che condividono gli stessi metodi di base e i stessi campi. Nel caso delle classi di finestra, l'idea è esattamente la stessa, cioè avete la definizione di classe di finestra che condividono lo stesso comportamento, cioè condividono la stessa window procedure, e poi potete instanziare tante istanze che hanno vita propria, ma hanno lo stesso comportamento, quindi questa è l'idea di fondo. Oltre a questo, come si può fare in C++, C++ e così via, è anche possibile definire delle sottoclassi di una classe che non esiste, quindi potete derivare da una classe e definire una classe che eredita i metodi, la classe madre, diciamo così, della classe da cui deriva, e però può sovrascrivere alcuni metodi o estendere il comportamento in qualche modo. Si può fare la stessa cosa anche con le WIN32, nonostante non si usi un linguaggio, a oggetti, quindi nonostante C sia un linguaggio che non, cioè di base, non offre nessun strumento per modellare questo approccio qui, le WIN32 però sono ragionate a oggetti, se vogliamo, per cui possiamo appunto lavorare oggetti, creare classi di finestre, creare istanze di finestre che sono istanze di una classe, se volete, e poi si può anche estendere una classe di finestre con comportamenti aggiuntivi. Come si fa? Creando un'altra classe che deriva e semplicemente per tutti i comportamenti che non vuole sovrascrivere, invoca DEF-Window-Proc, che se ricordate era la procedura di finestra di default che abbiamo usato più volte nel nostro codice, che è stato in pratica, se ricordate la volta scorsa abbiamo fatto alcuni esperimenti creando una procedura della nostra finestra, qui in fondo alla procedura alla fine chiamavamo DEF-Window-Proc proprio per così, per dire tutti i messaggi che io non gestisco li faccio gestire alla procedura standard. Questo nel caso delle classi, nel caso di questa classe, questa DEF-Window-Proc chiaramente non fa nulla perché nel senso è la window procedure di default di Win32 che non fa altro che prendere il messaggio smistarlo, buttarlo via e poi non farci nulla. Quindi questo in genere non fa praticamente nulla però è vero che cosa di immaginare di avere una catena, se volete, di window proc, quindi di funzioni di questo genere qui, ognuna delle quali poi la catena chiama la precedente. Quindi potete avere delle sottoclassi di classi di finestra e quindi per esempio immaginate di sovrascrivere la procedura del pulsante per dire del pulsante in pratica diciamo di azione magari più chiara blocco note è un buon esempio, blocco note è in faccia molto primitiva. Se facciamo se cerchiamo di rimpiazzare o cercare il testo qui dentro questa interfaccia che però non si apre perché questa interfaccia qui è composta da una piccola finestra qui sono dei textbox si chiamano questi sono dei checkbox questi sono dei button ok? Queste sono tutte interfacce standard di Win32 ognuno di queste ha una sua window procedure che gestisce il comportamento il fatto che cambi colore e così via se noi vogliamo possiamo cambiare questi pulsanti e creare una sottoclasse di pulsante che magari alcuni messaggi li gestisce in maniera particolare proprio il resto delega il comportamento alla window procedure standard del pulsante di Win32 quindi questo si può fare si può creare un pulsante custom nostro che magari cambia il tipo di testo risponde e così via però per tutto il resto quindi tutti gli altri comportamenti quindi tutti gli altri messaggi che arrivano alla finestra possiamo delegarli alla deaf window proc del pulsante di Win32 che farà le varie attività che stanno per animare il pulsante ok? Quindi concettualmente è un sistema orientato agli oggetti che permette di fare molte delle cose che i linguaggi orientati agli oggetti permettono di fare nonostante bisogna farle a mano purtroppo perché il linguaggio non ci permette di fare niente specificato bisogna fare tutto quanto con le primitive del linguaggio C quindi non è fortemente rapido ma si può fare un po' abbiamo visto la paint appunto come si colora una finestra è tutto reattivo ricordate per cui si dipinge una finestra soltanto quando Win32 vi chiede rifarlo quindi quando arriva il messaggio di dipingi finalmente e per segnalare a Win32 che vogliamo aggiornare una finestra non possiamo farlo in maniera esplicita bisogna invalidare la finestra eventualmente segnando alcune regioni non più pronte non più valide a quel punto Win32 ci farà ridipingere la finestra due note a margine qui perché sono rilevanti fino a un certo punto però mi auguro che poi non userebbe le Win32 in pratica però in alcuni casi quando si usa le Win32 comunque la natura delle Win32 sottostanti diventa evidente anche chi le usa con linguaggi più avanzati quindi in particolare se userete Windows Forms o altri altri framework più avanzati per lavorare su Windows chiaramente le proprietà delle Win32 sottostanti a volte sono trasparenti si vedono e ci si sbatte per virgolette per cui due cose importanti a un certo punto però rilevanti allora quando abbiamo delle finestre e delle finestre figlie quindi quando andiamo a midare delle finestre dentro l'altra finestra quello che avviene è che c'è il window clipping automatico ossia le finestre le finestre figlie tagliano quindi clippano se si direbbe via le regioni nella finestra madre ossia la finestra madre non riesce a dipingere sotto le finestre in cui ci sono delle finestre figlie quindi per fare l'esempio di prima del nostro blocco nota che è un buon esempio qui dentro questa finestra qui questa finestra qui che è la finestra madre la finestra replace contiene delle finestre figlie e queste finestre figlie ritagliano quegli spazi dove la finestra replace non riesce più a dipingere quindi sotto il pulsante quell'area lì effettivamente è clippata via per ragioni di efficienza quindi in quella zona lì ci potrà dipingere soltanto il pulsante la finestra madre non ci può dipingere ok semplicemente quando colora lì sotto non ha alcun effetto ok questo perché la finestra ha un unico un unico singolo buffer dove un'unica un'unica tela un'unico superficie in cui la finestra si dipinge e quindi le finestre figlie vanno a dipingersi nella finestra della finestra madre direttamente per ragioni di efficienza quindi non vengono composte poi al runtime ma lavorano sulla stessa sulla stessa tela in sostanza quindi quando fanno quando queste finestre e le finestre figlie elaborano il messaggio WM Paint vanno a colorare la stessa area di memoria in sostanza per ragioni di efficienza il che significa appunto che la finestra non ha capacità novi viene tagliato via la regione di cui non ha più controllo perché c'è sopra la finestra ok questo per ragioni di efficienza quindi questo è il window clipping e questo significa anche che non è possibile usare la trasparenza tra finestre nelle WM 32 per cui quando avete una finestra che sovrappone un'altra finestra e la finestra sopra non riesce a essere trasparente perché sotto non c'è nessuno che possa dipingersi di sotto quindi tutti gli effetti di trasparenza interni alle WM 32 devono essere emulate con delle cose estremamente faticose quindi dipingendo su vari strati però è sempre la finestra figlia che si occupa eventualmente di far trasparire gli elementi da sotto quindi non quindi fare grafica un pochino più elaborata è molto difficile un intervento di quel tanto è che di solito appunto si usano altri strumenti per fare delle grafiche elaborate Flutter questo problema non ce l'ha adesso che Flutter invece è un fa cioè compone la grafica in maniera completamente indipendente per cui anche se abbiamo oggetti simili a questi quindi abbiamo degli oggetti che sono figli dei altri sottoggetti che si dipingono sopra la trasparenza è gestita e quindi anche questo problema qui non ci sono come al solito perché le Winters 2 vengono da un sistema da altri da altri da periodi diversi ok ora facciamo altre due ultime cose per vedere in dettaglio gli ultimi elementi di Winters 2 dopodiché le possiamo mettere da parte la prima è proviamo a fare una cosa di questo genere quindi una specie di pozzolo orribile che però ci permetterà di gestire i messaggi la volta scorsa abbiamo visto i messaggi che arrivano alla nostra applicazione e in particolare i messaggi legati al mouse quindi lo spostamento del mouse il fatto che il mouse può passare nelle zone che non sono parte del client quindi le parti del titolo della caption di borde e così via e tutti quei passaggi generano comunque dei messaggi alla nostra finestra adesso andremo a fare una cosa molto banale cioè andremo a interagire con il click la volta scorsa abbiamo semplicemente creato un message box per allertare il fatto che l'utente avesse cliccato o abbiamo aggiornato una label adesso andremo a gestire in maniera più sofisticata il click così da fare un'interfaccia interattiva e poi proveremo a creare la nostra prima finestra quindi andremo a creare un pulsante che è sempre una cosa molto banale ma finora non l'abbiamo fatto quindi direi che vale la pena vedere come si fa e arriveremo alla fine a una specie di non so un'applicazione che una specie di tris strano con delle sottofinestre l'idea è a quel punto che creeremo delle sottofinestre figlie fatte a mano che ci permetteranno di implementare una specie di gioco del tris poi chiaramente poi implementarlo veramente lo sarà lasciato come per il vostro diletto se proprio volete però ci fremeremo qui quindi ci fremeremo con la creazione di controlli quindi di componenti di UI con le winter quindi sperimenteremo tutti questi ultimi concetti ok vando alle ciance facciamo qualcosa e per farlo riprisco un attimo il punto che si può arrivare nel senso che avevamo preso anzi forse riparto dal nostro esempio del font quindi questo esempio qui era se ricordate era questa applicazione qui che non si vede perché è molto semplice che non fa altro che scrivere su schermo ok quindi facciamo questa cosa qui qui già reagivamo al click per cui faremo estenderemo questa cosa andando a creare una specie di nube di punti così usiamo in qualche modo il click del mouse e possiamo gestirlo in vari modi ok per farlo faccio una copia di questo così tengo traccia point e ripuliamo un attimo tutto che allora questa qui non ci servirà più la scritta la possiamo tenere volendo ma non è importante per cui direi che la mettiamo via tutta la pentria ripremo tutta da zero per questo la possiamo cancellare magari tengo giusto il get client track sappiamo quanto è grande lo schermo tutto il resto non ci interessa più poi il click qui andiamo a gestire in altro modo per cui lo tagliamo per il resto non c'è molto altro quindi qui la destroy questo serve sempre per distruggere la finestra qui creiamo la classe clicchiamo la finestra e la mostriamo questo è il nostro message path quindi il resto è tutto al solito diciamo così allora quello che dobbiamo fare è questa cosa qui questa cosa qui ossia è una lume di punti per cui l'idea è che l'utente possa cliccare sullo schermo e come al solito sullo schermo intendo sull'area client della nostra applicazione e abbiamo già visto come si regiscono come si ottengono i punti le coordinate dei punti per cui andremo a memorizzare dove l'utente è cliccato e semplicemente con un doppio loop anidato ogni volta che dobbiamo aggiornare lo schermo andremo a presentare ci andremo a creare una lube di punti collegati tutti collegati a tutti gli altri punti che poi creerà queste sagome del genere qui niente di particolarmente sofisticato però bisogna tenere traccia quindi dei punti dove l'utente ha cliccato per andare a ricordarsi da dove e a dove tracciare le nostre linee questo esercizio l'unica cosa che è utile insomma per fare questo esercizio è nel proiettarvi nella giusta nella giusta la giusta posizione mentale perché dovete ricordarvi che nel Win32 il disegno è sempre reattivo nel senso che noi potenzialmente non abbiamo mai l'occasione di dipingere finché lo schermo cioè la finestra non viene presentata a schermo per cui ogni volta che c'è una qualsiasi interazione tra l'utente e la nostra applicazione in realtà quella interazione non ha un effetto grafico direttamente bisogna ricordarsi che il click o la digitazione di un tasto o qualsiasi altra attività dell'utente è un messaggio in arrivo che viene gestito in qualche modo e se quell'attività deve avere un effetto grafico bisogna tenerne traccia e poi quando è l'occasione di dipingersi presentarla a schermo quindi non c'è una reazione immediata grafica ma la reazione è sempre asincrona perché si vedranno gli effetti del click sotto quando finalmente faremo la paint quindi c'è sempre bisogno di una struttura dati interna che tiene traccia di quello che è successo perché poi la paint deve presentare a schermo la schermata aggiornata a quel momento di quello che deve essere mostrato all'utente quindi internamente le nostre applicazioni avranno le nostre finestre in realtà avranno sempre una struttura dati più o meno sofisticata in cui vanno a rappresentare quello che è la situazione grafica della nostra questa veniva già con l'esercizio precedente con i messaggi se ricordate perché avevamo bisogno di avere un array di stringhe per avere un appoggio dove mettere le stringhe che erano arrivate nel frattempo potenzialmente le stringhe possono arrivare con una frequenza molto elevata l'importante è che l'ultima paint che viene richiesta da Windows presenti a schermo tutte le stringhe caricate nel frattempo per cui questo questo questo appoggio è fondamentale per questo motivo alla stessa maniera faremo la nostra nuova di punti quindi anche qui in una posizione qualsiasi che ci è comoda faremo un array di punti e useremo la struttura dati point che è proprio di quindi internamente di di di di c'è questa struct point che avrà due campi x e y che possiamo risicolare per cui creeremo points è un array per cui definire un massimo di punti che vogliamo gestire diciamo che sia 12 ok quindi questo è un array di 12 punti questo è un array possiamo fare perché poi è uno struct ben definito per cui è semplicemente una coppia di interi che poi vengono moltiplicati 12 volte che è un array molto semplice e per ricordarci qual è cioè a che punto dei punti siamo arrivati serve come al solito una variabile di appoggio che ci conteggia i punti per cui lo chiamiamo c points c super count ok per cui iniziamo con zero poi di volta in volta ci ricordiamo a che numero di punto siamo arrivati per l'inserimento non serve sia per inserirlo chiaramente sia per visualizzarlo perché chiaramente non possiamo visualizzare punti che non sono state registrate quindi bisogna nel presentare lo schermo bisogna fermarsi al punto c pointesimo ok questo avviene appunto sia nel click sia nel page per cui prima facciamo magari facciamo gestiamo il button up che è la procedura in cui andiamo a registrare il click e per questo in realtà andiamo a riciclare il il point.c perché qui c'era già l'estrazione dei parametri quindi usiamo la stessa strumento qui in sostanza fuori le coordinate dal nostro click quindi da l param qui in realtà questo è x e questo questo è y ok questi sono i nostri parametri e a questo punto li possiamo mettere dentro un dentro la variabile dentro l'array e quindi lo facciamo in maniera così c count no c points scusate c points x diventa x qui bisogna scriverlo perché non bisogna allocare il punto il punto è già allocato perché è uno struct quindi il struct viene già creato in questa fase qui questo non cerco definizione del punto lo troviamo subito come lo vediamo questo punto è composto da x e y quindi nulla di esotico ok abbiamo scritto nel punto a questo punto incrementiamo c points cosicché al prossimo click chiaramente scriveremo al punto successivo tutto qui c'è un unico problema perché chiaramente i c points a questo punto saranno più di 12 perché bisogna fermarsi ok quindi il punto dell'equitrito è semplicemente un oggetto con una x long e una y long quindi anche l'array non deve essere ulteriormente complicato adesso è il momento direi che per gestire questa cosa non facciamo altro che fare il x points uguale cioè maggior uguale a x points semplicemente o meglio o meglio o meglio forse ha più senso quindi se siamo arrivati in fondo non lo chiamo cioè non memorizzare ok può fare in vari modi ok e questo è per ora quanto a questo punto bisogna soltanto mostrare a schermo queste cose che quindi qui dentro nel web paint andremo a presentare a schermo qual è la situazione attuale se qual è la struttura dei punti a momento ecco come facciamo farlo allora facciamo un semplice doppio loop in sostanza quindi facciamo un doppio loop attraverso lungo i punti e andiamo a fare tutte le stanghette le linee che collegano i vari punti quindi int dall'ottato teresimo a c points quindi qui bisogna stare attenti a non fare max points perché alcuni punti ancora non sono stati definiti quindi vediamo per i primi punti vediamo secondo loop da zero sempre a i points quindi gira esattamente mi rondo più per i punti che abbiamo e a questo punto bisogna abbracciare a schermo la linea allora mentre allora quando disegniamo a schermo nelle delle 32 bisogna immaginare che quando facciamo paint quando quindi quando invochiamo begin paint e fino alla end paint bisogna immaginare che lo schermo è di nuovo completamente pulito cioè il il buffer viene ripulito viene cancellato e poi noi andiamo a ridisegnare sopra un buffer completamente buono questo è perché Wint 2 non si ricorda del buffer tra un'invocazione e l'altra di WM Paint questo poi tra l'altro non è neanche completamente vero nel senso che può farlo in parte quindi il fatto che venga cancellato e venga in realtà venga ripulito con il brush quindi al momento noi abbiamo il black anzi se usiamo il black brush non si vede nulla torniamo qui al white brush perché il tratto standard della penna è nero quindi nero nero chiaramente non si vedrebbe quindi di default Wint 32 quando ripulisce la nostra applicazione ci fa il favore di rimbrattarla con il brush di background questo possiamo anche chiedere di non farlo possiamo dipingere su una finestra già dipinta però la difficoltà è che noi non sappiamo che aspetto abbia in genere la finestra sottostante questo perché la finestra nel frattempo può aver cambiato dimensioni per esempio quindi quando la finestra si allarga in particolare ci sono aree del buff che non sono mai state dipinte quindi quelle chiaramente vanno ripulite in maniera manuale in caso se non lo fa per noi però classicamente facciamo finta che Wint aveva ripulito lo schermo con il brush default di background e poi tocca a noi ripartire da zero la cosa strana è che mentre dipingiamo in realtà però il buffer si colora pian piano quindi in realtà mentre coloriamo possiamo andare a leggere il buffer la tela e vedere cosa mi ha dipinto finora quindi in qualche modo mentre dipingiamo c'è uno stato della tela e della tavolozza se ricordate c'era questo fine track che vi dicevo che è la nostra tavolozza poi c'è la tela che è il nostro rack client diciamo così su cui andiamo a dipingere per cui in realtà stranamente quando andiamo a manipolare le interfacce per dipingere bisogna tenere traccia dello stato della pittura fondamentalmente questo questo ho già visto parzialmente quando lavoravamo con il font perché qui accade esattamente la stessa cosa ossia prima di iniziare a scrivere quindi a dipingere per ricordate andiamo a selezionare il font perché da questo select object in poi tutte le nostre attività di struttura quindi tutte le chiamate a draw text ma anche le altre chiamate text out che sono equivalenti usano quel font perché c'è un font attivo su una nostra tavolozza in quell'istante finché non si fa un'altra select object che cambia il font stessa cosa avviene per i brush quindi per i colori stessa cosa avviene per la in realtà in questo caso no perché field rect chiede il colore quindi qui il brush viene passato alla field rect però avviene per il disegno con la penna per ricordate quindi per tutte quelle che sono tratti linee cose di questo genere c'è una penna attiva diciamo così nella nostra tavolozza che è quella che viene utilizzata da tutte le chiamate per dipingere quindi per tracciare quindi in questo caso la penna attiva è quella di default che è la penna spessa un pixel e di colore nero poi possiamo chiaramente cambiare penna però ogni volta che la cambiamo tutte le chiamate di pittura di disegno con la penna cambiano e soprattutto c'è anche questo è molto strano che non si troverà in altre interfacce per il disegno Win32 ha il concetto di dove è appoggiata la penna che è molto strano per cui bisogna spostare la penna prima poi tracciare con la penna e poi ogni volta bisogna rispostare la penna di qualche modo funziona così non so perché però è così invece di fare immagineremmo che ci sia una draw line mettiamo possiamo dare inizio e fine non funziona così bisogna prima spostare la mano quindi move to x e move to x lascia intende che c'è una move to che è la versione preistorica della funzione e poi move to x per la giornata diciamo così e move to x prende il nostro hdc quindi il nostro handle to the device context quindi il contesto la tavolozza la tela e la x di partenza la x di partenza chiaramente sarà andiamo a usare il punto quindi il punto noi partiamo da i quindi partiamo dal punto da questo root qui arriviamo al punto della j quindi il punto di partenza è punto iesimo x e poi points iesimo y giusto e poi possiamo potremmo se vogliamo possiamo passare un puntatore a punto come ultimo parametro che ci dice dove era la penna il punto d'appoggio prima di spostarla adesso questo non ci interessa perché lo spostiamo e basta quindi passiamo null e quindi questo sposta la penna ma non traccia ancora nulla perché a quel punto per disegnare per tracciare la linea bisogna fare line to quindi si sposta e poi si traccia line to prende hdc di nuovo e poi il punto d'arrivo quindi points j di x o meglio x di j in realtà e poi points di j questo non prende nessun parametro e questo dovrebbe tracciare questo fa alcune cose che non necessariamente sono sensate penso che farà traccerà la linea dallo cioè anche su punti coincidenti quindi fa alcune cose che non sono utili perché quando i e j è lo stesso punto in realtà il punto non serve quindi si potrebbe si potrebbe saltare se uno volesse ma non è che cambia molto l'algoritmo quindi possiamo lasciare così e direi che possiamo provare a vedere questo ok adesso mi aspetto che cliccando prima volta non accado nulla chiaramente che c'è soltanto un punto e poi non compare nulla perché ho dimenticato la cosa fondamentale ossia nessuno sta invalidando lo schermo in teoria se lo nascondo e lo ripresento dovete vedere qualcosa non avevo invalidato lo schermo quindi non le Wint3D2 non facevano il paint perché nessuno stava dicendo a le Wint3D2 che si era aggiornato per quanto spografico perché ricordate che questa attività qui non ha alcun effetto grafico stiamo soltanto registrando la coordinata e aspettando che qualcuno rispinca lo schermo se nessuno lo fa chiaramente non si rulla ogni volta che per qualche ragione le Wint3D2 sono obbligate a ridipingere lo schermo quando nascondo e ripresento si aggiorna la schermo ok per ovviare questo problema chiaramente andremo a aggiungere qui un invalidate text ossia anzi in realtà dentro lì perché se non diciamo nessun punto c'è ragione di dipingere each window null true vi ricordo che sono quale finestra invalidare quale regione tutto se passiamo null e poi true significa ripulisci tutto e riparti da zero quindi qui stiamo già dicendo suggerendo a Windows che la validazione della finestra richiede una ripulitura della finestra funziona meglio ok e si arriva fino a 12 punti dopo che si interrompe no? quindi a questo punto non registrava altri punti perché il nostro buffer si esaurita quindi non c'è più spazio dove mettere qui chiaramente potrò mettere un buffer circolare se potessimo come farlo rapidamente non aggiunge molto però prima di fare questo in realtà aggiungerei un elemento c'è un'opzione per pulire lo schermo ossia gesteremo il click con il destro sullo schermo sempre e andremo a ripulire il nostro array per cui come si fa questa cosa andiamo a gestire semplicemente il R cioè R button up quindi il click cioè rilascio il click con il puntone da destro sempre sulla finestra principale ovviamente che non ci sono altre finestre così break ok e a questo punto in realtà in questo pulsante non bisogna fare chissà quanto metto comunque il blocco perché potremmo fare varie cose però la cosa più banale che si può fare in realtà è unzerare C points cioè fare C points uguale a zero tanto poi si riinizia a scrivere dallo zerese elemento quindi in realtà poi si sovrascrive di click in click quindi senza andare a zerare nulla posso semplicemente fare così e invalidare perché finalmente voglio che la finestra venga rivinta se vogliamo essere veramente sicuri che i punti siano stati cancellati e non soltanto non più visualizzati possiamo anche a zerare l'array dei punti se vogliamo essere veramente veramente bravi e evitare che per cui con zero memory passiamo il puntatore alla memoria e la dimensione della memoria ossia size of point per max points giusto? per cui con zero memory passiamo il puntatore da zerare cioè l'inizio del blocco di memoria da zerare e poi quanti byte da zerare i byte sono point per la dimensione dell'array tra l'altro in realtà mi sa che il compilatore ci arriva da solo se gli passiamo la size of dell'array per cui possiamo anche trovare se il tcc ci vuole bene questa è un'operazione che possiamo anche non fare se facciamo size of points però vediamo se ci dà un errore qui è il compilatore che sa per metter tempo di compilazione quante grande l'array points dovrebbe poterci arrivare da solo sì non ha dato il lavoro che lì immagino che sia giusto e ok quindi ripartiamo da zero e a quel punto ci aspettiamo che lo schermo venga ripulito ok click destro e click riparto ok lascio un attimo se dovete recuperare questo ma non c'è molto scusate adesso una cosa che facciamo al volo è cambiare penna quindi una cosa che si può fare con una certa la priorità è cambiare il colore della penna che qui la penna appunto ce n'è un attiva di volta in volta per fare select object per attivare la penna appena creata e poi la passeremo la penna andremo a fare create pen allora le penne cioè tutte le altre strutture di grafica di un'interfa 2 qui facevamo la anzi questo si può che toglie quindi creavamo il font che al momento non ci serve lasciamo per caso in cui poi si può scrivere qualcosa quando creiamo la penna appunto usiamo la funzione create pen dove andiamo a specificare lo stile della penna la dimensione della penna e il coloro della penna che appunto ci serve per fare tutti i tratti questo crea un oggetto pen che gestiamo con una handle to pen quindi hpen ovviamente come hbrush questo via tutte handle degli oggetti grafici possiamo creare chiaramente qui dentro quindi direttamente quando ci servono però in realtà andremo a crearle ogni volta ogni volta che ci arriva una penna per cui in genere quando una penna un brush un font così vengono usate tante volte o ogni volta che viene chiamata la pen in genere si cerca di fare di ottimizzare creandola dentro WM Create quindi anche la penna andremo a crearla qui e faremo hpen pen red per esempio qui uso lo stile le vinti due ok create pen a questo punto ci sono tre parametri che ci interessano lo stile e di solito praticamente le penne sono solide hanno un tratto solido unico se no possono essere tratteggiate punteggiate e così via e allora tra l'altro lo stile questi qui tratteggiati e partenari sono vari soltanto se la penna non è più larga di uno quindi per tratti spessi queste qui non sono valide paradossalmente per cui le GDI sono molto limitate per tanti versi per cui possiamo fare bastante poco però per fare un tentativo facciamo con PSDash quindi useremo una penna tratteggiata così lo spessore deve essere uno o meno e infine ci mettiamo un colore quindi possiamo passare un colore qui una colorref quindi un oggetto colorref in realtà è sempre un valore intero e per crearlo usiamo un'altra piccola macro che si chiama RGB che ci permette di creare dei colori passando dei parametri RGB quindi RGB è come al solito una direttiva al preprocessore come tante cose delle Win32 che ci permettono di pacchettizzare un valore R valore per il verde valore per il blu dentro un singolo intero alla fine perché colorref alla fine dei conti è un intero non so se riesco a trovare la definizione da qualche parte ma non è che sia così importante alla fine dei conti ecco ecco ok quindi è una D word che lo d word la sua volta è una parola doppia quindi alla fine è un intero a 32 bit che dovrebbe essere e quindi diciamo così collassato dentro i bit c'è la specifica del colore RGB quindi adesso in questo caso facciamo non so un tratto rosso magari un tratto non necessariamente rosso così più gradevole ok quindi questa crea la penna la penna tratteggiata è rossastra e a questo punto prima di utilizzarla cioè prima di dipingere di tratteggiare bisogna fare select object qui dentro quindi qui dentro dentro l'ACC andiamo a fare select object esattamente come come facevamo per il select font quindi usiamo questa chiamata qui esattamente come si attivano i font si attivano anche le penne quindi qui faccio pen red e poi ignoro il fatto che mi sta qui mi tornerà quindi questo select object qui mi tornava il font di default qui in realtà mi tornerà la penna di default quindi la penna nera quindi l'oggetto di ritorno la handle cambia in base a quello che viene passato ovviamente quindi questo è un comportamento molto strano cioè per fare le cose per bene devono esserci select pen select font e così via per avere varie funzioni per ogni singolo oggetto che si può attivare non è stato fatto così quindi c'è una unica funzione che prende qualsiasi oggetto grafico lo attiva e poi ritorna il riferimento al corrispettivo quindi l'oggetto che è stato scalzato dalla nostra tavolozza se noi vogliamo tornare a tratteggiare con la penna normale dobbiamo poi tornare a fare select object con default pen ok tra l'altro altra cosa quando facciamo handpaint poi la tavolozza viene scartata quindi questa paint struct qui viene distrutta e la tavolozza attiva c'è se resistere quindi il fatto che questa pen forse attiva alla prossima chiamata di handpaint non è rilevante perché si riparte dalla tavolozza di default che è appunto sfondo bianco testo nero penna nera e bisogna riattivare tutte le cose vediamo se siamo riusciti a fare cose che poi hanno effetto grafico sarebbe credevole ok ok e fin qui nulla di sconvolgente credo e a parte fare farlo con un buffer che magari possiamo fare a tempo perso proviamo a fare precisamente un controllo o meglio un componente quindi andiamo a creare un oggetto una finestra una finestra figlia che vive dentro la nostra finestra principale quindi quell'idea è che questa è la finestra su cui lavoriamo e sulla quale dipingiamo noi quindi che abbiamo controllo di quello che si vede perché gestiamo Wampaint adesso andremo a creare una finestra che vive qui dentro è una finestra figlia sarà una di classe button quindi sarà un pulsante ovviamente che avrà l'aspetto di un pulsante standard di Windows vi farà qui dentro e noi non potremmo non potremmo gestirla perché la window procedure che gestisce il pulsante non è nostro ok perché andremo a creare una finestra esattamente con questo metodo qui quindi sempre quella create window di classica quindi con questo metodo qui come nome di classe non passeremo il nome della nostra classe ma il nome di una classe standard a quel punto l'onere di gestire la classe dipende cioè viene lasciato a chi ha definito la classe quindi in particolare la procedura di quella classe di cui non abbiamo nessun conto ok dobbiamo farlo e come al solito anche qui noi andremo a farlo dentro la create window qui dentro quindi nella create si fanno tutte queste attività di preparazione perché anche il pulsante chiaramente è un pulsante che viene creato con la finestra e poi rimane vivo rimane valido fin tanto quella finestra non rimane attiva quindi questo pulsante che adesso potremmo mettere in un angolo magari dello schermo sarà un pulsante che ci permette di resettare i punti quindi funzionerà esattamente come il clip test non farà niente di più esotico però ci permette di resettare i punti e quindi ci permetterà di cliccare qui in basso a destra ok proviamo a farlo allora intanto questo questo pulsante questo sottopulsante diciamo così che andiamo a creare è una finestra gli effetti quindi l'oggetto con cui andiamo a tracciare quella quella sottopinestra è sempre una edge quindi comunque per noi è indistinguibile una finestra vale l'altra una finestra figlia è comunque sempre una finestra agli occhi delle guinte quindi il nostro la nostra finestra button sarà che ne so edge reset button qualcosa di genere quindi handle to reset button che al momento non ha nessun valore però l'idea è che alla creazione andremo a creare una finestra quindi magari dopo aver fatto la penna il font e così via andiamo a creare questo pulsante e lo facciamo con la nostra abituale create window quindi appunto stesso metodo con cui andiamo a creare una finestra principale non cambia assolutamente nulla cambia quello che ci mettiamo chiaramente per cui il primo parametro che ricordate è la classe della finestra che come tutte le stringhe costanti vanno messe tra text e la classe è button tutto maiuscolo questo è deve essere così quindi questa classe qui esiste perché le Win32 prevedono che esistano e quindi i pulsanti di Windows sono dei button maiuscoletto scritti così è stata una cosa che magari è così in attesa è che in realtà i pulsanti i button sono tanti e possono avere aspetti anche molto diversi da loro perché per esempio il check button no scuola il check box la spunta è in realtà un pulsante il radio button quindi il pulsante quello lì circolare che si permette di attivare le varie opzioni alternative quindi se c'è un'opzione alternativa è anche quello un button e sono vari pulsanti che a occhio non sembrano pulsanti ma in realtà sono finestre della classe button anche se poi hanno un aspetto molto diverso ok il pulsante chiaramente avrà un test avrà un test interno questo magari è importante vedere tutte le finestre quando le creiamo hanno ovviamente una classe quindi una classe e poi un testo questo qui era la caption della nostra finestra quindi questo testo qui che passiamo qua compare compare dove? compare nella caption quindi compare qui in alto nel titolo della finestra questo perché le finestre principali le finestre overlaps che diventano finestre di primo ordine dentro Windows usano il loro testo interno mostrandolo qui sopra quindi ogni finestra ha un testo associato le finestre primarie lo mettono qui sopra però le finestre non primarie vediamo se ho ancora il blocco noto aperto no le finestre non primarie hanno comunque modo di mostrare il loro testo e lo fanno semplicemente in altro modo qui questo blocco noto blocco noto ha un testo ed è qui sopra ovviamente la finestra figlia che permette di ripensare il testo questa è un'altra finestra questa è una finestra di primo ordine sempre quindi è una finestra overlaps che però vive come dialogo della finestra principale vedete che è una finestra però è una finestra di classe diversa ovviamente perché questa è la finestra in cui scriviamo questa è la finestra in cui facciamo altre cose però sono due finestre di stessa come si può dire di rilevanza no perché quando chiudiamo questa viene chiusa anche questa quindi questa comunque è più rilevante però a livello concettuale per Win32W sono due finestre equivalenti sono comunque finestre di primo ordine indipendenti vedete che sono entrambe attive e entrambe avranno una window procedure interna che fa che svolge il loro lavoro questa finestra in particolare è composta da varie finestre questa finestra qui è una finestra di classe button maiuscoletto e il testo che le passiamo compare come testo del pulsante quindi se noi cambiassimo classe e facessimo diventare questa qui una finestra principale find next comparerebbe nel titolo quindi semplicemente è un modo diverso per rappresentare il testo interno vi citavo prima che il checkbox questo tipo di oggetto qui è comunque un button questo qui è un button assolutamente come questo solo che cambia lo stile la grafica e il text compare invece a destra della spunta della spunta ok però il concetto è lo stesso quindi qui qui mettiamo il nostro text della finestra e sappiamo che comparirà dentro il pulsante chiaramente quindi lo renderà sarà l'azione del pulsante quindi non sono presenta i punti a questo punto bisogna passare lo stile della finestra qui ricordate che lo stile era overlap window che usavamo questo qui che sono le finestre quelle principali in classica quindi overlap possono essere sovrapposte e vivono nel parco delle finestre principali di windows chiaramente una finestra come un pulsante ha degli stili ben diversi lo stile fondamentale principale che deve essere associato a tutte le finestre figlie è ws child banalmente nel senso che questa è una finestra figlia quindi si comporta come finestra figlia quindi viverà dentro l'area client di un'altra finestra che deve essere la finestra madre questo è fondamentale se no questo determina come si comporta la finestra in assenza di questa chiamata qui in genere si apre una finestra primaria che chiaramente non è quello che vogliamo fare poi una finestra può essere visibile o meno e quindi anche qui aggiungiamo ws visible questo prima non lo facevamo perché overlapped window lo stile questo qui mi sa che contiene già visible come stile per cui non è importante darlo in questo caso però noi possiamo volendo attivare o disattivare un pulsante rendendolo visibile o facendolo sparire e in questo caso si fa cambiando togliendo aggiungendo questo stile della finestra ok ultima cosa e forse la cosa più rilevante le cioè le le le finestre di una classe standard di solito aggiungono una serie di stivi aggiuntivi che valgono soltanto per quelle classi di finestre proprio perché bisogna determinare come funzionano le finestre di classe button e quindi giusto per complia di anche qui andiamo a vedere un attimo quali sono gli stili che una finestra button supporta quindi c'è una lista di stili che appartengono ai button delle guinte da due quello che ci interesserà adesso sarà il cosiddetto push button cioè il pulsante cliccabile che è lo stile del pulsante quello che è classico quando si pensa un pulsante delle guinte da due si immagina quello però vedremo che in realtà ce n'è un buon e qui vedete che c'è l'elenco dei vari pulsanti qui sono tutti i pulsanti che possiamo utilizzare cioè tipi di pulsanti che possiamo utilizzare dentro le guinte da due qui vedete un pulsante a tre stati quindi un pulsante che può essere non cliccato cliccato a metà e cliccato del tutto quindi sono molto rari in realtà quindi si usano abbastanza poco c'è il checkbox che dicevo prima quindi il checkbox è un tipo di pulsante c'è il bitmap che permette di usare un'immagine dentro il pulsante invece che metterci dal testo vediamo dopo left, right, bottom e così via sono degli stili aggiuntivi che cambiano la descrizione del testo se è necessario push button è quello che ci interessa push button è il pulsante classico che può essere cliccato c'è anche uno stile aggiuntivo che è push like cioè uno stile che si può aggiungere a un pulsante che non è un push button per fare in modo che si comporti come un push button ossia che possa essere spinto come un push button radio button sono i pulsanti circolari che può essere attivati o meno e così via e ci sono alcuni che sono un po' particolari quindi dicevo che c'è il push button il checkbox quindi e il radio button che sono quelli un po' più classici ci sono alcuni che sono un po' più strani c'è il command link che si è introdotto con vista sono un po' tipici sono quei pulsantoni grossi molto gommosi con un titolo grande e un titolo piccolo che sono un po' più complessi da creare sono questa roba qui si vedono ogni tanto sono bastanti non vengono stati chissà quanto perché sono un po' più particolari però si vuole fare un pulsante questo è comunque un pulsante quindi questo pulsante qui ha un'icona un text e una descrizione questo testo grande è il text della finestra quindi l'unico testo obbligatorio è quello che passiamo nella creazione della finestra compare come come azione qui in alto se volete una descrizione breve piccola qui sotto la si può aggiungere con un altro passando un messaggio speciale alla finestra che poi viene mostrato questo ok però per ora ci limitiamo a cose molto banali quindi il bs poi abbiamo coordinate e dimensioni quindi questo qui di solito usavamo fai tu win32 ci fidiamo questo qui questo va benissimo per le finestre di alto livello dove Windows deve deciso doveva metterle per le finestre figlie si può passare ma non ha alcun effetto perché vale 0 dovrebbe valere per cui chiaramente è una finestra figlia dobbiamo decidere noi dove metterla e la metteremo per ora la mettiamo nell'angolo sopra a sinistra questa è in coordinate locali del nostro client quindi 0 0 e poi il pulsante lo facciamo grande 250 quindi ci inventiamo delle dimensioni dovremmo essere sicuri chiaramente che il testo entri e tutto quanto però mettiamo questo a questo punto passiamo la finestra madre qui di solito era nulli chiaramente perché le finestre questa è una finestra di primo ordine quindi è nulli in questo caso però passiamo la finestra madre quindi la finestra dove verrà annidata la finestra e abbiamo un riferimento alla finestra perché ce l'abbiamo grazie al messaggio quindi ci stiamo gestendo la create della nostra finestra che ci passa l'age window che ci serve e quindi passiamo direttamente questo questo sarà il riferimento alla finestra alla finestra che ha ricevuto webcreate quindi è chiaramente la nostra finestra altre due cose allora quindi si complica allora abbiamo la documentazione che è più facile ci sono altri tre parametri che adesso si usano in maniera un po' atipica allora il il terzo parametro è se ricordate è un riferimento al menu andiamo per riuscire a aprire il lavoro è un riferimento al menu che di norma questo parametro qui viene utilizzato per creare il menu della finestra ossia sarebbe a dire nel blocco note questo oggetto qui quindi noi adesso non lo facciamo perché è molto complesso però possiamo definire un menu standard della nostra finestra e poi quando viene creata appiopparle il menu qui dentro quindi qui normalmente se ne volessimo creare un blocco note dentro al great window faremo prima create menu cioè creeremmo gli elementi del menu e poi una volta creato l'hmenu lo passeremmo alla finestra però passando nulla la finestra è senza menu per le finestre figlie chiaramente le finestre figlie non possono avere un menu per cui questo hmenu a cosa serve? allora serve come al solito i parametri vengono riciclati senza alcuna piada in Windows 2 per risparmio di spazio quindi questo hmenu che alla fine dei conti è un puntatore è un handle quindi è un puntatore quindi alla fine dei conti è un intero lo usiamo come intero non ci cerca niente e quindi ci mettiamo dentro un id magico che però va castato a menu perché sennò il complicatore non è contento e ci mettiamo un valore qualsiasi che è 1, 2, 3 o un valore che piace a voi se non metteci un numero che vi rappresenta qualcosa questa costante che questo menu qui viene usato perché quando il pulsante emette dei click cioè viene cliccato emette si porta dentro il suo hmenu cioè è orribile cioè quando il pulsante viene cliccato poi arriva un messaggio che dice è stato cliccato un pulsante che come numero magico dentro come suo hmenu aveva 1, 2, 3 quindi voi lo usate per capire qual è il pulsante che è stato cliccato è un id sì è molto brutto purtroppo è fatto così è orribile ma c'è un senso storico perché l'idea di conto è questa quando cliccate su un elemento del menu qui quindi quando che ne so quando cliccate su file new per esempio per creare una nuova finestra questo click del menu in realtà è per la finestra che gestisce è equivalente a un clic su un pulsante di nome new che fa un'attività X quindi in realtà c'è una vaga idea di fondo che ha la sensazione che i clic sul menu sono equivalenti a dei clic su dei pulsanti che potrebbero essere da qualche parte sull'interfaccia a vostra istituzione avere delle attività che sono soltanto pulsanti delle attività che sono soltanto nel menu o attività che sono sia pulsanti che menu ok però l'idea di fondo è che a voi arriva un messaggio che vedremo che si chiama è un messaggio comando si chiama quindi vi arriva un comando che sia che l'utente clicchi qui sia che l'utente clicchi sul pulsante sullo schermo sia attenzione che l'utente clicchi cioè utilizzi uno shortcut da una stiera questo si chiama acceleratore in realtà nel gergo di 32 quindi si chi clicchi ctrl n ctrl o e così via tutte queste attività qui generano un comando con quell'identificatore lì l'idea è che voi nella vostra finestra poi gestite semplicemente queste notifiche e come vengono attivate dall'utente è indifferente quindi il menu i pulsanti e gli acceleratori quindi ctrl n in questo caso hanno lo stesso effetto ok però adesso per i nostri scopi qui basta passare un, due, tre e buon'altro ultima cosa complicata qui bisogna passare la nostra edge instance che se ricordate è il handle all'applicazione quindi la distanza dell'applicazione per quanto riguarda la guin 32 noi questa variabile qui non ce l'abbiamo dietro perché la variabile ci arriva nel win main quindi o questa edge instance la memorizzazione è una globale da qualche parte oppure c'è una funzione dell'equin 32 che ci divide in soccorso ossia che si chiama get module handle null questa funzione qui ci dà la handle al modulo alla nostra distanza e visto che un'applicazione può essere composta di un modulo non è così si può passare anche un valore qui non diceva null quindi questo ci tornerà la nostra edge instance quindi spesso si usa questo questo modo per ottenere un puntatore alla nostra edge instance per chiarezza ci metto edge instance ok non è bello mi rendo conto però è così che si fa ok a questo punto dovremmo avere un pulsante adesso vediamo se questa cosa avviene perché in teoria l'ho creato come finestra figlia il fatto che sia una finestra di una classe che non implementiamo noi vuol dire che è già pronta ad essere utilizzata quindi in teoria dovrebbe comparire la scherzo come vediamo se si torna e magicamente c'è un pulsante di una bruttezza inerrabile ma c'è un pulsante quindi questo pulsante qui che appunto ha lo stile grafico di Windows 95 perché perché è una stessa applicazione anzi no con il nostro punto 11 perché c'è il font quello di default perché la nostra applicazione sulla carta è stata compilata come si faceva nel lontano negli anni 90 ok quindi non è un pulsante bello se chiaramente segnalassimo a Windows che la nostra applicazione è concia del mondo moderno avrebbe lo stile quello classico di Windows 10 in questo caso ok al momento è un push button quindi funziona è cliccabile ma non fa niente ovviamente perché non è stato collegato a nulla questo il pulsante cosa fa al momento quando viene cliccato manda un messaggio alla finestra madre quindi nel cioè quello che avviene che questo nel window procedure del vostro pulsante dentro il lbutton app quindi gestendo questo messaggio qui dentro la classe button qualcuno per conto nostro ha creato qui del codice che va a gestire il button up della finestra e qui dentro va a cercare la finestra madre e a mandarle un messaggio che è di tipo WM command quindi ci arriverà un messaggio di tipo command ok i comandi sono tutti quelli che possono essere generati da vari oggetti in realtà quindi i pulsanti sono soltanto uno dei vari sorgenti di comandi e i comandi vanno gestiti perché così andiamo a reagire in qualche modo e questo è come si fa in sostanza prima di fare questo volevo mostrarvi cioè provare a rendere un po' più gradevole il pulsante cioè invece di tenere qui proprio sul bordo sopra sinistra lo spostiamo perché un'altra cosa che spesso bisogna fare è gestire il layout della nostra finestra ok perché la nostra finestra è questa finestra qui è disegnata da noi quindi in particolare questo vale per i contenuti interni chiaramente ma vale anche per le sottofinestre quindi nessuno sposta quella finestra nel punto giusto anzi qui è sempre nell'angolo sinistra quindi non è molto utile ma mettiamola in un punto più scomodo mettiamola in un punto scelto a caso è un punto che potrebbe non esistere quindi è un punto qui ah tra l'altro ecco se disegno qui adesso chiaramente l'illusione è che i punti siano anche sotto però la finestra figlia clippa quindi cioè ci disegna sopra quindi se non fosse visibile non si vedrebbe sotto perché la finestra cancella clippa quindi toglie quei punti che la tele sottostante quindi non può essere trasparente proprio perché per questo effetto di clipping il clipping funziona perché le finestre in windows vengono disegnate le finestre principali vengono disegnate dalla più vicina alla più lontana per ragioni di efficienza perché le finestre vicine possono oscurare quelle sottostanti vitalmente quindi ad un certo punto lo schermo è coperto e quelle sotto possono non segnarle per virgolette ok questo capita fateci caso a volte può capitare se voi avete per dire ah qui apro un video qualsiasi difficile farlo vedere vabbè non posso farlo vedere perché non c'è la taskbar che non perdo tempo con i sub però fate caso a questo se voi avete la taskbar di windows quando passate su percola mouse vi da la preview della finestra vedete quello che avviene sotto fate caso a questo effetto se aprite youtube o qualsiasi video in realtà e lo coprite con un'altra finestra a un certo punto quella preview smette di aggiornarsi perché il video non si aggiornà più perché per errori di efficienza a un certo punto windows e anche browser sospendono l'aggiornamento di quel video per evitare di averlo presentare a schermo quindi per ragioni di efficienza si disegna dall'alto al basso e invece nel fatto che riguarda le finestre figlie si parte dalla finestra madre e poi ci si disegna sopra e ogni figlia della madre va a clippare la sua zona quindi va a ritipingerci in bianco e poi ci si ridisegna sopra ok quindi dicevo nessuno si occupa di fare il layout della finestra quindi quando noi andiamo a tagliarla perché ridipensiamo la finestra il pulsante svanisce che rimane in quelle coordinate lì per cui è compito nostro spostare il pulsante e renderlo utilizzabile e questo lo faremo semplicemente reagendo in questo caso a WM size che è il il il il il il il il il il il il il il il il il il il il il il il il il il il il il il il il il come si si porta dietro in realtà le dimensioni della finestra di destinazione questo è in realtà sono due modi come possiamo determinarle o facciamo get client rect quindi ci leggiamo la dimensione del client come facevamo qui questo è in realtà non è neanche più utile quindi questo possiamo farlo sempre e otteniamo la dimensione del client della zona client di una finestra si potrebbe fare però il messaggio size in realtà ci si porta dietro una serie di parametri come al solito quindi il parametro v bar può assumere questi tipi di valori in base a quello che è appena successo alla finestra quindi se per esempio la finestra è massimizzata quindi è a pieno schermo se è minimizzata quindi è stata resa invisibile e così via e poi l param contiene la dimensione della clientaria quindi in particolare la parte bassa dell'intero contiene la larghezza e la parte alta contiene la altezza per tirare fuori questi valori bisogna purtroppo fare la larghezza era la low order quindi facciamo low world questo è un altro classico parametro è una direttiva processore di win32 di lparam esatto e la height sarà high world di lparam perché è un intero lungo che contiene due sotto interi uno è la larghezza e l'altro è la altezza questo perché devono compattare una serie di informazioni dentro gli stessi oggetti quindi in questo modo tiriamo fuori la dimensione questo è equivalente a target client quindi questo qui questo qui ci dà ci popola un rect quindi in realtà sarebbe forse più comodo però diciamo così e a questo punto spostiamo la finestra è la sotto finestra quindi la finestra finghia come si sposta la finestra con una funzione ovviamente che si chiama move window in maniera molto originale notate che move window fa una serie di cose move window è una funzione delle windows che permettono di spostare una finestra e notate che permette di spostare qualsiasi finestra quindi in realtà questa è una cosa che lavorate con win 32 e poi ci si sorprende in realtà perché non c'è alcuna esonazione delle finestre vostre e di altre applicazioni quindi poi se volete si può fare con find window per esempio find window è una funzione delle windows che permette di cercare una finestra per nome di classe o per nome del caption o per altri modi con find window voi potete andare a scattabellare delle finestre di windows tutte anche le finestre di windows stesse quindi in realtà le finestre come sono la taskbar sotto tutte le finestre di sistema in qualche modo allora questa è la versione classica permette soltanto di filtrare con classname e windowname classname è la classe registrata e windowname è quello che compare in alto nel titolo tra l'altro se avete già provato con dei software di replicazione di finestre e così via non so tipo se fate streaming usate obv e così via avrete fatto caso al fatto che quando vi permette di scegliere di replicare la finestra usa questi strumenti qui quindi vi permette di definire tipo di finestra e a volte di filtrare in base al nome cioè il titolo che compare in alto sulla barra non è perché gli strumenti che si hanno per pescare una finestra da quelle che esistono sullo schermo sono queste alla fine dei conti però una volta che otteniamo una edge window di una finestra nostra o di qualsiasi altro sistema di applicazione poi possiamo manipolarla quindi possiamo spostarla quindi questa questa questa questa move window una volta che abbiamo un edge window di riferimento vale per tutte le finestre eccetto l'unica limitazione qui è se è una finestra che il cui utente utente proprio a livello di sistema è diverso quindi se eseguite un blocco note da da da da da da da amministratore quel blocco note o altre applicazioni che gira da amministratore quel blocco note è isolato da tutte le altre applicazioni perché non questi questi messaggi non passano da un edge all'altro ok quindi questo l'unica forma di isolamento è questo quindi quindi finestra la possiamo spostare possiamo anche ridimensionarla quindi è uno spostamento con ridimensionamento in effetti e poi possiamo anche dire devi ridimingersi o meno possiamo forzare la finestra a ridimingersi in questo caso in realtà vogliamo soltanto spostarla quindi romu window e chi spostiamo la nostra edge cos'era button qualcosa riserva button quindi il puntatore alla finestra qui noi non dobbiamo cercare la finestra perché già ce l'abbiamo quindi quando la creiamo memorizziamo le rifiutazioni alla finestra senza doverla cercare ogni volta però sulla carta potremmo andare a cercarla se volessimo dove la spostiamo la mettiamo in fondo a destra quindi facciamo width con un bordino quindi width meno 10 height meno 10 la manteniamo cross width 250 e poi diciamo non devi ridipingerti perché non è cambiato nulla quindi se se non c'è bisogno non c'è bisogno che tu faccia il paint di nuovo sempre per ragioni di efficienza è un'altra ok proviamo a far vivere questa roba ah qui è senso di nulla misterioso allora cosa ho sbagliato ho letto male i parametri sicuramente ah sono punto io perché la coordinata chiaramente è nell'angolo sopra sinistra del pulsante però devo considerare che il pulsante ha una dimensione scelto ma non si vede pulsante perché è fuori dallo schermo quindi in realtà è meno la sua dimensione e meno la sua altezza e poi il bordino quindi così ha più senso meglio ok ok quindi a questo punto tra l'altro notate che io l'ho creata la sotto finestra l'ho creata in punto qualsiasi cosa era 300 400 in maniera molto arbitraria in realtà noi se ricordate dall'esecuzione di messages se ci seguiamo un attimo messages ci dava noi vedevamo qui che in realtà ah troppo da va beh il primo messaggio è create poi activite poi size poi move quindi in ordine erano sempre questi quattro messaggi sempre che ci avvertono della creazione della finestra quindi in realtà create viene invocata subito poi c'è subito size quindi prima ancora della prima paint e della prima mostrata a schermo la finestra viene ridimensionata per cui poi in realtà queste corno di qui non sono rilevanti più di tanto perché poi è lo spostamento che causa subito lo spostamento sulla finestra quindi in realtà la sotto finestra non la vedremo mai nella punto di partenza perché viene subito spostata in basso a destra e a questo punto il pulsante si sposta insieme a destra in maniera fluida e corretta però appunto tutte le operazioni di layout sono compito nostro quindi bisogna gestire in automatico il volksize e eventualmente fare degli aggiustamenti per far sì che il pulsante faccia quello che deve e che si comporti graficamente in maniera corretta se abbiamo una pulsantiera complessa con vari pulsanti che devono adattarsi allo schermo sarà compito nostro che effettivamente andrà a vedere che il width è minore di 220 che si può gestire e adattare lo schermo in modo da farlo funzionare quindi qui vanno a fare potremmo fare se non fare le cose vagamente per bene potremmo fare il minimo tra min esiste in 22 tra 20 20 20 20 21 21 Non ho abbastanza caffine per pensarci bene, comunque l'importante è che adattiamo la larghezza del pulsante allo schermo e quindi per adattare... Ok, faccio l'omplimento brevissimamente, il min non esiste, quindi adesso facciamo fin da nulla, ero convinto che ce ne fosse uno nel V32. Vabbè, comunque avete capito il concetto, se c'è qualcosa da adattare dinamicamente al schermo in base alla dimensione dello schermo, bisogna farlo a mano e anche lì gli strumenti più avanzati come Flutter, per ragazzi, altre cose, ci permettono di fare queste cose con grande facilità. Ho rotto qualcosa, adesso l'ho aggiunto subito, direi che facciamo una pausa e vediamo subito. Ah no, manca l'ultimo pezzo, in realtà è la pulizia dello schermo, che è la cosa che volevamo fare, la facciamo subito dopo, così per il tempo facciamo un definito di respiro e poi attaccamo. Pausa.