Ok, riprendiamo brevemente dall'inizio la descrizione del Wide Equivalent Privacy Protocol per la protezione dei dati nella trasmissione su una rete wifi di tipo 802.11b. Allora, brevemente riprendendo un po' le fila di quello che abbiamo già detto. Allora, questo è il plaintext da cifrare. Il plaintext viene concatenato, questa è l'operazione di concatenazione, viene concatenato con il tag del plaintext. Il tag viene calcolato usando una funzione di checksum nota in letteratura che è la CRC, che si utilizza per garantire l'integrità dei dati trasmessi su reti imperfette, quindi dove le eventuali modifiche al plaintext dipendono da errori di trasmissione, non dipendono da attaccanti malevoli. Quindi in particolare il CRC non è assolutamente un MAC sicuro, anche perché non utilizza alcuna chiave per segnare il messaggio e calcolare il tag. Quindi questo è il tag. Il tag concatenato col messaggio, questa coppia, l'idea è di cifrarla, esattamente come accade nel paradigma MAC del encrypt. Quindi prima si tagga il messaggio, poi la coppia messaggio tag viene cifrata. Quindi l'idea dei progettisti era appunto quella di implementare un MAC del encrypt, però senza usare, chiaramente, come abbiamo detto, un MAC sicuro. La cifratura viene fatta usando uno stream cipher e vi ricordo che la cifratura negli stream cipher si fa nel seguente modo. Quindi si applica un PRG al seme, che è il segreto condiviso, l'output è una stringa pseudocasuale, questa stringa pseudocasuale viene combinata in XOR col plaintext. Infatti vedete che qui abbiamo l'OXOR e questo è l'equivalente del PRG applicato al seme, al segreto condiviso. Nel caso di WEP lo string cipher che è stato utilizzato è RC4, un vecchio string cipher oramai deprecato, tra l'altro. E questa che vedete qui è la funzione di pseudorandom generation, che si chiama appunto RC4, che deve prendere in input il seme segreto per generare la stringa pseudocasuale che utilizzeremo per la cifratura. Ora diamo un'occhiata all'input del PRG. L'input del PRG è la concatenazione di due stringhe. Andiamo a vedere queste due stringhe. Quella di sinistra, questo che viene chiamato initial value, è una stringa random, casuale, di 24 bit. Ok? Questa invece sulla destra, che cos'è? Questo è il seme, è il segreto. K è la chiave condivisa. Tutti gli utenti che si collegano alla rete wifi portetta in questo modo, condividono K. C'è un protocollo di handshake, che non vi sto a raccontare perché si basa su meccanismi che ancora non abbiamo studiato. Comunque vale un discorso analogo a quello che abbiamo fatto ieri per TLS. Quindi c'è un setup iniziale durante il quale ogni utente collegato alla rete wifi condivide K. Ok? Quindi K è il segreto condiviso. Benissimo. I progettisti sapevano già che gli stream cipher sono vulnerabili all'attacco di tipo 2 time pad. Cosa vuol dire questo? L'abbiamo visto qualche settimana fa. Vuol dire che in uno stream cipher voi non potete usare la stessa chiave due volte per cifrare due diversi messaggi. Perché altrimenti l'attaccante recupera facilmente sia la chiave che il plaintext. Ok? Quindi questo non è chiaramente possibile. Consapevoli di questo, i progettisti, quindi sapendo che non potevano usare brutalmente il PRG applicato direttamente a K, che altrimenti si sarebbero esposti al 2 time pad attack. Cosa hanno deciso di fare? Hanno deciso di combinare appunto con questa concatenazione la chiave con un nonce, con un valore casuale. Quel famoso initial value di 24 bit. Ok? In questa maniera, dato che l'initial value cambia al cambiare di M, viene fatto un sampling per ogni messaggio che deve essere cifrato, quindi va da sé che come conseguenza l'input del PRG cambia per ogni messaggio. Questo appunto per evitare il 2 time pad attack. Ok? Dopodiché l'output finale sarà la coppia nonce ciphertext. Ok? Questa è l'idea. Quindi se vogliamo, questa non è altro che un'implementazione di idee che già abbiamo visto, ovvero il fatto di dover lavorare con un cifrario probabilistico, se vogliamo esserci più assicuri, il fatto di appoggiarsi a un paradigma di tipo MAC da Encrypt, per garantire sia la secrecy che l'integrity, e quindi diciamo che l'implementazione è ispirata a queste idee, che in linea di principio sono idee valide, naturalmente il problema è come le andiamo a implementare. E quindi i problemi ce ne sono parecchi. Ne elenchiamo alcuni, i più noti, ma poi in realtà le vulnerabilità sono innumerevoli. Ora, in prima battuta, il modo in cui viene calcolato il seme da dare impasto al PRG è un modo che non è sufficientemente randomico. Il seme dovrebbe cambiare ogni volta. Lì è vero, sì, che cambia ogni volta. Però va detto che comunque, in ogni caso, ogni volta il seme ha una struttura che in parte è sempre la stessa. Perché lì non è che gli initial B e 2K vengono mescolati, i bit dell'uno e dell'altro. Lì la parte di età del seme è sì randomica, ma l'altra metà del seme non è randomica, è sempre la stessa stringa. Ok? Quindi in realtà, anche se i semi che vengono usati per cifrare diversi messaggi sono diversi tra di loro, in realtà sono fin troppo simili tra di loro, hanno delle correlazioni tra di loro, perché condividono una stessa parte che è K. Ok? E questo è un primo problema che rende non del tutto impredicibile il risultato del PRG. Ok? Quindi facendo criptanalisi sul PRG, osservando diversi ciphertext, si riescono a dedurre delle informazioni relative a K. E questo è un primo problema. L'altro problema, ancora più banale, deriva dal fatto che il meccanismo di campionamento dell'initial Velo a 24 bit non era poi così randomico. Ok? E la probabilità di collisioni sull'initial Velo era tutt'altro che trascurabile. Per cui è chiaro che se lo stesso initial Velo veniva usato due volte, di nuovo si ricadeva nel to time pad attack, perché a quel punto se corrispondono gli initial Velo corrisponde di semi, visto che K è sempre la stessa, e quindi corrispondono le stringhe pseudorandom generate nel PRG. E quindi, di nuovo, to time pad attack. Quindi, nel modo in cui viene costruito il seme e nel modo in cui viene calcolato l'initial Velo, ci sono delle vulnerabilità che rendevano l'output del PRG piuttosto predicibile. Ok? A questo l'ho sommato il fatto che RC4 di per sé è oramai diventato un PRG predicibile. Ok? Vulnerabile. Quindi, diciamo che le debolezze associate allo stream cipher, al modo in cui viene usato lo stream cipher, sono più di una, naturalmente. L'altra debolezza ovvia riguarda invece la coppia plaintext e tag. Proprio perché il tag non è protetto da chiave. Il tag è generato usando una funzione che non è un maxicuro, una funzione senza chiave, un nostro CRC. Quindi, anche se la coppia plaintext tag viene cifrata, nonostante questo, in ogni caso, è vulnerabile ad attacchi di tipo malleability. Nel senso che l'avversario ha modo di andare a modificare, può intervenire, modificando il ciphertext, ok, in maniera tale da alterare m e il tag di m, proprio perché il tag non è protetto da chiave a sua volta. Ok, quindi manca la proprietà di ciphertext integrity, perché manca la prova di integrità sul tag. quindi anche in questo caso, se vi ricordate, nel caso di string cipher, abbiamo visto come funziona la malleability. Abbiamo fatto un esempio, in cui facevamo vedere che modificando il ciphertext, automaticamente la modifica si poteva propagare al plaintext nascosto nel ciphertext. E qui succede la stessa identica cosa, in questa maniera si può andare, si possono andare ad alterare questi due, il messaggio e il suo tag, in maniera piuttosto semplice, proprio perché comunque il tag non è protetto da chiave, non è protetto da un maxicurve. Ok, quindi il modo in cui vengono usati i diversi ingredienti è fondamentalmente sbagliato. Ok, poi se consideriamo la costruzione nel suo complesso, quindi la prendiamo come una costruzione di tipo MacDenencrypt, l'abbiamo visto ieri, di default il paradigma MacDenencrypt non è sempre sicuro, anche se usiamo ingredienti sicuri, a differenza dell'encrypt del MacDenencrypt tant'è che questa costruzione con questi ingredienti è vulnerabile ad un attacco di tipo Chosen Ciphertext, di tipo Chosen Ciphertext, quindi analogo al Poodle e analogo anche a quello che abbiamo discusso prima per SSH si chiama Chop Chop, il tipo di attacco Chosen Ciphertext di cui, rispetto a cui il web è vulnerabile ed è una variante del Poodle che abbiamo visto che abbiamo visto ieri e della versione che abbiamo visto oggi nel caso di SSH, qualcosa di simile. Quindi, è debole il modo in cui sono usati gli ingredienti, è debole il modo in cui sono combinate nel paradigma MacDenencrypt, ultimo esempio, ripeto, il web è una sfidza di vulnerabilità, queste sono quelle più significative. L'ultimo esempio è la vulnerabilità ad attacchi di tipo denial of service. Questo ve lo spiego perché è piuttosto interessante, piuttosto carino. Ora, tutte le comunicazioni all'interno della rete wifi sono cifrate, ok? Nella maniera che abbiamo appena visto. Tranne una, ovvero il messaggio finale con cui l'utente fa il logout dalla rete wifi. Ok? Il messaggio di disconnect non è cifrato. Ok? Quindi, questo che cosa vuol dire? che se un avversario al di fuori della rete wifi sniffa i metadati di un utente, ok? Quindi, qual è la sua identità diciamo all'interno della rete wifi e manda un messaggio di disconnect relativa a quell'identità, quello che succede è che l'utente viene disconnesso, anche se non è stato lui a mandare il messaggio di disconnect, ma lo fa qualcun altro al posto suo. Quindi, in questa maniera è piuttosto banale attaccare la rete provocando il disconnect degli utenti che sono collegati. E questo è un esempio di denaro allo service. Si impedisce agli utenti di accedere al service. Ok? Quindi, per tutti questi motivi e altri ancora, il protocollo web è ormai da tempo sconsigliato e di precato ed è il motivo per cui è stato sostituito da una versione più sicura che è il WPA che vi mostrerò nella prossima slide. Quindi, torno a ripetere, non vi collegate mai ad una rete wifi che utilizza web come protocollo fotografico. questa è l'idea. Il WPA che esiste già in diverse versioni è il protocollo di encryption standard per le reti wifi di tipo 802.11i WPA sta per wifi protected access esiste dal 2004 ed estende diciamo stendo si non necessariamente non ne ha bisogno no no non ne ha bisogno anche perché i primi attacchi dove siamo finiti i primi attacchi che vi ho raccontato servono per violare K quindi chiaramente sono condotti di un attaccante che non è all'interno della della rete o potrebbe essere all'interno della rete con una K diversa però non ha importanza insomma qui qui per lo meno gli attacchi basati a passivi basati su live dropping quindi sullo sniffing non hanno bisogno che l'attaccante sia collegato alla stessa rete ma compreso anche l'attacco all'integrità pensa all'attacco sull'amaliability del messaggio l'attaccante intercetta il messaggio lo altera e poi lo inoltre così com'è quindi non ha bisogno di essere collegato di essere autenticato all'interno della rete questo non è vero il chop chop invece richiede che tu sia un utente della rete invece e devi denaro lo service anche quello lo puoi fare da fuori quindi diciamo che nella maggior parte dei casi non è necessaria come condizione ora il WPA è basato su un metodo di encryption che usa il paradigma MAC dell'encrypt esattamente come il web però stavolta lo fa in maniera in maniera sicura tant'è che garantisce l'autenticata di encryption è un protocollo proprietario del WPA si chiama CCM il cifrario MAC dell'encrypt che utilizza e per la cifratura usa un un cifrario probabilistico in randomized counter mode quindi l'idea è la stessa del web perché anche il web nelle intenzioni voleva essere un MAC dell'encrypt con un cifrario probabilistico di tipo randomizzato però chiaramente lo faceva nel modo sbagliato qui l'idea è rimasta un po' quella siamo sempre all'interno di MAC dell'encrypt però si usa un cifrario CPA sicuro si usa stavolta un MAC e non una funzione di checksum che è uno di quelli che abbiamo visto in passato quindi basato sulla costruzione cbc di un prf prf che è s quindi s cbc mod per il MAC e quindi vedete utilizza due strumenti per la confidenzialità per l'integrità che sono entrambi sicuri quindi la costruzione è dimostrabilmente essere sicura da notare che dato che si usa il MAC dell'encrypt ok il cifrario probabilistico che viene usato non è il cbc perché ieri abbiamo fatto vedere che il cbc mod è fonte di una vulnerabilità all'interno del paradigma MAC dell'encrypt per via di quel chosen ciphertext attack che abbiamo descritto e di cui il pudro era un esempio mentre invece il MAC dell'encrypt diventa sicuro se si utilizza il random mind counter mod come cifrare probabilistico è esattamente quello che succede qua dentro ok invece per quanto riguarda il MAC va bene un qualunque MAC sicuro e AS come PRF usato nella costruzione FCBC che è uno di quelli che abbiamo visto nelle prime lezioni dedicate ai MAC è un MAC sicuro e quindi problemi non ce ne sono questo per quanto riguarda la versione 2 del WPA che è stata utilizzata per parecchi anni più recentemente è stata aggiornata diciamo che il WPA2 è ancora quello che si trova in gran parte delle reti wifi però già in molte invece si utilizza già il WPA3 invece è piuttosto diverso quindi non è compatibile con il WPA2 è piuttosto diverso rispetto al WPA2 è molto più efficiente perché perché usa come sistema di autenticati di encryption usa il Galois counter mode che vi ho raccontato brevemente ieri e se vi ricordate ieri vi avevo detto che uno dei vantaggi del Galois counter mode è l'efficienza uso delle risorse e questo nella rete wifi è particolarmente sensibile come problema quindi il WPA3 è più snello rispetto al WPA2 ha performance offre performance migliori senza però perdere nulla in termini di sicurezza ok fin qui vi ho mostrato tutti esempi di protocolli che lavorano a livello di trasporto fondamentalmente o a livello applicazione come nel caso di SSA quindi dal livello di 4 in su invece a livello di rete che cosa succede? ci sono dei meccanismi per garantire la protezione dei dati end to end a livello di rete la risposta è APSEC APSEC è un protocollo che fornisce confidenzialità integrità e quindi l'autentichetta di encryption a livello a livello IP della rete quindi siamo a livello 3 quindi chiaramente lavorando a livello più basso APSEC richiede il coinvolgimento di dispositivi che non sono di fatto coinvolti quando invece si lavora a livello più alto a livello applicativo a livello di trasporto faccio l'esempio dei router dei gateway ok siccome i router hanno un ruolo attivo ad esempio banalmente quello dell'istradamento e queste sono problematiche gestite a livello di rete se la cifratura avviene a livello di rete invece che a livello di trasporto vuol dire che vengono cifrate anche delle informazioni che servono ai router e ai gateway ok ma se vengono cifrate informazioni che servono anche a loro bisogna che questi dispositivi siano coinvolti nel protocollo perché questi dispositivi devono essere loro stessi in grado di fare cifratura e decifratura che è un po' esattamente quello che succede qui vedete una rappresentazione grafica di come del livello al quale viene organizzata e gestita la VPN quindi il canale di comunicazione protetto quando questo avviene a livello di rete praticamente quello che succede è che localmente quindi localmente significa a livello proprio della rete locale dove risiede ad esempio dove è collocata liceo quando vuole mettere un messaggio che sta da un'altra parte in un'altra rete in arrivare al locale tutto viene gestito come se nessun meccanismo di cifratura fosse coinvolto ok dopodiché la cifratura delle informazioni quindi la creazione del canale di comunicazione protetto avviene nel momento in cui i dati passano per il primo router quello che raccoglie le informazioni dagli host locali e ha il compito di trasmetterli sulla rete pubblica ok lì avviene la cifratura lì avviene il vengono eseguiti quei meccanismi che permettono di creare una VPN sicura da router a router ok quindi è chiaro che per realizzare a livello pratico questo tipo di protezione dei dati è necessario che tutti i router coinvolti siano router diciamo che montano eseguono il protocollo IPsec basta che ci sia un router che non monta questo protocollo ed ecco che su quel ramo della rete non potete sfruttare IPsec e questo è un po' il limite di questo tipo di di soluzione chiaramente più a basso livello siamo e più è lo sforzo che dovete fare a livello dei singoli dispositivi per per renderli compatibili ok quindi il canale di comunicazione sicuro è quello che va da router a router no i due router estremi del percorso che permette di collegare host a host ok no ripeto basta che ci sia un router lungo il percorso che non è in grado di gestire di supportare IPsec e di lì la comunicazione non può passare perché a quel punto il router non sarebbe in grado di interpretare i pacchetti e decidere come stradarli questa è un po' è è l'idea IPsec naturalmente è un framework che al suo interno ha tanti diversi protocolli proprio per gestire tutte le diverse tipologie di problematiche che riguardano ad esempio il lanshink tra i diversi router i problemi legati all'estradamento nonché chiaramente la cifratura e che dicendo in particolare la cifratura viene gestita da quello che è il protocollo più importante del framework IPsec che è l'ESP l'Incapsuletta di Security Payload che è il protocollo che si usa appunto per la la cifratura dei dei pacchetti qui c'è una doppia modalità disponibile nel senso che si può decidere se cifrare l'intero pacchetto quindi non solo il payload non solo il messaggio che trasporta ma anche il suo header anche tutti i suoi metadati e chiaramente i router IPsec supportano questo tipo di opzione perché naturalmente sono tutti in grado di lungo il percorso di decifrare leader per decidere come instradare il pacchetto l'idea è che a un router al router c'è una fase di enxhake durante la quale i router condividono lungo il tragetto le chiavi per la cifratura e per l'integrità a coppie router successivi negoziano hanno una fase di setup durante la quale negoziano il materiale crittografico e questo permette loro naturalmente quando arriva un pacchetto di ingresso di decifrarlo decifrare leader naturalmente e decidere come instradarlo senza chiaramente decifrare il payload diversamente si può decidere invece di proteggere solo il payload lasciando in chiaro il leader ok la classica modalità VPN prevede l'intera cifratura del pacchetto vale un po' il discorso fatto per TLS le chiavi usate sono numerose si usano chiavi diverse per la cifratura e per il MAC si usano chiavi diverse a seconda della direzione di comunicazione e comunque stiamo parlando di comunicazione router to router non end to end perché ogni ramo del percorso end to end ha le sue negozia le diverse chiavi da utilizzare e il PSEC sprutta diverse modalità tutte quante che rispondono al paradigma encrypted MAC non è utilizzatissimo rispetto invece a protocolli di più ampio successo come TLS proprio perché necessita che tutti i router lungo la rete supporti il PSEC perché diversamente non sarebbe possibile e questo è un grosso limite chiudiamo la carrellata di esempi di paradigmi di cifratura authenticata mostrandovi come funziona la cifratura authenticata di Whatsapp e come funziona quella di Telegram le faccio vedere tutte e due perché quella di Whatsapp usa un paradigma che è l'encrypt del MAC quindi un paradigma standard mentre invece quella di Telegram usa uno schema integrato originale quindi prende le primitive come AS e SHA 256 e le utilizza in un modo nativo quindi in uno schema misto ok Telegram nasce dopo Whatsapp nasce originariamente perché perché si voleva offrire uno strumento che ponesse la sicurezza come focus non so se avete presente se vi ricordate la cronostoria di queste applicazioni però le prime versioni di Whatsapp non supportavano la crittografia ok quindi le trasmissioni non mi inchiare arriva Telegram e dice no noi vogliamo superare i limiti di Whatsapp perché vogliamo supportare la crittografia e lo facciamo in un modo nativo originale attento alle performance ma anche alla robustezza e questo è stato un po' diciamo il cavallo di battaglia di Telegram quando è uscito Whatsapp ha risposto dicendo va bene adesso supportiamo anche nella crittografia e lo facciamo usando un paradigma standard ok perché sappiamo come si comportano i paradigmi standard e tutto sommato hanno avuto ragione nel senso che al giorno d'oggi probabilmente è più robusto Whatsapp di quanto non sia Telegram e il motivo è che Whatsapp ha optato per un paradigma standard Telegram per un paradigma nativo e dopo qualche anno di tentativi di attacchi di crittanami su Telegram qualche vulnerabilità di Telegram è venuta fuori se qualcuno voglia di fare questo tipo di approfondimento vi posso dare riferimenti c'è ad esempio un bell'articolo del del Politecnico di Zurigo il cui ricercatori hanno individuato quattro diverse vulnerabilità di diversa natura del protocollo di Telegram offrendone poi al tempo stesso anche potenziali rimedi e questo è interessante perché appunto mette in evidenza il fatto che usare protocolli nativi ci espone a delle vulnerabilità che naturalmente nel caso di paradigmi standard sono già state studiate ampiamente e quindi se ne conoscono le caratteristiche adesso più recentemente è venuta fuori come ulteriore app per di questo tipo di servizi che è Signal che non c'entra niente con Signal protocoll di Whatsapp sono due cose diverse questo che vedete in questa slide è la descrizione del protocollo di autenticata di encryption che usa Whatsapp e che si chiama Signal poi invece c'è l'app che è diversa da Whatsapp un'altra cosa che anche questa si chiama Signal e che invece ha un altro meccanismo ancora di autenticata di encryption che a detta loro è il più sicuro di tutti poi in base a cosa dicono questo specialmente nel confronto con Whatsapp non lo so non è chiaro però ognuno tirerà quel proprio mulino e anche lì sarebbe interessante andare a vedere come funziona nel dettaglio ora qui in poche righe capiamo subito per quale motivo lo schema lo schema adottato da Whatsapp è uno schema standard ok innanzitutto hanno copiato a piene mani il meccanismo di TLS quindi hanno una fase di setup di un shake iniziale durante la quale una master secret viene concordata ok dopodiché esattamente come in TLS si usa HKDF con il master secret come input per generare tutte le chiavi che servono ok se ve lo state chiedendo cosa succede alle vostre chat ogni chat ha una master secret e quella rimane sempre ok poi ogni messaggio inviato all'interno di una chat viene cifrato con una chiave diversa la modalità è quella dell'encrypt mac quindi uno standard di fatto il più classico degli encrypt mac perché la cifratura viene fatta usando AS256 in CBC mod quindi un cifrario probabilistico CPA sicuro ok per quanto riguarda invece l'integrità si usa HK che come ben sappiamo si basa su SHA256 ok è interessante notare che le primitive di fondo sono le stesse che usa Telegram perché anche Telegram usa AS e usa SHA però li usa in modo completamente diverso come vedremo poi ok le master le master secret key vengono cambiate solamente quando avvengono degli eventi importanti l'ho citato lì ad esempio quando se disinstallate WhatsApp e lo reinstallate lì in quel caso vengono chiaramente aggiornate vengono cambiate le master secret keys così come se cambiate il telefono la vera è che potete fare il backup delle vostre chat e importarle però nel momento in cui cambiate il telefono da quel momento in avanti il proseguo delle chat avviene sulla base di un nuovo master secret condiviso con l'host dall'altra parte ok e la negoziazione del master secret quindi tutto il materiale crittografico che serve per la cifratura e l'integrità è un qualcosa che avviene end to end tra i due host coinvolti e non coinvolge minimamente i server centrali di WhatsApp e quindi non ha modo di decifrare i messaggi che vengono scambiati quindi è una cifratura robusta non solo nei confronti di avversari esterni ma anche nei confronti di WhatsApp stesso dei server stessi di WhatsApp ok quindi niente di strano dentro WhatsApp l'unica cosa che forse vale la pena raccontare è che è un po' è un pochino originale rispetto al paradigma che conosciamo è il modo in cui WhatsApp gestisce gli allegati ok quindi quando trasmettete un vocale o quando trasmettete una foto un'immagine no la cosa avviene in una maniera un pochino più laboriosa e avviene in questo modo questa è la diciamo la cronologia degli eventi quando un allegato viene poi involto quindi anche gli allegati vengono cifrati ok solo che vengono cifrati usando chiavi diverse naturalmente rispetto a quelle di messaggio che ho detto prima ogni messaggio tra l'altro viene cifrato con una chiave diversa quindi lo stesso vale anche per gli allegati quindi il tutto comincia con il mittente che vuole mandare un allegato che cifra l'allegato usando una coppia nuova di chiavi chiave di cifratura chiave di integrità per il mac ok chiavi che come al solito derivano usando hkdr a partire dal master secret dopodiché che cosa succede che l'allegato non viene trasmesso direttamente al destinatario ma l'allegato viene caricato su quello che viene chiamato blob store che è un repository temporaneo dei server di whatsapp ok qui c'è un passaggio intermedio vedete ok quindi il vostro allegato arriva scriptato sui server di whatsapp chiaramente chi gestisce il server di whatsapp vede sul blog store un file cifrato e non ha modo di ispezionarlo di aprirlo perché non conosce le chiavi ok a questo punto che cosa succede che lungo il canale della chat quindi sul canale diretto mittente destinatario quindi sullo stesso canale che si utilizza per trasmettere i messaggi tanto per intenderci il mittente trasmette la coppia di chiavi al destinatario ok diciamo il canale è una VPN protetta e quindi posso trasmettere le chiavi sicuro del fatto che queste le potrà leggere solo il destinatario c'è la VPN tra i due e quindi posso tranquillamente trasmettere le due chiavi oltre alle due chiavi il mittente invia anche un digest calcolato usando shadow 156 dell' allegato cifrato ok e naturalmente un puntatore al repository al blog store dove l'allegato è parcheggiato dove l'allegato si trova in quel momento ok quindi riassumendo cifro l'allegato usando chiave di cifratura e chiave per il mac lo lo parcheggio nel blog store mi metto a disposizione il server centrale di whatsapp dopodiché al destinatario trasmetto le chiavi che ho usato per la cifratura trasmetto un digest del file dell'attachment cifrato e il puntatore allo store dove si trova il file cifrato a questo punto il destinatario che riceve tutte queste informazioni che cosa fa preleva dal blob store l'allegato verifica che sia integro attraverso il digest questo per avere la garanzia che mentre il file cifrato è rimasto nello store nessuno lo ha modificato ok quindi questo è il ruolo alla funzione del digest calcolato con SHADW256 permette al destinatario di verificare l'integrità del file cifrato una volta che la verifica ha successo a questo punto può decifrare il il l'attachment usando le due chiavi il paradigma è sempre quello dell'encrypt del MAC e quindi a ritroso fa le operazioni che già conosciamo per recuperare l'allegato in chiave ok questo è il modo in cui viene gestita la trasmissione del degli attachment in un WhatsApp tutto chiaro? sì allora per garantire l'integrità del contenuto chiaramente basta il MAC il digest SHADW256 è un livello in più che tu aggiungi perché perché se il destinatario verifica che il ciphertext è corrotto perché il digest non corrisponde non va nemmeno avanti con la decifratura sì è anche beneficenza permetti che ci sia che ne so questo può capitare con un allegato particolarmente grosso situazioni di questo genere per cui se il ciphertext è corrotto per tanti motivi che magari non sono legati alla sicurezza io non procedo neanche con la decifratura perché tanto so già che non è integro potrebbe non essere integro perché perché non è andata a buon fine la trasmissione dal sender al blog store è successo qualcosa nel blog store o è successo qualcosa nella trasmissione dal blog store alla destinata tante cose possono capitare e corrompere il ciphertext se non è integro io non lo decifo che è un'operazione che invece di per sempre magari può essere anche piuttosto laboriosa ok non so se avete mai notato ogni volta che dovete vi mandano un allegato una foto qualche ogni volta che lo dovete aprire rimane offuscata c'è il timer che gira perché sembra che lo stia scaricando e ci vuole del tempo parte di quel tempo che voi state aspettando dipende dipende sì dalla trasmissione dal blog store al destinatario ma parte dipende anche dalle operazioni legate alla verifica del digest e alla decifratura ok poi non so se vi è mai capitato che il download dell'allegato fallisce fallisce perché è fallito è fallita la verifica è fallita la verifica del digest tipica made ok ok it's automatic it's a it's automatic all now all the communication are protected by this kind of VPN including including attachments I don't remember whether it is still an option that you can flag in the options of the app I don't remember but for sure by default nowadays everything is encrypted yeah yeah yeah yeah yeah end to end in this way meaning that the whatsapp servers are excluded because because of the way in which in which we have seen that the encrypted mac is used yeah even the database everything is encrypted with the key material that is known only by the two hosts and not by the server the device the device that's why the master secret is renegotiated whenever you change the device or you reinstall the app everything must be renegotiated every cryptographic material most dite conoscere e different key for every massage within the conversation it should be who knows telegram telegram è interessante perché ripeto questo protocollo che si chiama mtproto nasce quando ancora whatsapp non garantiva la trasmissione protetta delle informazioni e nasce con l'idea di usare nella maniera più efficiente possibile primitive criptografiche le stesse che usa whatsapp perché anche qui dentro vedete che si fa uso di as e di sha 256 quindi le primitive di fondo sono sempre le stesse ma si usano in maniera radicalmente diversa non si usa il paradigma encrypt the mac ma qualcosa che come vedremo qui adesso mescola un po' l'uso delle diverse primitive per cui questo non è un approccio composizionale di meccanismi che abbiamo già visto qui non vedete un cifrario probabilistico cpa sicuro o un mac ma vedete che mescolando l'uso delle due primitive si ottiene un qualcosa che in teoria dovrebbe garantire contemporaneamente segretezza e integrità ok questo è più o meno vero nel senso che recentemente ripeto sono state trovate delle vulnerabilità a questo protocollo in parte risolte con delle patch in parte telegram non ha nemmeno risposto a determinate vulnerabilità che sono state sollevate dai ricercatori comunque la situazione è ancora un po' così un po' nebulosa da questo punto di vista ora vediamo brevemente che cosa succede questo è lo schema che ho preso direttamente dalla documentazione di mtpro questo è il plaintext il formato del pacchetto che va cifrato ok contiene diversi metadati c'è un valore random di disessione il payload il messaggio vero e proprio da cifrare il padding e di così via questa è l'equivalente del master's secret ok quindi è una chiave k che i due due host durante una fase di nshake iniziale hanno condiviso ok qui dice anche come è stata condivisa allora persistente significa che non cambia mai tra i due host è sempre la stessa qui dice che è stata generata usando giffy elman che è un protocollo basato sulla cifratura chiave pubblica che vedremo dalla prossima settimana quindi sappiamo che c'è una fase nshake iniziale che permette ai due host di condividere il master's secret che è la nostra chiave k da qui in avanti vedete come il master's secret viene utilizzato per cifrare e al tempo stesso garantire l'integrità del del messaggio ok ora vediamo un po' che cosa succede bisogna generare dei valori randomici perché chiaramente la cifratura deve essere probabilistica ok quindi vedete che la chiave e il messaggio ok vengono concatenati dati in pasto a shadow 156 che quindi calcola un digest questo digest dipende dalla chiave e dipende dal messaggio il messaggio vedete che già di per sé ha degli elementi randomici perché c'è un sale il sale è un non informazione randomica ok quindi anche se avete messaggi della stessa sessione magari con un payload uguale o comunque molto simile comunque va con un sale diverso e quindi questo mescola rende già di per sé randomico il messaggio quindi chiave messaggio concatenati insieme producono un digest per effetto di shadow 156 questo digest lo chiamiamo message key ok poi cosa succede? succede che la stessa chiave insieme a questa message key vengono dati in pasto ad un algoritmo che è di fatto HKDF ok in realtà su questo input e su questo input non si usa sempre l'intera K una parte di K si usa qui e l'altra parte si usa qua quindi K da due diversi contributi diciamola banalmente si prende K la si divide in due una metà va in shadow 156 col messaggio l'altra metà va in KDF in HKDF insieme a il message key ok quindi l'output di HKDF vedete che dipende in parte dall'applicazione due volte fondamentalmente di una funzione hash applicata sulla chiave perché c'è un primo passaggio qui ma un secondo passaggio anche qua ok e in parte invece dipende dal messaggio quindi in parte la chiave e in parte il messaggio vengono usati come input di HKDF per generare che cosa per generare di base due informazioni importanti quali sono queste due informazioni importanti beh una è una chiave AS da 256 bit perché per la cifratura si utilizzerà AS 256 ok l'altra informazione è il nonso l'initial value che serve per un cifrario probabilistico basato su AS ok perché noi sappiamo che non possiamo prendere un block cipher e usarlo così com'è lo dobbiamo rendere probabilistico noi conosciamo due modi per rendere probabilistico un block cipher come come come se possiamo farlo in randomize counter mode in cbc mode ok telegram usa un altro modo simile al cbc mode che si chiama ije ok che è questo questo è un cifrario probabilistico basato su AS 256 fate finta che sia una roba simile al cbc mode ok che quindi ha bisogno per lavorare della chiave e del nonso ok sia la chiave che il nonso derivano da hkds che ha usato come input che cosa in una maniera un po' elaborata ha usato sia la chiave il master secret che il messaggio ok a questo punto il nostro cifrario probabilistico con queste con queste chiave nonso viene usato per cifrare il messaggio il cui risultato è questo satatext ok contemporaneamente la message key vi ricordate il digest della prima operazione che abbiamo fatto viene concatenato con cifrtext ok qual è secondo voi il ruolo che ha qui il message key di garantire quale proprietà l'integrità ok più ci sono i metadati più ci sono i metadati no infatti vedete che questo questa message key di fatto è il digest di di un'operazione di hashing fatta sul messaggio e sulla chiave e quindi dovrebbe garantire l'integrità non solo del messaggio cifrato ma anche del materiale crittografico che è stato usato per la cifratura mentre invece la chiave il non su usato per la la cifratura sono valori pseudo casuali impredicibili perché derivano dall'applicazione di HKDF il cui input è una qualche combinazione del valore del master secret e del messaggio ok e questo è il modo in cui funziona telegram dall'altra parte si verifica come prima cosa che questo valore sia corretto ok anzi si decifra il cypher text e poi se ne verifica l'integrità rispetto al message key al contrario scusate perché prima prima mi ricostruisco le chiavi perché chi riceve il messaggio usando il message key e il master secret è in grado di ricostruire chiave non perché l'input hkdf sono il message key e il master secret il message key fa parte del payload il master secret lo conosco uso hkdf recupero queste due informazioni usando queste due informazioni decifro il cypher text recupero il il plain text una volta che ho recuperato il plain text usando master secret e plain text il shadow 256 verifico la message key che faceva parte del payload quindi attraverso una catena di operazioni alla rovescia riesco a non solo a decifrare ma a verificare anche l'integrità quindi vedete questa è una costruzione che usa in maniera nativa primitive che già conosciamo le primitive di fatto sono due AS e SHA è vero che c'è anche hkdf ma non è una primitiva perché deriva da hmach e hmach non è altro che l'applicazione di SHA ok dopodiché qui però non vedete niente di quello che abbiamo studiato noi a livello di composizioni classiche encrypt and mac or mac and encrypt perché qui è tutto misto è tutto mescolato non è che prima si fa la cifratura e poi l'integrità o viceversa prima l'integrità poi la cifratura perché è tutto incastrato no in un algoritmo che mette insieme l'uso dell'una e dell'altra primitiva e quindi qui non riusciamo a dire questo non è neone neone neone neone chiaramente ok e quindi è uno schema integrato integrato proprio perché usa le primitive e lo fa in una maniera originale e è vulnerabile non è vulnerabile teoremi non ce ne sono a differenza delle costruzioni canoniche no c'è un teorema che dice che l'encrypt del mac è sicuro se usa un cifrario cpa sicuro e un mac sicuro punto fine della storia poi è ovvio che ci possono essere dei problemi legati all'implementazione e via dicendo però in linea di principio quello è abbiamo il teorema con il mac dell'encrypt sappiamo che non è così con questo neanche meno lo sappiamo ok quindi anche qui diciamo che col passare degli anni i vari tentativi all'inizio non hanno portato nessun risultato negli ultimi tempi qualcosina è venuto fuori a livello di vulnerabilità di diversa natura sia per quanto riguarda l'uso delle chiavi i nones che ci stanno qua dentro qualche cosina a livello di vulnerabilità è emerso ok poi chiaramente sono molto di queste cose sono state sistemate nell'implementazione però diciamo che non la la garanzia assoluta del fatto che questo schema integrato è sicuro non ce l'abbiamo ecco questo è un po' questo è un po' il discorso ok dubbi? tutto chiaro? va bene diciamo che sì ci fermiamo qua la prossima volta proseguendo su questi argomenti passeremo alla cifratura basata su chiave pubblica quindi cifratura asimmetrica non più simmetrica e quindi un paradigma completamente diverso che tra le altre cose ci permetterà di risolvere il problema dell'handshake iniziale necessario per condividere il master set ok ok grazie grazie