ok bene buongiorno allora intanto per capire how many non italian speaking ok ok so the lesson the lectures will be in italian yeah and but during the lecture if any questions i i will switch to english whenever you want yeah exactly as we we mentioned uh weeks ago so okay no problem also yeah yeah yeah okay even before and after the lecture uh for any any question and issues we can discuss whenever you want ok thank you dunque tanto benvenuto anche a faccia note non note questo è il corso di cyber security di sicurezza informatica questo lo sapete già di cosa parleremo in questo in questo corso il programma avete visto questo qua è presente nella nella scheda dell'insegnamento ci sarà una forte componente teorica su quelli che sono i principi della crittografia e che ci permetteranno di affrontare tematiche di natura più pratica diciamo che gran parte degli argomenti che vanno dalla seconda sezione in avanti rappresentano una un escurso di quelle che sono diciamo maniera crescente gli argomenti che vanno dalle primitive le operazioni primitive che stanno alla base della crittografia fino ad arrivare alla definizione di protocolli crittografici basati su queste su queste primitive fino ad arrivare alla definizione di sistemi complessi che fanno uso di primitive di e di protocolli crittografici questo appunto dal ne sono gli argomenti che tratteremo in linea di principio dalla sezione 2 in avanti parallelamente affronterò anche invece il tema della cyber security dal punto di vista del sistema azienda che deve gestire la protezione della sicurezza dei propri asset utilizzando naturalmente i meccanismi teorici che andremo a studiare e questo invece riguarda la prima parte del programma la sezione 1 dove si dove affronteremo quelle che sono le tematiche di natura gestionale dal punto di vista di chi all'interno in azienda deve gestire la sicurezza ok questa è anche la parte che prevede aspetti di natura un po più pratica ad esempio li vedete nella sezione 1 5 no quella buon esercizio di pen testing anche perché questo è un po' la diciamo la ricaduta pratica più importante che sia in contesti di quel tipo la mia idea è di portare avanti parallelamente la sezione 1 e le sezioni successive quindi alternando lezioni puramente teoriche dove racconteremo quelle che sono appunto le caratteristiche delle primitive fotografiche alle storie dove invece vi racconterò cosa significa fare sicurezza all'interno dell'azienda cosa significa difendere il perimetro aziendale e che cosa significa mettere in atto strumenti e attività legate non solo al pen testing ma tutto quello che concerti naturalmente il problema dalla cyber security in generale quindi questo ci permetterà di alternare no momenti di natura più teorica momenti di natura un po più un po più pratica questo avrà una ricaduta anche su quello che sulle che sono delle modalità d'esame che è la cosa che forse interessa maggiormente capire l'esame prevede un progetto e prevede una prova orale che vengono valutati equamente impari nel contribuiscono in pari misura al voto finale la prova orale tocca diciamo in maniera trasversale tutte le sezioni del programma tranne quella sezione o quelle sezioni che invece riguardano lo svolgimento del progetto ok e adesso capiremo più nel dettaglio questo che cosa significa ci sono diversi modi almeno tre modi di fare il progetto per l'esame uno è prettamente pratico e consiste esattamente in quell'esercizio che ho menzionato prima quindi fare pen testing ok di solito questo consiste nel realizzare una piccola rete virtuale il cui allestimento fa parte del progetto stesso della cosa di cui parleremo su come questo può avvenire e all'interno di questa piccola rete virtuale dove di solito è sufficiente che ci siano anche solamente due macchine virtuali un attaccante e una vittima e all'interno di questa piccola rete virtuale realizzare mettere in pratica alcune delle cose che vedremo inizione quindi implementare un attacco valutare uno strumento di difesa o situazioni di questo genere vi mostrerò alcuni esempi possibili di progetti svolti in questa maniera qua ne trovate già a disposizione anche nell'area blended sulla piattaforma dell'insegnamento che dopo vi farò vedere quindi una una possibilità sicuramente è quella appunto di realizzare una mini rete virtuale dove fare qualche esercizio di questa natura di pen testing e questo è un modo di fare il progetto naturalmente chi fa il progetto in questa maniera qua preparerà l'orale sulle altre sezioni quindi da 2 3 4 5 tralasciando la prima e questo è un modo un altro modo di fare il progetto consiste invece nel realizzare una tesina di approfondimento su uno qualunque dei temi che affrontiamo o che menzioniamo solo marginalmente la cyber security è un mare magnum di argomenti estremamente vasto che chiaramente noi non avremo la possibilità di visitare in maniera di navigare in maniera esaustiva è impossibile nell'ambito di un qualunque corso toccare tutti quanti gli argomenti possono essere utili interessanti per la cyber security quindi ci sono tante opportunità di prendere uno qualunque dei temi che affronteremo le azioni e di approfondirlo o essere voi stessi promotori di un argomento che non tocchiamo le azioni dire a me piacerebbe realizzare una tesina su su questo argomento chiaramente in quel caso un progetto coprirà anche se magari magari marginale una di quelle sezioni lì e quindi l'orale lo faremo sulle altre ok va lo stesso discorso di prima la terza alternativa anche questa invece più pratica diciamo consiste nel fare la verifica di un protocollo criptografico a un certo punto nella sezione 5 quando parleremo di protocolli criptografici studieremo anche delle tecniche per fare la verifica delle proprietà di sicurezza di protocolli criptografici quindi verificare se un protocollo garantisce la confidenzialità che è una delle proprietà che andremo a studiare quindi un'altra opportunità per eseguire il progetto consiste nel prendere un protocollo criptografico qualunque che concorderemo insieme modellarlo e farne la verifica formale delle proprietà questo chiaramente in questo caso di nuovo l'orale verterebbe sulle altre sezioni non e non sulla 5 quindi vedete ci sono vari modi di fare il progetto per quanto riguarda il progetto naturalmente vi chiederò di realizzare una presentazione come se fosse una discussione di di tesi ok quindi vi chiederò di realizzare un po di slide e giorno dell'esame voi presenterete il vostro progetto come se fosse una lezione ok e della durata di un quarto d'ora di più insomma un'esposizione snella di quelli che sono i risultati che avete acquisito mi racconterete il vostro progetto in quella maniera lì perché anche l'esposizione del progetto fa parte della valutazione naturalmente e poi seguirà l'orale che anche quello durerà un'altra quindicina di minuti di solito faccio una domanda per per ogni sezione del del corso non più di di tre domande che sono più o meno questo modo in cui si svolge si svolge il ruolo l'ora la tipologia dell'esame in qualunque momento durante il corso la possiamo discutere insieme nella proponete o sono a chiedete a me se non avete di cosa fare magari posso essere io a proporvi degli argomenti o una volta che abbiamo stabilito per ciascuno di voi qual è la tipologia più adatta il progetto comunque sempre un'esperienza individuale ok quindi ciascuno di voi farà il proprio il proprio progetto su un'idea che potrete proporre in qualunque in qualunque momento durante durante lo svolgimento del del corso questo è anche uno dei motivi per cui certi argomenti cercherò di anticiparli proprio per darvi anche più tempo per lavorarci sopra se potete portarli all'esame per quanto riguarda il materiale io l'ho già caricato tutto nel senso che la pagina blender del corso c'è link all'aula virtuale che uso per la registrazione delle lezioni la uso anche per fare ricevimento se qualcuno di voi per qualche motivo vuol fare ricevimento non in presenza in giorni che non siano il mercoledì e il giovedì ci mettiamo d'accordo e ci possiamo vedere online e qui vedete già i le cinque sezioni anzi vediamo se ho già trovato un refuso le cinque sezioni del del corso ecco adesso sono diventate cinque no perché non me la sono andata ok quindi adesso sono diventate cinque e quindi in ciascuna di queste schede trovate i pdf che uso gli slide in formato pdf più sezione per sezione troverete anche del materiale di approfondimento di cui vi parlerò di volta in volta poi in particolare per quanto riguarda il il progetto di penetration testing ho già preparato una cartella dove ci sono tutta una serie di di esempi vedete questi sono tutti esempi di progetti che sono stati svolti in passato su diverse tematiche a lezione ve ne farà vedere qualcuno però qui ne trovate anche anche di più rispetto a quelli che discuteremo che discuteremo a lezione e poi troverete qui man mano in questa in questa cartella tutte le registrazioni io di volta in volta di solito il giorno stesso in cui si è svolta la lezione carico carico qui sopra il link alla registrazione in modo tale che potete andarvele a rivedere o anche magari vi perdete qualche lezione qua le ritrovate le ritrovate tutte ok quindi qui dentro trovate tutti i riferimenti a tutto quanto il materiale che viene utilizzato e tornando alla scheda del corso io qua ho citato anche dei possibili testi di riferimento sia in italiano che in inglese ci sono adesso questa è la scheda in italiano ma c'è anche quella in inglese con materiale di riferimento allora sicuramente il testo che io ho usato come riferimento per la sezione 1 lo trovate scaricabile online è open access è open access se vi interessano altri testi relativa alle altre sezioni io qui ho indicato dei manuali però in realtà ce ne sono tanti in letteratura più o meno equivalenti e molti di questi sono disponibili in open access e quindi eventualmente se mi chiedetevi vi posso indicare quelli che vanno la pena in inglese ma è particolarmente facile trovare testi sulla crittografia in open access non è un problema in italiano in open access non si trova praticamente nulla quindi però questo per dirvi che ci sono anche possibilità di accedere a libri di testo fatti molto bene senza doverli comprare questo sicuramente va bene direi che ho detto più o meno tutto ci sono domande? c'è qualcosa che sul corso devo cambiare il giorno di ricevimento un'altra cosa che mi sono dimenticato che farò in presenza insomma noi faccio la lezione mercoledì e giovedì quindi queste sono giornate in cui prima o dopo la lezione io sono sempre disponibile per il ricevimento ok? quindi in queste due giornate senza nessun problema in altre giornate magari mi iscrivete prima e ci mettiamo d'accordo per farlo o online come dicevo prima oppure in presenza quando sono disponibili quindi da questo punto di vista nessun tipo di problema e niente direi che questo è tutto ecco insomma noi faremo lezione mercoledì mattina mercoledì pomeriggio e giovedì pomeriggio oggi pomeriggio non facciamo lezione l'ho annullata vi avviso sempre prima naturalmente quando ci dovessero essere dei cambiamenti ok? e questo è quanto ecco insomma poi se ci sono altre questioni che non riguardano esclusivamente questo insegnamento siccome io sono il coordinatore della magistrale quindi per qualunque genere di domanda dubbio o questione che volete pubblicare io sono sempre sempre disponibile ok? quindi fate pure riferimento a me per qualunque genere di problema che riguarda il corso di lava in generale insomma va bene? e d'accordo insomma questo è direi che se non ci sono domande da parte vostra noi oggi stamattina cominciamo e inizierei già in ordine sparso perché no dottor? sì ci saranno anche i seminari? può essere l'anno scorso sono riuscito a organizzarmi dipende sempre dalla disponibilità degli stakeholder esterni l'anno scorso ne avevo organizzati un paio tant'è che trovate qua da qualche parte anche anche le slide di quella lezione che di quel seminario che avevamo fatto ci provo anche quest'anno a vedere se riesco a invitare qualcuno magari dalle aziende per portare un la loro esperienza più diretta e pratica e mi piacerebbe quindi casomai poi ve lo dico vi avviso e in ogni caso come per le lezioni che faccio io la registrerei e metterei a disposizione del materiale questo sicuramente poi se ci sono dei temi particolari di vostro interesse me lo dite il prima possibile perché in genere io qualche ora me la lascio sempre come diciamo cuscinetto per riempirla con cose che vedo che possono essere di maggiore interesse visto che comunque c'è margine per approfondire qualche argomento e se le indicazioni vengono da voi tanto meglio insomma io sono contento di approfondire quelle cose che vedo che sono più interessanti più apprezzate dal vostro punto di vista quindi questo è va bene direi che questo è quanto voi sapete se c'è qualcuno che di solito frequenta da remoto in streaming oppure ok ok ok ti colleghi dal no giusto per sapere perché tanto in ogni caso la stanza virtuale comunque aperta perché la registro quindi però giusto per sapere se c'è qualcuno da remoto che perché le parti che delle volte non me ne accorgi se non guardo che ci sono i partecipanti però anche quando uno segue da remoto ci sono delle domande non non fatevi scrupoli ecco da questo punto di vista va bene io stamattina inizierei quindi non non dalla sezione 1 ma inizierei proprio con la primissima parte relativa agli aspetti teorici genere adesso non è il caso oggi perché facciamo lezioni solo stamattina però visto che il mercoledì facciamo quattro ore vorrei fare due ore di natura più teorica e due ore di natura un pochino più più pratica dividendo in questa in questa maniera e quindi direi che adesso lo mettiamo qua direi che oggi cominciamo parlando di delle basi della della della della della della della critografia che se ci serviranno appunto per arrivare ad approfondire tutte le varie le varie tematiche di interesse quindi partiremo in maniera soft con alcune nozioni di base che ci sia il corso è self-contained non assumo nessun genere di conoscenza pregressa tranne naturalmente alcune basi che comunque richiamerò quindi il background lo vediamo lo vediamo insieme e naturalmente poi dipende da certi contesti perché quando tratteremo la parte un po' più pratica ecco che magari di qualche non se ne progressa specialmente per quanto riguarda le le reti quello è naturalmente eh vantaggio se se ne avete ecco questo questo sicuramente eh invece per quanto riguarda la parte teorica eh direi che non ci sarà nessun problema da questo punto di vista eh le slide che uso sono in inglese però sono altamente tecniche come contenuti come natura per cui non credo che ci sarà nessun problema nel caso me lo dite eh e dove ci sono dei dubbi approfondiamo ehm come anticipato oggi cominciamo con un po' di di preliminari un po' di nozioni di base eh che comunque ci serviranno in corso d'opera e purtroppo non ho il tempo mi piacerebbe di eh fare un po' un excursus di quella che è anche la storia della della crittografia che ha radici lontane eh eh però direi che di fare questo non c'è tempo se volete se volete approfondire da un punto di vista storico le origini della crittografia me lo dite vi posso consigliare qualche testo interessante da questo punto di vista questo che trovate su questa slide The Codebreakers forse è uno dei libri scritti meglio che racconta racconta la storia la storia della crittografia da dagli antichi greci fino a dopo la seconda guerra mondiale insomma perché comunque è un libro la cui prima edizione risale agli anni 60 eh eh quasi un libro di narrativa quindi quasi un romanzo quindi è anche divertente da da leggersi ci sono parecchi aneddoti interessanti se invece vi interessa vi interessa un libro di questo genere però in italiano vi posso dare vi posso dare i riferimenti del caso ora per poter parlare di crittografia ci servono un po' di nozioni matematiche di base perché come dice la slide Cryptography is hard mathematics in action hard perché perché la maggior parte dei risultati matematici che sfruttiamo sono risultati legati ad un qualche grado a un qualche livello di difficoltà no? perché il scopo della crittografia è quello di mettere a disposizione strumenti per nascondere per celare e questi naturalmente fanno ampio uso di problemi che vengono dalla matematica e che sono difficili da risolvere ed è proprio quel livello di difficoltà che fa sì che usando questi strumenti dovremmo essere in grado di nascondere l'informazione a coloro che non vogliamo che la cedano e quali sono le nozioni di base che ci servono in realtà sono molto poche e ben confinate quindi ripeto non assumerò nulla dando nozioni per scontate e le nozioni che ci servono riguardano fondamentalmente la teoria dei linguaggi e le riguardano come vedremo un po' di teoria della probabilità che sono i due macro argomenti su cui si basano molte delle nozioni soprattutto a livello di definizione delle proprietà che riguardano la sicurezza informale faremo ampio uso di teoria della probabilità in particolare di teoria dei giochi perché molte delle proprietà di sicurezza che andremo a vedere si esprimono in questi in questi termini però sono piuttosto semplici nel senso che meno male che vedrete che sono sempre le stesse e quindi i concetti di base non sono eccessivamente complessi ora in realtà di teoria dei linguaggi ci servono solamente pochi pochi rudimenti condensati in una notazione che è questa che vedete in questa slide che utilizzeremo abbondantemente la crittografia lavora fondamentalmente su string ok? l'obiettivo della crittografia appunto è manipolare in un modo apparentemente casuale manipolare string che ad un certo livello di astrazione potete considerare come string binario né più né meno perché questo ci fa comodo perché qualunque tipologia di informazione la possiamo vedere ad un certo livello di concrattessa come una stringa di bits ok? quindi le primitive e gli algoritmi che studieremo di fatto sono rappresentabili come funzioni matematiche che lavorano su stringhe ok? stringhe che vengono manipolate spesso volentieri vengono spezzate, ricomposte, concatenate attraverso una serie di operazioni che si basano su primitive matematiche che come vedremo alla fine sono poi sempre le stesse sono molto poche le operazioni che si usano le operazioni primitive che si usano in crittografia sono veramente poche e quindi alla fine le operazioni di base che vedremo sono sempre le stesse le stringhe come detto si compongono a partire dai simboli dell'alfabeto di riferimento il genere dell'alfabeto che assumeremo è quello binario quindi 0 e 1 e le stringhe si ottengono per concatenazione dei simboli dell'alfabeto e se prendiamo in considerazione un alfabeto generico sigma è un insieme di simboli l'operazione tipica per la creazione di stringhe di una certa lunghezza a partire da questi simboli è quella che vedete espressa come la ennesima potenza l'ennesima potenza dell'alfabeto è quell'operazione che ci permette di prendere n simboli dell'alfabeto concatenarli e formare una stringa una parola di lunghezza n la definizione che vedete sigma la n che cos'è? beh ci dice che sigma la n è l'insieme di tutte le parole di lunghezza n composte di simboli che fanno parte di sigma tutto qua niente di strano niente di particolare però ha una notazione che è bene ricordarsi perché dominio e codominio delle funzioni criptografiche che studieremo sono sempre una qualche combinazione di potenza di alfabeti ok? quindi oggetti come sigma la n rappresentano parti del dominio e del codominio delle funzioni criptografiche che studieremo perché? perché le funzioni criptografiche lavorano su stringhe e producono stringhe quindi dovremmo avere a che fare con questo tipo di dominio a volte utilizzeremo questa notazione che vedete qua sigma minore uguale a n per esprimere l'insieme delle stringhe di lunghezza al più pari a n quindi matematicamente parlando come vedete qui questo sigma minore uguale a n l'unione di che cosa? di tutti gli insiemi di stringhe di qualunque lunghezza purché appunto minore uguale a n costruite usando i simboli di sigma quindi formalmente è questa unione qua no? c'è la stringa vuota perché quell'unione va da 0 a n quindi c'è anche la stringa vuota che è l'unica stringa di lunghezza 0 e che di solito le indichiamo con epsilon poi ci sono le stringhe di lunghezza 1 le stringhe di lunghezza 2 le stringhe di lunghezza 3 fino ad arrivare alle stringhe di lunghezza n ok? quindi quando vedrete questa notazione qua sigma a minore uguale a n stiamo denotando insieme di tutte le parole la cui lunghezza è appunto minore uguale a n ok? quindi funzioni crittografiche appunto che come vedremo lavorano su stringhe l'altra componente fondamentale che vedremo fin dall'inizio è un po' di teoria delle probabilità perché come vedremo in crittografia è fondamentale affidarsi alla teoria lo vedremo già oggi il motivo per cui è importante affidarsi alla teoria delle probabilità perché fin da subito abbandoneremo un'idea di crittografia ideale di crittografia perfetta poi vedremo questo che cosa che cosa significa e nell'abbandonare un'idea di una crittografia ideale dovremmo appoggiarsi appoggiarsi a approssimazioni che si basano ampiamente sulla teoria della probabilità ora non pretendo di rivedere un intero corso di teoria di calcolo combinatorio di teoria della probabilità anche perché noi useremo poche nozioni che fanno parte di questo ambito qui ho rassunto quelle che di fatto utilizzeremo con maggiore frequenza quindi che cos'è una random variable cos'è una variabile casuale che cos'è una distribuzione di probabilità e in particolare che cos'è una distribuzione di probabilità uniforme ora se avete fatto un corso di calcolo della probabilità nella vostra esperienza di progressa cos'è una random variable lo sapete se non lo sapete è una cosa estremamente banale una variabile casuale una random variable è una qualunque variabile che può assumere come valori i risultati di un fenomeno casuale di un esperimento casuale ok l'esempio classico dell'esperimento casuale è il lancio della monetina no? o il lancio di un dado ok? una variabile casuale che assume come valori gli esiti del lancio di una monetina quindi che assume come valore testa oppure croce quella è una variabile random proprio perché assume come valori i possibili esiti di un esperimento casuale no? e lo stesso se vogliamo che so, raccogliere i risultati di diversi lanci di un dado usiamo una variabile casuale che assumerà come valore una delle 6 facce del dado a seconda del risultato dell'esito del lancio ok? quindi si dice random casuale proprio perché il valore che esso assume dipende da un fenomeno che è casuale ok? e che viene descritto attraverso una opportuna distribuzione di probabilità no? una distribuzione di probabilità che cos'è? è una funzione che assegna ad ogni possibile esito dell'esperimento casuale un valore compreso fra 0 e 1 che rappresenterà quindi la probabilità la likelihood che quel valore rappresenti effettivamente l'esito dell'esperimento no? e nei due esempi che vi ho fatto il lancio della moneta o il lancio di un dado i diversi possibili esiti hanno sono tutti quanti associati alla stessa probabilità assumendo che la moneta non sia truccata assumendo che il dado non sia truccato nel caso della moneta la distribuzione di probabilità associata ai due possibili esiti testa o croce ci dice che questi due esiti hanno entrambi probabilità un mezzo ok? se invece parliamo del dado i sei possibili esiti hanno tutti probabilità un sesto ok? ora l'assegnamento di questi valori di probabilità ai vari possibili esiti dell'esperimento prende appunto il nome di distribuzione di probabilità e i due esempi che vi ho fatto sono esempi di distribuzione di probabilità uniformi proprio perché ogni possibile outcome ogni possibile esito dell'esperimento è associato allo stesso valore di probabilità e guarda caso le distribuzioni di probabilità uniformi sono quelle che ci interessano maggiormente nell'ambito della crittografia siccome come vedremo poi tra poco l'obiettivo è quello di mascherare il più possibile una determinata informazione e se il modo in cui l'informazione viene nascosta dipende da un calcolo di natura probabilistica naturalmente saremo tanto più più bravi a celare l'informazione quanto più un osservatore esterno un avversario, un attaccante non riesce a dedurre nulla di significativo sulla base di quelli che sono i possibili esperimenti probabilistici che vengono eseguiti quindi se tutti i possibili eventi se tutti i possibili outcome hanno la stessa probabilità l'avversario non ha nessun vantaggio a priori nello stabilire ma è più probabile che succeda una cosa piuttosto che un'altra è più probabile che quella informazione che è nascosta provenga da una determinata origine piuttosto che da un'altra no, se tutto è caratterizzato da una distribuzione di probabilità uniforme ecco che come vedremo entreremo nel dettaglio di queste affermazioni che sto facendo diventa più difficile per un avversario riuscire a svelare determinate informazioni quindi sicuramente ci interessano le distribuzioni uniformi non tutte lo sono adesso io vi ho fatto due esempi di distribuzioni uniforme ma è facile tirare fuori esempi di esperimenti casuali i cui possibili outcome non sono descritti dalla distribuzione di probabilità uniforme tanto per fare un esempio banale simile alle due che vi ho appena fatto prendete in considerazione non uno ma due dadi quindi il vostro esperimento non è il lancio di un dado ma è il lancio di due dadi i possibili assumiamo che i possibili outcome che ci interessano di questo esperimento non siano tanto il fatto che il primo dado esibisce un 3 il secondo dado esibisce un 4 ma l'outcome che ci interessa è la somma no? dei risultati dei due dadi ok? quindi l'esperimento casuale è il lancio di due dadi i possibili outcome sono i numeri compresi tra quali sono i possibili outcome? tra 2 e 12 no? che sono le somme possibili a seconda di cosa saltano fuori e cosa saltano fuori c'è un dado quindi il dominio degli outcome possibili è l'intervallo da 2 a 12 qual è la distribuzione di probabilità associata a questi valori? è uniforme oppure no? no ad esempio perché non è uniforme? ad esempio qual è la probabilità associata al 7 come risultato? come risultato allora intanto come facciamo a fare i conti? eh? è un po' di più in realtà è un po' di più perché allora intanto quante quante sono le possibili i casi possibili quindi ogni dado può dare 6 valori 6 risultati per ciascuno di questi 6 l'altro dado può dare i suoi 6 quindi stiamo parlando di disposizioni di 6 elementi presi due alla volta in termini tattici in termini pratici i casi possibili sono 6 a quadrato quindi sono 36 no? intuitivamente è molto semplice il primo dado può dare 1 e se il primo dado da 1 l'altro dado può dare da 1 a 6 quindi 6 diversi casi il primo dado può dare 2 quindi sono altri 6 casi il primo dado può dare 3 altri 6 casi quindi alla fine sono 6 per 6 no? quindi sono 36 i casi possibili quindi ripeto formalmente sono 6 al quadrato niente ciao formalmente sono 36 perché si tratta di disposizioni di 6 elementi presi due alla volta quindi e la formula è n alla k quindi 6 al quadrato quindi sono 36 quanti di questi 36 danno 7 come risultato? no no un po' di più e e e e e e e e e e e e e e e e e e e e e e e e i e e questi quanti sono i e quando è che viene 7? Viene 7? Se il primo dado da uno il secondo dado deve dare 6 se il primo dado da 2 il secondo dado deve dare 5 e andiamo avanti così sono prima di tutto beh perché 12 scusate ho fatto si ho sbagliato allora allora così così così così e così no? sono secchi sono sei infatti uno con sei oppure sei con uno due con cinque oppure cinque con due quattro con tre oppure tre con quattro ok quindi ci sono tutti ok quindi quanto viene? quanto fa? sei un sesto un sesto invece qual è la probabilità associata all'outcome 2? quindi un trentaseiesimo quindi è tutto tranne che una distribuzione di probabilità uniforme perché abbiamo un outcome che ha la probabilità associata a pari un sesto ne abbiamo un altro che ha la probabilità associata a un trentaseiesimo e così via gli altri saranno valori anche loro diversi ok il sette è il risultato più probabile questo è il motivo per cui al casino quando al gioco del lancio dei dadi si scommette sul sette perché è l'esito più probabile ok e ripeto a noi interesseranno distribuzioni di probabilità uniforme è quasi sempre una delle assunzioni di base no? quindi random variable probability distribution uniform probability distribution questi sono i tre concetti che utilizzeremo ampiamente tutto qua ok le funzioni criptografiche sono funzioni che lavorano su questi insiemi cioè su insiemi di parole su insiemi di stringhe di una certa lunghezza ok e si tratta come vedremo di funzioni di natura probabilistica no? e non tarderemo molto a giustificare il motivo per cui dobbiamo usare funzioni di natura probabilistica lo vedremo lo vedremo abbastanza rapidamente le funzioni criptografiche che andremo a studiare che lavorano su stringhe che fanno uso dell'attività delle probabilità sono funzioni che sono poi utilizzate in una marea di contesti diversi il cui obiettivo è quello di garantire una qualche condizione di sicurezza dove per sicurezza vedremo si possono intendere tante diverse cose tante diverse proprietà ok noi cominceremo studiando le tre proprietà fondamentali della sicurezza che sono confidenzialità che è un sinonimo di segretezza e integrità e autenticazione entreremo nei dettagli di queste di queste tre però diciamo che le stesse primitive possono essere utilizzate per garantire queste diverse proprietà in diversi contesti quali sono questi contesti? è importante garantire la sicurezza dei dati memorizzati stoccati da qualche parte data at rest significa dati che risiedono ad esempio in un database ad esempio in un dataset ovunque quindi la sicurezza dei dati stoccati ok di solito in questo caso la proprietà che ci interessa è la confidenzialità no? garantire che quei dati non siano accessibili agli utenti non autorizzati ma anche l'integrità mi interessa che un dato memorizzato da qualche parte non venga modificato senza che io me ne accordi ok ma è altrettanto importante garantire la sicurezza dei dati trasmessi data in transit che cosa significa? significa garantire la sicurezza delle informazioni quando queste vengono comunicate di solito in rete ok e anche lì quali sono le proprietà che ci interessano? di nuovo probabilmente la segretezza ma anche l'integrità ma probabilmente anche l'autenticità delle informazioni cioè garantire che l'informazione che venga trasmessa rimanga segreta cioè solo gli utenti autorizzati la possono leggere ma voglio anche garantire che rimanga integra io voglio avere la garanzia che l'informazione che parte da qui e che arriva là arrivi nella stessa forma in cui è partita che non sia stata modificata da qualcuno nel mezzo ok quindi integrità ma anche autenticità chi la riceve deve magari volere la garanzia dell'identità di chi l'ha trasmessa ok quindi anche in questo caso la sicurezza è importante e in ultima istanza è importante garantire la sicurezza anche dei dati anche quando questi vengono utilizzati quindi mentre vengono utilizzati ok quindi sicurezza dei dati nei dispositivi di memoria e in quel caso il dato ha un ruolo passivo è semplicemente memorizzato ma io ne voglio garantire una qualche condizione di sicurezza sicurezza dei dati nel momento in cui vengono trasmessi trasferiti da un luogo all'altro sicurezza dei dati quando vengono utilizzati perché non necessariamente a use data è a communicated data data in transit data in transit data in transit data in transit is clear i transmit over the internet file or something else data in use could be for instance the fact that I'm doing some local computation and this local computation requires a combination of local data and cloud based data so this data have to be combined somehow obviously there's a communication there's an implicit communication but not only communication there's also some computation and I wanted such a computation would be secure okay even the outcome of the computation has to be secure there are even more complex examples like for instance multi-party computation which is a very nice application of cryptography have you ever heard about multi-party computation a small example all of you have some personal information we have to compute a result based on all the inputs on all your inputs so she has a piece of information she has another piece of information you have the third piece of information these three pieces of information are necessary to compute some kind of result okay but all of you intend to maintain the secrecy of your own piece of information you don't want to reveal your piece of information to her and she doesn't want to reveal her piece of information to you but this piece of information has to be combined somehow by preserving this security condition and multi-party computation has the objective of combining this information without compromising the secrecy is one of the multi-party computation is one of the applications forse more elaborate more sophisticated in the field in the field ultimately vanno molto di moda perché pensate alle nell'ambito dell'intelligenza artificiali gli approcci federati dove avete dataset che devono essere costruiti combinando informazioni che vengono da diverse fonti non è spesso volentieri un dataset locale deve poter partecipare all'addestramento di un sistema centralizzato senza che le informazioni del dataset vengano da quindi l'idea lì è che tante diverse fonti devono fornire il loro contributo al dataset per poter addestrare un sistema centrale ma il sistema centrale non deve apprendere le informazioni relative al dataset locale questo è un classico esempio di applicazione della multiparty computation in tutti e tre i contesti ci sono un sacco di esempi complessi che fanno uso di crittografia ma alcuni di questi li studieremo in dettaglio altri li accenderemo soltanto ad esempio data at rest perché è importante oggi come oggi garantire la sicurezza la confidenzialità delle informazioni che sono stoccate da qualche parte beh immaginate appunto oggi come oggi i dati hanno un grande valore i big data hanno un grande valore perché? perché vengono utilizzati per addestrare reti neurali che danno una grossa mano in determinati contesti il valore non sta tanto nello strumento in sé nella rete ma sta nei dati che vengono usati per addestrare ok e quindi spesso e volentieri la confidenzialità del dataset è fondamentale ok pensate a dati sensibili in un contesto aziendale perché non è safe in un contesto aziendale usare chat GPT per redigere il bilancio previsionale dell'azienda è efficace e molti lo fanno ma perché non è safe fare? perché significa di fatto mettere in piazza i vostri dati che possono essere di natura critica ok quindi è interesse dell'azienda fornire sì i propri dati per addestrare un sistema che possa aiutare in certi processi decisionali ma io voglio anche garantire che i dati che fornisco rimangano confidenziali ok e ci sono un sacco di approcci che vengono utilizzati nell'ambito della cifratura per garantire questo in questo particolare contesto data in transit lì vedremo tante cose come si fa a garantire la confidenzialità l'integrità l'anticità delle informazioni che vengono trasmesse su internet è il primo argomento che faremo e quello lo studieremo in maniera approfondita ok HTTPS è un esempio di protocollo che garantisce questo e che si basa su un protocollo crittografico che si chiama TLS e che noi andremo a studiare in maniera approfondita molto nel dettaglio delle multiparty computation vi ho già detto qualche cosa ed è uno degli approcci che si usa molto spesso per garantire la sicurezza dei dati appunto utilizzati e poi ne ho citati altri che vanno di moda come ad esempio l'omomorphic encryption che è uno è uno degli argomenti su cui uno potrebbe fare una tesina perché noi non avremo tempo di approfondirlo ma è molto interessante perché l'omomorphic encryption risolve un problema non banale ora cosa succede se per garantire la sicurezza dei dati at first voi li cifrate ok poi però quei dati li dovete usare ad esempio perché li dovete aggiornare immaginiamo che sia un database ok voi mantenete il database contiene dati sensibili quindi sul database le informazioni sono cifrate usando uno dei metodi che studieremo ok poi però capita che il database non c'è chiaramente il database non è la sola lettura è anche scrittura allora io devo fare una modifica normalmente come farei dovrei prendere il dato da modificare decifrarlo aggiornarlo cifrarlo nuovamente memorizzando il database però queste sono operazioni che in certe fasi espongono l'informazione l'omomorphic encryption è una tecnica che permette di modificare direttamente il testo cifrato con la garanzia che gli aggiornamenti che vengono fatti al testo cifrato sono propagati sono ereditati anche dall'informazione che è nascosta all'interno del testo cifrato ok sembra strano dita così però ci sono operazioni che preservano questa questa proprietà per fare un esempio banale ci sono delle operazioni tale per cui che ne so voi prendete la somma di due interi 5 più 7 fa 12 ok bene voi prendete il 5 lo cifrate prendete il 7 lo cifrate ottenete due due valori cifrati che rappresentano il 5 e il 7 sommate due valori cifrati ottenete di nuovo un valore che apparentemente non ha alcun significato perché è una cifratura decifrate questo risultato e cosa ottenete ottenete 12 ok quindi operazioni applicate sui valori cifrati producono lo stesso esito sui quelli che vengono chiamati test in chiaro i plaintext associati con i valori cifrati quindi capite bene che è un approccio estremamente conveniente in determinati casi purtroppo è molto costoso in termini computazionali l'homomorphic encryption è pesante dal punto di vista della complessità computazionale quindi non se ne può fare un uso massivo e poi ho citato la trust in execution environment perché anche questo va di moda mettere a disposizione degli ambienti sicuri quindi sia dal punto di vista hardware che dal punto di vista software quindi che ne so aree aree della memoria che sono protette da un punto di vista criptografico dove le esecuzioni che vengono lanciate sono sicure sono garantite quindi sono dei piccoli ambienti a tenuta stagna diciamo così dove è possibile fare delle computazioni in maniera sicura dove i dati non possono essere corrotti dove di esito delle computazioni non possono essere non possono essere corrotti naturalmente queste cose funzionano sotto determinate condizioni ok quindi questo giusto per citarvi alcune soluzioni estremamente sofisticate e che però tutte quante queste si basano comunque sul problema di garantire determinate condizioni di sicurezza in uno di questi trascinati dati stoccati in transito o in uso e tutte quante fanno comunque uso di operazioni primitive che sono quelle che noi studieremo fatto ok il primo problema che andremo studiare se vogliamo è il problema con cui è nata la crittografia è il problema della confidenzialità o segretezza confidentiality e secrecy sono sinonimi proprietà che vogliamo garantire nel caso di data in transit il nostro riferimento sarà quello sebbene poi in realtà si applichi più o meno nella stessa misura anche per i data trust o i news però diciamo che il nostro modello di riferimento è quello dei data in transit ovvero il problema nella sua astrazione più semplice è questo immaginate di avere due due agenti o nell'ambito della crittografia gli agenti che comunicano sono sempre Alice e Bob questo per motivi storici ok quindi Alice vuole comunicare un messaggio a Bob usando un canale di comunicazione aperto pubblico non privato quindi un canale dove altri possono intervenire poi capiremo in che modo ok e l'obiettivo naturalmente di Alice è quello di riuscire a trasmettere questo messaggio in maniera confidenziale cioè solo Bob deve essere in grado di leggere il messaggio in un contesto in cui lungo il canale di comunicazione ci possono essere degli avversari li chiameremo così o attaccanti che ascoltano il canale che osservano il canale e vedono ciò che passa ok partiremo dallo scenario più semplice in assoluto ok quindi dalle assunzioni che vedremo qui ora l'idea l'idea per appunto garantire la confidenzialità del messaggio che viene trasmesso l'idea di base è quella di usare una una funzione che prima di trasmettere il messaggio ne altera la forma diciamo una funzione che prendi in input il messaggio prendi in input un'altra informazione segreta questa volta condivisa tra Alice e Bob ok questa informazione segreta la chiameremo chiave la chiameremo in particolare chiave simmetrica perché è la stessa quindi Alice e Bob condividono a priori una stessa informazione segreta solo loro due la conoscono quindi useremo una funzione l'idea è quella di usare una funzione che in input prende il messaggio che Alice vuole trasmettere a Bob in maniera confidenziale la chiave che Alice e Bob condividono questa funzione manipolerà in qualche modo questi due input il messaggio che dovrei davanti chiameremo plain text e l'informazione segreta che appunto dovrei avanti chiameremo chiave l'output di questa funzione sarà una stringa che risulterà appunto dalla combinazione di queste due informazioni e che chiameremo sci-fi text dopodiché Alice trasmette il sci-fi text a Bob dall'altra parte Bob che cosa fa? prende il sci-fi text applica lo stesso algoritmo la stessa funzione stessa adesso prendiamolo un po' in maniera astratta applica un algoritmo analogo a quello che ha usato Alice usando come input questa volta sci-fi text e la stessa chiave che ha usato Alice per recuperare dal sci-fi text il plain text e quindi il messaggio questa è l'idea che naturalmente dovremmo formalizzare quali sono le assunzioni queste invece sono importanti di base che faremo all'inizio perché questo ci permetterà di introdurre la criptografia in maniera incrementale aumentare il livello di difficoltà vedremo che rilassando le assunzioni aumenterà il livello di difficoltà delle primitive che dobbiamo realizzare quindi nel caso più banale più semplice con cui partiremo assumeremo che Alice vuole trasmettere un solo messaggio usando la chiave condivisa quindi la chiave viene usata una volta sola poi si butta via questa è la prima soluzione fondamentale l'altra soluzione fondamentale è che per adesso ci interessa garantire solo la segretezza e non l'integrità l'integrità la tireremo fuori più avanti quindi l'unica proprietà che ci interessa è che il messaggio che Alice trasmette a Bob sia letto solo da Bob e non da qualcuno che ascolta lungo il canale ok chiaramente chi ascolta lungo il canale vede passare il ciphertext ma non conoscendo la chiave non dovrebbe essere in grado di risalire al plaintext questa è l'idea ok e terza soluzione anche questa abbastanza importante per adesso assumeremo che Alice e Bob condividono già la chiave segreta in base a qualche algoritmo che hanno eseguito in precedenza magari si sono incontrati e se la sono scambiata in un foglietto magari hanno eseguito qualche altro protocollo che andremo a studiare più avanti però per adesso noi assumiamo che Alice e Bob condividono già il segreto che serve per creare il ciphertext o recuperare il plaintext ed è sempre la stessa Alice e Bob usano la stessa chiave da qui come vedremo il nome dell'approccio che si chiama appunto cifratura chiave simmetrica questa è l'idea ok vediamo di cominciare a formalizzare questa intuizione ok e lo facciamo introducendo la prima formalizzazione che vediamo di cifrario o di sistema crittografico questa formalizzazione è dovuta a Shannon che è lo stesso che ha studiato la teoria dell'informazione se qualcuno di voi in passato vi è capitato di incontrarla e qui appunto vedete la formalizzazione di quello che prende il nome di cifrario di Shannon è una definizione molto generica che vedremo poi come declinare in tanti modi in tanti modi diversi e qui vedete appunto che un cifrario di Shannon ha fondamentalmente due componenti due funzioni una prima funzione cosiddetta di encryption di cifratura e una seconda funzione di decryption di decifratura ora cominciamo a guardare un po' quelli che sono i dominio e codominio di queste funzioni ora la funzione di cifratura è e sta per encryption prende in ingresso una chiave che è il segreto che Alice e Bob condividero noi qui per semplicità assumiamo che la chiave appartiene a un dominio di tutte le possibili chiavi che chiamiamo keys quindi keys è l'insieme di tutte le possibili chiavi quindi il segreto condiviso tra Alice e Bob è un elemento di questo dominio poi l'ingresso prende anche il messaggio in chiaro il plaintext e assumiamo che questo plaintext sia il dominio di tutti i possibili messaggi in chiaro quindi in input la funzione dell'encryption prende una coppia con questo motivo per cui abbiamo il prodotto cartesiano insieme a delle chiavi insieme a dei plaintext che cosa restituisce? restituisce quello che abbiamo chiamato cifratext che è appunto il risultato della combinazione di chiave k e plaintext m in base a un qualche algoritmo che appunto ha come obiettivo proprio di prendere questi due input elaborarli insieme in qualche modo e produrre il ciphertext ok? c si dice essere l'encryption di m sotto la chiave k ok? dall'altra parte viceversa bob quindi e è la funzione che usa lì dall'altra parte abbiamo bob che usa la funzione di decryption di e quindi è una funzione che in ingresso prende un'altra coppia data da che cosa? da una chiave e da un ciphertext quindi keys al solito dominio di tutte le chiavi ciphertext al dominio di tutti i possibili testi cifrati quindi la funzione di decryption prende un input k e c e restituisce cosa? restituisce un plaintext m ok? naturalmente affinché questo sistema funzioni correttamente bisogna soddisfare questa condizione di correttezza che ho evidenziato in giallo perché senza questa condizione di correttezza il sistema non serve a niente ok? cosa dice questa condizione di correttezza ci dice che se noi cifriamo m con k no? quindi quel e di k m appunto ci restituisce la cifratura di m usando k ok? quindi se noi prendiamo questa cifratura e la diamo in pasto alla funzione di decifratura utilizzando sempre la stessa chiave k allora il risultato dovrà essere di nuovo m no? questa è la condizione di correttezza intuitivamente ovvia perché è quella condizione che ci garantisce che cosa? che se Alice cifra un messaggio ciao bob usando k e la cifratura la manda bob bob quando prende la cifratura che ha ricevuto e la decifra usando la stessa chiave k deve ottenere il messaggio ciao bob ok? noi assumeremo sempre tranne in certi casi che questi domini chiavi plaintext cifratura sono insemi di string tipicamente string binaria a volte assumeremo che sono degli interi ma le due cose sono del tutto equivalenti perché un intero lo possiamo comunque rappresentare come una stringa binaria quindi la soluzione di base è sempre la stessa ok? questa è la definizione di base di cifrare di Shannon e tutti gli algoritmi di cifratura la chiave simmetrica rispondono a questo schema generale poi cambiano in funzione di come è definita la funzione e o di come è definita la funzione d prendiamo un esempio ok? vi faccio vedere due o tre esempi storicamente famosi di cifrare di come può essere implementato un cifrare di Shannon prendiamo questo che si chiama one time pad ok? il one time pad lavora su elementi che sono stringhe binarie vedete l'alfabeto zero uno tutti di pari lunghezza ok? infatti vedete usando la notazione che abbiamo introdotto all'inizio della lezione questi tre insiemi key, splint, ciphertext sono gli insiemi di stringhe binarie di lunghezza l l grande è la lunghezza fissa ok? dove l è un parametro cosa fa il cifrario di Shannon nel caso del one time pad? beh, implementa la cifratura usando una delle operazioni binarie più utilizzate nell'ambito della fettografia che è l'ore esclusivo l'exclusivo or ok? e tra poco vedremo per quale motivo si usa nell'ore esclusivo e quindi la cifratura consiste nell'ore esclusivo tra la chiave e il messaggio allo stesso modo la decifratura consiste nell'ore esclusivo tra la chiave e il ciphertext diamo un esempio prendete prendete questo messaggio M fatto di 4 di 4 bit 0011 se la chiave è 0101 il ciphertext sarà la stringa 0110 questo è il risultato dell'applicazione della tavola di verità dell'ore esclusivo ve la ricordate la tavola di verità dell'ore esclusivo perché è così bella e adatta nell'ambito della crittografia secondo voi questa è la tavola di verità dell'oxono ok è estremamente simmetrica estremamente simmetrica ok ok e questo fa sì che se voi la usate nel modo in cui vediamo qua e io vi nascondo la chiave e vi faccio vedere il ciphertext voi non avete nessuna informazione osservando il ciphertext che vi permetta di stabilire che un certo plaintext possa essere più probabile di un altro ok perché dipende dalla chiave perché perdete questo caso qui io vi faccio vedere il ciphertext 0 1 1 0 ok la chiave non la conoscete non la conoscete ora voi dovete cercare di immaginarvi qual è il plaintext che ha originato quel ciphertext ragioniamo bit per bit il primo bit del ciphertext è 0 ora quello 0 potrebbe essere stato originato da un plaintext uguale se il bit corrispondente della chiave è anche lui pari a 0 ma anche no perché perché il bit 0 potrebbe derivare dal bit 0 se il bit corrispondente della chiave vale 0 ma potrebbe derivare anche dal bit 1 se il bit corrispondente della chiave è 1 ora voi la chiave non la conoscete quindi vuol dire che i due bit del plaintext sono equi probabili perché la distituzione di probabilità è uniforme avete la stessa probabilità che questo bit sia stato generato da uno 0 o da un 1 a seconda di un'informazione che voi non conoscete ok ora tornando al discorso delle distruzioni di probabilità la chiave sarà una delle possibili chiavi che stanno qua dentro ma se voi la chiave la scegliete applicando una distribuzione di probabilità uniforme quindi vuol dire che tutte le chiavi sono equi probabili quindi di nuovo l'avversario non ha un criterio per poter dire ma forse questa chiave è più probabile di quest'altra no sono tutte più probabili quindi l'avversario non sa nulla di significativo sulla chiave osservando il cypher sa che i possibili plaintext hanno tutti la stessa probabilità di poter generare quel cypher a seconda della chiave ecco che l'avversario non sa nulla al di là del fatto che stiamo giocando con distribuzioni di probabilità uniforme non sa nulla quindi l'unica cosa che può fare è indovinare fare un guess a caso ma la probabilità di indovinare sarà dettata da che cosa dalla distribuzione di probabilità uniforme applicata alle chiavi quindi tanto più sono le chiavi quanto più sarà bassa questa probabilità ok ora dimostrare la correttezza è abbastanza facile dipende dalla proprietà dell'Oxor che vedete qui cosa succede se io applico la funzione di decryption usando k al ciphertext che è stato generato usando sempre k su m allora basta applicare la definizione no il ciphertext è k xor m la funzione di decifratura che cosa fa fa k xor il ciphertext quindi l'espressione da risolvere è k xor k xor m lo xor è associativo quindi potete spostare quelle parentesi da sopra sotto quindi potete fare indifferentemente prima k xor m e poi xor k o viceversa proprio perché lo xor è associativo ma k xor k cosa dà come risultato se voi fate lo xor di due stringhe uguali quindi il confronto bit a bit è sempre fra due bit uguali quindi il risultato sarà una sequenza di zeri no perché 0 xor 0 fa 0 1 xor 1 fa 0 quindi se voi fate k xor k il risultato è una sequenza di zeri quanti zeri l zeri perché le stringhe sono tutte di lunghezelle quindi quanto fa a questo punto una sequenza di l zeri in xor con un qualunque m guardate le prime due righe della tabella di verità dell'oxor a sinistra avete sempre 0 a destra avete m il risultato è che cos'è è sempre m no è sempre m perché 0 xor 0 fa 0 0 xor 1 fa 1 quindi il risultato di fatto è la seconda colonna ok quindi 0 una sequenza di l zeri in xor con m viene da m e quindi abbiamo dimostrato la correttezza del one time pad se voi decifrate usando la stessa chiave ciò che avete cifrato usando quella chiave riottenete il plain text di partenza ok come vedremo OTP è il massimo della sicurezza che possiamo ottenere ok che è appunto la sicurezza cosiddetta perfetta ideale senza chiave non avete nessun modo di stabilire che un plain text è più probabile di un altro ok potete adattare OTP al fatto che i plain text non è detto che siano sempre della lunghe FL quindi possiamo usare anche plain text di lunghezza variabile e quindi passare a quello che si chiama variable OTP dove la lunghezza del plain text può essere minore o uguale di L in quel caso che cosa farete? se voi avete una chiave lunga così e un plain text lungo così userete solo un pezzo della chiave per cifrare il plain text se la chiave è lunga 100 bit e il plain text è lungo 20 bit per cifrare quel plain text userete solo i primi 20 bit della chiave però l'algoritmo è sempre quello infatti qui lo vedete nella definizione in cui vedete ho usato una notazione vettoriale cioè della chiave K si usano solo un numero di bit pari alla lunghezza effettiva del plain text ok anche in questo caso banalmente vale la condizione di correttezza poi andando avanti ah due parole proprio dal punto di vista storico legate ad OTP proprio perché OTP è il cifrario più sicuro che possiamo immaginare e poi dopo lo dimostreremo questo storicamente è stato utilizzato in contesti particolarmente critici ha uno svantaggio di cui di nuovo parleremo tra poco ovvero il fatto che per funzionare dovete avere chiavi che sono lunghe tanto quanto il plain text no e questo può essere un problema se io devo cifrare un file di 250 mega mi serve una chiave lunga 150 mega non è banale condividere una chiave di questa lunghezza tra Alice e Bob dove Alice e Bob sono due tenti qualunque quindi è sì idealmente sicuro ma è di difficile implementazione negli anni della guerra fredda la linea rossa che collegava direttamente il telefono della casa dello studio vale della Casa Bianca con il cremlino era una linea di comunicazione protetta tramite one time pad c'erano due libroni rossi così che i due uffici condividevano e che contenevano la chiave ok però questa è una cosa fattibile in contesti estremamente particolari nella prassi questo su internet dove chiunque può parlare con chiunque questa cosa qui diventa infattibile un altro esempio di cifrario di Shannon famoso cifrario per sostituzione molti lo conoscono come cifrario di Cesare è un esempio che vi faccio perché vi fa vedere un modo alternativo di definire la chiave in questo caso vedete che la chiave non è una stringa plaintext e cifrtext sono come al solito stringhe di lunghezze alle grande la chiave invece non è una stringa ma è una funzione in particolare è una funzione di permutazione vi ricordate cosa sono le funzioni di permutazione? voi avete un dominio di elementi ok una funzione di permutazione è una funzione che a ogni elemento del del dominio associa un ed un solo elemento dello stesso dominio e è una funzione in univoca ok quindi non ci sono due elementi che sono apporti nello stesso viene chiamato appunto di permutazione perché è una sorta di modo di se vogliamo rimescolare le carte ok quel disegno che ho fatto prima relativo all'esito degli outcome del lancio di due dadi ebbene quelle linee che collegano i numeri relativi al primo dado con i numeri relativi al secondo dado è un esempio di permutazione cioè questo è un esempio di permutazione che collega l'1 al 6 il 2 al 5 il 3 al 4 e così via perché è un esempio di permutazione perché questi collegamenti queste relazioni descrivono una funzione obiettiva ad ogni elemento che sta a sinistra viene associato un 1 ad un solo elemento che sta a destra in maniera bioniluca ok quindi l'1 viene mappato sul 6 il 2 sul 5 il 3 sul 4 e così via sapete quante permutazioni possibili ci possono essere su su questo dominio qua vi ricordate qual è la formuletta per calcolare il numero delle permutazioni possibili se n è il numero di elementi in questo caso n è 6 ci sono n fattoriale diverse possibili permutazioni quindi sono tante è un numero molto grande ok poi stabiliremo che cosa significa essere sufficientemente grande nel contesto della crittografia però è un numero grande ora la chiave nel nostro caso è una permutazione ok quindi l'avversario dovrebbe sapere qual è la permutazione che io uso per cifrare in maniera tale da riuscire a decifrare ok e come funziona la cifratura? beh semplicemente applicando bit a bit la funzione di permutazione quindi tornando al nostro esempio dove la permutazione è quella che ho disegnato lì quindi se la permutazione è quella che mappa l'1 nel 6 il 2 nel 5 il 3 nel 4 il 4 nel 3 il 5 nel 2 il 6 nel 1 supponiamo di voler cifrare il messaggio 2 5 1 ok quindi 2 5 1 è il plaintext che io voglio cifrare la cifratura sarà il risultato dell'applicazione della permutazione a ogni elemento del plaintext quindi la cifratura sarà 5 2 6 perché il 2 viene mappato nel 5 il 5 nel 2 l'1 nel 6 quindi la cifratura del plaintext 251 è il ciphertext 526 se la chiave è la permutazione che abbiamo appena descritto ok quindi è chiaro che per tornare indietro devo seguire a ritroso la permutazione quindi applicare la funzione inversa per far sì che dal 5 si torni al 2 dal 2 si torni al 5 dal 6 si torni al 2 ok quindi in pratica ogni simbolo viene sostituito con un altro molto semplice si dice che Giulio Cesare la utilizzasse per cifrare le proprie lette si dice ok e chiaramente è corretto ha dei limiti che intuitivamente si possono anche immaginare ad esempio se il plaintext che devo cifrare è 2511 il cifertext è 5266 ora esaminando il cifertext cosa potete dedurre a proposito del plaintext anche pur non conoscendo la funzione di permutazione però c'è qualcosa che potete dedurre il cifertext no non che il 6 è l'1 perché non sapete la funzione di permutazione però cos'è che sapete sapete che le ultime due cifre del plaintext sono uguali quindi non è più vero facendo un paragone con l'ATP che abbiamo fatto prima non è più vero che tutti i plaintext sono i più probabili no l'ATP perché era bello perché esaminando il cifertext io non avevo un modo di associarlo preferibilmente ad un plaintext piuttosto che un altro perché qualunque plaintext a seconda della chiave che uso potrebbe essere mappato in quel particolare cifertext che io vedo passare no perché il cifertext OTP che io vedo passare lo potete riconvertire a qualunque plaintext qualunque plaintext giocando sui valori della chiave e siccome io la chiave non so qual è quindi vuol dire che tutti i plaintext sono i più probabili in questo caso non è più vero che tutti i plaintext sono i più probabili ce ne sono molti che hanno probabilità vero di essere associati al cifertext 5266 perché se voi prendete il plaintext 2513 voi quel plaintext lo potete escludere perché il plaintext 2513 non potrà mai essere mappato come il cifertext 5266 perché le ultime due cifre devono coincidere quindi voi di fatto avete modo di eliminare tutta una parte di possibili plaintext che hanno probabilità zero e quindi concentrare la ricerca solo su quelli fattibili quindi state riducendo la dimensione del dominio delle possibili soluzioni che nel caso di una ricerca a forza brutta io le provo tutte può fare la differenza perché ho meno possibilità tra cui cercare formalizzeremo quest'idea magari la prossima volta oggi non ce la facciamo però l'intuizione è che questo cifrario è vulnerabile proprio per questo motivo qua mentre invece OTP non lo era vediamo se riusciamo a finire gli esempi di cifravi di Shannon vediamone uno nel contesto dell'aritmetica quindi come dicevo prima uno scenario in cui plaintext chiavi e ciphertext non sono string binarie ma sono numeri interi ripeto alla fine sono equivalenti le due cose perché il numero intero lo potete sempre rappresentare in binario e una stringa binaria la potete interpretare come se fosse un numero intero quindi le due rappresentazioni alla fine sono equivalenti quindi dove applicate una potete applicare l'altra questa è l'idea però in questo caso qua dove appunto vediamo chiavi e plaintext come valori interi abbiamo una variante dell'OTP che si chiama appunto additive OTP perché fa uso di un'operazione che nell'ambito dell'aritmetica se vogliamo è la controparte dell'Oxor nell'ambito della logica noi come vedremo la stragrande delle operazioni primitive delle funzioni crittografiche che studieremo usano l'Oxor ok non solo usano l'Oxor come nell'OTP ma usano anche le permutazioni come nel cifrario di sostituzione sono le due operazioni che vanno per la maggiore perché hanno delle belle caratteristiche come vedremo nell'ambito dell'aritmetica invece l'operazione che si usa maggiormente è la sommula la somma modulare ok quindi si usa l'addizione in aritmetica modulo N e questo perché ha caratteristiche simili a quelle che abbiamo visto per l'Oxor cioè l'Oxor è bello perché perché preso un ciphertext lo potete riconvertire a qualunque plaintext a seconda della chiave che avete se usate l'aritmetica modulo N avete la stessa caratteristica preso un ciphertext lo potete riconvertire a qualunque plaintext a seconda del valore della chiave come funziona sifrattura e risifrattura in questi casi beh molto semplicemente vedete invece di fare l'Oxor tra K e M si fa banalmente la somma tra K e M però la si fa in aritmetica modulare cioè si fa la somma modulo N dove N è un parametro così come prima è la lunghezza della stringa L grande era un parametro in questo caso N è un parametro ok è proprio il fatto che si usa il modulo N che fa sì che qualunque ciphertext noi otteniamo lo potremmo riconvertire a qualunque plaintext a seconda del valore della chiave facciamo un esempio banale senza perderci in conti ragioniamo in modulo 5 ok quindi i possibili valori sono 01234 no i possibili ciphertext no ora prendete il plaintext che ne so 7 facciamo il contrario ragioniamo il reverse engineering prendete il ciphertext 3 ok da quale plaintext potrebbe essere stato originato il 3 andiamo a vedere come funziona la decifratura funziona in maniera ortogonale alla cifratura se la cifratura somma la decifratura chiaramente sottrae ok per decifrare un ciphertext devo sottrarre la chiave sempre in aritmetica modulare ok ora prendete il ciphertext 3 no potrebbe essere stato generato da qualunque possibile plaintext pensate a un plaintext qualunque qualunque cifrandolo potreste ottenere 3 dove la cifratura ripeto è la somma modulo 5 nel nostro caso ok quindi l'operazione da fare è il plaintext più la chiave modulo 5 no se il nostro parametro è 5 ok ora supponiamo appunto che il risultato di questa operazione sia 3 l'avversario vede passare 3 non sa chiaramente qual è la chiave si deve chiedere quale potrebbe essere il plaintext che ha dato come risultato 3 sono tutti equiprobabili oppure no come nel caso del cifrario di sostituzione alcuni non lo sono per niente vi dovete chiedere prendete un qualunque plaintext c'è un modo fissato a m di dare 3 come risultato c'è una chiave che ci converte l'm che avete scelto in 3 quindi ognuno di voi pensi a un m qualunque ok e provate a vedere se esiste una chiave k tale per cui l'm che avete scelto più k modulo 5 di da 3 ok come? dipende 8 chi è? m se m più k fa certo se m più k fa 8 o un multiplo di 8 il risultato sarà 3 allora il punto è scegli un m qualunque esiste un k tale per cui l'm che hai scelto più k ti da un multiplo di 8 perché se ottieni un multiplo di 8 il risultato è 3 no? mi avete seguito? è chiaro l'esempietto che ne so 12 no? 12 è il plaintext qual è il multiplo più 8 di 8 più vicino a 12 è 16 ok? quindi se la chiave è 4 che è la differenza tra 12 e 16 ecco che la cifratura di 12 ti dà come risultato 3 ecco 12 più 4 fa 16 16 modulo 5 fa 3 no scusate ho fatto mali conti 16 modulo 5 fa 1 no volevamo farlo diventare 3 no abbiamo detto ho detto una cavolata deve fare 18 quindi quindi 15 sì no no ho fatto mali conti quindi se scusate quindi se voglio che faccia 3 allora facciamo le versi di engineering il tuo plaintext è 12 la domanda è esiste una chiave K che sommata 12 ti dà modulo 5 3 allora devi pensare quali sono i numeri interi che ti danno 3 come risultato quando applichi modulo 5 18 18 ti dà ti dà 3 quindi la chiave è 6 esatto mi ero perso nei conti quindi se il plaintext è 12 scegli come chiave K 6 il risultato fa 18 modulo 5 3 ok questo è il ragionamento che potrebbe fare l'avversario vede passare 3 e dice bene il separate text è 3 il plaintext potrebbe essere 12 la risposta è sì perché se il plaintext è 12 e la chiave che io non conosco fosse 6 il risultato fa 3 ma questo discorso lo potete generalizzare a qualunque plaintext perché per qualunque plaintext esiste una chiave che sommata al plaintext gli dà un numero che è 3 posizioni più avanti rispetto a un múltipo di c perché questa è l'idea ok quindi questo cosa significa che tutti i plaintext sono equiprobabili perché per tutti i plaintext esiste una chiave che combinata con quel plaintext ci dà il site modulo 1 modulo n ci dà il cipher test che io sto vedendo passare in questo caso 3 ok un po' come nell'OTP il discorso vedete lo stesso solo che stiamo ragionando su numeri invece che su combinazioni logiche basate su workstation ci siamo? vi vi torna per esempio quindi la versione additiva del one time pad funziona bene va bene direi che possiamo chiudere qui in questo caso al luna quindi noi oggi pomeriggio non ci vediamo ma ci vediamo domani pomeriggio per altre con missing adesso pedi fine più 똑 parte torn cotßen pap