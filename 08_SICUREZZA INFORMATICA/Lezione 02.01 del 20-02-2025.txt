Bene, allora direi che possiamo cominciare. Ieri abbiamo visto un po' di esempi di cifrari di Shannon e anche se in maniera un po' intuitiva abbiamo cercato di capire se fossero sicuri, quanto fossero sicuri oppure no, però in maniera chiaramente non formale. Oggi vediamo come stabilire formalmente la robustezza, il livello di sicurezza di questi cifrari, attraverso delle definizioni che ci permetteranno appunto di stabilire la robustezza rispetto alla prima proprietà che ci interessa che è la confidenzialità o la segretezza. Ora, intuitivamente ieri abbiamo capito che un cifrario si intende sicuro se il plaintext rimane nascosto, rimane segreto dal punto di vista di un osservatore esterno che non conosce la chiave con cui è stato cifrato il plaintext, osservatore esterno che l'unica cosa che può fare è osservare il ciphertext che viene trasmesso sul canale. Quindi un osservatore esterno che ha solo ed esclusivamente visibilità del ciphertext non dovrebbe essere in grado di dedurre nessun tipo di informazioni relativamente alla natura del plaintext. Questa è l'idea intuitiva dietro il concetto di sicurezza. Chiaramente noi vogliamo che questa intenzione venga formalizzata rispetto a delle condizioni che siano le più lasche possibili, che siano le più deboli possibili, ovvero vogliamo dare all'osservatore esterno, al potenziale attaccante, tutti i vantaggi possibili. Questo per metterci al riparo rispetto a quello che potrebbe essere nel mondo reale lo scenario peggiore possibile. Questo cosa significa? Significa applicare una serie di condizioni che sono praticamente tutte a favore dell'attaccante, ovvero assumeremo che l'attaccante, l'avversario, conosce l'insieme di tutti i possibili plaintext, quindi conosce la natura del plaintext, ovviamente non sa qual è, però ne conosce la natura. Assumiamo anche che l'avversario conosce il cifrario che è stato usato, che viene usato da Alice per cifrare il plaintext, che dovrà essere inviato e cifrato a Bob. Conoscerne il cifrario significa, tra l'altro, conoscerne anche i dettagli dell'algoritmo di cifratura e decifratura. Quindi assumiamo che il cifrario sia open source da questo punto di vista. sa che Alice, nel nostro esempio, utilizzerà una chiave che fa parte di un certo dominio, quindi anche il dominio delle chiavi è noto, e che è stata scelta casualmente sulla base, come abbiamo visto ieri, di una distribuzione di probabilità uniforme, e naturalmente conosce il cifrtext, perché lo vede passare nel canale. Quindi in pratica l'avversario sa tutto, tranne la chiave che è stata usata per creare il cifrtext, e naturalmente il plaintext, visto che il suo obiettivo è chiaramente quello di riuscire a indovinare, o quantomeno in maniera significativa, quale messaggio è stato cifrato. In altre parole, e qui vedete un esempio, assumeremo che il nostro cifrario è sicuro, se la probabilità che l'avversario ha di indovinare quale plaintext è stato cifrato, non cambia in nessun modo, anche se l'avversario vede il satatext, vede la cifratura del plaintext. Quindi, che l'avversario veda o non veda il cifrtext, per lui la probabilità di indovinare il plaintext deve essere sempre quella. Ad esempio, se il plaintext è il risultato del lancio di una moneta, la probabilità che l'avversario ha di indovinare l'esito del lancio è pari al 50%. Immaginiamo che Alice prenda il risultato del lancio della moneta, lo cifri e lo trasmetta a Bob, l'avversario vede passare il cifrtext, lo esaminerà, farà tutto quello che vuole sul cifrtext, conoscendo tutto quello che abbiamo detto prima. Nonostante questo, la sua probabilità di indovinare qual è stato l'esito del lancio della moneta deve comunque rimanere al 50%. Quindi, in pratica, il cifrtext e tutte le informazioni a corredo che l'avversario ha non devono dargli un vantaggio nel tentativo di indovinare qual è stato il plaintext che è stato cifrato. Ad esempio, vediamo un po' nella pratica, vi faccio vedere un esempio di cosa significa essere sicuri rispetto a questa nozione che dobbiamo formalizzare. prendete in considerazione un esempio reale come questo, ovvero di una roulette elettronica. Quindi, ce ne sono di sistemi di elettronico gambling che funzionano più o meno sulla base di questo principio qua. Quindi, voi immaginate che ci sia uno scommettitore che vuole piazzare una scommessa sul risultato della roulette, rosso o nero. La probabilità ideale che lui ha di vincere è 18 su 37, perché ci sono 18 caselle rosse altrettanto nere e una verde nella roulette, 37 numeri dal 0 a 36. E questo è chiaro per tutti. Immaginiamo di piazzare la nostra scommessa su internet e immaginiamo che, per ragioni tecniche, il coupé effettua il lancio prima che vengano fatte le scommesse, senza far vedere il risultato. Poi, per garantire agli scommettitori che il lancio è stato fatto prima di piazzare le scommesse, cosa fa? Pubblica una cifratura del risultato. Perché fa questo? Perché così chi piazza la scommessa ha la garanzia del fatto che è il coupé a decidere il risultato, l'esito, dopo che ha visto come sono state piazzate le scommesse. Quindi, in molti casi, effettivamente, anche se con qualche complicazione, funziona in questo modo la gestione delle scommesse in questo contesto qua. Quindi siamo nello scenario che dicevamo prima. Gli scommettitori, in teoria, vedono la cifratura del risultato. E anche se la vedono, la loro probabilità di vincere deve comunque essere ancora 18 su 37. In altre parole, osservare e studiare il cifratext non deve dare nessun tipo di vantaggio. Questa è l'idea. Ok? Tenuto conto del fatto che lo scommettitore può fare quello che vuole sul cifratext, lo può analizzare utilizzando tutti gli strumenti che vuole. A rispetto di questo, non deve essere in grado di ottenere un vantaggio significativo. Ok? Questa è l'idea. No? La nozione di sicurezza formale che adesso vi faccio vedere e che si chiama perfect security, si basa su questa intuizione. Ok? Nella definizione che vi farò vedere, noterete che si usa una variabile casuale, che è questa. Vediamo un po' se riesco a scrivere qua sotto. Ok. Nella definizione che vi farò vedere, si usa una variabile casuale, questa k calligrafica qui, no? Questa variabile casuale che cosa rappresenta? Rappresenta la variabile che prenderà come valore la chiave di cifratura. Ora, la scelta della chiave di cifratura è randomica, è random, e si basa su una distribuzione di probabilità uniforme. No? Quindi, come abbiamo detto ieri, questo è fondamentale. Ok? Quindi la variabile, la variabile che memorizza, la chiave usata per cifrare, è una random variable, associata ad una distribuzione di probabilità uniforme. Ok? Scusate, ma volevo tornare un attimo indietro. chiaramente anche la cifratura sarà rappresentata da una variabile casuale. Perché? Perché la cifratura si fa usando la chiave. La chiave è l'esito, è l'outcome di un esperimento casuale, cioè la scelta randomica della chiave tra due minuti e due chiave, in base alla distribuzione uniforme. Quindi, anche la cifratura, cioè il risultato dell'applicazione della funzione di encryption, la chiave che è stata scelta in maniera randomica, e al plaintext, è a sua volta una variabile casuale. Teniamo a mente, ricordiamoci queste due condizioni. Ok? La definizione formale che adesso vi faccio vedere, di perfect security, in pratica stabilisce che conoscere la cifratura non aumenta né cambia la probabilità di indovinare il plaintext. Questa è... Né, come vedremo, conoscere la cifratura ci permette di non solo non indovinare il plaintext, ma non intuire nessuna delle proprietà del plaintext. Vedremo questo cosa significa più nel dettaglio. Ok? La definizione è questa. Quindi abbiamo un cifrario di Shannon, con la sua funzione di cifratura e di cifratura. Abbiamo un esperimento randomico casuale che assegna alla variabile random k la chiave che io decido di utilizzare per cifrare, quindi la scelta della chiave randomica immagino la distribuzione di probabilità uniforme. La condizione di perfect security ci dice cosa? Adesso poi la commenteremo. Che presi due qualunque plaintext, la probabilità, questa è la funzione di probabilità, la probabilità di questo evento, questo è un evento, cioè il fatto che la cifratura di N fatta con una chiave scelta randomicamente, quindi la probabilità che la cifratura di N fatta con una chiave scelta randomicamente, sia uguale a un certo a un certo plaintext C è uguale alla probabilità che il plaintext alternativo M' primo ha di essere cifrato e dando come risultato lo stesso cifrtext C. Ok? Questo cosa significa? Qual è l'intenzione di questa definizione? Preso un cifrtext? L'idea è del duomo. Preso un cifrtext, i possibili plaintext sono equitobabili. Perché partiamo ragionando sul cifrtext? Perché cifrtext è ciò che l'avversario vede passare. Io vedo passare, se vale quella condizione lì, per me che osservo il cifrtext, tutti i plaintext sono equiprobabili. Hanno la stessa probabilità di essere quelli che hanno originato quel cifrtext. E quindi io cosa posso ne duro è nulla. Ok? Non c'è un plaintext che è più probabile di un altro. Questa è l'idea. Ok? Questa è l'idea di perfect security. ok? Quindi se un cifrario soddisfa questa definizione, è sicuro in maniera ideale, in maniera perfetta. Esistono delle definizioni alternative che è un'idea. E' un'idea. E' un'idea. di perfect security che in qualche modo riassumono un po' l'intuizione che abbiamo appena visto e che sono elencati in questo teorema. Questo teorema in pratica ci dice che questa definizione qua che abbiamo appena visto è equivalente ad altre due definizioni che adesso vediamo. partiamo dalla seconda. La seconda cosa dice? Vediamo un po'. Preso un cifrtext qualunque esiste una costante che dipende dal cifrtext tale per cui vale la condizione di uguaglianza che vedete qua sotto. cosa dice quella condizione di uguaglianza? Ci dice che preso qualunque plaintext il numero di chiavi che mappano quel plaintext a c il nostro cifrtext è sempre lo stesso. E' pare a quella costante lì. Ok? Perché questa definizione è equivalente a quell'altra? cosa ci dice questa definizione? No, immaginate io vedo passare un cifrtext lo esamino quel cifrtext sarà associato ad una costante ipotizziamo tiro un numero a caso 20 ok? Questo cosa significa? Significa che per ciascun plaintext possibile ci sono esattamente 20 chiavi diverse che trasformano quel plaintext nel cifrtext che io ho visto passare. se questo vale per tutti i plaintext quindi ogni plaintext ha 20 chiavi diverse che lo mappano in quel cifrtext io cosa posso dedurre osservando il cifrtext? Nulla vuol dire che tutti i plaintext sono equiprobabili al contrario se non valesse questa condizione qua immaginiamo che ci sia un plaintext che non può essere mappato in nessun modo nel cifrtext che io vedo passare quindi vuol dire che ha zero chiavi associate poi magari ce n'è un altro che ne ha dieci cioè ci sono dieci chiavi diverse che mappano quel plaintext nel cifrtext che io vedo passare quindi io cosa posso dedurre intanto che il primo plaintext ha probabilità zero di aver dato origine al senso che ho visto quindi lo posso descartare e magari posso anche dedurre che un altro plaintext è più probabile di un altro a seconda di quante chiavi sono associate ok quindi l'idea è molto simile a quella che abbiamo visto prima e si basa sempre sull'intuizione per cui tutto deve rimanere equiprobato no? sono certi punti in questa caso sono più chiari o per l'interno può capitare ci possono essere più chiavi che producono la sua social linea di principio linea di principio secondo te sono tutte le possibili chiari questi sono più chiari le provo tutte e questo è il punto no? c'è l'idea ma questo lo posso fare chiaramente ne parleremo dopo di questione di questa situazione chiaramente questa è una non è che io devo sapere quali sono le chiavi associate a un plaintext che producono quel ciphertext se in linea teorica vado questa condizione qui ok allora ho la garanzia di sicurezza ad esempio nel caso in certi casi è banale perché questa costante è pari a 1 no? è pari sì quindi prendi il caso di OTP no? tu vedi passare questo ciphertext ok ora quante sono le chiavi che ad esempio trasformano questo plaintext in questo ciphertext la chiave io non la conosco ma la chiave è una sequenza di bit che in XOR con M ci da C quindi ce n'è una sola c'è una sola chiave possibile che trasforma quel particolare plaintext in quel ciphertext ora se io cambio il plaintext di nuovo ci sarà una sola chiave possibile che trasforma quel plaintext in 1 1 0 1 quindi e questo vale per tutti i plaintext no? se io vado a passare questo ciphertext so che tutti i plaintext sono possibili e per ciascuno di loro c'è una sola chiave che lo trasforma in 1 1 0 1 ok quindi vale questa condizione qua cioè la costante in quel caso è 1 ok quindi tra l'altro abbiamo appena dimostrato che OTP è perfect secure proprio per questa condizione qua ok l'ultima variante della nozione di perfect security cosa dice? dice che se la variabile casuale che mi rappresenta la scelta della chiave è come dicevamo prima associata a distribuzioni uniforme e se lo stesso discorso vale per la cifratura ok quindi la cifratura è una variabile casuale con distribuzione uniforme cosa vuol dire? vuol dire che tutti i ciphertext hanno la stessa probabilità di essere generati a partire da un certo plaintext allora posso dire che il mio cifrario è perfettamente sicuro ok ora la definizione 3 è ortogonale rispetto alla definizione 1 che abbiamo visto prima cioè questa che cosa dice? dice io vedo il ciphertext ok tutti i possibili plaintext sono i più probabili no la definizione 3 ragione al contrario perché cosa dice? dice preso un certo plaintext se io scelgo in maniera randomica la chiave tutti i possibili ciphertext sono i più probabili ok quindi la condizione 1 e la 3 sono una all'opposta dell'altra ed entrambe che cosa dicono? entrambe ci dicono che non esiste un legame specifico tra un certo plaintext e un certo ciphertext che possa aiutare l'avversario a risolvere l'enigma perché? perché dato un plaintext se io scelgo randomicamente la chiave tutti i ciphertext possono essere generati in maniera equiprobabile o viceversa io vedo un ciphertext so che la chiave si sta scelta in maniera randomica e questo mi dice che tutti i plaintext potrebbero aver dato origine a quel ciphertext in maniera equiprobabile ok ma questo contemporaneamente significa dire che per ciascun ciphertext esiste un numero costante di chiavi che mappano un plaintext qualunque in quel ciphertext nell'esempio che abbiamo visto prima con il numero a 1 ci siamo? è chiaro? ok? ora prima abbiamo usato la condizione 2 nell'esempio per dimostrare che OTP è perfettamente sicuro ok? la stessa condizione la potete usare per dimostrare che variable OTP non è perfettamente sicuro variable OTP che è questo qua variable length one time pad questo non è perfettamente sicuro e per dimostrarlo potete usare la condizione 2 quindi questo cosa vuol dire? vuol dire che preso un ciphertext qualunque non è vero che tutti i plaintext hanno lo stesso numero possibile di chiavi che li mappano in quel ciphertext nel caso di OTP è vero la risposta è 1 in questo caso no perché secondo voi naturalmente qual è la differenza tra OTP e variable length OTP? il fatto che non avete il vincolo sulla lunghezza del ciphertext in OTP i ciphertext sono tutti lunghi uguali L è grande ok qui invece i ciphertext possono essere di qualunque lunghezza no? allora prendete un ciphertext di lunghezza 100 bit immaginate che L grande sia che ne so 256 bit ok prendete un ciphertext di lunghezza 100 bit no? ok ora prendete un plaintext di lunghezza 150 bit quante sono le chiavi che mappano quel plaintext nel ciphertext che abbiamo appena visto? zero se voi avete un plaintext di 150 bit usando usando questo algoritmo scendendo una chiave in maniera randomica non potete generare un ciphertext di lunghezza più corta ok quindi vuol dire che per molti plaintext ovvero tutti quelli che hanno una lunghezza diversa da quella del ciphertext il numero delle chiavi che mappano quei plaintext in quel ciphertext è zero poi invece ci saranno tanti altri plaintext quali quelli che hanno la stessa lunghezza del ciphertext per le quali esisterà una ed una sola chiave che li trasforma in quel ciphertext quindi la condizione 2 del teoreo non vale perché non è vero che tutti i plaintext sono i più probabili alcuni hanno probabilità zero ok questo cosa significa intuitivamente che VOTP se lo usiamo cosa rivela all'avversario la lunghezza del plaintext e quella è già un'informazione che viene svelata che rende sicuro il cifrario chiaramente rispetto alla perfect security no con OTP allora OTP risolve il problema a monte dicendo tutto deve essere della stessa lunghezza e quindi il problema lì non c'è perché i plaintext sono tutti lunghi uguali allora nella pratica come si risolve questo problema allora o viene ignorato in molti casi reali si tollera che il cifrario sveni la lunghezza del plaintext all'avversario anzi nella maggior parte dei casi questa questa vulnerabilità chiamiamola viene tollerata tant'è che nella definizione che vedremo dopo la perfect security questa cosa viene ammessa in altri casi invece si cerca di risolvere il problema ad esempio come si fa a nascondere l'allunghezza del plaintext si prende il plaintext si fa quell'operazione che si chiama padding per cui si allunga il plaintext con delle informazioni spurie di bits puri dummy e poi si cifra quello ok non è una policy completamente sicura perché se il plaintext contiene una porzione di informazione che l'attaccante già conosce cioè la parte dummy questo può indebolire in che senso c'è un errore un errore di trasmissione beh in quel caso me ne accorgo solamente se uso meccanismi che oltre alla segretezza garantiscono anche l'integrità un po' come si fa con i codici di correzione degli errori classici no ma cosa siamo nei codici di correzione degli errori proprio per accorgersi del fatto che c'è stato un errore di trasmissione lungo il canale allora faccio il confronto tra un'informazione che ho ricevuto il codice di correzione degli errori che è verifico qua vedremo che succede bene o male un po' la stessa cosa però di integrità parleremo parleremo più avanti anche il cifrario per sostituzione non è perfettamente sicuro ok quello che abbiamo visto l'esempio è abbastanza semplice no prendete ragioniamo sui numeri no voi vedete passare questo cifrario questo cifrario ok e sapete che questo cifrario è stato generato usando un cifrario per sostituzione quindi un cifrario la cui chiave è una permutazione ok voi osservando che questo cifrario che cosa imparate del plaintext imparate che le ultime tre cifre sono uguali sì ok quindi ci saranno plaintext che hanno probabilità zero di aver generato quel cifrtext cioè zero chiavi perché perché magari sono plaintext che hanno valori diversi nelle ultime tra posizioni ci saranno invece dei plaintext che hanno una chiave che li mappa in questo cifrtext sono quelli che avranno le stesse tre le ultime tre posizioni con lo stesso valore e la chiave la funzione di permutazione mappa questo valore nel valore 1 e avvaloramento per gli altri cifri ok quindi vedete il motivo è analogo a quello di v ot p alcuni plaintext sono più probabili di altri e quindi per questo motivo neanche il cifrario per sostituzione è perfettamente sicuro questo perché nel cifrario per sostituzione che abbiamo visto ieri si usa una sola funzione di permutazione per tutte le posizioni del plaintext ok si usa sempre la stessa quindi il se il messaggio è fatto così no e mi dà origine a questo cifrtext è perché la funzione di permutazione che è stata usata che è sempre quella mappa il 2 nel 7 il 3 nel 2 il 4 nel 1 ok come potremmo fare per rendere il cifrario per sostituzione perfettamente sicuro dovremmo cambiare la funzione di permutazione a seconda della posizione del bit del numero nella stringa quindi dovremmo usare una chiave più complicata cioè una chiave che in questa posizione usa una funzione di permutazione in questa posizione ne usa un'altra qui un'altra più un'altra più un'altra ancora quindi in particolare se qui qui e qui usate tre diverse funzioni di permutazione allora non sarà più vero che qui qui e qui ottenete tre valori uguali ma otterrete tre valori diversi e quindi in quel modo voi spestate la relazione tra la natura del plaintext e quella del sulfurtext e quindi tornate ad essere perfettamente sicuri ok tutto chiaro c'è un altro modo di vedere la perfect security anche questo ha un significato intuitivo molto interessante e che conferma formalmente quello che vi ho detto prima intuitivamente ovvero se il cifrario è perfettamente sicuro non solo l'avversario non ha un vantaggio nel una volta che ha visto il ciphertext nel riconoscere quale plaintext lo ha generato perché sono tutti e tutti probati ok quindi non solo non è in grado di aumentare la propria probabilità di indovinare il plaintext ma non può neanche dedurre nessuna proprietà relativa alla struttura del plaintext quindi non solo non indovino il plaintext dal ciphertext con una probabilità maggiore rispetto a quella di provarci a caso ma non riesce a indovinare nemmeno che proprietà ha il plaintext ok qui per semplicità per proprietà si considera una qualunque un qualunque predicato booleano cioè quindi un qualunque predicato qui che associa al ciphertext un valore di verità ad esempio un esempio di proprietà per una stringa binaria è la parity no cioè il fatto che nella stringa ci sia un numero pari di uno o un numero di risparmi di uno quella è una proprietà ok il numero di uno è maggiore del numero di zeri anche quella è una proprietà ok quindi potete immaginarvi qualunque proprietà no questa questo teorema qua vi dice che se il cifrare è perfettamente sicuro qualunque sia la proprietà che voi scegliete l'avversario non è in grado di intuire con una probabilità chiaramente maggiore del 50% perché stiamo parlando di proprietà booleani quindi se io cerco di indovinarla a caso ho il 50% di probabilità di azzeccarci ok ma questa teorema cosa vi dice che qualunque sia la proprietà che prendete in considerazione l'avversario non ha una probabilità maggiore del 50% di indovinare se il plaintext che ha originato il cyphertext che stiamo osservando ha oppure no quella proprietà ok la formalizzazione del teorema questa qua vedete che dice che il cifrare è perfettamente sicuro se qualunque sia la proprietà che voi scegliete la probabilità di questi due eventi è la stessa ovvero voi prendete due plaintext qualunque ok ora la probabilità che il primo plaintext cifrato con una chiama randomica soddisfi la proprietà è uguale alla probabilità che l'altro plaintext cifrato con una chiave randomica ha di soddisfare la stessa proprietà ok c'è un'altra parola prendete due plaintext qualunque cifrateli i due cifrate che ottenete hanno la stessa probabilità di soddisfare la proprietà ma se vale questa condizione cosa vuol dire vuol dire voi osservate il cifratex vuol dire che ragionando a ritroso non siete in grado di capire che proprietà è un plaintext perché tutti quanti i plaintext sono equiprobabili nel senso che tutti quanti i plaintext hanno la stessa probabilità di generare un cifratex fatto in un certo modo quindi voi vedete il cifratex è fatto in un certo modo che ne so contiene due zeri quattro uno oppure a parità dispari oppure quello che volete no qualunque proprietà di rendimento però voi in virtù di questo teorema sapete che qualunque plaintext ha la stessa probabilità di averlo generato quindi questo cosa vuol dire in generale vuol dire che la struttura del plaintext non influenza la struttura del cifratex perché plaintext anche molto diversi tra di loro generano dei cifratex che sono fatti in un certo modo sempre rispetto alla stessa distribuzione di probabilità ma questo c'è la possibilità di sicurezza in che senso no no no questo è una conseguenza della definizione di sicurezza perfetta cioè il teorema dice che se un cifrario è perfettamente sicuro allora vale questa condizione qua quindi io non riesco non riesco se uno di un cifrario è perfettamente sicuro osservando la struttura del cifratex non riesco a imparare niente su quella che è la struttura del plaintext la cifratura allora potrebbe essere diversa potrebbe essere diversa perché dipende da come viene campionata la chiave qui dentro non lo sappiamo ok però quello che conta non è tanto chi è il cifratex ma il fatto che soddisfa o meno la proprietà ok chiaro che m ed m' genereranno due cifratex diversi ok però la probabilità che questi due cifratex soddisfano la proprietà che mi interessa è comunque la stessa se la proprietà che mi interessa è il numero di uno deve essere dispari allora quella condizione lì mi dice che prendi due plaintext qualunque cifrali i cifratex che ottengono hanno la stessa probabilità di avere un numero dispari di uno sulla proprietà sulla natura proprio prima parlavamo proprio dello specifico cifratex o dello specifico plaintext qui parliamo semplicemente in maniera più astrata parliamo appunto di proprietà cioè il fatto che il cifratex soddisfi la proprietà ok quindi qual è la conseguenza di questo teorema ripeto un altro esempio se tu vedi un cifratex che ha un numero dispari di uno sapere che ha un numero dispari di uno non ti dice nulla rispetto alla natura del plaintext perché perché questo teorema ti dice che preso una qualunque coppia di di plaintext la probabilità che cifrandoli ottieni un cifratex con numero dispari di uno è la stessa per entrambi hanno la stessa probabilità di restituire un cifratex con un numero dispari di uno quindi sapere che un cifratex ha un numero dispari di uno non ti permette di dire ah c'è un plaintext che è più probabile di un altro no e quindi ripeto questa è una conseguenza della sicurezza perfetta infatti la teoria dice se il cifratex è perfettamente sicuro allora vale questa condizione qua in realtà non sei solo se quindi è vero anche viceversa se vale questa condizione qua allora il cifratex è perfettamente sicuro ok questa condizione qui ci conferma una volta di più che VOTP e cifratex per sostituzione non sono perfettamente sicuri no perché se la proprietà che vi interessa è la lunghezza è boh la lunghezza è 10 è una proprietà booleana ok non è vero che presa una qualunque coppia di plaintext la probabilità di generare un cifratex che soddisfa quella proprietà è la stessa perché? perché se il plaintext è di lunghezza 10 la probabilità è 1 se il plaintext è di lunghezza 5 la probabilità è 0 quindi altro che uguale la differenza tra le due è quella la massima possibile e lo stesso discorso vale per il cifrare di sostituzione quindi vedete ci sono tanti modi di esprimere la perfect security purtroppo nella pratica la perfect security è troppo forte ieri vi ho fatto l'esempio allora prima avevamo detto bene OTP è perfettamente sicuro anche la versione aritmetica di OTP è perfettamente sicura per lo stesso motivo quella con l'aritmetica modulare ok e vi ho fatto l'esempio di una situazione reale in cui si usa OTP però per usare OTP io devo avere una una chiave enorme lunghissima perché se io devo cifrare un mega un tera di plaintext io ho bisogno di usare una chiave che ha la stessa lunghezza un mega un tera quel che è quindi mi serve un librone con una chiave lunga quanto vogliamo da utilizzare di volta in volta quando vogliamo cifrare e questo è un problema per Alice e Bob condividere che ne so un giga un tera quello che vogliamo di chiave ok è effettivamente un problema che nella realtà non siamo in grado di affrontare questa situazione specifica che rende OTP perfettamente sicuro cioè il fatto di avere chiavi lunghe quanto il plaintext non è un caso non è un caso perché infatti c'è un teorema sempre dovuto a Shannon che dice che se un cifrario è perfettamente sicuro allora il numero delle chiavi deve essere per forza maggiore uguale al numero dei plaintext e questa è una caratteristica che OTP ce l'ha perché in OTP le chiavi sono lunghe tanto quanto il plaintext quindi per ogni plaintext ho una chiave adatta per per cifrarlo quindi in quel caso vale l'uguaglianza in generale il numero delle chiavi deve essere maggiore uguale del numero dei plaintext chiaramente questa è una realtà una dimostrazione ma è abbastanza semplice ve la lascio per esercizio perché sono giusto un paio di passaggi algebrici molto semplici ora è chiaro che ripeto nella realtà questa cosa non è praticabile non è praticabile perché perché i plaintext che gli utenti potrebbero vorrei cifrare sono grandi a piacere è lo stesso discorso però non vale per le chiavi di solito il dominio delle chiavi è molto più piccolo rispetto al dominio dei plaintext per questione di praticità ok quindi cosa vuol dire vuol dire che nel mondo vero nessun cifrario potrà essere perfettamente sicuro ok a meno che tutti quanti non usiamo OTP però ripeto non è realistico usare tutti quanti OTP perché ciascuno di noi dovrebbe condividere una pila alta così di sequenza di bit con qualunque altro utente che rappresenta la sequenza di chiavi da usare per applicare OTP ogni volta che vogliamo comunicare e questo chiaramente non è non è affattibile ok quindi questo cosa vuol dire vuol dire che dobbiamo nel mondo reale abbandonare la perfect security e usare una definizione più rilassata che però funzioni in tutti i contesti pratici che ci che ci interessano e per poter fare questo abbiamo bisogno di rilassare non solo la definizione di perfect security ma dobbiamo anche introdurre delle restrizioni su che cosa? Beh sull'avversario e anche sugli algoritmi di cifratura e di cifratura faccio un esempio torniamo un attimo qui ok questo è un modo per caratterizzare la perfect security qui come nelle altre definizioni la condizione è che due probabilità devono essere uguali allora qual è l'idea più ovvia per rilassare questa questa condizione qua invece di dire le due probabilità devono essere uguali posso accontentarmi di dire che le due probabilità non sono proprio uguali ma quasi uguali sono vicine ok sono approssimativamente uguali e quindi questa è una prima condizione più rilassata che noi possiamo introdurre appunto per avere una condizione di sicurezza più realistica ed è una che applicheremo però questo ripeto non basta dobbiamo introdurre delle restrizioni anche su che cosa? su tutti tutti gli algoritmi che vengono usati in particolare sugli algoritmi di cipratura e di cipratura e sul potere dell'avversario ok in un contesto reale l'avversario non è che ha a disposizione risorse infinite e tempo infinito per cercare per analizzare il ciphertext e scoprire il plaintext perché se chiaramente se la soluzione fosse questa cioè l'avversario ha risorse infinite vince sempre come fa come fa a vincere? se l'avversario avesse tempo e risorse di calcolo infinite qual è il modo più semplice per dato il ciphertext trovare trovare il plaintext il modo più semplice in assoluto trial or the possible case no ho tutto il tempo che mi serve ho tutte le risorse di calcolo che che mi servono perché devo impassiere a non usare il ciphertext cercando cose strane boh provo tutte le chiavi di cipratura possibili e vedo cosa succede quello cosiddetto attacco a forza bruta brute force attack ok quindi mi devo limitare a considerare avversari che hanno delle risorse limitate sia computazionalmente parlando che dal punto di vista del del tempo ok in gergo si dice che gli avversari rispetto ai quali noi verifichiamo la robustezza dei cifrari sono i cosiddetti avversari efficienti cioè sono avversari che eseguono degli algoritmi efficienti ma che devono comunque rispettare dei constraints legati al tempo e al potere di calcolo ok lo formalizzeremo fra poco cosa vuol dire nella pratica essere un algoritmo efficiente ma se l'avversario è costretto a usare algoritmi efficienti allora anche il cifrario ha lo stesso vincolo cioè non è che posso usare algoritmi di cifratura di cifratura con risorse infinite quindi anche gli algoritmi usati dal cifrario devono essere tra virgolette efficienti cioè devono rispettare determinati vincoli relativi all'uso delle risorse ok quindi quello che faremo per rilassare la perfez security è cambiare quella condizione di uguaglianza sulle probabilità di certi eventi che imporremo che non devono più essere uguali e limitarci a considerare algoritmi efficienti cioè algoritmi che devono rispettare determinati vincoli relativi alle risorse per formalizzare tutto questo useremo una definizione che si ispira alla teoria dei giochi perché si usa la game theory perché come nella game theory noi qui abbiamo da una parte Alice e Bob che eseguono gli algoritmi che il cifrario mette a disposizione per cifrare decifrare quindi dialogare nel rispetto delle proprietà di confidenzialità dall'altra chi c'è? c'è l'osservatore esterno l'attaccante l'avversario che vede passare il sci-fi text e cerca di intuire qual è il plain text che lo ha originato quindi da una parte abbiamo l'utente onesto che è quello che esegue l'algoritmo che esegue il cifrario dall'altra abbiamo l'avversario disonesto ok e i due competono in una specie di gioco in cui l'utente onesto che d'ora in poi chiameremo challenger esegue l'algoritmo che è il sistema di cifratura di metà disposizione dall'altra abbiamo l'adversario l'attaccante che invece cerca appunto di indovinare qual è il plain text e ognuno lui cercherà di seguire delle strategie che gli permettono di avere successo ok quindi quello che adesso andremo a vedere è una definizione il versato di perfect security ispirata alla teoria dei giochi dove abbiamo un challenger che fa certe cose abbiamo un adversary che fa altre cose i due hanno obiettivi opposti perché il challenger vuole garantire la secrecy l'adversario la vuole violare quindi gli obiettivi sono opposti quindi cercano ciascuno di raggiungere il proprio obiettivo ok il gioco che i due conducono viene chiamato in gergo attack game proprio perché è un gioco in cui l'adversario cerca di attaccare il in cifrario in particolare quello che fa il challenger ora prima di farvi vedere la definizione formale vi faccio vedere graficamente com'è il name shake che rappresenta l'esecuzione del gioco tra dell'attack game tra challenger e adversary ok quindi da una parte a sinistra abbiamo il challenger e dall'altra abbiamo l'adversario ok ora teniamo a mente quelle condizioni che ci dicevano quali sono le informazioni note all'attaccante cioè l'attaccante sa tutto praticamente sa quali sono i possibili plaintext sa qual è il cifrario che viene utilizzato vede il cyphertext l'unica cosa che non sa ovviamente qual è il preciso plaintext che viene cifrato e con quali chiari questo non so quindi non vi dovrebbe sorprendere il fatto che nell'attack game che andiamo a descrivere è l'avversario il plaintext che sceglie due plaintext e li trasmette al challenger cioè in pratica è lui che dice al challenger guarda questi sono i possibili plaintext che tu puoi cifrare perché perché è una delle condizioni che abbiamo detto all'inizio il dominio dei plaintext è noto all'avversario quindi nell'attack game è lui che sceglie i possibili plaintext ok quindi l'avversario sceglie due plaintext di trasmette al challenger il challenger che cosa fa sceglie la chiave in maniera casuale seguendo una distribuzione di probabilità uniforme quindi la scelta una chiave randomica presa dal dominio delle chiavi questa notazione che si usa spesso significa proprio che k è un elemento del dominio keys scelto randomica r sta per random quindi scelto in maniera casuale sulla base di una uniform probability distribution ok e poi che cosa fa deve cifrare uno dei due messaggi che è ricevuto dall'avversario ok il risultato sarà un ciphertext che anche questo sarà randomico perché se è randomica la chiave è randomico anche il ciphertext quale tra M0M1 il challenger cifra nel cifra uno dei due che vedete MdB dove B è un valore fissato in maniera non deterministica prima dell'esecuzione dell'esperimento ok chiaramente il challenger non sa che esperimento sta eseguendo cioè se siamo nell'esperimento 0 e quindi devo cifrare M0 o se siamo nell'esperimento 1 e quindi devi cifrare M1 l'avversario non lo sa ok quindi in base all'esperimento che il challenger deve eseguire cifrerà uno dei due messaggi e poi che cosa fa restituisce il ciphertext all'avversario adesso l'avversario che cosa fa vede il ciphertext ha a disposizione risorse di calcolo e tempo di calcolo limitati perché è costretto a eseguire un algoritmo efficiente fa quello che vuole fondamentalmente esamina il ciphertext fa delle scelte casuali quello che vogliamo il suo obiettivo a un certo punto è quello di sparare un risultato un beat ok chiaramente lui vorrebbe che questo risultato dipendesse dal particolare plaintext che il challenger ha deciso di cifrare faccio un esempio lui non sa cosa è stato cifrato però se usando il suo algoritmo efficiente l'avversario è in grado di rispondere uno tutte le volte che il challenger ha eseguito l'esperimento uno mentre invece è in grado di sparare come output zero tutte le volte che il challenger ha eseguito l'esperimento zero che cosa vuol dire vuol dire che l'avversario sa con certezza cosa è stato cifrato ok perché lo sa perché magari ha usato un algoritmo efficiente furbo che esaminando c gli permette di capire se è stato cifrato m0 m1 ok noi nella definizione di sicurezza che adesso dovremo vedere andiamo a misurare la probabilità che lui l'avversario ha di sparare 0 oppure 1 quando siamo in un certo esperimento se la probabilità è la stessa vuol dire che l'avversario sta un po' andando a caso cioè se immaginatevi statisticamente siamo nell'esperimento 1 quindi il challenger cifra m1 ok immaginate di eseguire questo esperimento tante volte ok ora se l'avversario la metà delle volte risponde 0 e l'altra metà delle volte risponde 1 cosa vuol dire che lui non ne ha un'idea sta cercando di nominare ma non ne ha un'idea di quale sia il planitex è chiaro che se tutte le volte che siamo nell'esperimento 1 lui spara 1 invece vuol dire che lui ha la certezza ok quindi noi ci aspettiamo che la probabilità di questi due output 0 o 1 sia non uguale perché se no torniamo nella perfect security ma sia quasi uguale ok quasi è chiara l'idea quindi l'attack game è questo andiamo a vedere allora vedete un po' che succede allora l'avversario abbiamo detto che sceglie i due planitext no l'esperimento è deciso a priori in maniera non deterministica solo la challenger sa in quale esperimento ci troviamo se deve cifrare 0 o 1 ok il challenger sceglie randomicamente la chiave e quindi cifra uno dei due messaggi che ha ricevuto dall'avversario a seconda dell'esperimento in cui ci troviamo ok l'avversario fa tutti i suoi calcoli computa eseguendo un algoritmo efficiente e alla fine di questa computazione spara un risultato ok noi cosa andiamo a misurare ciò che misuriamo lo chiameremo vantaggio dell'avversario rispetto alla sicurezza cosiddetta semantica ok noi andiamo a calcolare la differenza tra la probabilità di questi due eventi dove leggiamo un po' questo è l'evento che ci dice che siamo nell'esperimento 0 ok e l'avversario spara 1 come output no questo è invece l'evento in cui siamo nell'esperimento 1 diciamo nell'altro esperimento e l'avversario di nuovo spara lo stesso output ok quindi confrontiamo la probabilità di questi due eventi qual è la probabilità che l'avversario spara 1 quando siamo in questo esperimento qual è la probabilità che l'avversario spari di nuovo 1 quando siamo in questo esperimento è chiaro che se queste due probabilità sono uguali vuol dire che l'avversario non sta lavorando bene cioè nel senso che non riesce a dedurre nulla perché per lui che siamo nell'esperimento o nell'altro la probabilità di dare un certo output è sempre la stessa quindi vuol dire che non riesce a dedurre nulla quindi dal punto di vista dell'avversario è bene che queste due probabilità siano molto diverse fra di loro per lui il caso migliore è quando una di queste due probabilità è massima 1 e l'altra 6 minima 0 in quel caso la differenza fa 1 in quel caso vuol dire che lui ha la certezza di quale esperimento si sta svolgendo ok quindi questo intuitivamente ci dice che la differenza tra queste due probabilità rappresenta il vantaggio che l'avversario ha nei confronti dell'attac game quindi nei confronti del challenge tanto più grande è questa differenza tanto più è probabile che l'avversario riesca a capire se siamo nell'esperimento 0 o se siamo nell'esperimento 1 cioè a capire se il challenge ha cifrato M0 oppure M1 quindi per questo motivo la differenza fra quelle due probabilità si chiama vantaggio semantics security advantage perché la nozione di sicurezza basata su questo tag game si chiama sicurezza semantica non si chiama più perfect security ma semantic security ok è chiaro l'attac game ci siamo no ora fissato questo tag game la definizione di sicurezza semantica è questa che vedete qua un cifrario è semanticamente sicuro se il vantaggio dell'avversario cioè questa quantità qua è negligible negligible significa trascurabile significa molto molto molto vicino vicino al zero poi dobbiamo formalizzare cosa significa questo per adesso accontentiamoci dell'intuizione quindi il vantaggio dell'avversario è negligible per tutti gli avversari efficienti cioè quegli avversari che eseguono algoritmi che sono limitati in un certo modo dal punto di vista delle risorse perché non possiamo avere una definizione rispetto a tutti i possibili avversari perché fra tutti i possibili avversari c'è quello che si mette lì fa un attacco a forza brutta a disposizione tempo infinito ed è chiaro che prima o poi quindi è importante limitarsi agli avversari efficienti quindi vedete sono entrati in gioco quei due elementi di cui parterevamo all'inizio cioè il fatto di considerare algoritmi efficienti quindi limitati in qualche modo e il fatto di rilassare la condizione di uguaglianza sulle probabilità di certi eventi non pretendiamo più che questi eventi abbiano la stessa probabilità ma ci accontentiamo che queste probabilità siano molto vicine quanto vicine tanto vicine da avere una differenza negligible cioè molto molto molto vicina a zero ok è chiaro che per rendere completa questa definizione dobbiamo capire da un punto di vista matematico cosa significa negligible e cosa significa efficient ok poi poi spero entro la fine della lezione vi faccio vedere matematicamente parlando questi due concetti cosa significano però dal punto di vista intuitivo io vorrei che adesso fosse chiaro per voi perché usiamo questo attack game perché è un attack game che rispetta l'espressività dell'avversario cioè quello che può vedere e quello che può fare e dall'altra quali sono gli elementi di questo attack game che ci permettono di rilassare la condizione della perfect security ok quindi nel mondo realo come no nel mondo reale ripeto se usiamo otp se usiamo one time pad abbiamo perfect security però nel mondo reale otp non si può usare perché perché non abbiamo a disposizione chiavi tante chiavi lunghe quanto tutti i possibili playtests questo non si può fare quindi ci accontentiamo della semantic security ok questa non è ancora la condizione finale di security perché questa è la nozione di sicurezza che ci serve rispetto alle funzioni iniziali banali che abbiamo fatto ieri ovvero quali erano ci interessa solo la secrecy ok uso la chiave una volta sola perché devo trasmettere un solo messaggio dopodiché la chiave la butto la butto via e la chiave è già condivisa ok sotto queste tre condizioni la semantic security è la nostra di sicurezza che ci serve è realistica ancora no perché ancora no perché non è vero che nel mondo reale io la chiave la butto via ogni volta che mando un messaggio vorrei usarla più di una volta però di questo parleremo più ci arriviamo step by step ok complichiamo le cose step by step va bene vi faccio notare che nell'attack game è vero che l'avversario sceglie a piacere due plaintext però devono avere la stessa lunghezza ok il plaintext scelti l'avversario devono avere la stessa lunghezza perché perché se non hanno la stessa lunghezza l'abbiamo visto prima l'avversario vince subito quindi ammettiamo che il problema della lunghezza è un problema che possiamo trascurare che è esattamente poi quello che succede nella realtà ok il resto del resto poi parleremo poco più avanti in particolare cosa significa efficiente cosa significa trascurabile la cosa che vi posso anticipare è che di solito un algoritmo è efficiente rispetto al problema che ci interessa quando le risorse che ha a disposizione di calcolo e di tempo sono limitate polinomialmente ok quindi eseguo l'algoritmo in tempo polinomiale ho a disposizione algoritmi che hanno una complessità polinomiale perché perché sono comunemente le le condizioni che vanno nel mondo reale poi vi farò qualche esempio più particolare perché la sicurezza semantica è la nozione di sicurezza più naturale più intuitiva uno dei motivi è che la semantic security implica altre nozioni alternative di sicurezza ok quindi questo vuol dire che è la più corretta da usare perché usare quella significa soddisfare anche altre nostri alternative tra queste io ve ne cito due perché sono interessanti ovvero la sicurezza semantica implica la sicurezza contro questo tipo di attacco che adesso vi faccio vedere il message recovery attack e implica anche la sicurezza contro questo tipo di attacco che è il party prediction attack sono due attacchi che hanno a che fare con le nozioni di perfect security che abbiamo visto prima sono delle forti delle forti analogie ok non vi farò vedere la dimostrazione vi faccio vedere com'è fatto il message recovery attack com'è fatto il party prediction attack ci basta sapere che se un cifrario è semanticamente sicuro allora è robusto rispetto a questi attacchi non è vulnerabile ok il message recovery attack è descritto da questo attack game è un attack game dove il challenger sceglie casualmente come al solito la chiave sceglie il messaggio vedete stavolta il challenger che sceglie il messaggio ok e calcola il ciphertext ok quindi fa tutto da solo l'avversario non interviene dopo aver fatto questo trasmette il ciphertext ok l'avversario lo riceve esegue il suo algoritmo efficiente sul ciphertext e cerca di indovinare quale plaintext ha generato quel ciphertext ok quindi fa un guess questo è il guess dell'avversario l'avversario cerca di indovinare in maniera più o meno furba qual è il plaintext che ha generato quel ciphertext ok ora il vantaggio che l'avversario ha è uguale alla differenza tra queste due probabilità questa è la probabilità che l'avversario indovini il plaintext ok questa che cos'ha one over the number of possible plaintext the probability over random guess ok se voi comprate un biglietto della lotteria che probabilità avete di vincere one over the number of tickets è più lo stesso no questa è la probabilità che l'avversario ha di indovinare il plaintext senza fare nulla no senza eseguire nessun algoritmo vado a a caso ok questa invece è la probabilità che lui ha di indovinare eseguendo il suo algoritmo efficiente di analisi del cybertext più o meno furba fa tutto quello che vuole ok ora se queste due probabilità fossero uguali cosa vorrebbe dire che l'algoritmo efficiente dell'avversario non serve a niente se quelle due probabilità sono uguali se quelle due probabilità sono molto diverse in particolare se questa è molto più grande di questa cosa vuol dire vuol dire che l'avversario ha un vantaggio vuol dire che l'algoritmo efficiente dell'avversario mi dà un vantaggio perché mi fa indovinare il main text con una probabilità più alta rispetto a quella casuale quindi la differenza tra quei due valori è il vantaggio dell'avversario tanto più piccolo tanto più sicuro il sistema tanto più grande tanto più vulnerabile quindi la definizione di sicurezza contro il messenger recovery attack ci dice che un cifrario è sicuro se il vantaggio che l'avversario ha in questo attack game è negligible per tutti gli avversari efficienti ok c'è un teorema che ripeto noi non vedremo c'è un teorema che dice che se un cifrario è semantic secure allora è anche sicuro rispetto a questo attack quindi questa cosa ci piace ci piace perché vuol dire che l'algoritmo efficiente dell'avversario non è in grado di aumentare significativamente la probabilità di indovinare il plan notate non stiamo mai dicendo che l'avversario non può non può vincere perché non è così l'avversario può fare un po' indovinare però però questa probabilità è ok ok o perlomeno non è piccola la probabilità di indovinare è piccola la differenza tra la probabilità di indovinare eseguendo l'algoritmo efficiente e la probabilità di indovinare a caso è diverso da dire è piccola la probabilità di indovinare perché ad esempio se i plain text possibili sono due testo la probabilità di indovinare è altra il 50% questo non vuol dire che il cifra è insicuro perché se questa che è la probabilità di indovinare usando l'algoritmo efficiente dell'avversario è il 50,001% vuol dire che l'algoritmo efficiente dell'avversario non dà un vantaggio significativo rispetto a quello che tira a caso il suo guess ok quindi no è la differenza su cui noi ragioniamo non è questo se poi noi vogliamo che la probabilità che l'avversario ha di indovinare sia piccola cosa dobbiamo fare bisogna che questa sia molto piccola e come facciamo a far sì che questa sia molto piccola dobbiamo avere il denominatore molto grande chiaramente ok per forza l'altra proprietà è relativa a un altro tipo di attacco che è il parity prediction attack ok questo ha a che fare assomiglia molto all'altra definizione di di perfect security che abbiamo visto prima basata sulla impredicibilità delle proprietà del del plaintext infatti vediamo questo attack game che cosa dice prendete la conoscete la funzione di parità per le sequenze di bit la parity è questa funzione qui lo XOR di tutti i bit del del plaintext quindi in pratica la parità di una stringa è 1 se il numero di bit 1 è disparo la parità è 0 se il numero di bit 1 è pari per questo si chiama parità ok quindi la proprietà che ci interessa è la parità ok vediamo come funziona il challenger che cosa fa sceglie la chiave sceglie il plaintext come prima e come prima calcola il ciphertext e lo trasmette l'avversario esegue il suo algoritmo efficiente al termine del quale prova a indovinare la parità del plaintext ok cioè esaminando il ciphertext cerca di capire quale è la parità del plaintext cioè quanti bit pari a 1 ci sono nel plaintext ok chiaramente la probabilità che ha di indovinare è il 50% vero vero falso ok infatti il vantaggio che l'avversario ha è la differenza tra la probabilità che lui ha di indovinare eseguendo il suo algoritmo efficiente basato sul ciphertext e la probabilità che lui ha di indovinare a caso che è il 50% quindi come prima quella differenza lì se è molto molto molto piccola vuol dire che l'algoritmo efficiente dell'avversario non ci dice nulla non serve a nulla invece se è grande quella differenza allora vuol dire che il vantaggio dell'avversario è significativo quindi di nuovo come prima la definizione di sicurezza è simile un cifrario è sicuro rispetto a questo attacco ok se questo vantaggio qui è negligible per tutti gli avversari efficienti ok anche questa definizione qua di sicurezza è implicata dalla semantic security quindi se un cifrario è semantic secure allora è robusto rispetto a questo attacco qua quindi vuol dire che se io uso un cifrario semanticamente sicuro non solo l'avversario non ha una probabilità significativa di indovinare il plaintext in base a quello che abbiamo detto prima ma non ha neanche una probabilità significativa rispetto a un mezzo di indovinare la parità del plaintext quindi una delle caratteristiche che il plaintext ha ok poi c'è un'altra versione di cui dirò poco di questa tag game qua in questa tag game qui la scelta dell'esperimento è fatta a monte esternamente in maniera non deterministica non è una cosa non è una scelta fatta dal challenger è come se ci fosse un oracolo che dice al challenger fai l'esperimento zero oppure fai l'esperimento uno scelta non deterministica ok c'è una variante di questo tag game in cui la scelta dell'esperimento la fa il challenger e la fa lanciando una moneta quindi la fa in maniera probabilistica testa faccio l'esperimento zero croce faccio l'esperimento uno ok l'attac game basato su questa variante si chiama bit guessing perché a quel punto perché si chiama bit guessing perché a quel punto l'avversario deve indovinare qual è stato il risultato del lancio della moneta deve indovinare qual è l'esperimento la definizione è questa qua ok quindi è lo stesso tag game che abbiamo visto prima quindi l'avversario calcola i due plaintext della stessa lunghezza il challenger sceglierà in questo caso casualmente l'esperimento quindi lancia una moneta per decidere se eseguire l'esperimento zero l'esperimento uno sceglie casualmente la chiave e calcola il ciphertext del messaggio M0 M1 a seconda dell'esperimento di nuovo cosa deve fare l'avversario indovinare il risultato del lancio della moneta quindi se se sono nell'esperimento zero se sono nell'esperimento uno c'è un teorema di cui vi do la definizione ma non vi commento la dimostrazione che stabilisce qual è il vantaggio dell'avversario ok il vantaggio dell'avversario è questo qua e ci dice che l'avversario vince questo attack game con questa probabilità no scusate l'avversario vince questo attack game se solo se il cifrario è semanticamente sicuro con questo vantaggio qui l'ho detto al contrario il vantaggio della tag game per la sicurezza semantica in questo contesto qua è questa quantità però questa è una cosa secondaria giusto per farvi vedere che si può cambiare la policy di scelta dell'esperimento non succede niente la definizione di sicurezza non cambia questo è quello che lo vedi dalla dimostrazione se tu segui i passaggi della dimostrazione ti salta fuori il due terzo quello che devi dimostrare è questo questa è la tesi il teorema ti dice guarda il vantaggio della tag game della semantics che abbiamo visto prima è quella roba lì ora il vantaggio è la differenza fra questi due la probabilità di questi due eventi e bisogna dimostrare che questa roba qui è uguale a questa e questi sono i passaggi algebrici che che lo dimostrano quindi il perché lo vedi ma vabbè adesso questa è una cosa che ci interessa di meno è giusto da sapere che c'è chiudo oggi con sì facciamo il tempo con alcuni dettagli su quelle cose che non abbiamo specificato ovvero in tutte le definizioni di sicurezza semantica che abbiamo visto abbiamo parlato di negligible ed efficient ok intuitivamente sappiamo cosa vuol dire matematicamente cosa vuol dire e questo ve lo faccio vedere in una slide ovvero matematicamente vi faccio vedere che cosa vuol dire per una funzione essere negligible così come vi faccio vedere anche per una funzione cosa vuol dire essere efficient allora intuitivamente una funzione è negligible se converge molto molto rapidamente è vero è un po' l'idea che abbiamo detto prima quindi una funzione che ad esempio si comporta così no? una funzione che molto velocemente si avvicina al zero l'equazione che stabilisce quanto velocemente si deve convergere a zero è quella che vedete qui ok quindi una funzione f dai naturali ai reali è negligible se fissate una qualunque soglia c'era threshold quindi fissate una qualunque soglia piccola piacere aggiungo io ok quindi io posso prendere che ne so immaginiamo qua ok quindi fissate una qualunque no scusate sorry qua ok quindi fissate un qualunque valore piccolo a piacere l'idea di quella definizione è che la funzione prima o poi va sotto questo valore ok prima o poi infatti quella definizione dice guardate che sceglieteci come vi pare ok esisterà sempre un n0 ok tale per cui dal di qui in avanti la funzione è più piccola di questa quantità 1 fratto n elevato c ok ripeto l'intuizione è che voi potete scegliere un numero piccolo quanto vi pare prima o poi la funzione va sotto con lui questo è il numero non esattamente va sotto quel numero ma va sotto 1 fratto n elevato da c ok quindi va sotto una quantità che dipende dall'intuizione perché n è l'intuizione ad esempio questa è una funzione negligible questa ha anche una funzione negligible questa non lo è perché è vero che esistuisce numeri molto piccoli ma non converge abbastanza rapidamente ok questa è una definizione una caratterizzazione alternativa per le funzioni negligible ovvero questa condizione qua adesso non mi interessa che voi sappiate i dettagli analitici di queste funzioni serve solo per darvi un'idea per farvi capire intuitivamente cosa significa essere a noi interessa questo intuitivamente cosa significa essere negligible ok un'altra cosa che ci dobbiamo ricordare è che se una funzione è negligible la sua inversa è superpone ok quindi che ne so questa è una funzione superpoli quindi superpoli è contrario di negligible negligible molto piccolo molto rapidamente superpoli molto grande ok poi l'ultima definizione che ci serve per caratterizzare gli algoritmi efficienti è quella che ci dice quando è che una funzione è limitata polinomialmente anche qui graficamente è molto facile perché quella definizione ci dice che una funzione è limitata polinomialmente polibounded dice se sta sempre sotto un certo polinomio il grafico di una certa funzione polinomial perché questa questa che cos'è questo è un polinomio di grado c ok quindi che ne so prendete questa funzione qui è limitata polinomialmente perché ad esempio posso definire un polinomio una funzione polinomio che potrebbe essere che ne so questa ok e la nostra funzione sta sempre sotto questa che abbiamo disegnato prima la funzione esponenziale non è limitata polinomialmente perché non c'è nessun polinomio che sta sopra di lei ok quindi se voi avete una funzione che sta sotto un polinomio sotto una funzione polinomio allora vuol dire che quella è limitata polinomio al metto questa è l'idea abbastanza astratta insomma senza entrare troppo nei dettagli però vi dà un'idea di che cosa significa ragionare con funzioni negligible super poli o limitate polinomio al metto ok perché ci servono queste nozioni perché ci permettono di capire quello che vedremo la prossima volta perché ci vuole più di un quarto d'ora quindi la prossima volta vi faccio vedere brevemente cosa significa per un algoritmo essere efficiente e cosa vuol dire per la probabilità di un certo evento essere descritto da una funzione negligible e che questi sono i concetti appunto che abbiamo usato per dare la difesa di semantic security ok e questo ci permetterà di capire anche perché nella realtà poi si fanno determinate scelte e vi farò vedere un esempio un esempio classico è quanto deve essere lungo la chiave possiamo perdere il caso di otp dove la chiave è lunga tanto quanto il plaintext ma nei casi reali quanto deve essere lunga una chiave sapendo sapendo che l'attaccante nei vari attack game deve seguire gli algoritmi efficienti che sono appunto limitati probabilmente e questo appunto ci permetterà di stabilire nel mondo reale in base a quelle che sono le risorse di calcolo attuali quali sono dei band al giorno d'oggi ragionevoli va bene se non ci sono domande ci vediamo alla prossima settimana connectionsazioni un taught'un standard ai si non ciRo è non ti devo un persino non