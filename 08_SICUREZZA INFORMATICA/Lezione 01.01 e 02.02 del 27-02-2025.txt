Ok, direi che possiamo cominciare. L'obiettivo della lezione di oggi è chiudere la parte relativa ai cifrari a flusso e poi conto anche di chiudere la parte introduttiva che abbiamo amministrato ieri sul perimetro di sicurezza in ambienti aziendali. Così spezziamo in due la lezione. Allora, tornando al discorso che avevamo lasciato in sospeso sui cifrari a flusso, questo lo possiamo minimizzare, non ci serve. Eravamo arrivati a raccontare qualcosa sui generatori di numeri casuali, se vi ricordate, che hanno delle forti analogie con i PRG, con i pseudorandom generator, se non che, come abbiamo sottolineato ieri, mentre i PRG che si utilizzano per i cifrari a flusso sono impredicibili, il che garantisce la sicurezza semantica di cifrari a flusso, nella stranale di maggioranza dei casi, questo non vale per i generatori di numeri casuali, che invece tipicamente sono predicibili. Vi volevo mostrare una caratterizzazione alternativa del concetto di impredicibilità o di sicurezza semantica per i cifrari a flusso, e in particolare per i PRG, nel senso che ieri abbiamo visto quando è che un PRG è sicuro rispetto ad un certo attack game che abbiamo definito e abbiamo visto che questa nozione di sicurezza si può esprimere in termini di impredicibilità. Oggi vi faccio vedere un ulteriore modo di esprimere la sicurezza dei PRG, che si basa sul concetto di indistinguibilità, che è un concetto che in realtà a monte si applica ad altri ambiti, come ad esempio quello della teoria delle probabilità, dove serve per misurare quanto diverse distribuzioni di probabilità sono simili o difformi tra di loro. Vediamolo con questo esempio in cui descriviamo attraverso, come al solito, un attack game, cosa significa confrontare due distribuzioni di probabilità. Immaginate di avere un dominio di elementi e di avere due distribuzioni di probabilità associate a questo dominio. Quindi due distribuzioni che associano una certa probabilità a ogni elemento del dominio. Lo scopo dell'avversario è quello di, osservando dei campionamenti, capire questi campionamenti a quale distribuzione di probabilità fanno riferimento. Quindi l'idea è che abbiamo il challenger che ha due distribuzioni di probabilità, e quello che deve fare è estrarre un elemento dal dominio seguendo una delle due distribuzioni di probabilità. Il compito dell'avversario è capire quale distribuzione di probabilità il challenger ha seguito, ha usato per fare il campionamento, il shopping. Quindi vedete l'iscrizione dell'attac game, il challenger calcola, estrae un elemento, con questa terminologia qui, se riesco a scrivere la lavagna oggi, con questa notazione qui stiamo dicendo che il challenger sta estraendo un elemento, X, dal dominio R, da questo dominio qua, usando una certa distribuzione di probabilità, quale? Quella stabilita dall'esperimento. Le due distribuzioni sono P0 e P1, il challenger segue uno di due esperimenti in base al quale deve estrarre usando P0 e usando P1, e fa l'estrazione. L'avversario osserva il risultato dell'estrazione, l'avversario osserva il risultato dell'estrazione, e cerca di indovinare qual è la distribuzione di probabilità che è stata usata. Ok? È chiaro che il vantaggio dell'avversario è se si calcola sempre dello solito modo, che abbiamo sempre visto in tutti gli attac game, cioè come differenza tra due probabilità, ovvero la probabilità che l'avversario spari un certo risultato quando siamo nell'esperimento 0, meno la probabilità che l'avversario spari lo stesso risultato quando invece siamo nell'esperimento 1. È chiaro che intuitivamente se le due distribuzioni di probabilità di 0 e P1 sono molto simili tra di loro, è difficile per l'avversario riuscire a distinguerle, e quindi il suo vantaggio dovrebbe essere molto piccolo. Ok? Prendiamo un caso limite. Un caso limite potrebbe essere quello in cui, prendete R che ha due elementi, A e B. Ok? Ora, prendete la distribuzione di probabilità di 0. Andiamo così, e si scrive meglio. Prendete la distribuzione di probabilità che associa ad A il valore 1 e A B il valore 0. Ora, se voi seguite quella distribuzione di probabilità e fate un esperimento, con probabilità 1 vi salta fuori A e B non vi salta fuori mai. Ora, prendete quest'altra distribuzione di probabilità, A. Ora, all'avversario quanti esperimenti servono per capire se il challenger sta usando P0 o sta usando P1? Lo indovino subito, basta un esperimento, perché se l'avversario osserva A vuol dire che il challenger ha usato la distribuzione P0 per fare il sampling. Se osserva B vuol dire che il challenger ha usato la distribuzione P1. Ora, cambiamo leggermente le cose, per cui supponiamo invece che... No, non volevo cancellare tutto. Sì. L'avversario conosce le due distribuzioni, ma non sa quale sta usando il challenger. Sì, sì, si riconosce, riconosce. Sa, ok. Se invece la situazione è questa, siamo qui. Se invece questa situazione, vediamo un po', 0,52, 0,48. Ora, se questa è la situazione, le due distribuzioni sono molto più simili. Quindi chiaramente è più difficile per l'avversario riuscire a distinguere, osservando i sampling, se il challenger sta usando P0 o P1. E così via. Questa cosa la possiamo portare al limite, quanto vogliamo. quindi il vantaggio che l'avversario avrà, chiaramente dipende da quanto sono simili le due distribuzioni. Ora, la nozione di indistinguibilità computazionale ci dice che due distribuzioni sono indistinguibili se il vantaggio che l'avversario ha, cioè la capacità che l'avversario ha di distinguere una dall'altra, di fatto, è trascurabile per tutti gli avversari efficienti. Quindi vuol dire che un avversario che ha a disposizione un tempo polinomiale per osservare i risultati dei campionamenti, metterli a confronto e cercare di capire se il campionamento viene da P0 o viene da P1, per lui è un vantaggio, si tratta di un vantaggio trascurabile, quindi molto molto vicino a zero. Ok? Quindi se... E l'idea qual è? L'idea è che usando la nozione di indistinguibilità possiamo ridefinire la sicurezza dei PRG. In che modo? Beh, lo vediamo subito. Prendete queste due distribuzioni di probabilità. Ok? Allora, immaginiamo di avere un PRG. Allora, abbiamo un PRG che lavora su... Non rimangono i colori fermi. Lavora su questo dominio di semi e spara su questo codominio di stringa pseudorandom. Ok? Quindi abbiamo un PRG classico e... Considerate queste due distribuzioni. Allora, questa è la distribuzione... Cioè, P1 è la distribuzione ideale perché è la distribuzione uniforme su R. Ok? Cosa vuol dire? Vuol dire che in base a P1 tutte le stringhe pseudorandom hanno la stessa probabilità di essere generate. Ok? Che, se ci pensate, corrisponde a dire che la stringa pseudorandom è scelta in maniera veramente casuale. Ad esempio, lanciando una moneta per ogni bit della stringa. Tutte le stringhe hanno la stessa probabilità di essere generate. Perché è ideale questa distribuzione? Perché noi vorremmo che un PRG si comportasse esattamente così. Visto che il compito del PRG è sparare e creare una stringa pseudorandom che andrà in XOR con il plaintext, noi vorremmo che il PRG si comportasse in questa maniera qua. sotto invece che cosa vediamo? Vediamo il comportamento effettivo del PRG. Cioè, vediamo la distribuzione reale associata al comportamento del PRG. Come è definita P0? È la distribuzione che a ogni elemento del codominio delle stringhe pseudocasuali che cosa associa? Andiamo a vedere come viene calcolato. Allora, al denominatore avete la cardinalità dei semi. Quanti sono i possibili semi? Al numeratore che cosa avete? Avete la cardinalità dell'insieme dei semi per cui il PRG genera quel particolare, quella particolare stringa pseudocasuale. Tutti i semi, voi contate tutti i semi tali per cui il PRG a partire da quel seme vi dà quel particolare R. Ok? Il rapporto fra queste due quantità vi dice qual è la probabilità che il PRG spari quel particolare valore pseudorandom, quella particolare stringa pseudocasuale. Ok? Faccio un esempio banalissimo. immaginate di avere a disposizione dieci semi. Ok? Solo uno di questi fa sì che il PRG spari una certa stringa pseudocasuale. Quindi qual è la probabilità di quella stringa? È uno su dieci. Perché? Perché gli altri nove semi sparano qualcos'altro. Ok? Potrebbero, dipende, non abbiamo garanzia del fatto che ogni seme dà un luogo ad una diversa stringa pseudocasuale. Nella definizione di PRG non abbiamo mai detto da nessuna parte che è una funzione iniettiva. Ok? Quindi ci potrebbero essere delle collisioni, cioè diversi semi che danno lo stesso risultato. La collisione sui semi adesso non è così rilevante in questo contesto. In questo contesto quello che ci interessa di più è il fatto che l'output del PRG sia impredicibile. Ok? Poi è chiaro che quanti sono i semi che poi collidono influenza invece questo valore qua che invece è importante perché è in questo modo che sappiamo qual è la probabilità associata a ogni stringa pseudocasuale. È chiaro che se ci sono se per una certa stringa se per una stringa tanti semi che collidono mentre per un'altra magari ne ho uno solo allora vuol dire che quelle due stringhe non hanno la stessa probabilità di essere generate chiaramente e quindi vuol dire che il PRG non è ideale perché non si sta comportando in maniera ideale cioè in maniera tale da essere paragonabile a una distribuzione di probabilità uniforme su tutti i possibili risultati ok infatti l'idea l'idea l'idea qual è è che se queste due distribuzioni di probabilità P0 e P1 cioè quella ideale P1 è la distribuzione ideale P0 è la distribuzione reale associata al PRG se queste due distribuzioni di probabilità P0 e P1 sono indistinguibili fra di loro rispetto a questa nozione qua che abbiamo appena visto cosa vuol dire vuol dire che un avversario che osserva una stringa pseudo casuale non riesce a capire se quella stringa è stata generata in maniera veramente casuale usando P1 la distribuzione ideale oppure se è stata generata usando P0 cioè usando il PRG quindi se dal punto di vista di un avversario estrarre a caso una stringa o chiedere al PRG di farlo è la stessa cosa ma se è la stessa cosa torniamo al discorso che facciamo ieri vuol dire che il PRG è sicuro perché si comporta veramente come un campionatore casuale di sequenze di bit ok quindi alla fine stiamo ridefinendo in maniera un po' diversa esattamente lo stesso concetto che abbiamo visto ieri ok in particolare ieri abbiamo detto il PRG è sicuro se non riusciamo a distinguere l'output generato dal PRG da un output generato casualmente ma questo significa nella stessa misura dire che la distribuzione di probabilità associata a un campionamento puramente casuale è indistinguibile dalla distribuzione di probabilità associata all'uso del PRG abbiamo semplicemente formalizzato un pochino di più quello che avevamo già detto ieri ok va bene questo chiude il discorso relativo alla sicurezza dei pseudorandom generator che sono usabili nel contesto degli string cipher o perlomeno danno origine a string cipher semanticamente sicuri solamente se loro stessi sono sicuri sicuri rispetto a quale nozione quella che abbiamo appena visto oggi adesso che corrisponde a quella che abbiamo visto ieri e che corrisponde al concetto di impredicibilità ok questo chiude un po' il discorso relativo al PRG e qui implementazioni pratiche sono quei due esempi che vi ho fatto vedere ieri ovvero salsa e cia cia che funzionano utilizzando primitive di base come permutazioni e exor vi faccio vedere così come ieri vi ho fatto vedere un esempio relativo all'onion routing oggi vi faccio vedere un altro esempio pratico pratico dove possiamo usare il PRG adorando un generator ok ed è un esempio abbastanza interessante perché risolve un problema abbastanza piuttosto diffuso l'applicazione di cui parleremo è quella del cosiddetto bit commitment e si basa su un protocollo che si chiama coin flipping qual è il problema del bit commitment come dice un po' il termine è un problema in cui ci sono due agenti che si devono mettere d'accordo su un valore ok ora se i due agenti sono in presenza ci sono tanti modi efficaci di arrivare ad un accordo ok il problema invece è un po' più interessante quando i due agenti non si vedono sono a distanza faccio un esempio banale ok non so stasera vogliamo andare al cinema ok e non sappiamo come deciderci su cosa andare a vedere io vorrei andare a vedere un film d'azione voi vorreste andare a vedere un film romantico ok come ci mettiamo d'accordo per non fare torto a nessuno quale potrebbe essere un'idea lanciamo una moneta se viene testa vinco io andiamo a vedere un film se viene croce vincete voi andiamo a vedere l'altro film ok questa è un'idea se siamo in presenza è facile realizzare questo tipo di strategia ma se siamo al telefono invece che essere in presenza come facciamo a realizzare lo stesso tipo di strategia qual è il problema di problema della trasparenza perché chi lancia la moneta se la lancio io voi vi dovete fidare di quello che io vi dico o viceversa c'è una mancanza di trasparenza quindi di fiducia ci sono tanti problemi come questo in cui ci si deve appunto affidare ad un valore che in questo caso viene stato a sorte ma tutte le parti coinvolte devono avere la stessa garanzia del fatto che effettivamente il valore che viene dichiarato è quello che è stato estratto che non viene cambiato ok il coin flipping protocol è stato proposto per risolvere questo problema in un contesto in cui gli agenti coinvolti non sono in presenza e lo si può risolvere in tanti modi dal punto di vista tecnico ok e uno dei modi per risolverlo è tramite l'uso dei PRG dei pseudo random generator allora intanto vediamo il protocollo come è definito poi vediamo come risolverlo usando i PRG allora il protocollo funziona in questa maniera abbiamo Alice e Bob che si devono mettere come abbiamo appena detto nel nostro esempio mettere d'accordo su un valore booleano ad esempio il risultato del lancio di un modi ok come fanno a mettersi d'accordo allora l'idea è questa ognuno dei due sia Alice che Bob scelgono a proprio piacimento un bit ok poi l'idea è che se lo scambio in qualche modo che adesso vedremo il risultato su cui avere commitment quindi il risultato su cui i due si metteranno d'accordo sarà l'oxor dei due bit ok quindi io scelgo un bit voi scegliete un bit facciamo l'oxor di questi due bit il risultato sarà il valore finale su cui ci mettiamo d'accordo su cui c'è commitment ok ora il problema qual è? il problema è scambiarsi questi bit in maniera tale che nessuno né io né voi abbiamo la possibilità di fare cheating quindi di ingannare di ingannare l'altro ok faccio un esempio banale supponiamo che il risultato finale che a me piace che a me fa comodo sia uno il mio bit è zero scelgo zero voi scegliete uno se scegliete uno zero xor uno fa uno vinco io sono contento se scegliete zero io so che vado a perdere ok magari voi mi inviate il bit che avete scelto zero io non ve l'ho ancora mandato il mio io ho scelto zero ma mi accorgo che quello che ho scelto è perdente allora cosa faccio? lo cambio nel momento in cui so qual è il vostro bit e quindi vinco sempre allora il dubbio la domanda è chi per primo trasmette all'altro il proprio bit e chiaro il problema? come lo risolviamo questo problema? allora si può risolvere in maniera asimmetrica questo è un modo vediamo che cosa succede Bob sceglie il suo bit random di zero ok? Alice farà altrettanto a questo punto cosa succede? che Bob fa un commitment su B zero che cosa significa un commitment su B zero? significa che Bob deve creare una stringa appunto detta di commitment chiamiamola C che Bob manderà ad Alice il valore di C non svela nulla del contenuto di B zero però ha una garanzia del fatto che Bob una volta che ha scelto B zero non cambierà più il valore di B zero è una sorta di garanzia poi vediamo come realizzare questa garanzia ok? insieme al commitment C Bob genera un'altra stringa che è S che è il valore che serve per aprire il commitment e verificare che quello era il commitment di B zero vediamo poi nel dettaglio come funziona parallelamente a Bob Alice che cosa fa? sceglie il suo bit e dopo aver ricevuto il commitment da Bob manda il proprio bit a Bob ok? quindi tornando rappresentiamolo graficamente abbiamo Alice abbiamo Bob Bob sceglie il proprio bit che mandano B zero Alice sceglie il proprio bit B1 nessuno dei due vuole svelare il proprio bit all'altro prima dell'altro per il problema che dicevamo prima quindi che cosa succede? succede che Bob non manda B zero ad Alice ma gli manda un commitment di B zero quella famosa garanzia di cui parlavamo prima ok? quando Alice riceve il commitment allora manda Bob il proprio bit ok? a questo punto Bob che cosa deve fare? deve mandare ad Alice la stringa s che serve per aprire il commitment a questo punto Alice farà un check su scusate oltre ad essere naturalmente gli manda anche B zero a questo punto Alice dovrà fare un check e verificare che B zero il commitment e l'apertura del commitment siano coerenti yeah similar similar to the casino case in which I publish the ciphertext and afterwards I publish the key needed to open the ciphertext in this case it's similar to considering the commitment as the ciphertext associated to B zero and opening string as the key needed to open the ciphertext so in this case Alice it is sufficient that Alice uses S to open C and compare the result with B zero ok that's the idea S è unico per C vediamo dopo vediamo dopo vediamo dipende dall'implementazione però idealmente ogni commitment ha una sua stringa di apertura nella realtà non succede mai e quindi bisogna fare attenzione però idealmente c'è un solo modo di aprire il commitment poi in realtà vedremo che non è così ok però per adesso possiamo assumere che sia che sia così naturalmente per aprire il commitment è necessaria la opening string a questo punto del protocollo sia Alice che Bob possono fare questo calcolo otterranno lo stesso risultato e questo risultato sarà il valore su cui si mettono d'accordo ad esempio quale film andare a vedere ok ora questo protocollo funziona sotto determinate condizioni e le condizioni importanti da rispettare sono due la prima è l'hiding hide significa nascondere e si riferisce al fatto che questa informazione qua cioè il commitment non deve svelare nulla ad Alice sulla natura di B0 perché è chiaro che se in qualche modo Alice osservando il commitment fosse in grado di risalire a B0 ecco che il protocollo salta per aria perché fallisce perché a quel punto Alice indovina B0 prima di trasmettere a Bob il proprio beat e quindi vince sempre questo pandilancia ora avril ora for di.- be mentre attorno l'magittarin di pensi di pensi di trasmission di lei di time di quale tu tra i tu cripta analisi di commitment ok quindi la prima proprietà che dobbiamo soddisfare l'hiding alice non deve dedurre nulla riguardo a b0 osservando c no che è una proprietà che poi abbiamo già visto anche in passato quando abbiamo discusso della sicurezza somatica l'altra proprietà è il binding bind significa associare legare mettere relazione e cosa ci dice questa proprietà? ci dice che in pratica una volta che Bob ha ricevuto b1 l'unica cosa che può fare appunto è rispondere con il proprio bit e la string di apertura di c no? Bob non dovrebbe essere in grado di modificare a posteriori il proprio bit e trovare una opening string alternativa che in combinazione con c gli permetta di svelare il bit che desidera ok? perché se Bob noi sappiamo che c'è questo legame B0 C ed S ok? c'è questo legame ovvero C è il commitment di B0 rispetto alla opening string S ora immaginiamo che Bob riesca a trovare un'altra tripla no? con lo stesso commitment un valore diverso del bit e un valore diverso della opening string se Bob conoscesse queste due triple allora cosa potrebbe fare per ingannare Alice? beh manda il commitment ok? aspetta di vedere qual è il bit di Alice poi sceglie tra tra B0 e B0 primo quello che gli fa comodo per vincere sapendo chi è B1 dopodiché pubblicherà ad Alice uno dei due bit e la opening string che gli conviene o S o S primo ok? soddisfare la proprietà di binding significa dire che Bob non è in grado di trovare un'altra opening string per lo stesso commitment che dia come risultato un altro un altro bit chiaro? quindi in pratica l'hiding è una garanzia a tutela di Bob cioè l'hiding è una proprietà per Bob perché garantisce a Bob che Alice non riesca a dedurre B0 osservando il commitment ok? il binding è invece una proprietà a garanzia di Alice perché è una proprietà che garantisce ad Alice che Bob non possa fare cheating dopo aver osservato B1 modificando la opening string scegliendo come gli pare la opening string in maniera tale da associare C a un bit qualunque ok? quindi se vagono sia l'hiding che il binding entrambi gli agenti sono tutelati sono garantiti e quindi non c'è possibilità per nessuno dei due di imbrogliare e quindi siamo tutti contenti perché l'egito finale del protocollo sarà fair per entrambi ok? è chiaro in cosa consiste il bit commitment e in particolare il coin flipping protocol ora per implementare questo protocollo ci serve qualche meccanismo grittografico che permetta a Bob di creare un commitment e una opening string che soddisfino contemporaneamente hiding e binding ok? e un modo di farlo è usare un prg come meccanismo grittografico quindi l'idea è che usiamo un prg per definire l'algoritmo di commitment e associando naturalmente al commitment anche l'opening l'opening string come avviene la cosa? lo vediamo qua allora il prg che usiamo deve avere certe caratteristiche poi capiremo per quale motivo allora il prg sarà una funzione che come al solito mappa semi di un certo dominio s in string pseudo casuali di un certo codominio r ok? quindi abbiamo un prg chiaramente il prg assumeremo che sia sicuro questo ci serve per garantire la proprietà di come vedremo la proprietà di hiding e in più deve avere questa condizione questa condizione come vedremo ci serve per garantire la proprietà di binding ok? cosa dice quella condizione? che il dominio il codominio delle stringhe pseudo casuali restituite dal prg è almeno il triplo come dimensione rispetto alla cardinalità dello spazio dei semi no scusa si hai ragione il cubo il cubo il cubo hai ragione si si il cubo ok? adesso questa è una condizione che ripeto ci servirà per dimostrare la proprietà di binding come funziona il commitment l'algoritmo è quello che abbiamo visto prima ok? il commitment funziona nel seguente modo Alice deve scegliere un numero casuale un numero scusate una stringa casuale dal codominio e mandarla a Bob a questo punto Bob da parte sua scelgo un seme e fa questo calcolo qua ok? ovvero genera il commitment applicando il PRG al seme se vuole fare il commitment di questo bit il calcolo da fare semplicemente è questo applica il PRG al seme se invece Bob vuole fare il commitment di questo bit allora il calcolo è un po' più complicato ed è questo cioè applica il PRG seme poi però lo combina in XOR con quella stringa che aveva scelto Alice ok? quindi questo è il modo in cui Bob fa il commitment del proprio bit a questo punto Bob cosa fa? come abbiamo visto prima nel protocollo manda il commitment ad Alice ok? quindi Alice si vede ricevere una stringa pseudo casuale ok? Alice risponde svelando il proprio il proprio bit e in risposta a questo Bob deve mandare ad Alice che cosa? il proprio bit e la opening string la opening string è il seme che Bob aveva usato per come input per il PRG ok? quindi vedete alla fine Bob manda questa coppia ad Alice dice guarda io avevo scelto B0 e per dimostrarti che non sto imbrogliando ti faccio vedere qual è il seme che ho usato per fare commitment su B0 così che tu possa verificarlo infatti Alice per verificare il tutto una volta che riceve il il seed da da Bob e il bit di Bob non deve fare altro che rifare il calcolo che aveva fatto Bob nel creare il commitment se ottiene lo stesso valore che ha ricevuto da Bob come commitment allora vuol dire che Bob non ha imbrogliato dal suo punto di vista ok? ci siamo? chiaro? ora intuitivamente intuitivamente se il PRG è sicuro dal punto di vista di Alice il commitment che riceve è indistinguibile da una stringa totalmente casuale no? ma se è indistinguibile da una stringa totalmente casuale non ha nessuna informazione per preferire B0 uguale a 0 piuttosto che B0 uguale a 1 infatti andiamo a vedere formalmente come dimostrare l'hiding l'hiding vale computazionalmente proprio perché il PRG è sicuro il fatto che il PRG sia sicuro l'abbiamo visto prima significa che l'output del PRG è computazionalmente indistinguibile rispetto ad una qualunque stringa casuale computazionalmente indistinguibile vuol dire che un avversario efficiente ha una probabilità trascurabile di riuscire a distinguere ok? ma se questo vale per questa stringa qui vale anche per questa no? perché? perché R è casuale è legato in XOR con una stringa anche quella casuale quindi l'OXOR di due stringa casuali è una stringa casuale quindi questo per dire che Alice riceva questo o che Alice riceva questo lei non lo sa in ogni caso ciò che riceve è computazionalmente indistinguibile rispetto ad una stringa pseudo casuale quindi Alice non riesce a dedurre nulla no? riguardo alla natura del bit che Bob ha scelto quindi l'hiding vale ok? Bob è tutelato no? ora ci dobbiamo chiedere se sia tutelata anche Alice ovvero ci dobbiamo chiedere se una volta che Bob ha visto il bit di Alice è in grado lui ha calcolato il commitment allora ci dobbiamo chiedere Bob supponiamo che Bob abbia calcolato il commitment di in questo caso ma dopo aver visto il bit di Alice si accorge che era meglio questo caso allora la domanda è a quel punto Bob può imbrogliare? ha già pubblicato il commitment deve mandare ad Alice la stringa di apertura e il bit che ha scelto allora ci dobbiamo chiedere se come abbiamo detto prima fissato un certo commitment che ha calcolato con un certo bit e con una certa stringa di apertura ci dobbiamo chiedere se per Bob è ragionevole trovare per lo stesso commitment ok una stringa di apertura diversa che però sia relativa all'altro bit ok ma per far questo Bob deve risolvere questo problema qua ok questo è immaginiamo il commitment che Bob ha calcolato su B0 cioè che è il bit che ha scelto ok immaginiamo che Bob si accorga di aver scelto il bit sbagliato per vincere era meglio se sceglieva l'altro quindi Bob si deve chiedere se riesce a trovare un seed diverso R l'aveva scelto Alice e quello non lo può cambiare che crea lo stesso commitment però sull'altro bit ok no ma andiamo a vedere la definizione di commitment la definizione di commitment in questo caso quindi quando il bit è 0 il calcolo è questo se il bit è 0 il commitment lo ha calcolato semplicemente come il PRG del seme se invece il bit è 1 il commitment si calcola così quindi Bob deve risolvere questo secondo problema esistono s0 ed s1 tale che g di s0 è uguale a g di s1 oxor e r ovvero usando un po' di proprietà algebliche Bob deve risolvere questo problema qua per riuscire ad imbrogliare cioè deve trovare due semi tale che l'oxor dei due PRG è uguale ad r se Bob risolve questo problema allora ha una strategia per imbrogliare Alice perché quando vede il risultato che Alice gli manda Bob sceglierà tra s0 ed s1 quel seme che gli permette di svelare il bit che preferisce ok ma Bob non riesce a risolvere questo problema perché non riesce a risolvere questo problema il che ci permette di dire che la proprietà di binding vale incondizionatamente Bob non riesce a risolvere questo problema sotto una condizione qual è questa condizione? allora andiamo a vedere prima avevamo assunto che vale questo ok quindi ricordiamocelo no ora la condizione che garantisce il binding incondizionatamente è questa cioè il fatto che questo questo numero qui sia trascurabile molto molto piccolo ok questo è il numero di semi dire che 1 sul numero di semi è una quantità molto molto piccola equivale a dire che l'insieme dei semi è molto molto grande cioè super poli come dicevamo l'altra volta se l'insieme dei semi è super poli e unitamente a questo fatto vale questa ipotesi che avevamo fatto all'inizio allora Bob non è in grado di risolvere questo problema perché andiamo a vedere per quale motivo no allora intanto Bob come può fare l'unico quale è l'unico modo che ha a disposizione Bob per risolvere questo problema andare per tentativi no cioè cercare due semi che soddisfano quella condizione lì ok ora andiamo a fare due conti le coppie possibili di semi sono così tante quello è il numero di coppie possibili a 6 0 6 1 ok la probabilità che Alice perché R è Alice a sceglierlo ok la probabilità che Alice ha di scegliere un R per cui esiste una coppia di semi che risolve quell'equazione è questa qua dove al numeratore abbiamo tutte le possibili coppie al denominatore abbiamo tutti i possibili output tutti i possibili scusate R ok voi immaginate che per ogni coppia di semi ci sia un R che risolve questa equazione ok quindi se per ogni per ogni coppia di semi esiste un R che risolve questa equazione allora vuol dire che la probabilità di beccare un R tale per cui esistono una tale coppia di semi è questa perché questo è il numero delle coppie questo è il numero degli R fate questo rapporto e ottenete la probabilità che l'R che Alice ha scelto sia tale per cui esistono due semi che risolvono quell'equazione ok faccio un esempio pratico avete 25 possibili coppie di semi ok e per ciascuna di queste coppie ci può essere un solo R che soddisfa quell'equazione quindi 25 possibili string casuali associate a quelle coppie se il numero totale di possibili string casuali è 100 vuol dire che 25 in 25 casi su 100 avrò scelto l'R associato ad una coppia negli altri 65 casi non avrò un R associato ad una coppia ok quindi questa è la probabilità che Alice sfortunatamente abbia scelto un R tale per cui esistono questi due semi che Bob potrebbe trovare e che gli permetterebbero di ingannare ok ora facciamo un ragionamento su questa probabilità ok se prendiamo l'ipotesi che avevamo fatto all'inizio che è questa la cardinalità di R è maggiore o uguale di S al cubo ok quindi qua sotto c'è qualcosa che è più grande di S al cubo quindi vuol dire che questa probabilità qui al massimo è 1 su cardinalità di S semplifichiamo no qua sotto avete qualcosa che è più grande di S al cubo quindi semplifichiamo un po' e la probabilità diventa al massimo questa ok quindi la probabilità che Alice abbia scelto un R per cui Bob può trovare S0 S1 in modo tale da risolvere queste equazioni e quindi imbrogliare è al massimo questa ma questa probabilità qui è è negligibile e quindi vuol dire che la probabilità che Alice scelga nel protocollo un R tale per cui Bob può risolvere questo problema è trascurabile vedete non stiamo neanche ragionando sul fatto che Bob ci metta più o meno tempo per risolvere questo problema non ci interessa Bob potrebbe anche essere un oracolo ok Bob potrebbe anche essere un oracolo che se Alice sceglie un Erwin per cui esistono questi due semi Bob li trova subito ma anche sotto questa ipotesi in ogni caso la probabilità che questo succeda è comunque trascurabile perché perché il dominio degli R è talmente grande super poli per cui la probabilità che Alice ne scelga uno sfortunato per cui Bob riesce a risolvere l'equazione è trascurabile quindi per questo motivo la proprietà di binding è valida incondizionatamente perché noi non stiamo facendo soluzioni su quanto è efficiente Bob Bob potrebbe avere a disposizione risorse illimitate in ogni caso la probabilità che lui riesca a ingannare è trascurabile ok quindi la proprietà di binding è più forte di quella di hiding in questa soluzione perché il binding vale incondizionatamente invece l'hiding non valeva incondizionatamente l'hiding valeva computazionalmente che cosa vuol dire vuol dire che l'hiding vale solamente se prendiamo in considerazione avversari efficienti quindi limitati polinomialmente il solito discorso che abbiamo sempre che abbiamo sempre visto ok quindi in questo caso qui abbiamo delle condizioni che in questo caso qua non abbiamo quindi in qualche modo possiamo dire che è un po' più tutelata Alice di quanto non lo sia Bob perché il binding è la proprietà a garanzia di Alice e l'hiding è la proprietà a garanzia di Bob sono tutelati entrambi perché anche Bob è tutelato perché perché l'hiding computazionale garantisce a Bob che se Alice è un algoritmo efficiente allora la probabilità che ha di ingannare è trascurabile però sotto l'ipotesi che Alice sia efficiente invece per quanto riguarda il binding abbiamo visto che Alice ha la garanzia che Bob non può ingannare indipendentemente dal tipo di avversario che è Bob ok quindi è chiaro è chiara la differenza tra il fatto che la proprietà valga incondizionatamente o computazionalmente questo è interessante perché più avanti usando una primitiva criptografica diversa dai PRG risolveremo lo stesso problema del coin flipping protocol e quindi del bit commitment però ruoli invertiti perché faremo vedere che usando un meccanismo diverso l'hiding riusciamo a garantirlo incondizionatamente mentre invece il binding lo riusciamo a garantire computazionalmente quindi invertendo il peso delle due proprietà anche uno potrebbe chiedere va bene ma allora esiste una soluzione che garantisce sia l'hiding che il binding incondizionatamente la risposta è no non c'è una soluzione di questo genere purtroppo ok quindi a seconda del tipo di soluzione criptografica che utilizziamo avremo che solo una solo una delle due proprietà vanno incondizionatamente l'altra varrà computazionalmente quindi ci accontenteremo questo è il discorso tutto chiaro? va bene questo chiude il discorso relativo agli stream cipher che abbiamo visto essere basati fondamentalmente sul concetto di PRG e quindi abbiamo visto quelle che sono le proprietà di sicurezza che caratterizzano appunto i PRG sicuri e quindi gli stream cipher semanticamente sicuri visto che abbiamo chiuso questa parte ne approfitto per chiudere anche l'altra parte che avevamo lasciato in sospeso quindi torniamo a parlare di perimetro di sicurezza tempo che ci rimane vediamo dove riusciamo ad arrivare da questo punto di vista ieri abbiamo iniziato a ragionare su che cos'è il perimetro di sicurezza per quale motivo il perimetro di sicurezza è sempre meno definito è sempre più sfumato e questo in virtù delle tecnologie nuove emergenti che vengono utilizzate in contesti corporate questa figura abbiamo visto ieri assume un po' quelle che sono delle diverse situazioni che si possono avere e ciascuna di queste è importante ricordare solleva diverse tipologie di problematiche di sicurezza non c'è uno scenario che è esente da rischi da minacce ok quali sono le minacce abbiamo iniziato a parlare un po' di diverse categorie abbiamo introdotto i malware siamo arrivati a mostrare un esempio di come funzionava un malware un worm in particolare un altro esempio che non mi ricordo se ieri avevo già accennato è questo che è forse il primo caso di botnet in larga scala che ha colpito massimamente la rete se vi ricordate un un bot un malicious bot non è altro che un dispositivo che è stato compromesso da remoto e di cui l'avversario assume il controllo ok se l'avversario compromette tanti diversi dispositivi si crea quella che appunto viene chiamata rete di bot quindi botnet che l'avversario può utilizzare per diversi scopi la prima botnet su larga scala che ha avuto una risonanza interessante per efficacia ed efficienza risale al 2016 il codice il codice è open source oggi come oggi quindi se cercate Mirai botnet trovate i sorgenti del malware e lo scopo per cui era stata lanciata questa botnet era condurre un attacco di tipo denial of service quindi l'obiettivo dell'avversario era prendere il controllo di una rete di dispositivi e usarli per interrogare massivamente contemporaneamente un server con l'obiettivo appunto di degradare le performance di quel server e di fatto saturarlo saturare la banda e quindi renderlo inutilizzabile la botnet ha raggiunto delle dimensioni attorno ai 100.000 dispositivi quasi tutti quasi tutti IoT ok sensori piuttosto che telecamere di sorveglianza collegate in rete quindi qualunque genere di dispositivo IoT e quindi questi 100.000 dispositivi sono stati usati per mandare contemporaneamente richieste ad un server non ricordo quale con lo scopo appunto di saturare la banda e la stragrande maggioranza se non tutti i dispositivi che facevano parte di questa di questa botnet sono stati compromessi in virtù di due diciamo inaccuratezze la prima il fatto che questi dispositivi avevano erano tutti quanti aperta la porta telnet che è una porta su cui il traffico viaggia in chiaro in plaintext quindi nessuna forma di cifratura ok porta aperte cosa significa? che significa che questi dispositivi erano disponibili ad aprire una connessione remota ok e una volta che ho aperto una connessione cosa faccio? chi aveva lanciato il malware semplicemente conduceva un attacco a forza bruta sulla password di admin del dispositivo quindi una cosa estremamente semplice ok siccome in molti molti casi i dispositivi erano in funzione utilizzando la password di fabbrica che di default in molti casi era semplicemente password o admin o qualcosa di questo genere esatto o se no come nelle smart tv 1,2,3,4 nelle smart tv il pin per sbloccare il parente al control e quindi cambiare la configurazione di sicurezza della televisione di default è 1,2,3,4 oppure 1,1,1 e nessuno lo cambia mai ok qui vale lo stesso discorso dalla fabbrica i dispositivi uscivano con delle password di default che nessuno si preoccupava di cambiare perché? perché tanto nel ragionamento degli amministratori di sistema perché devo andare a impostare una password sicura per una telecamera di solviabilità cosa potrà mai succedere? o per un sensore di umidità o di temperatura o cose di questo genere e invece diciamo che l'obiettivo c'era la vulnerabilità è abbastanza banale una volta che io ho il controllo di una botnet in quel caso l'obiettivo era il denaro service ok in tanti altri casi gli obiettivi a cui li abbiamo accennati sono diversi sfruttare la capacità dei calcoli di dispositivi quando questi ce l'hanno ad esempio a scopo di mining o cose di questo genere oppure vabbè qui ho citato spamming oppure le injection in questo caso ho citato l'injection sui browser o situazioni di questo genere furto di informazioni e quant'altro però diciamo che un motivo fondamentale per mettere insieme una rete di tanti dispositivi sono legati allo sfruttamento delle risorse di calcolo della rete che metto insieme e di conseguenza nella capacità di condurre attacchi di tipo denaro o service significativi perché lì quello che serve appunto sono risorse risorse di calco ora entrando un po' più nel dettaglio su quelle che sono le strategie per difendere il perimetro di sicurezza le tre cose fondamentali che bisogna fare su cui poi entriamo un po' più nel dettaglio sono da un lato la protezione dell'identità degli utenti ieri abbiamo detto che il perimetro di sicurezza è sfumato perché i diversi punti di accesso al perimetro sono rappresentati fondamentalmente dalle credenziali degli utenti quindi proteggere l'identità degli utenti è importante perché di riflesso significa proteggere il perimetro e tra i tanti modi per proteggere l'identità dell'utente sicuramente quelli più importanti sono relativi alle policy per la gestione delle credenziali di accesso in particolare delle password e questo probabilmente da qualche anno a questa parte lo state sperimentando anche voi perché le policy di scelta delle password sono sempre più complicate adesso qualunque sistema qualunque provider di servizi su cui voi avete un account ha dei requisiti che sono sempre più stringenti sul numero di caratteri che devono comporre la password tipologia di caratteri che devono comporre la password durata della password in certi casi vi obbligano a cambiarla ogni sei mesi sono tutte policy queste mirate naturalmente a irrobustire in questo caso le credenziali di accesso questo perché perché come poi ne discutevamo anche nelle scorse lezioni vogliamo aumentare il livello del parametro lambda che stabilisce la sicurezza del sistema e siccome le risorse di disposizione dell'avversario aumentano di conseguenza deve aumentare la robustezza dei sistemi che mettiamo in piego e il discorso che facevamo sulla lunghezza delle chiavi per i cifrari va in uno stesso modo per quanto riguarda le passwords più avanti tratteremo in maniera dettagliata i protocolli che servono che vengono usati per permettere ad un utente di autenticarsi tramite password come questi funzionano e quali sono le vulnerabilità di questo tipo di protocollo ok al di là del discorso legato banalmente alle password ci sono altri elementi che sono importanti per la protezione dell'identità dell'utente e che queste può e dell'impatto che questa può avere naturalmente sulla difesa del perimetro uno di questi sicuramente sono dato dalle policy relative all'autenticazione come un utente si autentica e anche qui le policy diciamo che si stanno evolvendo in maniera sempre più sofisticata in molti sistemi non è più sufficiente una autenticazione a singolo fattore dove il singolo fattore è che ne so la password piuttosto che è un'impronta digitale ma si usano sistemi multifattore dove si combinano più di questi elementi che ne so contemporaneamente l'utente è obbligato sia a presentare una password ma al tempo stesso a usare un codice one time tipo one time pensate ai sistemi di autenticazione che usano molti sistemi bancari adesso voi vi autenticate con le credenziali poi però vi arriva un messaggio tramite l'app se avete l'app installata sul telefono un sms o qualunque altro canale che vi chiede di inserire una one time password di un OTP come secondo fattore di autenticazione spesso questo è combinato con l'impronta digitale piuttosto che quello che no no no non c'entra niente in quel caso OTP significa one time password cioè una stringa che viene usata una volta sola one time invece l'OTP che abbiamo visto noi è il one time pen quindi l'autenticazione anche qui si sta evolvendo sempre più da questo punto di vista poi che cosa abbiamo abbiamo i meccanismi di autorizzazione cosa significa questo non basta che l'utente si autentichi per avere accesso a un sistema una volta che l'utente si è autenticato ha dimostrato la propria identità per avere l'accesso al sistema bisogna verificare quali sono i livelli di autorizzazione che questo utente ha quando chiede di effettuare determinati tipi di operazioni ok cosa può fare l'utente questa è la è la domanda e qui le politiche di autorizzazione sono diciamo estremamente variegate in letteratura diciamo che la branca di di di di ricerca che si occupa di queste tematiche prende il nome di access control quindi tutte le politiche di autorizzazione sono legate ai meccanismi di access control controllo degli accessi ovvero quei meccanismi che verificano qual è il livello di utilizzazione di un utente pensate ad esempio nel caso di linux al fatto che ogni utente oltre ad avere le credenziali di accesso può poi ha dei diritti a delle autorizzazioni sul sistema banalmente pensate all'accesso al file system quindi sui dati l'utente può avere diritti da proprietario può avere diritti di un certo gruppo oppure può avere diritti generici che stabiliscono cosa può fare su un certo file un utente che non è né proprietario né appartenente a uno specifico gruppo ok quello è un esempio banale di policy di gestione delle autorizzazioni e infine questo l'avevo già accenato ieri è importante curare anche l'aspetto relativo al controllo delle attività svolte dall'utente quindi anche qui non basta più che un utente sia riconosciuto gli sia data gli sia gli sia data l'autorizzazione a operare una certa operazione su sua richiesta perché perché le politiche di access control stabiliscono che l'utente A può fare l'operazione B sulla risorsa C ok e fin qui ci siamo bisogna anche verificare monitorare costantemente il comportamento dell'utente perché perché in certi contesti il comportamento dell'utente può svelare delle potenziali minacce di questo parleremo più avanti vi faccio un esempio banale avete un utente che si autentica correttamente chiede di scrivere un file ha il diritto di farlo però guarda caso quest'operazione la sta facendo da un host che è diverso rispetto a quello che usa comunemente perché si trova da un'altra parte lo sta facendo il sabato alle due di notte no e chiaramente è un contesto sospetto no e quindi non ripeto non ci si deve limitare a verificare le policy di autenticazione e autorizzazione ma bisogna anche monitorare l'ambiente il contesto in cui queste attività vengono svolte per ad esempio determinare se sono richieste attività anomale rispetto alla prossima rispetto a quello che succede comunemente adesso vi ho fatto un esempio forzato limite però ci sono tante situazioni in cui non è banale stabilire se ciò che sta accadendo è anomalo oppure no anche qui ci sono tutta una serie di tecniche di accounting che permettono di verificare monitorare cosa sta o cos'è successo in modo tale da stabilire se è il caso o meno di ad esempio sollevare un allarme perché? Perché si ritene che sta succedendo qualcosa di strano quindi da una parte meccanismi per rivolti al controllo alla gestione dell'identità dell'utente perché? Perché l'identità dell'utente è uno dei punti di accesso al sistema gli altri aspetti invece riguardano sicuramente la protezione dei dati quindi utenti da una parte dati dall'altra e i dati vanno protetti principalmente rispetto a due proprietà la segretezza o confidenzialità sono sinonimi e l'integrità ok? Abbiamo cominciato a studiare meccanismi per garantire la confidenzialità quindi i cifrai di Shannon in generale i cifrai a flusso finora in particolare studieremo meccanismi anche per garantire l'integrità proprietà che devono essere garantite sia in fase di di di storing quindi i dati che risiedono in memoria ma anche in transito quando questi vengono trasmessi e questo indipendentemente dal fatto che risiedano questi dati localmente in azienda quindi on premise oppure risiedono su altri provider nel cloud ok? il terzo punto invece riguarda il controllo del software quindi le tre classi fondamentali sono l'utente i dati e il software controllare il software ovvio perché l'esempio tipico devo garantire che il mio software non contenga dei virus non sia diventato un malicious bot e così di questo genere sia che si tratti di software in casa dentro l'azienda sia che si tratti di software invece fornito as a service quindi queste sono le tre macro aree rispetto alle quali dobbiamo garantire la sicurezza ora come si fa a verificare che tutti i meccanismi messi in atto per garantire la sicurezza dal punto di vista dell'utente dei dati e del software sono efficaci ed efficienti come si fa a fare verifica delle proprietà di sicurezza l'approccio che si usa è quello del dei team del red e blue team è un approccio anche questo come al solito è basato sulla teoria dei giochi noi abbiamo due squadre che competono con obiettivi con obiettivi opposti ok abbiamo un red team la squadra rossa in cui obiettivo è quello che vedete qua ovvero trovare le vulnerabilità intorno al sistema se ci sono vulnerabilità che possono riguardare l'utente il modo in cui sono gestiti i dati o i software che vengono utilizzati per accedere ai dati ok e trovare queste vulnerabilità l'attività di ricerca delle vulnerabilità prende il nome di pen testing penetration testing vedremo un po' di cose su questo e possibilmente riuscire a sfruttare queste vulnerabilità per accedere illecitamente agli asset che vale la pena compromettere ok di solito una volta trovate le vulnerabilità il red team che cosa fa crea o sfrutta un exploit già esistente capace appunto di sfruttare la vulnerabilità per ottenere l'accesso di cui parlavamo che cos'è un exploit qualunque cosa che appunto permetta ad un intruder di un avversario di sfruttare la vulnerabilità può essere un software può essere un exploit un malware può essere un exploit una sequenza di dati può essere un exploit dei comandi possono essere un exploit non esiste una definizione univoca di che cosa sia un exploit qualunque strumento utile per sfruttare una vulnerabilità che permetta di accedere in maniera illecita al sistema per verificare l'efficienza del red team ci sono delle metriche che vanno a misurare quanto appunto da un punto di vista prestazionale il red team è bravo a mettere in atto degli attacchi basati sulle vulnerabilità individuate di solito quelli tipi che sono il tempo medio che il red team ci mette per bucare il sistema o per arrivare agli asset che sono il suo obiettivo contrapposto al red team c'è il blue team il blue team ha l'obiettivo opposto rispetto al red team ovvero quello di proteggere il sistema ok naturalmente per proteggere il sistema il blue team deve mettere in atto tutta una serie di soluzioni meccanismi il proiettivo il proiettivo il proiettivo è quello di prevenire gli attacchi o quando questi sono inevitabili rispondere nella maniera più efficace possibile anche in questo caso per misurare il valore del blue team ci sono delle metriche come ad esempio il tempo medio necessario per rilevare rilevare un attacco o il tempo necessario per ripristinare il sistema dopo l'attacco e cose di questo genere ok quindi questo tipo di approccio che risale a idee che vengono dall'ambito militare nasce direi durante la seconda mara mondiale quando si facevano le simulazioni all'epoca di come si potevano eventualmente svolgere i fatti in campo di battaglia quindi lì si cercava di simulare le mosse del nemico il red team e di neutralizzarle utilizzando le proprie risorse cioè il blue team questo tipo di approccio è stato parafrasato e adattato al contesto della cyber security ed è sulla base di questo approccio che al giorno d'oggi funzionano un po' i sistemi di verifica delle proprietà di sicurezza perché all'interno di un'azienda avrete una parte dei servizi ICT che si occupano della messa in atto degli strumenti di difesa e loro sono il blue team dopodiché sempre loro o preferibilmente altri per evitare qualunque tipo di bias sono ingaggiati per realizzare il red team cioè coloro che cercano di bucare il sistema spesso e volentieri all'interno del blue team si utilizzano approcci analoghi ai quali del red team proprio per simulare potenziali attacchi quindi all'interno del blue team spesso e volentieri ad esempio si fa pen testing per verificare che il sistema che si è messo in atto sia sicuro lo si fa internamente o a volte spesso più volentieri lo si demanda in outsourcing ad aziende specializzate ok ci sono aziende che per lavoro fanno pen testing sulle aziende che richiedono questo tipo di servizi viene firmato un accordo viene stipulato un contratto in cui l'azienda committente autorizza per un lasso di tempo la chi fa il penetration testing a cercare di bucare il sistema perché senza quel contratto le attività di chi fa il pen testing sarebbero illegali ok quindi si firma un contratto in cui si dice dal giorno X al giorno Y tu sei autorizzato a cercare di in tutti i modi che tu ritieni opportuno sei autorizzato a cercare di bucare il mio sistema purché tu non faccia dei danni irreversibili purché tu non sfrutti tutte le conoscenze che acquisisci in questi tentativi portando fuori le informazioni e quindi usando il tuo vantaggio pubblicandole quindi tutta una serie di clausole che servono appunto per tutelare il per tutelare il committente ok questo lo dico perché mi raccomando sempre quando vi farò vedere gli esempi di questo genere qua e quando parleremo di progetto eventualmente se qualcuno volesse fare un progetto legato al pen testing sono sempre situazioni ricreati in un ambiente virtuale ok perché qualunque attività legata al pen testing anche solo fare attività come vedremo di scanning e di interrogazione di porte per vedere se su un certo server sono attivi certi servizi e verificare quali sono le configurazioni operazioni di questo genere quindi operazioni passive sono comunque operazioni illegali ok quindi nel mondo reale queste cose non si fanno no qualunque esercizio che vi mostrerò è un qualcosa ricreato in un contesto virtuale ok e quindi questo vale anche per le cose che farete voi quindi non sognatevi di pensare di provare nessuna delle tecniche che vedremo anche così solo per gioco su internet nei confronti di un qualunque di un qualunque server perché è una cosa che non non si può fare e ora come dicevo prima vediamo se riesco a arrivare alla fine vediamo anche ad esempio le attività del blue team chiaramente non danno una garanzia totale di sicurezza bisogna sempre prevedere che si possono verificare degli incidenti di sicurezza indipendentemente dal tipo di investimenti che il blue team fa e quindi una delle cose più importanti su cui accenderemo qualcosa consiste nel definire correttamente un processo di risposta agli incidenti dopo vi faccio vedere un esempio cioè una specie di protocollo che stabilisce come vanno gestiti gli incidenti di sicurezza o i potenziali incidenti di sicurezza perché io delle volte non ho la garanzia del fatto che si stia verificando un attacco magari ci sono degli indizi che fanno sembrare che ci sia un attacco in corso poi alla fine salta fuori che non lo è ok quindi in ogni caso si deve prevedere un processo che consenta di stabilire in maniera diciamo più rigorosa possibile come il blue team si deve comportare quando ci sono tutti gli indizi che fanno pensare che ci sia un attacco in corso ok in questo processo chiaramente bisognerà stabilire innanzitutto quali tipi di asset devono essere coinvolti sono potenzialmente associati all'incidente bisogna stabilire chi viene coinvolto da questo processo chi è responsabile di cosa in genere bisogna stabilire anche quelle che sono le priorità perché gli incidenti possono verificarsi contemporaneamente allora bisogna stabilire qual è l'urgenza con cui un certo incidente deve essere affrontato un altro invece no e anche questo è molto importante bisogna stabilire se è necessario interagire con degli stakeholder esterni all'azienda quando si verifica un incidente la legge ci impone dei vincoli da questo punto di vista se l'azienda viene bucata e perde informazioni sensibili che riguardano che ne so il database dei clienti o dei fornitori l'azienda ha l'obbligo di informare gli stakeholder esterni che sono coinvolti ok questo per legge è obbligatorio quindi tutta una serie di attività che ricomprendono quello che possiamo chiamare appunto un ciclo di vita dell'incidente che va da quando io individuo i primi sintomi fino ad arrivare ai feedback finali che io ottengo dopo aver analizzato aver risposto aver mitigato gli effetti dell'incidente possibilmente naturalizzato l'attacco è fatto un risoconto di tutte le attività che sono state messe in atto per risuono quindi il ciclo di vita dell'incidente va parte da quando da poco dopo che nasce l'incidente perché delle volte non lo individuo immediatamente fino ad arrivare al momento in cui io l'incidente lo chiudo perché l'ho già risolto è già stato documentato tutto quanto vi faccio un esempio estremamente semplice di che cosa significa gestire il ciclo di vita di un incidente di sicurezza prendete questa timeline ok all'inizio della timeline tutto sta funzionando come previsto il sistema sta lavorando correttamente senza anomalie ok già qui si apre una questione che cosa significa che il sistema sta funzionando correttamente senza anomalie e che non c'è nulla di diverso dal solito questa è la prima domanda che ci possiamo porre che è importante no per sapere che nulla di anomalo è in corso io devo avere una definizione chiara di che cosa è normale di che cosa è previsto ok io le anomalie le identifico solamente se so qual è invece il comportamento non anomalo e qui ci sono tutta una serie di strumenti che vi accenderò che servono proprio a questo distinguere i comportamenti usuali rispetto a quelli inusuali poi supponiamo che a un certo punto si verifichi un evento che è questo un utente apre una mail sospetta ok qui ci dobbiamo fare un'altra domanda abbiamo fatto tutto il possibile per evitare che eventi di questo genere si possano verificare abbiamo fatto training di tutti gli utenti li abbiamo messi in guardia rispetto ai pericoli legati in questo caso all'apertura di mail sospetta quindi rendere consapevole di tutti gli utenti dei rischi negativi e sicurezza è un aspetto importante che va tenuto in conto nei processi di cui parlavamo prima ora il fatto che l'utente in un certo momento apre una mail sospetta non solleva subito un incidente magari non succede niente in quel momento ok magari perché l'utente non si accorge neanche che la mail sospetta magari perché non c'è nessun effetto immediato no magari l'incidente sta già nascendo ma io ancora non me ne sono accorto c'è una latenza un tempo che va dal momento in cui succede qualcosa di critico al momento in cui io me ne accorgo è chiaro che più lunga è questo tempo è peggio stato le cose no perché nell'arco di questo di questo di questo tempo possono succedere altre cose che vedremo no ora quindi per un certo lasso di tempo non succede nulla i sensori non rilevano nulla di anomalo qualunque cosa sia di sensori naturalmente poi a un certo punto è chiaro che e questo succede normalmente dobbiamo assumere che esista sempre una latenza dal momento in cui qualcosa di critico accade al momento in cui ce ne accorgiamo perché perché i sistemi di protezione che abbiamo non saranno mai omnicomprensivi non copriranno mai tutti i casi possibili ok possiamo cercare di minimizzare questa latenza ma non la ridurremo mai a zero quando è che magari in questo caso ci accorgiamo di qualcosa di anomalo ad esempio a un certo punto lo stesso utente che avevano perte la mail sospetta dopo un po' di tempo si accorge che non riesce più ad autenticarsi con le proprie credenziali ok qua magari non c'era nessun motivo di preoccuparsi al passo 2 al passo 4 invece c'è l'utente che non riesce più a fare il proprio lavoro e che cosa fa l'utente in questo caso? a chi riporta l'anomalia ai servizi ICT gli dice oh io non riesco più ad autenticarmi ok non è ancora un incidente questo è un potenziale incidente però va gestito seguendo il processo di cui parlavamo prima ci deve essere un protocollo per cui l'utente apre un ticket qualcuno responsabile dei servizi ICT deve fare qualcosa innanzitutto per capire di che cosa stiamo parlando è un problema di sicurezza questo oppure no ancora non lo sappiamo magari l'utente ha dimenticato l'apposso quindi non è non è un incidente reale quindi inizia una fase qui indicata col 5 in cui per la prima volta chi si occupa di cyber security analizza il caso quindi no e questa latenza si assomma quella precedente i tempi si allungano ulteriormente ok nella stragrande maggioranza dei casi i sospetti incidenti in realtà non lo sono non solo in questo esempio in cui interviene il fattore umano anche gli esempi dove sono i software che identificano le anomalie e poi le classificano come incidenti oppure no ok quindi anche in quel caso spesso volentieri i sintomi di un incidente svaporano e non danno luogo a nessuna conseguenza perché perché non si trattava di incidenti reali ok poi invece torniamo al nostro caso magari salta fuori che si tratta veramente di un incidente no come facciamo ad accorgersene perché a un certo punto vengono messi in atto tutta una serie di controlli di verifiche per cui trovo degli indizi che messi insieme formano una prova allora scopro che l'utente aveva aperto una mail che conteneva un allegato vado ad esaminare quello che è successo e mi accorgo che l'allegato conteneva un malware allora lì ho la prova del fatto che si è verificato un incidente attraverso quel malware poi magari l'intrudere è riuscito a penetrare il sistema ha cambiato le credenziali dell'utente ha fatto altre cose quali sono da scoprire perché una volta che l'attaccante penetra il sistema poi non è che si ferma lì comincia a muoversi all'interno del sistema è una cosa che andremo a esaminare in dettaglio una volta identificato l'incidente la fonte come si è manifestato l'incidente che vettore ha utilizzato lo devo isolare lo devo contenere lo devo neutralizzare ok e una volta neutralizzato quindi sono sicuro che non è più attivo devo ripristinare il sistema a un funzionamento corretto quindi se possibile recuperare i dati consumati persi le funzionalità compromesse e via dicendo dopodiché cosa devo fare mettere le toffe là dove mi sono accorto che non c'erano in questo caso il problema che potrebbe essere stato la mancanza di training dell'utente bene che cosa faccio metto su un corso di aggiornamento per tutti gli utenti se invece la falla dipendeva non dalla manchevolezza dell'utente ma dipendeva da un software non aggiornato bene installo la patch e così via quindi faccio tutte quelle attività che fanno sì che quello stesso incidente non si verifichi più in futuro quindi imparo dall'incidente che ho subito per far sì che in futuro non si verifichi non si verifichi più ok e documento il tutto in modo tale che diventi storico proprio per favorire questo tipo di apprendimento continuo e questo è un esempio noi dalla prossima volta vedremo quali sono nel dettaglio tutte le fasi che consentono a un avversario di realizzare un attacco come quello descritto qui quindi il punto di vista del red team quindi come l'attaccante prepara l'incidente prepara l'attacco cercando le vulnerabilità creando un vettore d'attacco penetrando il sistema spostandosi nel sistema fino a che non arriva agli asset che gli interessano questo è il punto di vista del red team dall'altra parte chi c'è? dall'altra parte c'è il blue team quindi vedremo quali sono gli strumenti che il blue team ha a disposizione per cercare di ridurre il più possibile tutte le latenze i tempi morti che ci sono in questa timeline e che danno il respiro all'attaccante chiaramente più lunghe sono queste latenze più tempo si dà all'attaccante di fare dei danni ok? non possiamo sperare di arrivare a una situazione in cui l'evento critico non si verifica mai quello è impossibile però possiamo cercare di minimizzare gli effetti che un evento critico può avere sul sistema quello è ok? e quindi vedremo nel dettaglio dai due punti di vista che cosa significa mettere in piedi l'attacco e dall'altra cosa significa cercare di evitarlo va bene direi che per oggi ci possiamo fermare se non ci sono domande a Grazie.