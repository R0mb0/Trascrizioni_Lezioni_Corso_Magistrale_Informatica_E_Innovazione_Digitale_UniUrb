bene allora la settimana scorsa abbiamo visto come funzionano in diverse varianti i protocolli di autenticata di key exchange quindi protocolli che hanno come obiettivo quello di garantire l'autenticazione e la confidenzialità ok l'esempio che mi mostro oggi quello diciamo principale in ambito dei protocolli di questo genere implementati utilizzati nella pratica ovvero tls di cui abbiamo già parlato qualche tempo fa in particolare riferendoci al record protocol di tls ovvero come viene gestita la vpn che viene creata attraverso tls quindi come viene gestita l'autenticata di encryption attraverso la modalità paradigma dell'encrypte mac prima di questo c'è la fase di autenticata di key exchange ovvero quella fase in cui le due parti si devono riconoscere ok e mettersi d'accordo sul valore della chiave condivisa che verrà utilizzata per implementare l'autenticata di che dell'encryption quindi quello che vedremo adesso è il modo in cui ispirandosi ai protocolli che abbiamo visto settimana scorsa tls gestisce la fase iniziale di autenticazione ok useremo un po di notazioni che saranno chiare man mano assumeremo come al solito di avere un'autenticazione tra un agente p che di solito rappresenta il client e un agente q che invece rappresenta il server vedremo che all'interno del protocollo si fa uso di diverse primitive criptografiche si utilizza uno schema di cifratura la chiave simmetrica che indicheremo rispettivamente con es ds gli algoritmi di encryption e decryption verrà utilizzato mac per le segnature delle informazioni quindi la creazione dei tag per l'integrità e naturalmente si utilizzeranno le firme le firme digitali e l'end shake che di tls che consente di realizzare l'attenticazione di chi exchange inizia con il client p che invia una richiesta al server al server q la richiesta è un pochino più dettagliata rispetto a quanto abbiamo visto la settimana la settimana scorsa in particolare nella richiesta è compreso un valore randomico non valore casuale scelto scelto scelto da p che è questo n dc e più altre informazioni che servono per negoziare per mettersi d'accordo sul su come deve avvenire l'end shake su ad esempio quali primitive criptografiche quali schemi utilizzare per la fase di autenticazione si utilizzano all'interno di tls le operazioni tipiche di di fielman quindi si ragiona su un gruppo ciclico di i valori generati da un generatore g in particolare nella richiesta che p manda q vedete che compare un po come avviene tipicamente nel protocollo di fielman viene inviato g alla alfa dove la alfa un valore casuale scelto da p e mantenuto segreto da p quindi p invia g alla alfa noi sappiamo in virtù della assunzione relativa al problema dell'organismo discreto che un osservatore un avversario che vede passare g alla alfa non non è in grado di dedurre informazioni relative ad alfa che quindi rimane segreto e quindi vedete appunto che nella richiesta compaiono vengono trasmessi g alla alfa il valore randomico il non più tutta un'altra serie di informazioni che riguarda il modo in cui p offre a q di gestire l'end shake in particolare quali schemi crittografici utilizzare in particolare informazioni ad esempio relative al gruppo ciclico che p qui p fa riferimento in cui in particolare si deve riferire per interpretare g alla alfa ok quindi nell'offerta ci saranno informazioni relative a chi è il generatore g quindi qual è il gruppo ciclico ok ci saranno informazioni su quali schemi quali primitive criptografiche p intende usare per l'end shake perché tls è un protocollo che permette l'utilizzo di diverse funzioni crittografiche ok quindi in pratica l'offerta è un riassunto della della proposta che p fa a q relativamente agli strumenti da utilizzare per cifrare le le informazioni che diciamo che ai fini ai fini ai fini del shake qui quello che ci interessa è il valore randomico e la e la e g alla alfa che servirà appunto per la ciprica le reciproche identificazione come vedremo q riceve l'offerta e risponde in maniera direi simmetrica perché a sua volta sceglie un valore beta e trasmette al client g alla beta ok quindi esattamente come nel classico protocollo di di fielman abbiamo da una parte p che una parte p che conosce alfa e non lo diffonde nessuno dall'altra q che conosce beta e non lo diffonde nessuno p manda g alla alfa e q risponde con g alla beta quindi se vi ricordate questo è esattamente il classico and shake di di di fielman in più abbiamo detto che insieme a g alla alfa p manda un valore randomico un nonce lato client e il server risponde a sua volta con un nonce lato server ok quindi ciascuno ciascuno dei due sceglie un valore randomico gli altri metadati che qui sono rappresentati da questo mod rappresentano i parametri che sceglie il di adottare il server in risposta all'offerta che ha fatto il client che i parametri che ad esempio servono per stabilire come deve essere usato il cifraria chiave simmetrica o il mac che verranno utilizzati nel resto del del shake ok quindi p fa un'offerta gli dice va bene usiamo a s 128 usiamo h mac oppure usiamo qualcos'altro e corrisponde va bene usiamo questi con questi parametri ok quindi c'è un agreement tra p e q iniziale relativamente alle alle scelte sugli schemi da utilizzare come parametrizzarli mentre invece le informazioni specifiche che servono per il proseguio della del shake sono appunto g l'alfa non soggiora beta un altro nonso ok ora da questo momento in avanti inizia un l shake protetto tra tra p e q protetto nel senso che tutto ciò che viene trasmesso viene viene cifrato usando un cifrario a chiave simmetrica esempio a s 128 e usando chiavi simmetriche che derivano dalle informazioni che p e e q si sono scambiate e dal fatto che p e q in questo momento condividono un'informazione che nessun altro conosce e questa informazione se lo dice di fi elman protocollo di fi elman è g alla alfa beta g alla alfa beta è un'informazione segreta che solo p e q sono in grado di calcolare p lo può calcolare in questa maniera e q invece lo può calcolare in questa maniera essendo alfa e beta segreti noti solo a p alfa p e beta q nessun altro può fare questo tipo di calcolo ok e per la solita assunzione di fi elman computazionale un avversario che ve che conosce solamente g al alfa e g alla beta non è in grado di calcolare g al alfa beta quindi g al alfa beta è un segreto che solo p e q condividono questo è importante perché perché utilizzando questa informazione g al alfa beta nota solo a p e q concatenata con tutte le altre informazioni che p e q si sono scambiati in questo primissimo handshake ebbene la concatenazione di tutte queste informazioni viene usata come input ad una primitiva uno schema che abbiamo già visto in passato che hkdf se vi ricordate hkdf no è quello schema che a partire da chiamiamolo seme password o comunque a partire da un'informazione segreta deriva no in maniera pseudo casuale chiaramente agli occhi di un osservatore esterno una una stringa molto più lunga rispetto al seme da cui siamo partiti quindi in maniera analoga quanto fanno i prg e chiaramente solo p e q sono in grado di calcolarsi l'output di hkdf con questo input e questo ce lo garantisce la presenza nell'input di g al alfa beta ok in particolare visto che l'output di hkdf come abbiamo visto in passato stringa molto lunga che può essere poi spezzata ogni porzione dell'output può essere utilizzata con finalità diverse quindi in particolare ad esempio le prime due porzioni dell'output di k hkdf vengono usate come chiave chiavi simmetriche di uno schema di cifratura ok da notare che le comunicazioni che vanno da p verso q vengono cifrate con una chiave mentre le comunicazioni che vanno da q verso p vengono cifrate con un'altra chiave quindi le ho chiamate ksh e ksm ok queste due diverse chiavi vengono usate per le due diverse direzioni di comunicazione ok dopodiché da qui in avanti avviene parte un head shake cifrato tra p e q cifrato perché tls vuole privilegiare la privacy del degli utenti che stanno dialogando e quindi in particolare anche i certificati che p e q si scambiano vengono cifrati ok come nell'ultima versione del protocollo che abbiamo visto la settimana scorsa parte p con il primo messaggio dell'end shake primo messaggio che comprende diversi ciphertext che è quell'elenco di quattro ciphertext che vedete e che sono tutti come vedete ottenuti usando come chiave di cifratura la prima parte della stringa risultante dall'applicazione di hkdf ok quindi quella ksh tutte cifrature fatte con questa chiave che p e q condividono ora primo passo fondamentale se l'authenticated key exchange prevede la mutua authenticazione quindi sia di p che di q primo passo fondamentale p deve dimostrare la propria come vedremo la propria identità no questo abbiamo visto anche settimana scorsa ciò avviene trasmettendo il certificato ok da ricordare che questa questo ciphertext viene inviato solamente nel caso di mutua autenticazione cioè se sia p che q si devono autenticare reciprocamente tramite certificato ok e dove siamo arrivati ok scusate quindi siamo al primo ciphertext no persona detta male c1 è generato da q è generato da q e questa è la richiesta che q manda a p ho fatto confusione è la richiesta che comanda a p di avere di avere di ricevere il certificato se siamo in regime di mutua autenticazione ho fatto confusione il secondo ciphertext è il certificato di q no quindi q tipicamente si autentica sempre è il server quindi server ha sempre il certificato e quindi lato suo l'autenticazione avviene in ogni caso non è detto che invece avvenga lato due al lato client quindi q manda al client p il proprio certificato cifrato e poi per dimostrare di essere q manda una firma anche questa cifrata anche in questo caso di nuovo sempre per motivazioni legate alla privacy questa firma la vedete dentro c3 dove c3 ok dove quindi di nuovo c3 è un ciphertext generato usando la solita chiave di sessione e cifratura di che cosa? della firma digitale fatta da q con la propria chiave segreta di che cosa? beh di tutte le informazioni che sono state generate fino a quel momento tutto quello che tutto quello che p e q si sono già scambiati viene firmato da da q ok? e questo unitamente a c2 servirà per garantire l'autenticazione di q a p perché perché chiaramente poi vedremo che quando p riceve questi questi ciphertext aprirà il certificato di q andrà a vedere qual è la chiave di verifica di q e questo gli permetterà di verificare la firma fatta da q su tutti i dati che si sono scambiati in quel momento perché fino a questo momento p potrebbe aver parlato con chiunque ok? è solo nel momento in cui p riceve da q la firma sulle informazioni già scambiate che p avrà la garanzia di autenticazione e c4 invece di nuovo è un altro ciphertext vedete tutto quanto viene cifrato il motivo per cifrare tutto quanto ripeto è legato alla privacy e di q e non ad altro non sono motivi legati alla confidenzialità o all'autenticazione ma solo per garantire la privacy e il quarto ciphertext è la cifratura di che cosa? beh è la cifratura di un tag di un tag creato dal server usando un mac a chiave simmetrica la cui chiave di nuovo deriva dall'applicazione di hkdf come abbiamo visto prima e quindi questa funzione s che vedete qui è la funzione di segnatura del mac no? e questa che vedete qui invece è la chiave usata per fare la segnatura per creare il tag e di che cosa? di nuovo di tutto quello che è stato creato e scambiato fino a quel momento ok? a cosa serve questa segnatura? beh è una prova di integrità ok? quindi con questi quattro ciphertext tu cosa sta facendo? sta in prima battuta eventualmente chiedendo a chi di esibire il certificato se stanno in prima battuta mi sta mandando e e e e e e e e e e e e e e se è e Grazie. Grazie. Grazie. Grazie. Ok, va bene, grazie. Perfetto. Benissimo, allora riprendiamo. Quindi stavo dicendo che con questi, riassumo, con questi quattro ciphertext Q sta eventualmente, se necessario, chiedendo a P di esibire il suo certificato. Sta inviando a P il proprio certificato, sta inviando a P la propria firma su tutte le informazioni scambiate o prodotte fino a quel momento e sta inviando a P un tag creato con un Mac a garanzia dell'integrità di tutte le informazioni prodotte fino a quel momento. Tutto questo viene trasmesso, ripeto, cifrato usando uno schema di cifratura a chiave simmetrica, quello che è stato negoziato nel primissimo Elshake, e utilizzando come chiave di cifratura un valore che è di fatto estratto, una stringa che è estratta dall'output di HKDF. Ok? Che è stato generato a partire da un input che contiene chiave alfa beta. E questo... Ci sono anche tutte le altre informazioni proprio perché... Per ulteriore garanzia del fatto che P e Q, no? Condividono esattamente queste informazioni e queste non sono state modificate da... Da un avversario attivo. Perché se un avversario attivo provasse a violare l'integrità di primissimi due messaggi che P e Q si scambiano, che sono messaggi in chiaro, ecco che P e Q se ne accorgerebbero subito perché non riuscirebbero poi a dialogare. Dato che applicando HKDF otterrebbero stringhe diverse, quindi chiavi diverse e quindi P e Q non riuscirebbero a dialogare. Sarebbe... L'attacco di questo genere da parte di un avversario avrebbe effetto solo come attacco di tipo denial of service, ma non sarebbe un attacco che andrebbe a minare o a compromettere nessuna delle proprietà che abbiamo appena detto. Ok. Ok. Allora, allora... No, Q non firma KSM... Allora, KSM... È la chiave... È la chiave... No, KSM è la chiave per il MAC. Per il MAC. Qui è quel S. S è la funzione di segnatura del MAC. Ok. Quindi... KSM è la chiave per il MAC. No, allora... Se ho detto... No, potremmo essere che l'ha detto io e mi sono sbagliato. No, no. Se... È la chiave del MAC. Sì, sì. No, potremmo essere che mi sia scappato di dire una cosa del genere, ma... Mi sono sbagliato io. Quindi KSM è la chiave del MAC. KSH è la chiave del cifrario. La chiave simmetrica. Quindi, ad esempio, se P e Q hanno negoziato AS128 e HMAC, basato su SHA, è KSM. KSH e KSM, da dove arrivano? Arrivano dall'output di HKDF. E quindi entrambi le conosco. Ok. Ripeto, se un avversario facesse un attacco di tipo man in the middle, ok? Impersonando Q. E all'inizio potrebbe farlo, perché P manda G alla alfa, nonso, e l'offerta. L'avversario si comporta come man in the middle, quindi magari intercetta la risposta di Q, la sostituisce, e manda a P un G alla beta che ha scelto lui, un OSC che ha scelto lui e gli risponde con il mod. Ok? E quindi fino a quel momento P sarebbe portato a credere di condividere G alla alfa, beta, con Q, con Q invece la condivide con l'avversario. Però l'attacco non può andare oltre, perché a questo punto l'avversario cosa dovrebbe fare? Dovrebbe mandare, usando una chiave che conosce, perché KSH a questo punto l'avversario la conosce, perché è lui che ha deciso G alla beta, quindi conoscerebbe sia KSH che KSM. Il problema è il contenuto, perché è vero che C1 e C2 li può generare l'avversario, ma non può generare C3. Ok? Non può generare C3 perché non è in grado di firmare digitalmente tutte quelle informazioni. E qui capiamo il motivo per cui dentro la firma digitale di Q, vedete, ci sono tutte le informazioni che i due si sono già scambiati. Quindi un avversario non potrebbe neanche fare un attacco di tipo replay, cioè andare a prendere, che ne so, una vecchia sessione fatta legittima da P e da Q, per qualche motivo recuperare una firma digitale, e però non sarebbe quella che gli serve, perché la firma, vedete, riguarda informazioni di questa sessione. Ok? Quindi i replay attack non possono funzionare. Mentre invece potrebbe generare C4. Ok? Un avversario che si è comportato come man in the middle, C4 la può generare. No, questo senza dubbio. È C3 che non può generare. Quindi vedete, ogni cypher text ha il suo ruolo importante. Quindi C3 garantisce, dà la prova di autenticazione, C4 una prova di integrità. Ok? Ok? Quindi P riceve questi messaggi, fa le verifiche del caso, quindi in particolare verifica il certificato di Q, usando la chiave di verifica, la chiave pubblica presente nel certificato, fa il check sulla firma digitale che è dentro C3. Se tutto va bene, la prova di autenticazione è accettata da P, tutto è integro, posto naturalmente di nuovo che la verifica fatta sul tag di C4 abbia successo e quindi a questo punto del handshake P è convinto di parlare con il server legittimo. Quindi deve rispondere. Deve rispondere in che maniera? Beh, inviando il proprio certificato se richiesto, quindi se l'autenticazione deve essere mutua oppure no. Nel caso in cui anche il client mandi il certificato, ovviamente insieme al certificato poi manderà, e lo vediamo in C6, una propria firma di tutte le informazioni che sono state scambiate e prodotte fino a quel momento. Notate che per la cifratura, per generare i ciphertext, P usa chiavi diverse rispetto a quelle che ha usato Q, quello che dicevo prima. Quindi mentre prima avevamo una coppia di chiavi per la cifratura simmetrica e per il MAC lato server, lato client invece se ne usano altre due. che sono queste. Questa per la cifratura e questa per il MAC. Anche queste derivano, esattamente come le altre due, dall'output di HKDF, quindi sono note a entrambi. Quindi se siamo in regime di doppia mutua autenticazione, P manda il proprio certificato e la propria firma a Q, in maniera analoga a quanto aveva già fatto il server, e l'ultimo ciphertext, C7 invece, che cos'è? È semplicemente un tag cifrato di tutte le informazioni che sono state scambiate fino a quel momento. C7 è l'unica, vedete, obbligatoria. Quindi se siamo nel caso della one side authentication, quindi solo il Q, solo il server si deve autenticare, P invece no, la risposta di P consiste semplicemente in C7, che è la prova di integrità di tutte le informazioni che i due si sono scambiati fino a quel momento. Ok? Di fatto con C7, P sta dimostrando di essere l'utente, di essere l'agente che ha iniziato l'handshake con Q. Perché solamente chi ha iniziato l'handshake con Q, cioè colui che ha scelto alfa e ha trasmesso G alla alfa, è in grado di calcolare C7. Perché alfa serve per calcolare G alla alfa, beta, che serve come input per HKDF, in cui output sono tutte le chiavi necessarie per cifrare i vari messaggi che vengono trasmessi. Quindi, in pratica tramite C7, P sta dimostrando di essere appunto l'agente che ha dialogato fino a quel momento con P e non qualcun altro. Non ha ancora dimostrato la propria identità. Questo è importante da tenere a mente. se non ha condiviso il proprio certificato con una firma. Quindi, se mancano C5 e C6, il server sa di aver dialogato con un utente, con un agente, per tutto l'handshake, ma di fatto ancora non sa chi è. Questo è il caso di one side authentication. Poi, come dicevamo l'altra volta, l'identificazione in questi casi avviene in un secondo momento. Cioè, una volta che è stato completato questo handshake e che quindi viene creata una VPN protetta tra P e Q, all'interno di quella VPN protetta, P può fornire le proprie informazioni per l'identificazione, seguendo uno dei protocolli di identificazione che ad esempio abbiamo studiato. Quindi, che ne so, mandare la password, piuttosto che altri. L'handshake finisce qui. Quindi, al termine di questo handshake, di fatto, Q ha in garanzia della confidenzialità, perché tutto viaggia cifrato, e della integrità, perché tutto viene segnato con un MAC. Abbiamo la prova di autenticazione di Q attraverso una firma digitale, eventualmente abbiamo la prova di autenticazione di P, se anche lui ha un certificato, e cosa più importante, alla fine di tutto questo, P e Q condividono in maniera confidenziale una stringa, che è l'output di HKDF, dalla quale, dalla quale possono estrarre, dalla quale possono estrarre, tutte le chiavi che servono per il proseguio della sessione. Quindi, ad esempio, il famoso master secret, che serve per realizzare l'autenticata di encryption, di solito tramite encrypte del MAC, all'interno di TLS, come abbiamo visto già un po' di tempo fa. Come dicevo prima, parte dell'output di HKDF viene quindi utilizzato per generare, in realtà i master secret sono due, non è una chiave sola, ma sono due, perché una è la master secret per le comunicazioni da client a server, l'altra invece è la master secret per le comunicazioni da server a client. Nelle due direzioni si usano chiavi diverse. Ok? Questo è il modo in cui lavora la sessione di setup di TLS. Ok? Quindi questo è esattamente quello che succede, ad esempio, ogni volta che tramite il browser aprite una pagina web di un indirizzo HTTPS. Ok? Perché sotto c'è TLS che crea attraverso questo handshake crea una VPN basata appunto sui master secret che vengono negoziati con questo handshake. Poi, ripeto, all'interno della VPN creata in questa maniera qua, se necessario, il client che sta navigando quindi sul sito, se necessario, si identifica oppure no, usando un protocollo di identificazione, quindi esibendo le proprie credenziali, username e password. Ok? Quindi, di fatto, l'handshake che abbiamo visto è una implementazione dell'idea dell'ultimo protocollo che abbiamo visto, delle ultime due versioni del protocollo di OI e TTC che abbiamo visto la settimana scorsa, era quello più più completo. Poi, ripeto, siccome tutte le informazioni vengono trasmesse in maniera cifrata, abbiamo anche garanzie relative alla privacy, sicuramente lato client, a volte lato server la privacy non può essere garantita perché spesso e volentieri l'identità del server fa parte di metadati che non possono essere cifrati perché sono metadati trasmesse a un livello più basso. Qui ho fatto l'esempio dello SNI che è il server name indicator che è un attributo che di solito viene trasmesso come metadato in chiaro nei pacchetti ed è necessario che sia così anche per una questione di funzionalità perché diversamente la richiesta al server probabilmente non arriverebbe neanche se le informazioni in certi casi se le informazioni relative alla sua identità non fossero note. Questo è quello che succede ad esempio quando su uno stesso IP rispondono diverse macchine virtuali diversi server allora in quel caso lo SNI è indispensabile per distinguere un destinatario rispetto all'altro quindi questa informazione non può essere protetta. TLS poi è molto più complesso al suo interno di quanto non vi ho raccontato perché ha diverse modalità diverse funzionalità ha un meccanismo per fare il refresh delle chiavi periodico ha un meccanismo per creare in maniera light delle VPN se i due i due agenti coinvolti si erano già autenticati in precedenza in una sessione precedente questo tra l'altro questa è una di quelle funzionalità che ha rappresentato una vulnerabilità nella versione precedente era 1.3 quindi è uno schema piuttosto piuttosto complesso con tante diverse con tante diverse funzionalità e questo chiude il discorso relativo all'authenticator key exchange un'altra tipologia di protocolli complessi come l'authenticator key exchange e che vi voglio raccontare è quella dei protocolli di authenticate key exchange basati su password perché anche questi sono piuttosto comuni e affrontano delle problematiche che tipicamente si riscontrano ogni qual volta voi come client vi autenticate ad esempio col vostro home banking con con un servizio con lo vostro servizio di carta di credito con amazon con qualunque tipo di di server che offre servizi e che mantiene vostre informazioni sensibili come ad esempio il vostro numero di carta di credito o cose di questo di questo genere i protocolli anche basati su password sono interessanti perché cercano di risolvere uno dei problemi di cui abbiamo parlato in diverse occasioni che sono gli attacchi di tipo phishing ok cosa che il protocollo diciamo precedente che abbiamo che abbiamo visto in certi casi non è non è particolarmente adatto da affrontare ad esempio nel caso in cui appunto attraverso un attacco di tipo phishing un client è indotto a eseguire il protocollo H magari TLS quello che abbiamo visto prima con quello che lui pensa essere il server legittimo ok quando in realtà non lo è perché ha cliccato su un link fake e quindi si autentica si autentica con con un server fake e all'interno della sessione TLS questo specialmente se a lato client non c'è un controllo del certificato del server che è possibile e può essere indotto a trasmettere appunto le proprie credenziali usando un protocollo di identificazione che abbiamo tra quelli che abbiamo studiato e quindi rivelare al fake al server fake informazioni che poi lui userà con il server legittimo e quindi per offrire un livello di robustezza in più in questi in questi casi i protocolli H che ho basati su password fanno uso di tecniche di challenger response che servono per diciamo smascherare un server fake e per evitare che in fase di identificazione il client trasmetta delle informazioni sensibili come ad esempio la password ok chiaramente questi questi questi protocolli si basano sull'ipotesi che esista già una esistono già delle credenziali che consentano al client di identificarsi presso il server ok e appunto lo scopo di questo protocollo è quello di far sì che il client non debba trasmettere queste informazioni confidenziali per identificarsi ma innescano un handshake di tipo challenger response che consente diciamo in zero knowledge al server di identificare il client senza che il client debba svelare la password quindi come avviene in zero knowledge cioè dimostrami di conoscere la password senza farmi vedere la password ok quando use yeah that's that's another factor an additional factor of authentication in certain case yeah that's that's an additional factor that you can you can enable yeah so identification of the device or the location because yeah yeah yeah yeah yeah yeah that's true that's true that's true but that's an additional feature that you can add for as in multi-factor authentication where you provide your password you provide your bio bio net information and so and so and the device and the location represent additional factors yeah this kind of protocol that we are going to present have the main objective the protection of the passwords today domani no Bush Hebrew Channel because hefe tête schütt нормально Quindi dicevamo lo scopo è quello di realizzare un milkshake che in zero knowledge consente al client di identificarsi, però usando i meccanismi di challenge e response che abbiamo visto perché grazie a questi riusciamo a evitare che avversari possano ingannare il client facendo finta di essere il server. Vediamo per step come definire questi protocolli e come poi migliorarli mano a mano. Quindi dobbiamo immaginare di avere un client e un server che condividono già una password e che vogliano eseguire questo milkshake per consentire al client di identificarsi senza essere vulnerabili ad attacco di tipo phishing. Quindi ad esempio qui vedete nella versione più semplice di base che il server, vedete challenge e response, quindi entrambi devono partecipare attivamente. Quindi il server sceglie un valore randomico che invia al client, anche il client sceglie un valore randomico che manda al server, quindi client e server si scambiano i propri valori randomici. A cosa servono questi valori randomici? Vedete che entrambi si mettono d'accordo sull'uso di una certa funzione hash come ad esempio shadow156, calcolano il digest, l'hash di che cosa? Della concatenazione di 4 informazioni che sono la password, un contatore, inizialmente vale 0 e i due nonce. Perché si usano i nonce? I nonce si usano sempre per evitare gli attacchi di tipo replay, perché quello che usate in un handshake non è più valido per un altro handshake. Quindi vedete il client calcola l'hash di quelle 4 informazioni, lo trasmette insieme al suo nonce al server. Il server fa lo stesso calcolo per verificare che il client conosca la password, ok? E quindi se quel check da parte del server ha successo, vuol dire che il client si è identificato. Ok? Dopodiché anche il server si identifica in maniera analoga e quindi manda un secondo digest, infatti vedete che viene incrementato il contatore, da 0 passa 1, lo manda al client, il client fa la verifica e se la verifica ha successo anche lui ha la prova di autenticazione. Quindi al termine di questo handshake sia il client che il server che condividono appunto questa password hanno la prova di autenticazione. Ok? E le uniche informazioni che vedete vengono trasmesse sono due nonce e due digest. Ok? Quindi un attaccante che fa i best dropping, che ascolta il canale, non riesce a raccogliere nessun tipo di informazione che possa essere utile per recuperare la password. Primo fatto. Quali problemi ci potrebbero essere da parte di attaccanti attivi? Pensiamo a un attacco di tipo man in the middle, quindi un attaccante che agisce in questa maniera. Abbiamo il client, abbiamo il server, il client e il server vogliono parlare, però nel mezzo c'è l'avversario, ok? Che quindi instaura una sessione col client e una col server e cerca di riutilizzare le informazioni per completare un'identificazione col client. Di solito questo tipo di attacco si può evitare se si usa il channel binding, ovvero se ogni sessione viene battezzata con un identificatore, come abbiamo visto anche la settimana scorsa. Ogni sessione voi la potete identificare usando come identificatore le informazioni casuali, randomiche della sessione. Quindi se in tutti gli handshake voi fate riferimento all'identificatore di sessione, è chiaro che un avversario non può realizzare questo tipo di attacco. Perché quando riceve messaggi dal server, questi messaggi avranno un certo identificatore di sessione, id, ok? Che magari è la concatenazione dei nos, quello che volete, no? Per cui i messaggi che l'avversario riceve dal server non possono essere riciclati e utilizzati dall'avversario per essere mandati al client. Perché? Perché la sessione che l'avversario ha col client sarà basata su un altro identificatore. Quindi se l'avversario usa un messaggio che ha ricevuto dal server per inoltrarlo al client, il client se ne accorge. Perché vede che questi messaggi sono associati a un identificatore di sessione diverso da quello che lui sta usando in quel momento con l'avversario. Ok? Quindi con il session ID questo tipo di problema particolare si risolve. Il problema che non si risolve è questo. Ok? Che è il solito problema dei protocolli di identificazione, no? Cioè l'offline dictionary attack. Se la password è debole, l'avversario che vede passare questo digest, ma anche questo, siccome tutte queste informazioni sono pubbliche, perché i nos passano, sono trasmessi in chiaro, quindi l'unica informazione segreta per calcolare il digest è la password. Se la password è debole, l'avversario cosa fa? Implementa, come al solito, come abbiamo già visto in passato, l'attacco di ricerca a forza bruta della password. Prova tutte le password in un dizionario finché non trova quella il cui digest insieme al contatore e due nos dà come risultato il valore che l'avversario ha osservato lungo il canale. Ok? Quindi questa versione di base ha lo stesso tipo di problematica dei protocolli di identificazione che abbiamo visto basati su password. Quindi l'idea è di complicare un po' le cose per risolvere questo tipo di problema. Come implementare l'idea? Allora, questa è la versione originale del protocollo PAC, password-based authentication key exchange, e ricalca l'idea che abbiamo appena raccontato. Ovvero il client sceglie un nonce, il server sceglie un nonce, questi nonce vengono scambiati, entrambi calcolano questo digest, che è il digest di password identità dei due nonce, e questo digest tra l'altro verrà usato come master secret. Ok? Il problema di questa versione base del protocollo PAC è se la password è debole, l'attaccante riesce a svelarla. Ok? Quindi come fare a migliorare il protocollo? Questa è una prima versione del protocollo PAC che ha appunto come obiettivo il rendere il protocollo più robusto rispetto all'attacchio a forza brutta sulla password. E qui si usano, vedete, gli ingredienti di Diffie-Hellman, quindi si usa un gruppo ciclico con il suo generatore, la cui cardinalità è Q. P che cosa fa? P sceglie un esponente e calcola G alla alfa. Q fa la stessa cosa, calcola G alla beta. I due si scambiano G alla alfa e G alla beta. Ok? Quindi solito un shake di Diffie-Hellman. Niente di nuovo da questo punto di vista. Ok? Quindi questo significa che entrambi sono in grado di calcolare G alla alfa beta. Ok? E quindi che cosa fanno? Calcolano questo digest. Ci mettono dentro. Password. le due identità, G alla alfa e G alla beta, e vedete G alla alfa beta. Quindi dentro questo digest non c'è più solo la password come informazione segreta, ma c'è anche G alla alfa beta. Quindi un attacco a forza brutta non si può più fare. proprio perché oltre alla password c'è anche G alla alfa beta. G alla alfa beta lo possono conoscerci solo P e Q. Ok? Quindi questo protocollo sicuramente più robusto rispetto a quello di prima. Lo è se l'attaccante è passivo. Ok? O se fa attacchi diretti. Quindi implementa l'attacco a forza brutta o se ascolta il canale. Non è però robusto rispetto a attaccanti attivi che impersonano il ruolo di Q. Perché se Q, scusate, se l'avversario finge di essere Q, che cosa fa? Calcola lui beta, inizia nel shake con P, P pensa di parlare con il server legittimo, invece sta parlando con l'avversario e quindi gli manda il suo G alla alfa, Q sceglie G alla beta. Ok? E quindi quando P trasmette poi l'ash, l'avversario conosce tutte queste informazioni. Perché è lui che ha scelto beta. E quindi di nuovo può provare a fare un attacco a forza brutta, flop household. ok? Ok. Quindi per irrobustire ulteriormente il protocollo opache, questa è l'ultima versione, robusta anche rispetto ad attaccanti attivi che fingono di essere uno delle due parti, qui che cosa succede? Beh succede che si usa sempre di Fielman, però lo si usa in maniera un pochino più sofisticata, infatti vedete che abbiamo P che sceglie il suo alfa, però vedete non trasmette a Q G all'alfa, ok? Ma gli trasmette questo U, chi è U? È G all'alfa moltiplicato per un parametro A che è pubblico, elevato alla password, ok? Quindi questa è l'informazione che P trasmette a Q. Q fa la stessa cosa, sceglie un beta, calcola V che è G alla beta per un altro parametro B pubblico, elevato alla password, e naturalmente ora come fanno P e Q a calcolare G alla alfa beta? Perché alla fine di questo unshake sia P che Q hanno bisogno di condividere G alla alfa beta perché lo vogliamo mettere dentro il digest? Beh il calcolo lo si può fare solo se si conosce la password, perché Q riceve G alla alfa A alla password, quindi ha bisogno di recuperare G alla alfa, ma per recuperare G alla alfa deve dividere tutto per A elevato alla password, ma A elevato alla password io lo posso calcolare solo se conosco la password, ok? Quindi Q fa questo calcolo, recupera G alla alfa e quindi è in grado di calcolare G alla alfa beta. La stessa cosa fa P dall'altra parte, ok? E quindi alla fine di questo unshake P e Q condividono G alla alfa beta. La novità rispetto a prima è che l'avversario non ha visto passare né G alla alfa né G alla beta, perché ha visto passare qualcosa che è mascherato e che dipende dalla password. Dopodiché il digest vedete si calcola come al solito, dove questo sarebbe G alla alfa beta, quindi come nella versione precedente, solo che rispetto alla versione precedente un avversario che fa finta di essere uno dei due non è in grado di calcolare G alla alfa o G alla beta, e quindi non è in grado di calcolare G alla alfa beta, anche se è lui che ha scelto beta, e quindi non riesce a, non può realizzare l'attacco a forza brutta sulla password, perché questa informazione qui gli rimane segreta, anche se è lui che sta facendo finta di essere Q, per cui ha scelto beta, però questa informazione qui non è comunque in grado di calcolarla perché gli manca la password, ok? Questa è la versione finale del protocollo Pache, che è robusta e sicura rispetto a tutte le tipologie di avversario che abbiamo introdotto, quindi avversari diretti, passivi, che fanno i verse dropping, e attivi, che fanno anche man in the middle, ed è questa versione qui effettivamente quella che è utilizzata per realizzare la identificazione degli utenti nelle reti wifi protette dal sistema WPA3, che estende il WPA2 di cui avevamo parlato qualche tempo fa quando vi avevo fatto vedere gli esempi di authenticated encryption, quindi questa è l'ultima versione del protocollo di trasmissione sicurezza dei dati in ambienti wifi. E questo chiude il discorso relativo ai protocolli avanzati di tipo authenticated key exchange con TTP offline, perché abbiamo detto che in questi casi il ruolo del TTP è semplicemente quello di creare dei certificati che poi vengono utilizzati durante il handshake, ma il TTP di fatto non interviene mai. rimane da vedere, poi questo chiuderà definitivamente il discorso relativo ai protocolli di authenticated key exchange, il caso invece del TTP online, ovvero il caso in cui quando P e Q vogliono creare un canale di comunicazione protetto tra loro, devono interagire direttamente col TTP. Avevamo detto che uno dei vantaggi di questa soluzione è quello di poter evitare di usare schemi di cifratura a chiave pubblica e firme digitali, ma usare solo schemi di cifratura a chiave simmetrica. Lo svantaggio è il collo di bottiglia rappresentato dal TTP che deve partecipare a tutte e quanti le sessioni di setup. E quindi è un tipo di soluzione che può funzionare solo in contesti piccoli, diciamo, con un numero limitato di utenze. In genere si assume sempre che a priori ogni nuovo utente della rete protetta in questa maniera si registra, si deve registrare col TTP in qualche modo, e che il risultato di questa registrazione sia come al solito un accoppiamento, un binding tra l'identità dell'utente, DP, e una master key, che è una chiave segreta, che l'utente condivide con il TTP. Quindi una chiave simmetrica. Ok? In realtà la chiave non è mai una sola, ma sono sempre due, perché una è la chiave di cifratura e l'altra è la chiave di segnatura per creare i tag attraverso un MAC. Ok? E quindi sono queste due chiavi qui che vedete. No? Ok? Quindi, chiave di cifratura, chiave per il MAC. Quindi, una volta che l'utente si è registrato, tutte le comunicazioni tra l'utente e il TTP possono avvenire usando questo master secret, diciamo. Ok? Non ha importanza che schemi di cifratura e MAC utilizzare, come al solito l'importante è che siano uno ci assicuro e l'altro sicuro. Sulla base di queste, di questa informazione di registrazione, poi come vedremo tra poco, il TTP imposterà, diciamo, coordinerà l'inshake tra due utenti P e Q che si vogliono, che si vogliono autenticare tra di loro. In genere, in genere, il master secret, siccome è un'informazione molto sensibile, non viene memorizzato dal TTP nel, in memoria, diciamo. In questo ambito il TTP viene spesso chiamato Key Distribution Center, che i dissi, capiremo tra poco per quale motivo viene chiamato così, perché il suo ruolo, come vedremo, è quello di distribuire chi ha. Dicevo, siccome i master secret sono informazioni molto sensibili, in genere queste non vengono memorizzate direttamente, anche perché possono essere tante, no? E allora, di solito il TTP che cosa fa? memorizza una sola chiave segreta, che chiameremo Kttp, quindi questo è l'unico segreto personale che il TTP deve mantenere, perché? Perché questo serve per creare i master secret dei vari utenti. infatti quando un agente P che ha un'identità IDDP si registra presso il TTP, il TTP cosa fa? Genera il master secret per P in questo modo, usa un PRF e usando la propria chiave segreta applica il PRF all'identità dell'utente e il risultato sarà la sua chiave segreta, la sua master secret. Ok? Quindi, così facendo, il TTP non ha bisogno di memorizzare il master secret di tutti gli utenti, no? Se lo può ricalcolare ogni volta che serve. ogni volta che se sa di dover dialogare con P cosa fa? Applica il PRF usando la propria chiave segreta, applica il PRF all'identità di P ed ecco che ottiene la chiave che gli serve per dialogare con P. Ok? In questo modo l'unica informazione segreta che il TTP deve mantenere in memoria è questa che non deve rivelare a nessuno chiaramente. Ok? Il problema di questa soluzione è che una volta calcolata la chiave di un agente quello non può più cambiare dato che l'output del PRF applicato alla sua identità a meno che non cambia l'identità dell'agente. E questo è un problema perché invece a volte è bene fare il refresh delle chiavi. Ok? Un modo molto semplice per risolvere questo problema è usare il PRF in questa maniera. Usando applicando il PRF sì all'identità dell'agente concatenata però con un nonce. Ok? In questo modo il risultato sarà il Master Secret DP. Chiaramente in questo modo l'unica cosa che il TTP deve fare è memorizzare da qualche parte il nonce. Però è utile questa cosa perché? Perché se a un certo punto il TTP decide di fare il refresh della chiave DP è sufficiente che cambi il nonce. Ok? quindi far rifare la registrazione alla gente di fatto utilizzando però un nonce diverso. E questa è l'idea. dopo di che come avviene l'autenticazione tra P e Q tramite il TTP questo è il protocollo è il handshake che consentirà a P di instaurare una VPN con Q garantendo mutua autenticazione e confidenzialità. Come avviene? Vediamo un po'. Il protocollo viene avviato da P vedete? P sceglie un valore casuale un nonce e lo manda insieme alla propria identità a Q quindi P dice a Q voglio parlare con te questo è il mio nonce e questa è la mia identità. Q che cosa fa? Sceglie anche lui un nonce e manda una richiesta al TTP la richiesta vedete comprende i due nonce e le due identità ok? Ora il TTP che cosa fa? Verifica le due identità sceglie quella che sarà il master secret che P e Q devono condividere per instaurare una VPN attraverso autenticata da encryption e genera una serie di messaggi che adesso andremo a commentare i primi due sono destinati a Q e sono un ciphertext e un tag ok? il ciphertext contiene semplicemente il master il master il secret K ok? e viene e questo e questo ciphertext viene creato cifrando con la chiave che il TTP condivide con Q ok? quindi con questa dicitura qui noi intendiamo l'applicazione dell'algoritmo di cifratura a chiave simmetrica usando la chiave che il TTP condivide con Q e cosa contiene il ciphertext? contiene K il tag invece anche questo calcolato usando il MAC con la chiave che TTP condivide con Q e il tag va a proteggere l'integrità di che cosa? dell'identità di P dei due nonce e del ciphertext che ha appena prodotto quindi si ispira all'encrypt del MAC prima fa la cifratura e poi la la la la la la la la la la e qui sono questi ok? vedete sono la controparte l'esatta controparte dei due messaggi generati per Q. Questi vedete che vengono inviati a P insieme a che cosa? All'identità di Q e al nonce che Q aveva scelto perché queste due sono informazioni che in qualche modo devono essere diciamo certificate a P dato che P non le conosceva di fatto. Q le conosceva perché le aveva ricevute da P. Q aveva ricevuto da P questa coppia ma P non ha ricevuto niente da Q. Quindi questo è il motivo per cui questa coppia viene inviata a P direttamente dall'attitipi insieme a questa coppia di informazioni. Quindi alla fine P e Q condividono le stesse informazioni perché condividono la cifratura di K, la segnatura che garantisce l'integrità della cifratura e delle reciproche identità e nonce, nonché l'identità e nonce stessi. A volte il TTP non dialoga sia con Q che con P ma dialoga solo con Q, questo per evitare di diventare un collo di bottiglia, per cui a volte quello che succede è che la risposta destinata a P viene consegnata a Q e Q poi si fa carico di inoltrarla P. In questo caso la risposta per P prendendo il nome di ticket. Quindi il TTP prepara un ticket per P ma lo consegna a Q e poi è Q che lo inoltre a P. Alla fine di questo è il shake, questo è il session AD, la concatenazione come abbiamo già detto anche in passato, dei nonce, dell'identità dei due agenti. E il risultato finale è che P e Q alla fine di tutto sono reciprocamente autenticati grazie al TTP e condividono questo master secret che verrà usato per realizzare la VPN basata sull'autenticata di encryption. Ok? Ok? Questo è... Anche qui ci sono un sacco di informazioni che vengono in particolare firmate perché alla fine il senso del MAC è quello. In maniera analoga a quanto avevamo visto la settimana scorsa con l'autenticata di key exchange basato su schemi a chiave asimmetrica. E il motivo per cui vengono segnati tramite MAC tutte queste informazioni è per evitare fondamentalmente le stesse tipologie di attacco che avevamo visto la settimana scorsa. Anche qui adesso vi farò vedere che se eliminate in particolare dalla segnatura alcune di queste informazioni ecco che il protocollo diventa vulnerabile. A diverse tipologie di attacco che vanno a compromettere o la segretezza o l'autenticazione. Quindi in maniera molto simile a quello che avevamo già visto la settimana scorsa. Ad esempio, cosa succede se nella risposta a P non viene segnato tramite MAC il ciphertext? Ok? Quindi immaginate che nel tag non sia compreso il ciphertext. Ok? Quindi in pratica così facendo viene a mancare la prova di integrità del ciphertext per P. E quindi cosa potrebbe fare un avversario in questo caso? L'attacco è analogo a quello che avevamo visto la settimana scorsa. Ovvero l'avversario può registrare un suo agente con il TTP e può avviare un handshake con P tramite il TTP e quindi creare una sessione la cui chiave segreta sarà K. Dopodiché l'avversario che cosa fa? Si mette ad ascoltare altre sessioni. In particolare si mette ad ascoltare una sessione di handshake tra P e Q e quando a P deve arrivare la cifratura della chiave di sessione con Q l'avversario prende il ciphertext, lo intercetta e lo sostituisce con che cosa? Col ciphertext che aveva caratterizzato la sua sessione con P. Quindi il ciphertext contenente la chiave di sessione tra P ed R. Il P di questa sostituzione non se ne accorge. Non se ne accorge perché manca il tag sul ciphertext, sull'integrità del ciphertext. Quindi non può verificare l'integrità del ciphertext che riceve e quindi non si può accorgere del fatto che è stato sostituito. Ora la favola, quello che succede è che P è convinto che la chiave di sessione con Q sia K quando in realtà K è stata la chiave di sessione che P ha condiviso con R. Quindi in pratica questo attacco viola la confidenzialità perché è un attacco che induce P a inviare a Q dei messaggi cifrati con una chiave che l'avversario conosce. Ok? Vi ho fatto l'esempio specifico di mancanza di segnatura di questo ciphertext. Ok? Ma lo stesso discorso, dopo cambia il ruolo dell'avversario naturalmente, lo si può fare se voi togliete questo ciphertext qua dalla segnatura che viene fatta a beneficio di Q, quindi in maniera del tutto simmetrica. si invertono i ruoli, però l'efficacia dell'attacco è sempre la stessa. Quindi stesso discorso che avevamo già visto in passato, è importante che il tag copra il ciphertext per evitare che un avversario lo possa sostituire. Cosa succede invece se togliamo dalla segnatura il nonce di P? Quindi dalla segnatura destinata a P togliamo l'informazione relativa al nonce che P aveva scelto. Ok? E in maniera simmetrica, un discorso analogo a quello che sto per fare, vale se togliete questo. Quindi se dalla segnatura a beneficio di Q togliete il riferimento al nonce di Q. Bene, se togliete queste informazioni, che cosa succede? Cosa può fare un avversario? Siccome voi non segnate il nonce, non avete modo di verificare se siete vittima di un reply attack. Perché l'avversario cosa può fare? Può ascoltare un'istanza tra P e Q che è basata su un certo nonce. Dopodiché quando P e Q successivamente magari avviano un nuovo shake, l'avversario può intercettare e bloccare il primo messaggio che viene inviato da P e mandare a P la risposta, la stessa risposta, che l'avversario aveva ascoltato dalla sessione precedente. Ok? Ok? È chiaro che nel momento in cui P riceve questa risposta qua, no? Dato che manca il riferimento nel tag al nonce, il P non ha modo di verificare che questa risposta che gli sta ricevendo faccia veramente riferimento a questa sessione, ma potrebbe essere la risposta che invece ha ricevuto in una vecchia sessione e che l'attaccante gli sta mandando al posto di quella originale che dovrebbe ricevere. Ok? E questo l'attaccante lo può fare se manca questa informazione qua. Quindi in questo modo P è convinto di aver completato un'autenticazione con Q, di condividere con Q una chiave K, che aveva già condiviso con Q in precedenza, e quindi l'avversario di fatto sta convincendo P a usare K due volte. Se ci pensate è esattamente lo stesso tipo di problematica che avevamo visto con il protocollo H la settimana scorsa. Quindi stessa tipologia di attacco. Un problema di autenticazione si ha invece se voi omettete dalla segnatura destinata a P l'informazione relativa all'identità di Q. E lo stesso vale in maniera simmetrica se togliete questa. Ok? In questo caso, mancando la prova di integrità dell'identità della controparte, l'avversario può realizzare un attacco che va a compromettere la mutua autenticazione. L'avversario cosa fa? Registra un agente nuovo, R, e quando P e Q avviano un nuovo handshake, l'avversario che cosa fa? intercetta l'ultimo messaggio destinato a P e va a fare una sostituzione di identità. Pogliamo un attimo indietro, andiamo a rivedere dove questo avviene. Avviene qui. Ok. L'avversario che cosa fa? Intercetta questo messaggio e sostituisce qui l'identità di Q con dentro ci mette l'identità di R. P non se ne accorge. Non se ne accorge perché? Perché manca la prova di integrità. Il tag non copre l'identità di Q e quindi non si può accorgere di questa sostituzione. e quindi il risultato è che alla fine di questo attacco quello che è successo è che P pensa di essersi autenticato con R invece che con Q. L'ultima informazione che mancava da considerare all'interno del tag è il nonce di Q all'interno del tag destinato a P. Quindi vedete, le abbiamo esaminate tutte e quattro, le informazioni taggate le abbiamo esaminate tutte. Quindi simmetricamente un discorso analogo vale se togliete questo altro nonce. Ok. Ora anche in questo caso l'assenza del nonce rende il protocollo vulnerabile ad un attacco che va a compromettere il binding sul canale. quindi l'identificatore della sessione assumendo che come al solito l'identificatore di sessione sia questa quadrupla ok. Allora quando P e Q avviano l'anshake l'avversario può intercettare l'ultimo messaggio dell'anshake rivolto a P e modificare in questo messaggio il nonce di Q andiamo un attimo indietro quello che succede è semplicemente questo che questo è il messaggio che viene spedito a P siccome questo valore non è protetto dal tag l'avversario lo può sostituire con un valore spuri o qualunque nell'esempio ho messo 0 P non se ne accorge perché manca la prova di integrità sul sul nonce quindi P alla fine è portato a dare alla sessione che ha con Q un session ID che è diverso da quello che gli viene dato da Q quindi due session ID non vengono a coincidere e quindi P e Q di fatto non riusciranno a a parlare tra loro quindi vedete sono grosso modo gli stessi gli stessi attacchi che avevamo visto la settimana scorsa nel caso del protocollo A che e che mettono in evidenza quanto sia importante garantire l'integrità di tutte quelle informazioni che fanno parte della segnatura ok questo chiude chiude il discorso relativo ai ai protocolli di autenticata di key exchange con o senza con o senza TTP noi ci vediamo domani al career day ok non facciamo lezione e noi finiremo il corso la prossima settimana faremo lezione sia mercoledì che giovedì anche perché mancano due argomenti uno riguarda la verifica formale delle proprietà di sicurezza di protocolli complicati come questi usando metodi alternativi rispetto alla alle dimostrazioni basate sugli attack game che sono piuttosto complesse quando i protocolli sono a questo livello di complessità e poi vi volevo raccontare invece sicuramente come volevo raccontarvi come funziona la come viene usata la criptografia nelle blockchain e vi farò l'esempio della blockchain di bitcoin quindi quali sono le operazioni criptografiche che si fanno per garantire l'immutabilità della della blockchain ok e se faccio in tempo volevo farvi vedere un altro esempio pratico di vulnerabilità legate alla sicurezza nell'ambito invece dei classificatori quindi nell'ambito del deep learning machine deep learning alla fine cambia poco però mi voglio riferire specificatamente ai classificatori vi farò l'esempio dei classificatori di immagini tanto poi il problema della classificazione bene o male è sempre lo stesso ci sono delle vulnerabilità di classificatori che potrebbero essere sfruttate per degli attacchi anche importanti quindi se faccio in tempo anche nelle sei ore che mancano vi faccio questi tre questi tre argomenti qua va bene ci vediamo per chi viene ci vediamo domani al carrile day o altrimenti la prossima settimana qui no Grazie.