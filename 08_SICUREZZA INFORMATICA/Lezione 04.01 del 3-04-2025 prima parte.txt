Allora continuiamo a vedere gli esempi che avevamo elencato ieri per quanto riguarda possibili meccanismi mirati a garantire l'autentichetta di encryption con date associate. Abbiamo visto come funzionano Galois, Canter Mode e quantomeno il Record Protocol di TLS. Andiamo avanti, vediamo brevemente come funziona SSH, che storicamente è quell'applicazione che ha sostituito il vecchio Telnet, che era quel protocollo per creare una sessione remota, un'applicazione in modalità testuale disponibile per la shell di Linux, di Unix prima di Linux, di Linux poi. Telnet si usava per aprire sessioni di comunicazione remote, poi c'era la controparte FTP di cui abbiamo parlato negli esempi di pentesting, che invece veniva utilizzato per il trasferimento di file remoti. Sia Telnet che FTP funzionavano senza protezione dei dati, quindi trasmissione delle comunicazioni tutto in chiaro. Per cui SSH nasce per sostituire Telnet con un protocollo che invece garantisse anche la protezione dei dati, quindi confidenzialità ed integrità. SSH è piuttosto vecchio, qui adesso vi dico qualcosa brevemente delle prime due versioni, più o meno quello che dico per SSH vale anche per SCP, che invece è la versione sicura di FTP. Ok, quindi quanto riguarda la trasmissione dei file. In realtà SSH è molto simile come paradigma a TLS, quest'ultimo si è ispirato a quanto succede in SSH, tant'è che appunto come potete vedere il paradigma che SSH usa è quello dell'encryptive Mac, dove analogamente a quanto detto ieri per TLS, la fase di cifratura si basa su un cifrario probabilistico che è AES in CBC mode, e invece per quanto riguarda i Mac ve ne sono diversi, SSH supporta svariati standard tra quelli che abbiamo elencato quando abbiamo parlato dei Mac. Quindi in linea teorica, in virtù del fatto che vengono usati un cifrario che è CPA sicuro ed un Mac sicuro, SSH risulta essere a sua volta sicuro dal punto di vista dell'etichetta di encryption, se non fosse che in ogni caso, per via di aspetti legati all'implementazione, SSH ha sofferto nella prima versione, ma poi in realtà anche nella seconda, di alcune vulnerabilità, che di fatto lo rendono meno utilizzato, sicuramente da quando esiste TLS è stato un po' soppiantato da questo punto di vista, proprio perché comunque anche l'ultima versione ancora in uso di SSH soffre di alcune vulnerabilità. Di una di queste vi volevo raccontare brevemente come funziona. Si tratta di una vulnerabilità dovuta sempre ad un attacco di tipo chosen ciphertext, quindi in linea di principio lo stesso tipo di attack game che abbiamo discusso ieri, quindi un avversario che ha la possibilità di scegliere il ciphertext da farsi decifrare. In particolare nel caso di SSH la vulnerabilità sta appunto nel modo in cui è implementata la fase di decifratura. Ok? Quindi di nuovo è una vulnerabilità di implementazione piuttosto che di principio. Altrimenti come abbiamo detto prima, c'è il teorema che abbiamo visto ieri che ci dice che sotto certe condizioni, che SSH soddisfa, il sistema garantisce l'autenticato di encryption. Ora, come funziona la decifratura di SSH all'altra implementazione? È un'operazione che non è del tutto atomica. E questa mancanza di atomicità è la causa della vulnerabilità che rende possibile un attacco di tipo chosen ciphertext. Perché non è atomica la decifratura? Beh, perché viene eseguita in due fasi. Una prima fase in cui viene decifrato un campo, diciamo, del pacchetto che rappresenta la lunghezza del payload che contiene il messaggio che deve essere decifrato. Ok? Dopodiché, questa informazione viene appunto usata per decidere quanti ulteriori blocchi andare a leggere e quindi decifrare. Ok? Questo avviene naturalmente per quanto riguarda il primo blocco, il primo pacchetto di una sequenza di pacchetti in cui è suddiviso il nostro messaggio. Perché questa, diciamo, scomposizione della decifratura in due fasi è problematica? Problematica perché un avversario cosa può fare? Beh, può percettare un qualunque ciphertext di passaggio e riutilizzarlo, quindi inviandolo in un secondo momento al destinatario come se fosse il, diciamo, il primo pacchetto di una nuova sequenza. Ok? Perché fare una cosa del genere? Perché il destinatario cosa farà? Prenderà questo ciphertext sottoposto dall'attaccante e eseguirà la prima fase, quindi andrà a estrarre l'attributo del packet length decifrandolo e in funzione di questo andare a decidere quanti blocchi ulteriori decifrare. Quindi questo cosa significa? Significa che osservando cosa succede nella fase 2 della decifratura, l'avversario impara qualcosa sull'esito della decifratura fatta dal destinatario. è molto simile al puddle attack di cui abbiamo parlato ieri, no? Perché si basa sempre sulla stessa idea, ovvero l'avversario sa che un certo pacchetto che io gli mando, su un certo pacchetto che io gli mando, il destinatario fa determinate operazioni. Ok? Cioè decifra e poi in base all'esito della decifratura fa determinate operazioni. E l'avversario lo vede quali sono queste operazioni. Ok? Quindi a seconda di queste operazioni, l'avversario impara qualche proprietà del ciphertext che ha inviato al destinatario. In particolare in questo caso, se dopo aver decifrato l'attributo packet length, l'avversario vede che il destinatario aspetta un tot di blocchi per iniziare a decifrare, perché? Perché sa che ne deve decifrare N. ecco che l'avversario impara che il pacchetto che aveva inviato al destinatario, in quel campo conteneva N, o comunque un valore compatibile col fatto che poi il destinatario ha deciso di decifrare N blocchi consecutivi. Ok? O anche semplicemente il fatto che il destinatario nella decifratura dà errore, e può dare errore perché l'avversario magari manda un ciphertext che non rispetta la struttura che si aspetta al destinatario e quindi il fatto che in un certo, in un certa posizione del pacchetto trova quel valore che rappresenta la lunghezza del ciphertext da decifrare successivamente. In quel caso darebbe errore, un po' come succede nel Poodle Attack. Ok? Lì il trucco stava nel vedere come chi decifrava interpretava la parte di Padding, qui il giochino sta nell'interpretare come il destinatario reagisce alla decifratura di quell'attributo che rappresenta la lunghezza del messaggio. Quindi l'avversario non deve fare altro a quel punto che osservare come reagisce il destinatario all'esecuzione della prima fase e vedere cosa fa nella seconda fase. A seconda di questo, l'avversario riesce a dedurre delle informazioni sulla struttura del plaintext che è nascosto dall'interno del ciphertext che ha sottoposto al destinatario. Ok? Questo tipo di chosen ciphertext attack è di questo tipo proprio perché l'avversario scende un ciphertext da, magari uno di quelli che aveva già intercettato, da mandare il destinatario e da farsi decifrare. Guarda come si comporta il destinatario e in funzione di come si è comportato deduce qualcosa sul plaintext nascosto. Ok? È esattamente lo stesso tipo di idea del puddle attack che abbiamo descritto ieri. Quindi questi due esempi dovrebbero mettere in evidenza il fatto che nelle implementazioni le operazioni di decifratura e decifratura innanzitutto dovrebbero essere, dal punto di vista di un osservatore esterno, atomiche. e non dovrebbero fornire nessun tipo di feedback a chi osserva dall'esterno. Ok? Perché altrimenti si corre il rischio che chi osserva dall'esterno, in base a come si comporta chi fa la decifratura, potrebbe imparare qualcosa sulla natura del messaggio che è stato decifrato. in maniera indiretta. Cioè, faccio un esempio estremamente banale. Ok? Però il principio è esattamente lo stesso. No? L'avversario esegue un chosen ciphertext attack, invia un ciphertext che aveva intercettato prima al destinatario. Ok? E sa che il destinatario decifrerà il messaggio e se il primo bit del messaggio è un 1, fa una certa cosa. Se il primo bit del messaggio è un 0, fa un'altra cosa. E l'avversario magari ha modo di vedere che cosa fa il destinatario. Se fa la prima o se fa la seconda cosa. Quindi, osservando la reazione del destinatario, capisce indirettamente se il primo bit del plaintext è uno 0 o è uno 1. Ok? Quindi il principio è esattamente questo. Ed è lo stesso principio su cui si basa il pull dell'attacco che abbiamo descritto ieri e questo attacco contro SSH che abbiamo appena descritto oggi. Quindi la morale è quella che abbiamo appena detto. Le operazioni di disciupatura dovrebbero essere, dal punto di vista di un avversario che osserva da fuori, operazioni atomiche e che non rilasciano nessun tipo di feedback. che consente all'avversario di imparare qualcosa sulla natura del plaintext che è stato decifrato. Questa è un po' l'idea generale. Ok? Ci siamo? Ripeto, SSH ormai non dico che è deprecato, però da quando c'è TLS direi che è... non si usa di meno, si usa ancora in sessioni desktop di macchine Linux dove l'utente usa ancora la shell per collegamenti di tipo VPN verso ostre moti e quindi per abitudine in certi casi si usa ancora questo tipo di applicazioni come la SSH con SCP, però diciamo che non è il massimo della vita. Volevo passare invece a questo esempio che è il caso del protocollo 802.11b delle reti wireless. Questo è il protocollo che per anni si è utilizzato per proteggere la trasmissione dei dati in ambito wifi. ok? E in particolare l'802.11b è un protocollo che è estremamente vulnerabile. Per cui vedere come funziona è educativo, istruttivo, perché la sua progettazione contiene un sacco di bad practices per quanto riguarda l'utilizzo dei meccanismi di riprenditivi e crittografiche, per quanto riguarda scelte implementative, progettuali. Diciamo che ci sono diverse tipologie di errore dentro la progettazione di questo protocollo per cui è abbastanza interessante andare a vedere un po' nel dettaglio come funziona. L'idea del protocollo di protezione dei dati all'interno dell'802.11b che è il WEP, il Wired Equivalent Privacy Protocol, è quella che adesso andiamo a vedere e che non dovete mai usare. Ok? Quando siete col laptop e vi dovete collegare al wifi dell'aeroporto piuttosto che dell'università piuttosto che di qualunque altro luogo, non scegliete mai con le sessioni protette WEP, ma scegliete sempre con le sessioni protette WPA2 quanto meno, che è l'altro che vi farò vedere tra poco. WEP assolutamente no, specialmente se poi all'interno di quella sessione dovete trasmettere dati sensibili. Ok? Quindi non fate un banking su una rete wifi protetta da questo tipo di protocollo, tanto per fare un esempio. Ok? Come funziona nel protocollo WEP la cifratura con integrità? Allora, l'idea è un po' quella del paradigma MAC than encrypt. Ok? Adesso vedremo per quale motivo. Ora, andiamo a vedere come viene determinato il ciphertext a partire da un certo da un certo plaintext. Allora, sono persi qua. Eccoci qua. Allora, questo è il plaintext. Ok? Che viene concatenato. Qui ho preso la notazione pari pari presenti nella documentazione del web e lì la notazione è quella della doppia barra verticale per rappresentare la concatenazione. Ok? Quindi, vedete che cosa c'è? Si prende il plaintext e lo si concatena con questa stringa che è il risultato dell'applicazione di una funzione di checksum. Il crc è un algoritmo che prende in ingresso una stringa, in questo caso il plaintext, restituisce un valore che dipende dal plaintext. Esempi, abbiamo citato all'inizio quando abbiamo parlato dei Mac di algoritmi di tagging simili ai Mac che si utilizzavano per garantire l'integrità dei messaggi trasmessi in presenza di canali imperfetti. Ok? E quindi l'utilizzo di algoritmi che il cui obiettivo è quello di prendere un messaggio, calcolare un valore che dipende da quel messaggio e usare quel valore come tag del messaggio. CRC è uno di questi algoritmi storici, risale addirittura ai tempi di Unix. Ok? È una funzione di checksum che calcola un tag a partire da un messaggio, un po' come ad esempio prendiamo il caso della parità. Ok? La funzione di checksum CRC è un pochino più complicata perché usa un polinomio che viene messo in relazione col messaggio e dalla composizione del messaggio con un certo polinomio dovrebbe venire fuori un determinato risultato. Ok? E quello è il risultato che viene usato come tag. Dall'altra parte si fa lo stesso tipo di calcolo e se i conti tornano vuol dire che il messaggio è arrivato integro, non è stato modificato per colpa di un canale imperfetto. Ora, cosa va detto però? Va detto che CRC è una funzione di tagging per l'integrità del messaggio che va bene solamente nel caso in cui vogliamo preservare, vogliamo verificare l'integrità del messaggio in presenza di un canale imperfetto. Ok? non è il caso di utilizzarlo nei confronti di un attaccante che è intenzionato a modificare l'integrità del messaggio stesso, tant'è che come vedete è una funzione che non usa chiave, questo non è un MAC, CRC quindi non è un MAC, non usa una chiave per calcolare il tag. È una funzione che chiunque può applicare banalmente. Questo naturalmente i progettisti lo sapevano il fatto che il CRC non fosse un MAC e quindi tantomeno un MAC sicuro. E quindi il loro ragionamento qual è stato? Vabbè, è vero che il tag che noi calcoliamo in questa maniera non è sicuro perché uno che vuole compromettere l'integrità di M cambia M in M' calcola il CRC di M' e trasmette la copia alterata e il destinatario non se ne accorge di quello che è successo. Quindi erano consapevoli di questo pericolo. E il loro ragionamento qual è stato? Dato, va bene, è vero che questo tag non è sicuro, però noi che cosa facciamo? Prendiamo il messaggio, prendiamo il tag, li concateniamo, dopodiché li cifriamo. Quindi anche se il tag non è sicuro perché non abbiamo usato un MAC sicuro, in ogni caso noi lo proteggiamo cifrandolo. Per cui l'idea di questa costruzione è analoga a quella del MAC dell'encrypt perché prima viene calcolato il tag del messaggio e poi la coppia messaggio tag viene cifrata. Ok? Come avviene la cifratura? Quindi se vogliamo questa operazione qui sarebbe l'equivalente dell'applicazione di un MAC insicuro perché non è previsto nessun meccasso un chiave. La cifratura di questa coppia avviene usando di fatto l'idea degli stream cipher. Ok? Perché come potete vedere la cifratura avviene combinando la coppia messaggio tag in xor con quella che come vedremo tra poco dovrebbe essere una stringa pseudo casuale cioè il risultato dell'applicazione di un prg. Ok? Quindi questa roba qui che vediamo dovrebbe essere il risultato dell'applicazione di un prg sicuro. Ok? Quindi stessa idea degli stream cipher. uso un prg per ottenere una stringa pseudo casuale impredicibile la combino in xor in questo caso con messaggio tag ed ecco che ho il mio ciphertext. Ok? Questa è l'idea. Come funziona i prg? Vi ricordate? prg prende in input un seme segreto e da lì tira fuori una sequenza pseudo casuale. Ad esempio un modo per implementare un prg sicuro è attraverso l'uso di un prf o quindi ad esempio di un box site. In questo caso particolare il prg che è stato utilizzato all'interno di web è quello di uno string cipher esistente quindi non è che ne hanno implementato uno nuovo ad hoc ma semplicemente all'epoca stiamo parlando della fine del secolo scorso all'epoca si prese uno degli string cipher disponibili in letteratura che era rc4 e si è utilizzato il prg di rc4 ok? Bene noi sappiamo che il prg in input vuole il famoso seme il segreto il valore segreto condiviso come viene risolto questo questo problema? Passo indietro tutti gli utenti che si loggano ad una rete wifi condividono tramite una fase di handshake iniziale basata su meccanismi che ancora dobbiamo vedere dobbiamo studiare comunque l'idea è che chi si logga alla rete wifi condivide con la rete una chiave k una sorta di master secret ok? che è quel k che vedete quindi tutti gli utenti della rete wifi condividono la chiave k il segreto che viene usato come seme per il nostro per il nostro prg ora già all'epoca si sapeva che gli stream cipher sono vulnerabili al to time pad ovvero se voi usate la stessa chiave per cifrare due diversi messaggi ok? la chiave diventa immediatamente vulnerabile c'è un attacco che abbiamo fatto vedere un po' qualche settimana fa per cui l'avversario deduce immediatamente il valore della chiave se voi la usate due volte quindi i progettisti sapevano che la chiave k non poteva essere usata due volte per cifrare diversi messaggi no? ok? quindi sapevano che chiaramente come input al prg di rc4 non si poteva mettere direttamente k ah ma come mai non è riuscito ad entrare? aspetta però io non la vedo in attesa come mai non la vedo in attesa no? anche perché dovrebbe riuscire a entrare senza ma forse ha provato a collegarsi al di fuori dell'autenticazione Uniurb perché lei è sempre riuscita ad entrare non c'è la sala d'attesa no no no non c'è la sala d'attesa evidentemente sta provando ad entrare senza essersi prima autenticata sulla rete beh se comunque entra va su link da blended prima si deve autenticare che a forza quindi per cui se non so se ha bypassato blended in qualche modo però dovrebbe ma che strano non no no infatti no ma non c'è neanche la richiesta di di di di di di di ma ecco il suo account in Uniurb eh prova un po' a vedere se se abbiamo io non ho fatto niente di diverso dal solito per avviare la classroom che sta è strano ma è anche adesso è ancora giusto no? aspetta un po' allora aspetta un po' e quindi io cosa ho fatto partire? un'altra ma non è quella lì di un'altra un'altra ah io posso provare a uscire e rientrare per vedere che cosa mi spattano devo interrompere la registrazione rompiamo