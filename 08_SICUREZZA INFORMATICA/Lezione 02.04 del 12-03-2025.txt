ok bene oggi andiamo avanti con il tema della confidenzialità e cominciamo a rilasciare alcune delle condizioni che abbiamo posto fino all'inizio ovvero fino ad ora avevamo assunto che ogni chiave venisse usata una sola volta quindi per cifrare un solo messaggio ok e abbiamo sotto questa condizione abbiamo visto che la nozione corretta di sicurezza da usare è quella della semantic security ok oggi vediamo che se vogliamo rilassare la condizione sull'utilizzo della chiave dobbiamo estendere la nozione di sicurezza perché la semantic security di per sé non è più sufficiente in particolare vedremo che cosa succede quando l'intento è quello di utilizzare la stessa chiave per cifrare più messaggi diversi questo è quello che vedremo prima vi farò vedere che comunque esiste sempre la possibilità di chiaramente usare una sola chiave per messaggio e quindi se ci sono più messaggi da cifrare cambiare chiave ogni volta chiaramente questo ha un impatto dal punto di vista pratico abbastanza importante però sotto questa diciamo condizione particolare vedremo adesso che la sicurezza semantica continua a essere una nozione accettabile nel momento in cui però rilassiamo questa condizione vedremo che c'è una tipologia di diciamo di attacco di attacco game che vedremo tra poco e che fa sì che la nozione di sicurezza vada vada estesa vada cambiata perché nel momento in cui usassimo due volte la stessa chiave renderemmo il cifrario vulnerabile ok faccio un esempio estremamente banale del motivo per cui dovremmo fare questa estensione assumete di usare uno string cipher ok ora lo string cipher cosa dice di fare di prendere la chiave cioè il seme usarla per generare una string cipher cosa dice di un prg e poi fare lo che sort la string cipher ando me è il plain text ok ora fate questa operazione una volta per cifrare un messaggio e chiaramente se lo rifate una una seconda volta vi esponete la vulnerabilità ad esempio poniamo il caso che sia l'avversario a sottoporre al al cifrario un plain text di sua scelta ok chiaramente l'avversario non conosce la chiave però vede il risultato della cifratura conoscendo il plain text e conoscendo poi il ciphertext che che osserverà chiaramente saprà imparerà invertendo l'operazione di xor qual è stata la stringa pseudo random che è stata utilizzata appunto per generare il ciphertext ok e se lo stesso meccanismo viene usato per cifrare un secondo plain text la stringa pseudo random sarà sempre la stessa perché se non cambia la chiave prg è deterministico e quindi il risultato dell'applicazione per regia sulla chiave della sempre la stessa stringa pseudo random e quindi loxor verrebbe fatto usando una stringa che l'avversario già conosce quindi questo chiaramente comprometterebbe la confidenzialità del secondo messaggio che si va a cifrare questo un esempio banale di come un avversario può compromettere la confidenzialità per per uno string cipher se non si ha l'accortezza di modificare la chiave per ogni diverso messaggio che viene cifrato come vedremo oggi nessun cifrario semanticamente sicuro deterministico preserva la sicurezza in un contesto di questo genere in un contesto dove abbiamo necessità di incifrare diversi diversi diversi messaggi e quindi dovremmo intervenire e vedremo particolare che dovremmo in qualche modo rendere rendere il cifrario non più non più deterministico e in particolare vedremo che utilizzando le probabilità quindi rendendo il cifrario probabilistico risolveremo questo problema ora partiamo da dalla prima considerazione che ho fatto ovvero supponiamo di avere tanti messaggi da cifrare che cosa succede se io cambio chiave per ogni messaggio che devo cifrare la soluzione più banale che possiamo pensare di realizzare l'attacca game corrispondente quello che vedete qui non è altro che l'estensione naturale dello stesso attac game che abbiamo visto per la definizione della semantic security è lo stesso identica tag game l'unica differenza è che l'avversario non sottomette una sola coppia di messaggi per la cifratura ma ne sottomette una sequenza perché ne sottomette una sequenza perché abbiamo appena detto che l'idea non è più quella di cifrare un solo messaggio ma di cifrarne tanti diversi quindi nella tag game l'avversario sottomette al challenger una sequenza di coppie di messaggi di coppie di plaintext e come già abbiamo visto nella tag game della semantic security per ogni coppia di messaggi che il challenger riceve a seconda dell'esperimento in cui ci troviamo l'esperimento 0 l'esperimento 1 il challenger cifrerà uno dei due plaintext ok l'esperimento non cambia per tutta la durata della diciamo dell'attività quindi per tutte le coppie della sequenza stabilita dall'avversario l'esperimento rimane sempre lo stesso ok quindi per ogni coppia che il challenger riceve che cosa fa in base all'esperimento cifra uno dei due messaggi della coppia e restituisce il ciphertext all'avversario la cifratura come potete vedere viene fatta usando ogni volta una chiave diversa ok quindi il challenger cambia chiave ogni volta infatti vedete che vediamo un po' non riesco a scrivere stavolta ok vedete che per ogni query cioè per ogni coppia di messaggi che l'avversario manda al al challenger il challenger calcola una nuova chiave con la quale cifrare uno dei due messaggi dipende dall'esperimento e restituire il ciphertext all'avversario ok quindi di fatto l'estensione dell'attac game per la semantic security al caso in cui l'avversario sceglie una sequenza di coppie piuttosto che una sola coppie dopodiché il comportamento è quello già descritto in passato l'avversario a un certo punto smette di sottomettere coppie al challenger e attraverso il proprio algoritmo efficiente determina un risultato e come al solito il vantaggio dell'avversario è la differenza tra la probabilità di due eventi ovvero l'evento in cui l'avversario spara il risultato 1 se l'esperimento era 0 e l'evento in cui l'avversario spara lo stesso risultato se invece l'esperimento era 1 quindi come al solito tanto più piccola è la differenza tra queste due probabilità tanto più indistinguibili sono i due i due esperimenti dal punto di vista dell'avversario e quindi la definizione di sicurezza in questo contesto che chiamiamo multi key semantic security multi key proprio perché per ogni per ogni messaggio per ogni messaggio la chiave cambia ok però ogni messaggio la chiave cambia e che dice la notazione che dice appunto che il nostro cifrario è multi key semantic security se il vantaggio dell'avversario è trascurabile per tutti gli avversari ufficieri ok è sempre una scelta in maniera randomica sì sì dall'insieme delle chiave ok c'è un teorema che dice che se un cifrario è semanticamente sicuro in base alla nozione di sicurezza che abbiamo visto qualche settore fa allora è anche multi key semanticamente sicuro ok intuizione abbastanza ovvia perché se se un cifrario è sicuro nel cifrare un messaggio con una chiave allora lo è anche nel cifrare n messaggi con n chiavi diverse importante che non ci sia un legame tra le diverse tra le diverse chiavi ora di questa nozione se in realtà ce ne facciamo poco perché in contesti reali difficilmente abbiamo a disposizione così tante chiavi però ci servirà come ispirazione per il metodo che vedremo poi più avanti ok vediamo invece come si definisce l'attack game nello stesso scenario in cui l'avversario sceglie una sequenza di coppie da inviare al challenger però questa volta a differenza di prima il challenger usa sempre la stessa chiave ok invece di cambiarla quindi il challenger ha a disposizione un'unica chiave k per cifrare i messaggi che gli vengono sottoposti quindi questo tag game è identico al precedente con questa differenza il challenger non può cambiare chiave dopodiché lo svolgimento della tag game come abbiamo visto prima ovvero l'avversario sceglie una sequenza di coppie di messaggi sottopone al challenger a seconda dell'esperimento in cui ci troviamo il challenger cifra uno dei due messaggi e restituisce il ciphertext all'attaccante all'avversario e la condizione è esattamente la stessa che abbiamo visto prima questo tag game prende il nome di chosen plaintext attack ok si chiama così o CPA CPA appunto sta per chosen plaintext attack si chiama così perché è un attacco in cui è l'avversario appunto a scegliere i plaintext da sottoporre al al challenger in sequenza ok e la nozione di CPA security che cosa ci dice ci dice appunto che è un cifrario semanticamente sicuro rispetto al chosen plaintext attack se come al solito il vantaggio dell'avversario è trascurabile per tutti gli avversari efficienti quindi vedete che questo tag game estende quello che abbiamo visto qualche lezione fa nel senso che la chiave che si usa è sempre la stessa però invece che cifrare un solo messaggio ne devo cifrare una sequenza e questo fa un po' saltare il banco nel senso che i cifrari che erano semanticamente sicuri rispetto alla nozione vecchia rispetto a questa nuova nozione non sono più sicuri ok lo vediamo banalmente attraverso un esempio in particolare nessun cifrario deterministico può essere cpa sicuro può essere sicuro rispetto a questa nozione più realistica no di attacco più realistica proprio perché si dà la possibilità all'avversario di sottomettere più più messaggi non lo so e la dimostrazione di questa proposizione ve la faccio vedere perché è piuttosto semplice e ci mostra una strategia dell'avversario per vincere sempre il gioco una strategia che consente all'avversario di avere un vantaggio che è il massimo possibile perché è un vantaggio pari a uno e qual è questa strategia? beh l'avversario sceglie due messaggi diversi tra di loro no e li sottopone al challenger il challenger a seconda dell'esperimento in cui ci troviamo cifrerà m oppure m primo no e il ciphertext ottenuto viene restituito all'avversario e questo è la prima è il primo round l'avversario va avanti fa un secondo round e sottomette questa coppia ovvero la coppia di messaggi m m quindi sempre lo stesso plaintext lo può fare dove m è esattamente il primo elemento della coppia del round precedente anche in questo caso il challenger sceglierà uno dei due in base all'esperimento ma qualunque sia l'esperimento il messaggio scelto è sempre quello perché è sempre m e restituisce il ciphertext all'avversario a questo punto l'avversario non deve fare altro che confrontare i due ciphertext ok se i due ciphertext sono uguali l'avversario può concludere che eravamo nell'esperimento zero ok se invece i due ciphertext sono diversi allora l'avversario può concludere che eravamo nell'esperimento uno nell'esperimento zero il challenger sceglie il primo elemento della coppia nell'esperimento uno sceglie il secondo elemento della coppia quindi se eravamo nell'esperimento zero il challenger ha scelto m sia al primo round che al secondo round e quindi per forza c1 uguale a c2 perché? perché il cifrario è deterministico un cifrario deterministico è un cifrario che se usa la stessa chiave e gli viene dato in pasto lo stesso messaggio produrrà sempre lo stesso risultato ok quindi c1 sarà uguale a c2 se invece eravamo nell'esperimento uno il challenger avrà cifrato m primo al primo round avrà cifrato m al secondo round e quindi i due ciphertext saranno diversi ok ok quindi di fatto da questo confronto tra c1 e c2 l'avversario impara con probabilità uno qual è l'esperimento in cui ci troviamo ok quindi la differenza tra la probabilità di quei due famosi eventi è massima perché questa è la probabilità che l'avversario spari uno quando siamo nell'esperimento zero no e questa probabilità è uguale a uno perché l'avversario sa con certezza se siamo nell'esperimento zero ok questa invece è la probabilità che l'avversario spari uno quando invece siamo nell'esperimento uno ma questa probabilità è pari a zero perché di nuovo l'avversario sa con certezza quando siamo nell'esperimento uno sempre attraverso questo questo confronto qui e la differenza tra queste due probabilità è la massima possibile è uno quindi il vantaggio dell'avversario è il massimo possibile tutt'altro che trascurabile è pari a uno quindi vuol dire che l'avversario ha una strategia per stabilire con certezza in quale esperimento ci troviamo ok nella pratica le conseguenze di questa strategia sono quelle dell'esempio che vi ho fatto prima no ovvero prendete in considerazione uno stream cipher l'avversario sceglie un certo messaggio faccio un esempio pratico io so che la vittima manda una mail alla vittima ok so che il server della vittima cifra no tutte le mail in arrivo per memorizzarle in maniera confidenziale sul sull'hard disk del server lui è usando uno stream cipher ipotizziamo che l'avversario riesca ad accedere all'hard disk e quindi a vedere i ciphertext che sono memorizzati di sopra quindi l'avversario manda un plaintext m al server e osserva poi il ciphertext che viene memorizzato nell'hard disk ok l'avversario non conosce la chiave usata per ottenere c però sa che viene stato usato uno stream cipher per cui sa che c è il risultato dell'oxor tra m e una stringa pseudorandom ma questa stringa pseudorandom che cos'è? è il risultato dell'applicazione del PRG alla chiave k ok ora l'avversario conosce m conosce c di conseguenza impara il valore di s quindi di fatto sa qual è la stringa che viene legata in s or con m per ottenere c a questo punto la chiave è compromessa anche se l'avversario non conosce la k in ogni caso la k è compromessa perché? perché qualunque altro messaggio che voi andate a cifrare usando la stessa chiave l'operazione da fare sarà sempre questa ok quindi ma s è la stessa di prima perché? perché il PRG di lo string software è deterministico quindi l'avversario che vede sullo stesso hard disk un altro cifrtext cifrato nella stessa maniera siccome s la compromessa ecco che riesce a ottenere qualunque altro plaintext cifrato con quella stessa a partire dalla stessa chiave quindi questa è una conseguenza pratica un esempio pratico della strategia che rappresenta la dimostrazione del fatto che qualunque cifrario deterministico non può essere cpa sicuro cioè non può essere sicuro rispetto ad attacchi condotti da avversari che hanno la possibilità di sottomettere più plaintext al al cifrario ok e chiaramente nella pratica noi ci aspettiamo di usare cifrari cpa sicuri perché altrimenti l'unica alternativa che abbiamo è tornando indietro usare semplicemente un cifrario deterministico semanticamente sicuro però sappiamo che in quel caso siamo obbligati a cambiare chiave per ogni messaggio perché cifrari semanticamente sicuri deterministico deterministici sono multichissimaticamente sicuri cioè continuano a essere sicuri purché come abbiamo visto prima cambino la chiave per ogni per ogni messaggio ok però ripeto essendo questa una condizione piuttosto irrealistica nella pratica l'idea qual è? l'idea è di passare a cifrari che non sono più deterministici perché vogliamo garantire l'adozione di sicurezza descritta dall'attack game che abbiamo appena visto ok quindi questo è il motivo per cui nella pratica non si usano cifrari deterministici a meno che appunto non si ha la possibilità di cambiare chiave così frequentemente da garantire che ogni messaggio sia cifrato che ogni chiave venga usata una sola volta ma in realtà si usano come vedremo cifrari probabilistici ok non più deterministici cosa vuol dire questo? allora l'abbiamo visto prima quando è che un cifrario è deterministico? beh un cifrario è deterministico se quando gli date in pasto un plaintext usando una certa chiave questo è il nostro cifrario il risultato è sempre comunque lo stesso cifrario cifrate N con K ottenete sempre comunque lo stesso cifrario ok se volete ottenere l'abbiamo visto prima un cifrario un cifrario un cifrario un cifrario un cifrario un cifrario cifrario cifrario allora dovete cambiare la chiave ecco esattamente quello che abbiamo visto che abbiamo visto prima ok i cifrari probabilistici invece sono tali per cui se prendono in pasto un messaggio e una chiave K restituiscono non più in maniera deterministica un unico possibile cifrario ma restituiscono che cosa una distribuzione di probabilità su tanti diversi cifrario cifrario ok quindi questo cosa significa significa che se faccio un caso se voi cifrate due volte lo stesso messaggio usando la stessa chiave potreste tranquillamente ottenere due cifrario text inversi proprio perché cifrario non è più deterministico ma è probabilistico perché perché questo torniamo indietro torniamo indietro alla strategia dell'avversario che gli faceva vincere l'attack game della cpa security rispetto cifrario deterministici ok la stessa strategia che abbiamo descritto in questo slide non funziona più se il cifrario è probabilistico per quale motivo perché immaginiamo di essere nell'esperimento zero quindi il il challenger la prima volta al primo round cifra m e otteniamo un c1 ok la seconda volta quando si ritrova a cifrare di nuovo m otterrà un c2 che non è detto che sia uguale a c1 perché se il cifrario è probabilistico la prima volta che cifrate m con k potreste ottenere un c1 la seconda volta che cifrate m sempre con k potreste ottenere un altro cifrario c2 diverso da c1 proprio perché il cifrario è probabilistico quindi questo test qui fatto dall'avversario non ha più alcun senso perché perché molto probabilmente per entrambi gli esperimenti avverrà questo che c1 è diverso da c2 e quindi l'avversario non sarà più in grado di capire se eravamo nell'esperimento 0 o nell'esperimento 1 e questo quindi vanifica la strategia dell'avversario e ci permette di garantire la sicurezza del cifrario ok come si fa a rendere probabilistico un cifrario a definire un cifrario probabilistico come vedremo l'idea è di partire comunque da un cifrario deterministico perché quelli li abbiamo già sappiamo come funzionano e introdurre un qualche elemento randomico che li renda probabilistici questa è l'idea ci sono diversi modi di fare questa cosa un modo teoricamente piuttosto semplice consiste nello sfruttare i prf cioè l'epseo durando un function che abbiamo visto settimana scorsa quindi un'idea è quella di prendere appunto un cifrario deterministico comporlo nel modo che vedremo con un prf e ottenere quindi un cifrario probabilistico ok nella pratica il prf può essere come ben sappiamo rappresentato da un block cipher con dominio super poli se vi ricordate ok come avviene la composizione allora immaginate di avere un cifrario deterministico poi prendete una pseudo random function f la composizione che ci darà come risultato un cifrario probabilistico la si fa in questo modo andiamo a vedere come funziona la cifratura ok immaginiamo che l'unica chiave condivisa all'inizio da le par da chi fa cifratura sia k' ok e quella non cambia mai allora la cifratura usando k' di un plaintext m si fa nel seguente modo si sceglie in maniera randomica un input per il prf ok quindi questo x è scelto randomicamente potete fare ad esempio una campionatura in base ad una distribuzione di probabilità uniforme tra tutti gli elementi del dominio del prf ok dopodiché che cosa si fa si applica il prf usando k' all'input che è stato scelto probabilisticamente ok l'output lo chiamiamo k dopodiché il k generato in questa maniera lo usiamo per cifrare il plaintext m usando il cifrario deterministico l'esito che andremo a trasmettere sarà la coppia valore randomico x cifr text c quindi vediamo graficamente che cosa succede abbiamo m ok questo è il plaintext abbiamo k' questa è la chiave l'unica chiave condivisa che abbiamo fin dall'inizio prima cosa che si fa in maniera randomica scegliamo un valore x ok dopodiché usando k' e usando x come input applichiamo il nostro prf e il risultato sarà un valore k ok a questo punto usiamo k come chiave per cifrare il plaintext usando il cifrario deterministico che avevamo e il risultato sarà il nostro c chi deve fare la decifratura di che cosa ha bisogno ha bisogno di c ma ha bisogno anche di x perché chi deve fare la decifratura che cosa fa chi deve fare la decifratura è colui che condivide k' con chi ha fatto la cifratura quindi che cosa fa applica anche lui il prf usando k' su x per ottenere k e una volta che ha ottenuto k farà la decifratura di c per recuperare m quindi qual è l'idea di fondo l'idea di fondo è che io la chiave non la posso cambiare perché è k' e quella è e quella rimane però usando k' ne posso generare un'altra ogni qualvolta devo fare una cifratura e usarla per fare la cifratura perché in realtà vedete che la chiave di cifratura alla fine è k ma chi è k k è un qualcosa che deriva da k' tramite un prf c'è una chiave secondaria c'è una chiave secondaria c'è una chiave primaria che è il segreto condiviso tra dice bob e quella non cambia mai poi c'è una chiave secondaria che deriva da quella condivisa e e che viene usata per fare la cifratura vera e propria ok facciamo un caso pratico immaginiamo di usare come prf as il block cipher as immaginiamo di usarlo anche come cifrario deterministico ok quindi possiamo assumere che sia questo che questo sono as perché as contemporaneamente è un cifrario deterministico ma sappiamo anche che è un prf se il dominio dei blocchi ad esempio nel caso di s 128 è superpolico ok quindi in questo caso pratico per fare una cifratura a partire da una chiave condivisa k' che cosa dobbiamo fare dobbiamo lato lato mittente dobbiamo scegliere un valore randomico x cifrarlo con k' usando as il risultato di questa cifratura lo usiamo come chiave per cifrare il plaintext m ok è chiaro che un avversario che non conosce mettetevi nei panni di un avversario che conosce x perché x viene trasmesso insieme a c ma anche se conosce x non conoscendo k' se f un prf sicuro non è in grado di indovinare chi sia k lo dobbiamo cambiare per ogni massaggio esatto esatto perché perché è cambiando x che abbiamo la garanzia che se andiamo a cifrare due volte lo stesso messaggio otterremo comunque cifratex diversi perché se cambia x chiaramente cambierà la chiave di cifratura di n giusto? se voi cifrate m due volte la prima volta userete un certo x e quindi una certa chiave che darà luogo a un certo cifratex la seconda volta cambiate x ma cambiando x cambierà la chiave con cui cifrate m e quindi interrete un altro sai perché in questa maniera qui Alice e Bob riescono a mettersi d'accordo su una sequenza di chiavi partendo dal fatto che ne condividono una sola che è k' a primo ok nel caso multi key di cui parlavamo prima l'esigenza è che Alice e Bob x non deve essere condivisa perché viene trasmessa quindi non deve essere condivisa a priori invece nel caso multi key Alice e Bob fin dall'inizio devono condividere n chiavi diverse è lì la complicazione far condividere tante chiavi Alice e Bob invece in questo caso ne condividono una sola e a partire da quella ne possono generare di comune accordo un numero a piacere se vi ricordate è la stessa idea dell'esempio che avevamo visto la settimana scorsa del del protocollo per permettere ad Alice e Bob di capire se condividevano il nostro solo valore e lì a ogni stanza del protocollo usavano una chiave diversa e come facevamo a far condividere ad Alice e Bob tante chiavi diverse partendo dal proposto che in realtà ne condividere uno sola si usava un PRF sì sì assolutamente il PRF è deterministico ok ma perché questo meccanismo è probabilistico perché alla fine abbiamo definito un cifrario come composizione è vero che il cifrario che abbiamo definito è la composizione di un cifrario deterministico e un PRF che è deterministico però perché diventa probabilistico perché c'è questo elemento qui che è scelto probabilisticamente qui c'è un input di questa composizione che è randomico ok e quindi è questo elemento qui che rende l'intero l'intero l'intero meccanismo che abbiamo descritto qui graficamente è probabilistico proprio in virtù del fatto che uno dei suoi input questo è randomico ok quindi questo nuovo algoritmo che abbiamo descritto qui è la composizione è sì la composizione di due meccanismi entrambi deterministici ma dove c'è un input probabilistico quindi nella sua interezza è di fatto probabilistico perché a questo punto partite da k' volete cifrare m applicando il meccanismo che abbiamo appena visto di fatto ottenete una distribuzione di probabilità su tanti possibili ciphertext perché perché ognuno sarà associato a un x diverso scelto randomicamente quindi per un certo x1 verrà fuori c1 per un certo x2 verrà fuori c2 e così via questa distribuzione di probabilità è uniforme perché i x i sono scelti randomicamente in base alla distribuzione di probabilità uniforme e quindi di conseguenza la scelta fra questi ciphertext di nuovo segue una distribuzione di probabilità uniforme ok questo teorema qua ci dice che questa costruzione è sicura perché questo teorema ci dice che se voi usate un prf sicuro ad esempio AS128 e usate un cifrario semanticamente sicuro ad esempio che ne so uno string cipher basato su un prg sicuro ma potete combinare queste cose qua e c'è una condizione in più che adesso cerchiamo di capire il dominio del prf è super poli il dominio del prf è super poli allora questa costruzione è cpa sicura quindi vuol dire che è robusta rispetto alla cpa attacca che avevamo descritto prima quello in cui l'avversario sottomette tante coppie e così via ok perché è necessario che il dominio di f sia super poli il motivo è questo x l'elemento randomico è un elemento del dominio di f perché è un input per il prf allora se il dominio di f non fosse super poli la probabilità di indovinare x sarebbe non trascurabile no mettetevi immaginate una strategia banale dell'avversario ok che è mirata appunto a a a a a indovinare un valore di x lo vede ma dopo che è stato dopo che è stato scelto sì sì quello lo lo lo vede ok assolutamente perché vale lo stesso discorso di prima perché se non fosse super poli la probabilità per l'avversario di indovinare la chiave sarebbe non trascurabile se invece è super poli la probabilità è uno su una quantità super poli quindi è trascurabile ok è vero che è vero che la domanda che hai fatto è corretta è vero che l'avversario x lo vede il punto non è il fatto che lo veda non lo veda il punto è che torniamo qui no no ma te lo faccio vedere su questo ti ricordi la strategia che ha l'avversario per vincere il cpa attack game nel caso dei dei cifrari deterministici ora applica questa stessa strategia al cifrario probabilistico che abbiamo appena visto ok quindi la strategia dell'avversario è questa scegliere mm primo la primo round e mm secondo allora se il cifrario è probabilistico noi ci aspettiamo che c1 sia diverso da c2 sia nell'esperimento 0 che nell'esperimento 1 proprio perché il cifrario probabilistico ok ma andando a vedere come l'abbiamo definito il cifrario probabilistico è proprio vero che la probabilità nell'esperimento 0 che c1 sia diverso da c2 è vero? torna qui è vero che c1 è diverso da c2 con probabilità 1 ovvero c1 è uguale a c2 con probabilità 0 se tu fai la cifratura due volte dello stesso m usando questo meccanismo qua no cosa può capitare? siccome x è scelto randomicamente no quindi è come dire che te fai una campionatura dal dominio del prf e dici scelgo quell'x lì allora esiste la possibilità che lo stesso x venga scelto due volte no ora se lo stesso x viene scelto due volte che cosa succede? succede questo no cioè se disgraziatamente siamo nell'esperimento 0 e disgraziatamente il challenger sceglie lo stesso x due volte quindi sia per cifrare m nel primo round che per cifrare m di nuovo al secondo round in quel caso viene fuori che c1 uguale a c2 e quindi l'avversario vince la tag gain ok ora se la il dominio del prf è super poli la probabilità di beccare lo stesso x due volte è trascurabile no perché è 1 su una quantità super poli quindi negligible ok quindi è vero che scusa è vero che la probabilità di questo evento è diversa da 0 perché può capitare ma è comunque trascurabile se il dominio di f è super poli e a noi questo ci basta perché ci basta ci basta perché che sia trascurabile perché se andiamo a rivedere la nozione di cpa security come tutte le altre che abbiamo visto in passato questa ci dice che il vantaggio dell'avversario deve essere trascurabile ok quindi tornando alla sua strategia è vero è vero che in questo caso la probabilità di questo è 0 mentre invece in questo esperimento la probabilità di questo è diversa da 0 ma è una quantità diversa da 0 che comunque è trascurabile se il dominio del prf è super poli è chiaro quindi il motivo per cui abbiamo questa condizione qua su f quindi basta prendere un prf sicuro con dominio super poli ad esempio s128 basta prendere un cifrario semanticamente sicuro deterministico uno qualunque di quelli che abbiamo visto nelle altre lezioni quindi un string cipher un block cipher quello che volete li componete in questa maniera qua ed ecco che ottenete un cifrario probabilistico che è CPA sicuro questo è questa è la costruzione teorica più semplice per passare da cifrari deterministici a cifrari probabilistici ok ed è uno dei motivi per cui voi nella realtà non potete prendere che ne so AS128 e brutalmente usarlo per cifrare i vostri plaintext usando sempre la stessa chiave non va bene farlo no? perché AS128 è deterministico bisogna renderlo probabilistico per fare cifratura e in che modo lo si rende probabilistico ad esempio in questa maniera qua ok nella pratica si fa qualcosa di leggermente diverso rispetto a questa idea teorica qui e ci sono due approcci che vanno per la maggiore e che vengono utilizzati in letteratura per rendere probabilistici cifrari deterministici ve li faccio vedere perché sono interessanti entrambi e sono poi di fatto quelli utilizzati in molti in molti contesti il primo approccio è questo che è un'idea simile a quella che abbiamo appena visto perché perché di nuovo si utilizza un cifrario deterministico e si usa un PRF e li si combinano insieme sfruttando un input randomico per creare un cifrario probabilistico lo si fa in maniera leggermente diversa rispetto a quello che abbiamo visto prima perché la costruzione che vedremo adesso risulta essere particolarmente efficiente dal punto di vista delle performance però esattamente come prima che cosa succede? succede che un input per il PRF ok viene scelto randomicamente e questo è il dominio del PRF no? vedete è il dominio del PRF quindi esattamente esattamente come prima quindi X viene scelto randomicamente e viene dato in pasto al PRF usando come chiave la chiave K l'unica chiave K che è condiviso dalle parti ok? infatti vedete che no? succede succede questo adesso uniremo per un attimo il ciclo perché tra poco chiareremo a cosa serve però adesso cerchiamo le analogie con l'idea generale che abbiamo visto prima l'idea generale dice scegliete un input randomico per il PRF applicate il PRF e ciò che ottenete è la chiave vera e propria che dovete usare per cifrare il il plaintext qui l'idea della cifratura è quella di OTP no? perché come potete vedere l'output del PRF che sarà randomico viene legato combinato in XOR e questa è la cifratura quindi di fatto il cifratura che viene usato è OTP con che cosa? col plaintext quindi è esattamente l'idea di prima nel caso particolare in cui la cifratura si fa tramite OTP ok? il esatto esatto in questo caso K è l'unica chiave condivisa a priori dalle parti ok? dopodiché la cosa qui da mettere in evidenza è che questo vedete questa operazione viene eseguita all'interno di un ciclofor perché dobbiamo assumere che il messaggio sia diviso in tanti blocchi ok? e ogni blocco del messaggio viene cifrato in questa in questa maniera qua perché dobbiamo presumere che il messaggio sia diviso in blocchi? perché non possiamo assumere quanto sia lungo il plaintext mentre invece sappiamo che il il PRF produce stringhe di una lunghezza fissa stabilita dal codominio ok? quindi questi output qui hanno una lunghezza fissa ad esempio che ne so vogliamo che Y sia insieme dei blocchi di 256 bit ok? quindi il PRF restituisce una stringa lunga 256 bit no? e se il plaintext è un mega che cosa faccio? cosa faccio? prendo il plaintext lo spezzo in tanti blocchi ok? in maniera tale da avere blocchi di lunghezza pari a quella delle stringhe del codominio del PRF e quindi poter fare lo XOR ok? ok? è chiaro che se ho la necessità di spezzare il plaintext in tanti blocchi e fare questo giochino su ciascun blocco no? io non voglio usare la stessa chiave di cifratura per ogni blocco perché se no ricado nel problema che abbiamo detto fin dall'inizio la chiave deve sempre cambiare ok? e infatti vedete che per ogni blocco la chiave cambia perché cambia? la chiave per cifrare ogni blocco è è questa no? il risultato dell'applicazione del PRF che va in XOR col blocco ma la chiave cambia di blocco in blocco perché? perché di blocco in blocco cambia l'input del PRF la chiave è sempre K ma l'input cambia vedete? l'input non è semplicemente il valore randomico X se fosse semplicemente X cioè se io usassi sempre questo F di K X sur tutti i blocchi di M quindi vorrebbe dire che io la stessa chiave la uso per ciascun blocco e non va bene posso usare una volta sola quindi come faccio? in realtà qui l'input lo rendo parametrico rispetto al blocco e infatti vedete che qui dentro si usa non X ma X più J dove J è l'indice del blocco X è fisso viene scelto randomicamente e rimane quello ok? poi per il primo blocco l'input del PRF sarà X più 1 per il secondo blocco X più 2 per il terzo blocco X più 3 poi uso modulo N perché? perché quando sono arrivato all'ultimo devo ricominciare da capo ok? N N questo N grande qui è la cardinalità del numero di blocchi ok? faccio un esempio immaginate che di avere la cardinalità di X sia 1024 1024 blocchi blocchi estraggo a sorte un X mi viene fuori 1000 ok? quindi il primo blocco del plaintext lo cifro usando come sequenza pseudo random il PRF di K sull'input 1000 il blocco successivo il PRF di K un blocco 1001 poi il blocco 1200 1300 l'input 1400 quando sono arrivato a 1023 devo ricominciare da 0 per quello che è omov2m ok? quindi in questa maniera in questa maniera per ogni blocco del plaintext visto che cambia l'input del PRF cambierà anche il risultato dell'applicazione del PRF e quindi cambierà la stringa pseudo random che va in XOR col plaintext ok? vale valgono le condizioni del teorema che dicevamo prima è chiaro che se il PRF è sicuro anche se l'avversario conosce l'input e lo conosce perché X è trasmesso in chiaro comunque in ogni caso dato che K l'avversario non la conosce l'output del PRF è impredicibile se il PRF è sicuro ma se l'output del PRF è impredicibile è impredicibile anche il risultato di questo XOR quindi l'avversario che osserva il ciphertext dato che questa quantità è impredicibile non ha nessuna informazione per dedurre quanto vale il plaintext ok? lato di cifratura succede la stessa cosa chi deve fare la cifratura conoscendo K è in grado di calcolarsi tutti i PRF necessari per la cifratura applica l'Oxor sulla cifratura ed ecco che recupera il plaintext ok? in che senso non è possibile? il plaintext è più piccolo? se è più piccolo lo riempio con faccio padding del blocco del plaintext aggiungo degli zeri fino a farlo diventare lungo quanto un blocco e poi cifro e poi cifro quel blocco questo succede sempre ad esempio per l'ultimo blocco di plaintext perché magari il plaintext non è un multiplo la lunghezza del plaintext non è un multiplo della lunghezza di un singolo blocco quindi tu avrai sempre l'ultimo pezzettino del plaintext che sarà una porzione di blocco allora quello cosa fai? fai padding cioè aggiungi degli zeri che la farò diventare lungo quanto vuoi per poter fare l'oxor ok questa è un'operazione che si fa tipica il padding si fa sempre quando la cifratura è fatta a blocchi ok questa tecnica prende il nome di randomized counter mode ok ok e di solito il prf che si usa è un block cipher come AS128 perché deve essere un block cipher sicuro visto che il prf deve essere sicuro ok vale il teorema che abbiamo visto prima cioè per il randomized counter mode se f è un prf sicuro e se la dimensione dell'input per il prf è super poli perché questo n che cos'è è la cardinalità del dominio del prf quindi la condizione che avevamo visto prima allora il nostro cifrario è cipià sicuro ok vedete che nel teorema non ci sono condizioni sul cifrario deterministico che si usa perché cosa si usa? si usa OTP no la cifratura si fa usando l'oxor quindi di fatto la cifratura è OTP quindi non ci sono non sono necessarie condizioni aggiuntive perché sappiamo che OTP è sicuro quindi l'unica le uniche condizioni che dobbiamo verificare sono di fatto sul prf e sulla dimensione del suo dominio ok questo è quello che succede un esempio pratico di del randomize counter mode prende il nome di AES counter mode che non è altro che l'implementazione di questo meccanismo dove il prf che si usa è AS128 ok quindi AS counter mode non è altro che l'implementazione di questo meccanismo qui dove AS è il prf che usate AS128 è il prf che usate esistono diversi protocolli che nel mondo reale usano AS counter mode uno di questi che studieremo è IPSEC che è un protocollo per la cifratura a livello di rete quindi a livello IP dei pacchetti ok è chiaro questo c'è un altro approccio che invece prende il nome di cypher blockchaining mode cbc mode che è leggermente diverso rispetto a quello che abbiamo appena appena visto nel quello che abbiamo appena visto si usa un prf in combinazione con OTP in questo che vediamo adesso si usa invece un blockchipher non abbiamo un prf infatti vedete che si usa un blockchipher deterministico per costruirne uno probabilistico e come avviene la la la la cifratura allora ve lo faccio vedere attraverso un esempio perché adesso andremo a interpretare questo questo pseudocodice in cui abbiamo un plaintext diviso in blocchi abbiamo una chiave che è la chiave k condivisa dalle parti e un blocco alla volta vogliamo cifrare il il nostro plaintext ok quindi facciamo così immaginiamo di avere i vari blocchi di plaintext m0 m1 ok fino ad arrivare a all'ultimo che sarà comunque un po' minimalmente limitato e dall'altra parte abbiamo i corrispondenti blocchi di cifratext ok allora il primo blocco di cifratext come viene scelto randomicamente quindi questo è random è l'elemento randomico che rende il cifrario probabilistico ok poi che cosa succede c'è un ciclo in cui si effettua questa operazione che adesso andremo a commentare dove che cosa si fa si prende andiamo un po' a vedere j è l'indice del ciclo j va da 0 all'ultimo blocco meno 1 si prende il plaintext quindi si parte da j uguale a 0 quindi si prende questo si prende il blocco di cifratext corrispondente di pari indice questo che esiste già l'abbiamo scelto randomicamente ok e cosa si fa di questi due si fa il loro XOR e il risultato dell'Oxor viene cifrato col block cipher usando la chiamata quindi il risultato dell'Oxor viene dato in pasto al block cipher usando la chiamata il risultato chi è? è c di 1 questo qui l'abbiamo scelto randomicamente è l'equivalente dell'X dell'altro lo sceliamo a caso è randomico quindi non è la struttura di qualcuno no no sì invece c1 c1 che cos'è? è la cifratura c1 è la cifratura fatta con la chiave K di che cosa? dell'Oxor tra M0 e C0 sì e questa cosa va avanti quindi quando dovremo calcolare C2 chi usiamo come input? quali sono gli elementi che ci servono per calcolare C2? cioè la cifratura useremo C1 che l'abbiamo appena calcolato e useremo M1 cosa faremo? faremo l'Oxor fra C1 e M1 e il risultato lo cifriamo usando la chiave K e otteniamo 152 e questa cosa va avanti la conseguenza qual è? quando arriviamo in fondo avremo che ne so chiamiamolo M di immaginiamo di avere un plaintext di lunghezza massima possibile che è quella L lì ok anzi sarà L-1 perché siamo partiti da 0 quindi visto che M M al massimo contiene L blocchi ok quindi questo questo è l'ultimo blocco del plaintext no qua saremo arrivati a un certo punto a ottenere invece questo no perché perché questo qui che ho appena scritto questo qui l'ho ottenuto combinando M di L-2 con C di L-2 è il prossimo perché no perché io adesso cosa faccio prendo questo prendo questo faccio l'oxor cifro il risultato e ottengo C di M quindi questo cosa significa significa che il ciphertext contiene un blocco in più del plaintext ok ma questo è ovvio per quale motivo perché perché il primo blocco del ciphertext io come l'ho scelto casualmente quindi il primo blocco del ciphertext non è una cifratura del plaintext il primo blocco del ciphertext è un valore casuale tutti i successivi invece sono cifrature del plaintext e quindi ne avrò uno per ogni blocco del plaintext ma se ci pensate alla fine è esattamente come più o meno nel caso precedente perché nel caso precedente andiamo a vedere un attimo torniamo indietro al randomized counter mode il risultato del randomized counter mode era questa coppia cioè un ciphertext lungo quanto il plaintext più un valore randomico no? ma anche qui succede la stessa cosa perché perché il risultato della cifratura sarà un ciphertext che contiene un blocco in più rispetto al plaintext chi è quel blocco in più è un valore randomico ora perché questo cifrario questa costruzione probabilistica è perché il risultato finale cambierà a seconda del primo blocco che ho scelto randomicamente dato che tutti i successivi dipendono dai precedenti il fatto che ha un blocco in più intendo che c contiene un blocco in più rispetto a m e quel blocco in più è il primo che è stato scelto randomicamente perché poi vedi che c1 dipende da m0 c2 dipende da m1 cdl dipende da mdl-1 ok quindi alla fine esattamente come nel randomize counter mode io otterrò una cifratura che è un po' più lunga rispetto al plaintext perché è un po' più lunga rispetto al plaintext perché conterrà l'elemento randomico che rende il cifrario probabilistico questa è l'idea ok quindi vedete sono due strategie un po' dal punto di vista teorico leggermente diverso perché il randomize counter mode si invasa su un PRF e OTP per la cifratura qui invece non usiamo un PRF ma usiamo un block cipher poi nella pratica alla fine di tutto si riconosce a usare sempre gli stessi ingredienti perché nel caso del randomize counter mode ci serve un PRF sicuro guarda caso possiamo usare AS128 qui nel cbc mod ci serve un block cipher sicuro e guarda caso possiamo sempre usare AS128 perché AS128 è sia un PRF sicuro che un block cipher sicuro quindi alla fine l'ingrediente di base è sempre quello AS128 usato in due modi diversi però tra questi due modi c'è una differenza sostanziale che riguarda le performance ora guardate questo per calcolare questo vi serve vi serve questo e così vi è incascata quindi la generazione del DC è per forza sequenziale no torniamo invece al randomize counter mode qui la generazione di DC è per forza sequenziale ogni cj non dipende dal cj non dipende dal cdj-1 cdj dipende dal blocco di plaintext corrispondente e dipende da un valore pseudorandom che è un valore che io posso calcolare a priori senza conoscere cdj-1 cdj-2 e così via perché questo è il prf con la chiave k di una quantità che io so già quanto va una volta che ho deciso x una volta che ho deciso x tutti i prf che mi servono li posso già li posso già conoscere li posso già calcolare separatamente quindi questo cosa vuol dire vuol dire che il randomized counter mode si presta molto al calcolo parallelo perché i cj li posso calcolare tutti contemporaneamente dato che uno non dipende dall'altro quindi soluzioni hardware del randomized counter mode possono essere estremamente efficienti perché io posso costruire un circuito che all'interno del quale in parallelo tutti i vari cj vengono calcolati questa cosa non la posso fare nel cbc mode perché nel cbc mode ogni blocco di ciphertext dipende dal precedente e quindi non lo posso parallelizzare ok anche per il cbc mode c'è un teorema analogo al caso del randomized counter mode che dice che se il block cipher che io uso è sicuro ad esempio appunto AS128 e il suo dominio è super poli che è ad esempio il caso di AS128 perché deve essere super poli è il solito discorso perché io devo scegliere randomicamente un blocco e non voglio che ci sia una probabilità non trascurabile che venga scelto due volte lo stesso blocco randomico ok quindi il dominio deve essere super poli ok quindi se il block cipher è sicuro e lavora su un dominio super poli allora la costruzione che abbiamo appena visto è cpa sicuro esempio pratico se come block cipher usate AS128 in questa modalità qui quindi si dice AS in cbc mode allora avete un cifrario cpa sicuro e AS in cbc mode in particolare è usato in diversi protocolli tra cui TLS che lavora a livello di trasporto e PSE che lavorava a livello di rete TLS lavora a livello sopra a livello di trasporto e lo vedremo ovvero a un certo punto quando comincieremo a studiare i protocolli di criptografici per la trasmissione dei dati vi farò vedere nel dettaglio come funziona TLS e al suo interno per fare cifratura viene usato AS in cbc mode ok quindi AS lo potete usare sia in randomized counter mode che in cbc mode e sono le due modalità corrette per fare cifratura sicura ok quindi non basta usare un block cipher brutalmente così com'è perché è deterministico e quindi non va bene bisogna renderlo probabilistico e il randomized counter mode e il cbc mode sono due modi di rendere probabilistico un cifrario deterministico come AS questa è questa è l'idea quindi stiamo iniziando a vedere i cifrari reali quelli che vengono usati effettivamente nei protocolli nei protocolli reali ora sì allora la prima è puramente teorica ok la prima che abbiamo visto questa qua è questa è puramente teorica che ci dice usiamo un prf e un e un block cipher ok le due realizzazioni pratiche in realtà usano solo uno dei due no perché qui usiamo solo il prf e qua usiamo solo il block cipher però sono entrambe diciamo due implementazioni che partono da questa idea comune qua di combinare i due i due ingredienti e e sono indifferenti no le due implementazioni sono indifferenti perché perché c'è il teorema per entrambe no questo è il teorema per il randomize counter mode che ci dice che se il prf è sicuro e lavora con dominio super poli allora la costruzione è cpa sicura ma abbiamo un teorema analogo per il cbc mod perché e se tu confronti i due teoremi alla fine dicono la stessa cosa perché dicono entrambi dicono che la primitiva che viene usata che sia un prf che sia un block cipher deve essere sicura no quindi nel caso del block cipher deve essere sicuro nel caso del prf deve essere sicuro in entrambi i casi le due primitive devono lavorare su un dominio super poli quindi alla fine i due teoremi dicono la stessa cosa se tu usi una primitiva sicura che lavora su un dominio super poli allora atterrai una costruzione cpa sicura quindi sì la risposta alla tua domanda è indifferente usare il randomize il counter mode o il cbc mode è una questione di standard ci sono situazioni in cui si è preferito usare lo standard piuttosto che un altro e anche di implementazioni pratiche perché il randomize il counter mode si presta molto alle realizzazioni hardware che sfruttano il parallelismo quello sì ora entrambe si basano su un valore randomico che deve essere trasmesso in chiaro no nel caso del randomized counter mode è questo xp nel caso del cbc mode è il primo blocco del ciphertext quindi in entrambi i casi c'è un elemento randomico che di fatto viene trasmesso in chiaro così com'è insieme al resto del ciphertext ok questo elemento randomico il gergo viene chiamato nonso viene chiamato ok i nonso sono tutti quei valori scelti casualmente in base alla distribuzione di probabilità uniforme che vengono usati una volta sola e poi più ok e di fatto rappresentano li possiamo vedere come elementi che parametrizzano il cifrario deterministico di partenza no perché l'idea delle costruzioni probabilistiche che abbiamo visto è prendere una primitiva deterministica aggiunge un input randomico che quindi la fa diventare probabilistica ok quindi da questo punto di vista voi potete vedere i cifrari probabilistici come estensioni di quelli deterministici nel senso che voi aggiungete un nonce aggiungete un elemento randomico ok la notazione generale è questa che vedete qui no voi avete un cifrario e la cifratura si baserà con una chiave che non cambia mai sempre la stessa m è il plaintext e questo simbolo questo mu rappresenta il nonce cioè rappresenta l'elemento randomico che di fatto rende probabilistico il cifrario questo cambia ogni volta che avete un certo m da cifrare e quindi cambiando questo cambierà il risultato ok chi fa decifratura non solo deve condividere k con chi ha fatto la cifratura ma deve conoscere il nonce che è stato usato ma è esattamente quello che succede nelle due costruzioni che abbiamo visto perché in entrambi i casi il nonce viene trasmesso nel caso del randomize counter mode viene trasmesso insieme al cypher text nel caso del del cbc mode è esso stesso parte del cypher text è il primo blocco del cypher text e quindi anche in quel caso viene trasmesso e quindi in entrambi i casi si rispetta questo schema generale per cui chi vuole cifrare un plain text deve decidere un nonce e fare la cifratura usando la chiave k chi deve fare la cifratura deve usare la stessa chiave k e sul cypher text però deve conoscere anche il nonce che è stato utilizzato da chi ha fatto cifratura e la condizione di correttezza chiaramente è questa usando sempre la stessa chiave per fare cifratura e decifratura e naturalmente lo stesso nonce riottenete il vostro il vostro plain text quindi quando si parla di cifratura basata su nonce significa questo significa prendere una primitiva deterministica e renderla probabilistica dandogli come ulteriori input un elemento scelto randomicamente come nelle due costruzioni che abbiamo appena appena visto ok io direi che ci possiamo fermare anche qui perché poi rimane un esempio da mostrarvi alla fine di ogni blocco di lezioni sui vari argomenti vi propongo sempre un esempio pratico e l'esempio che vi farò vedere a questo punto domani riguarda il modo in cui cifrari cpa sicuri come le due costruzioni che abbiamo appena visto si usano sono stati usati per ad esempio nell'ambito della memorizzazione dei in questo caso dei film all'interno di supporti come dvd e blu-ray in entrambi i casi per proteggere per proteggere il contenuto e quindi renderlo non copiabile non privatabile diciamo naturalmente si si si si si fa uso di meccanismi crittografici e e vi farò vedere quali sono questi meccanismi eh sia nel caso dei dvd che nel caso dei blu-ray ok e va bene per oggi direi che ci fermiamo qui per oggi per stamattina perché poi ci rivediamo nel pomeriggio dove continueremo invece il discorso relativo alla kill chain e all' attività del red team grazie