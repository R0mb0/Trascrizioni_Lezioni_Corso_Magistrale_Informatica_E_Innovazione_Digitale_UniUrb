benissimo buongiorno a tutti oggi proseguiamo con le esercitazioni e l'esercitazione che abbiamo oggi è un'esercitazione diciamo in previsione di svolgere riguarda questa questa questo questo pacchetto python che è un si chiama nampi o nampai si pronuncia e credo si possa dire in tutti e due i modi quantomeno ho sentito dire alle due le versioni quindi potete scegliere quella che preferite ed è una libreria chiave per per quello che il calcolo scientifico in python diciamo per chi ha un po di dimestichezza con le librerie di calcolo numerico con gli ambienti calcolo numerico sta ecco diciamo al al mondo python un po come come diciamo matlab sta il nucleo di base di matlab sta appunto a tutto l'insieme poi di librerie di toolbox che si che si porta dietro quindi diciamo è l'ambiente di base in cui vengono definiti e poi qualche modo manipolati vengono messi a disposizione anche dei costrutti per manipolare per definire per manipolare per utilizzare degli oggetti che sono degli array multidimensionali e sono fondamentali per tutta una serie di applicazioni di calcolo scientifico ivi compresa ovviamente il machine learning che è il motivo per cui noi li introduciamo allora come sempre non c'è cosa migliore che cominciare a vedere come funziona e mettere un po le mani nel codice per cercare di capire come come questi strumenti lavorano quindi diciamo anche qui il mio consiglio è provare provare a fare provare a modificare vedere effettivamente con le vostre con le vostre mani con la vostra testa come come questo strumento lavora io oggi vi faccio vedere una panoramica generale però ecco l'invito è provare voi stessi ovviamente è la cosa migliore come sempre per imparare a programmare e programmare allora la prima cosa che dobbiamo fare è importare questa libreria nell'ambiente python quindi fare l'import e vedete alla riga 1 di questa cella di codice qui ho preparato un notebook che è dedicato appunto alla all'esercitazione che poi trovate anche su blended learning e qui ci sono varie celle appunto che adesso andremo a vedere insieme di esempio di funzionamento della libreria il primo ovviamente comando che dovete fare è l'import della libreria e questa potete se avete un sistema stand alone python l'avete già scaricata oppure la dovete scaricare e a quel punto diciamo la potete caricare in memoria nel vostro sistema se invece utilizzate un notebook come questo di colab è sufficiente appunto fare un import della libreria e questa poi viene direttamente caricata nel notebook colab vedete per fare l'import è sufficiente scrivere import nampi o import nampi es dopo di che c'è una sorta di alias che viene utilizzato solitamente viene scelto np per comodità per brevità che quelle praticamente l'alias con cui il nome con cui verrà utilizzato da qui in avanti questo questa libreria molto semplicemente vi dicevo il nucleo base sono gli array quindi l'oggetto array unidimensionale multidimensionale e array che possono essere inizializzati semplicemente a partire da ad esempio delle liste python più o meno ogni data a seconda del numero di dimensioni dell'array e gli elementi possiamo accedere poi agli elementi utilizzando le parentesi quadri ma ripeto la cosa migliore provare a vedere vedete che alla riga 3 c'è un comando che è np.array vuol dire che stiamo accedendo a una funzione propria di nampi che ci permette di creare un array array che è stato creato tra parentesi vedete tra parentesi quadri 1 2 3 sono i tre elementi dell'array quindi stiamo creando un array cosiddetto di rank di rango 1 perché è un array unidimensionale poi facciamo una stampa alla riga 4 del del type dell'array e infine quello che facciamo alla riga 5 è stampare la sua shape e alla riga 6 andiamo a stampare i tre elementi con indice 0 1 e 2 è una sintesi molto intuitiva e adesso vedrete che l'output è quello che ci aspettiamo cioè ci aspettiamo che l'output di type di a sia la classe nampi array la shape dell'elemento che abbiamo appena definito di a e 3 virgola il che significa che abbiamo la shape è una funzione un metodo applicato all'oggetto che abbiamo appena creato che vi restituisce qual è la sua la sua dimensione la sua forma in questo caso è una dimensione avendo una sola dimensione vi dice quanti sono gli elementi lungo quell'unica dimensione 3 virgola sta a indicare appunto che ha 3 elementi quindi abbiamo creato di fatto un vettore e poi abbiamo fatto la stampa di ognuno dei tre elementi del vettore ok ci siamo fin qui poi potremmo anche provare a fare creare array un pochino più articolati quindi questo è un array unidimensionale però direi potremmo vedremo dopo degli esempi su array bidimensionali possiamo creare anche array a tre dimensioni e così via in generale quando saliamo appunto dimensioni oltre le matrici quindi vettori e matrici si parla in generale di tensori qui c'è un esempio nelle righe dell'out a 13 commentato di un array tridimensionale quindi un tensore in tre dimensioni lo vediamo semmai alla fine del cioè più avanti nel corso dell'esercitazione se c'è tempo ma è abbastanza anche questo immediato una volta che uno ha avuto modo di sperimentare un pochino come funziona con i casi base quindi vettori e matrici uni e bidimensionali poi estendere ai tensori è abbastanza diretto per cui se c'è tempo ci guardiamo magari più avanti invece andiamo per gradi e andiamo a mandare in esecuzione questa cella del codice questa cella che semplicemente fa che cosa sostituisce l'elemento con il 10 0 con un altro elemento e poi facciamo la print e vedete in questo modo riusciamo a cambiare un elemento dell'array riga successiva creiamo un array con rank con rango 2 quindi di fatto una matrice un array bidimensionale e vedete viene viene creata sempre con il metodo array con la funzione scusatemi array di numpy e a questa funzione passiamo come argomento il esattamente quello che ci possiamo aspettare cioè l'elenco degli elementi dell'array vedete la prima lista definisce la prima riga poi c'è una virgola e tra parentesi abbiamo un'altra lista che che definisce di elementi un altro insieme di elementi che definisce la seconda riga quindi stiamo creando un array che ha due righe e tre colonne infatti quando andiamo a fare la print della shape ci restituisce due 2,3 che significa due righe e tre colonne e la sequenza di elementi che ha messo nella riga ovviamente contenuta tra parentesi quadra quindi 1 2 3 la sequenza di elementi che ha messo nella seconda riga è 4 5 6 tra parentesi quadra io qui gli ho fatto stampare alla riga 3 alcuni elementi che ho identificato con la coppia di indici riga colonna quindi b di 0,0 b di 0,1 b di 1,0 che sono rispettivamente gli elementi con indice 0,0,0 e 1,0 nella matrice quindi chiaramente lui ha stampato 1,2 e 4 se avessi per esempio stampato l'elemento in riga 1 e colonna 2 avrebbe stampato il 6 1,2 e poi invece se invoco print b ottengo chiaramente una print di tutto quello che è l'array in questo caso vedete riga per riga abbiamo l'array che è stato messo anche direttamente nella print sotto forma di riga e colonna fino a qui diciamo definizione di base una prima differenza ecco rispetto ai costrutti base di python degli array numpy e che sono di tipo omogeneo a differenza per esempio delle liste quindi solo elementi dello stesso tipo quindi da questo punto di vista sono array intesi nel senso tradizionale degli algoritmi delle strutture dati della programmazione l'inizializzazione viene fatta l'abbiamo visto tramite la funzione array e qui abbiamo un esempio di un vettore che contiene gli elementi da 0 fino a 5 che è stato inizializzato e poi è stato stampato un vettore un vettore in un array unidimensionali in numpy è un vettore riga per definizione quindi se io vado a mandare scusate se mando in esecuzione la cella di codice successiva dove abbiamo la print di vector di 0, vector di 2 e scusate la print di vector di 0 ovviamente mi stampa il valore 0 poi se vado a sostituire all'elemento con indice 2 il 5 lui mi stampa chiaramente il vettore che è stato modificato e invece con la distruzione della riga 8 abbiamo un reset dei valori originali qui vedete quello che vi dicevo cioè l'array così come l'abbiamo definito è un array riga numpy vi permette di utilizzare, vi mette a disposizione diverse funzioni per creare gli array, per creare degli array particolari e quindi abbiamo alcuni esempi in questa prima cella, adesso qui c'è un import che non è necessario rifare perché chiaramente l'abbiamo fatto prima in questa cella vi dicevo che cosa succede, utilizziamo la funzione zeros che è una funzione che vi permette di creare un array di tutti i 0 e quello che gli dovete specificare è semplicemente la dimensione dell'array, in questo caso due righe e due colonne e vedete lui ve lo stampa, questo lo potete anche modificare ovviamente a piacimento cambiando le righe e le colonne e ottenete ovviamente quello che vi potete aspettare cioè un array di tutti i 0 con righe e colonne inveceversa in qualche caso può essere comodo creare degli array con tutti i 1 e questo può essere fatto con la funzione once quindi np.once accedete alla funzione preposta e passando come argomento, come input da questa funzione il numero di righe e il numero di colonne sotto forma di lista riuscite a creare questo array quindi se vogliamo creare anziché un array di tutti i 1, un array con un valore costante possiamo utilizzare la funzione full che prende come due argomenti, due parametri, il primo è la dimensione dell'array da creare e il secondo è il valore costante che vogliamo creare quindi chiaramente sostituendo a questo un altro valore abbiamo ovviamente una modifica corrispondente che ci aspettiamo la funzione I invece vi permette di creare delle matrici identità chiaramente le matrici identità sono delle matrici quadrate quindi è sufficiente passargli un solo intero che rappresenta il numero di righe e di colonne lui vi crea la matrice identità corrispondente a quella dimensione poi è anche possibile accedere alla sottolibreria di calcolo numerico deputata alla generazione di numeri pseudo casuali per generare dei numeri casuali questo è molto importante in tutta una serie di applicazioni riguardanti la simulazione ma non solo anche riguardanti il machine learning pensate appunto all'inizializzazione casuale di un algoritmo che fa ottimizzazione pensate a tanti casi in cui questo può essere utile quindi per esempio selezionare in un dataset una porzione di questa da destinare al training e una porzione da destinare al test questo viene fatto casualmente quindi è importante avere a disposizione dei meccanismi che siano meccanismi di questo tipo che vi permettano di generare dei numeri casuali con una certa fluidità allora la sottolibreria random è deputata proprio questo e se voi accedete appunto al np.random e invocate la funzione random qui passate numero di righe e numero di colonne questo vi permette di creare un array che assegniamo alla variabile e in questo caso che viene riempito con dei valori casuali in questo caso generati casualmente nell'intervallo in maniera uniforme nell'intervallo 01 quindi tutti i numeri tra 01 hanno la stessa possibilità di essere estratti e di andare a popolare questo array in questo caso 2 per 2 va bene? se abbiamo la necessità di popolare l'array con una distribuzione di probabilità differente che non sia quindi una distribuzione di probabilità uniforme ma che sia ad esempio una gaussiana possiamo farlo andando semplicemente a creare dei campioni casuali che hanno una certa quindi che hanno una distribuzione normale come vi ho evidenziato qui con una certa media e una certa deviazione standard quindi posto che la media sia me e la deviazione standard sigma quadro è sufficiente generare, invocare la funzione np.randn dove quel randn sta per rand normal quindi la distribuzione normale con un certo numero di righe e di colonne creare quell'array e poi andarlo a moltiplicare ad esempio per il valore in questo caso 2.5 se vogliamo creare un array che ha sigma quadro pari a 6,25 quindi sigma pari a 2.5 e ci sommiamo il valore medio e il risultato è questo cioè sono tutti valori vi ha creato una matrice due righe e quattro colonne con valori generati da una distribuzione normale quindi randn ho invocato e questa distribuzione normale ha valore medio 3 e deviazione standard pari a 6,25 va bene? poi quello che possiamo fare ok, qui nella riga successiva abbiamo direi semplicemente una ridondanza con qualcosa che abbiamo già visto definiamo una matrice e vi fa vedere no, forse non l'abbiamo visto sopra quindi è il caso di guardare meglio allora come accedere ai singoli elementi possiamo accedere in due modi passandogli l'indice di riga e di colonna come nella riga 6 oppure come nella riga 8 separati da virgola sono due annotazioni equivalenti tramite le quali voi potete accedere al singolo elemento di qualunque array va bene? quindi parentesi 1, parentesi 2 oppure parentesi 1,2 in questo caso bene, allora il rango dell'array che cos'è? è il numero di dimensioni ok? quindi quella che viene chiamata la shape dell'array la shape dell'array è una tupla di interi che vi rappresentano la lunghezza lungo ogni dimensione quindi se io ho creato un vettore unidimensionale la shape sarà 6, potrebbe essere 6,1 o 1,6 nel caso in cui io specifici un vettore riga o un vettore colonna adesso questo lo vediamo tra poco però sostanzialmente il rango è chiaramente 1 in questo caso nel momento in cui genero un vettore come quello che abbiamo generato prima in questo caso noi andiamo a stampare il rank e la shape e quello che otteniamo è rank 1 shape 6, nel caso della matrice che abbiamo generato sopra che si chiama matrix se andiamo a invocare il metodo shape e poi applichiamo la lunghezza vi restituisce che il suo rank è 2 qui abbiamo costruito noi il rank del vettore cioè shape vi restituisce due argomenti in questo caso 2,3 la lunghezza di quei due argomenti vi dice qual è il rango di quel vettore che in questo caso è 2 cioè il numero di dimensioni dell'array bidimensionale nel caso di un vettore chiaramente la shape è unitario il rank è unitario perché la shape ha una sola dimensione va bene? queste sono cose abbastanza abbastanza semplici per cui semplicemente accedete tramite il metodo shape alle dimensioni delle dimensioni dell'array che avete creato e vi restituisce una lista con tutti gli elementi uno per ogni dimensione la lunghezza di questa lista vi dà il rank dell'oggetto che avete creato ci siamo fin qui? riuscite a seguire? sì, fin qui è tutto chiaro ok, perfetto ovviamente io posso anche invocare delle funzioni che vi permettono di trasformare un vettore in un vettore che abbia una forma diversa quindi ottenere un array con una differenza una differente scusatemi forma una differente shape e quindi posso trasformare il vettore che ho appena definito che è un vettore di default che ha dimensione 6, niente in un vettore che ad esempio è un vettore colonna un vettore colonna specifico tramite il metodo reshape che vado ad applicare all'oggetto vector che abbiamo creato sopra che questo deve avere sei elementi quindi sei righe e una colonna quindi sei elementi sulla riga e un elemento sulla colonna e poi posso andare a stamparne il contenuto e posso andare a vedere che cosa succede anche al vettore originale qui ho creato un nuovo vettore che ho chiamato column vector e andiamo a vedere che column vector vedete è un vettore che in questo caso è un vettore colonna e vi faccio notare che in questo caso la dimensione è 6,1 e lo vedete anche a livello della print perché ogni elemento di quella colonna è riportato tra parentesi tra parentesi quadral mentre il vettore originale rimane un vettore riga che ha dimensione 6,1 mentre qui siamo dimensione 6,1 questa è una distinzione importante perché io posso oltre che 6,1 posso creare anche un vettore con un vettore riga che esplicitamente abbia una riga e 6 colonne e quello avrà una shape 1,6 e quindi da un punto di vista matematico è sempre lo stesso da un punto di vista della programmazione bisogna tener conto di questa diversità per cui attenzione perché quando li create hanno un rango 1 e dimensione chiaramente 6,1 o 10,1 se voi volete creare esplicitamente un vettore colonna o un vettore riga dovete fare una reshape come è stata appena fatta perché è prevista una differenza tra vettore riga e vettore colonna così definiti rispetto al vettore riga di default come viene creato quindi se io vado a fare per esempio il rank del vettore colonna vedete che è un rank 2 cioè vi dice ho due argomenti 6,1 mentre la shape del vettore è 6, ok quindi questa è una differenza di cui tenere presente di cui tener conto da tenere presente di cui tener conto nel momento in cui andate a programmare questi oggetti quindi attenzione alle shape degli array perché appunto quando generate dei vettori vengono generati con rank unitario quando quando generate dei vettori e voi esplicitamente dite è un vettore riga un vettore colonna il rank è automaticamente due cioè avete due dimensioni di cui una lunghezza unitaria e qui vedete c'è quello che vi dicevo cioè io posso prendere lo stesso vettore quindi prendere il vettore colonna fare una reshape e mettere tutti i dati in una riga e 6 colonne e il contenuto chiaramente è questo il rank è due la shape è 1,6 il vettore originale da cui siamo partiti era questo cioè stesso contenuto informativo ma organizzato da un punto di vista dell'oggetto numpy formalmente in maniera diversa ok quindi il vettore che abbiamo chiamato row vector è un oggetto di dimensione 1,6 il vettore che abbiamo chiamato vector che abbiamo generato con quel nome è un oggetto che ha dimensione 6 e basta quindi row vector è di fatto una matrice 1,6 mentre vector è un array unidimensionale quindi la differenza fondamentale è proprio questa in questo che stiamo dicendo e di fatto quello che noi generiamo come abbiamo chiamato vettore colonna row vector o vettore scusate vettore riga row vector o vettore colonna column vector è di fatto una matrice bidimensionale in cui fissiamo una dimensione pari a 1 va bene? ok andiamo ok per riottenere il vettore originale posso fare così a partire ad esempio dal vettore colonna posso invocare di nuovo il metodo reshape da applicare e qui faccio direttamente la print vedete gli posso passare o 6 virgola che è appunto la dimensione la shape che io voglio ottenere oppure semplicemente se è un array unidimensionale passargli un singolo valore che è il numero di elementi che caratterizzano quel vettore e ritorniamo alla versione originale va bene? allora ovviamente abbiamo bisogno di indicizzare l'array quindi di accedere agli elementi dell'array e NumPy offre diversi modi di indicizzare gli array in particolare abbiamo per esempio lo slicing cioè che abbiamo già incontrato a proposito delle liste Python quindi esattamente come nelle liste Python gli array NumPy possono essere affettati fatti a fette e però bisogna tenere presente che siccome gli array possono essere multidimensionali dobbiamo specificare uno slice una fetta per ogni dimensione dell'array allora qui abbiamo una definizione di un array che andiamo a stampare che è questo è un array con tre righe e quattro colonne dopodiché utilizziamo lo slicing per andare a estrarre qualunque sotto array in questo caso un sotto array che seleziona le prime due righe e le colonne uno e due come facciamo a fare un'operazione di questo genere definiamo un nuovo array b che ovviamente prende a e di a va a prendere vedete tutte le righe fino a due ok quindi le prime due righe quindi le righe con indici zero e uno perché vi ricordo che l'estremità di destra lo slicing degli indici non viene mai non fa mai parte diciamo del sotto insieme che stiamo andando a selezionare e poi andiamo a selezionare le colonne dalla uno fino alla tre ovviamente estremo destro escluso il risultato quale sarà quello che ci aspettiamo ovvero che abbiamo selezionato nell'array a gli elementi che sono appunto nella riga zero e nella riga uno e nelle colonne uno e due ed è questo e abbiamo l'abbiamo stampato quindi abbiamo creato un array a partire da un sotto array di dell'array di partenza a qui c'è una cosa un po' sottile che bisogna tenere presente che lo slice di un array come abbiamo fatto è quella che viene chiamata una vista del dato originale quindi se io vado a modificare b vado a modificare come che è l'array vi ricordo che ho appena creato dall'array a estraendone un sotto insieme di elementi andando a modificare b siccome b è una vista ottenuta tramite lo slicing io vado a modificare di fatto l'array originale e questo si vede all'opera in questo in questo codice vedete se io vado a stampare a di 0,1 chiaramente lui mi stampa 2 che è questo elemento qui poi se io vado a cambiare invece l'elemento b e dico guarda che l'elemento b anziché essere 2 adesso è 77 e lo vado a a modificare in questo modo e poi vado a stampare di nuovo a di 0,1 a di 0,1 non è più 2 cioè io ho modificato b ma vedete in realtà ho modificato anche a proprio per questo meccanismo di vista cioè lo slicing vi fornisce una vista sul dato originale e quindi modificando questa vista modificate anche il dato originale quindi questa è una cosa di cui tenere presente nel momento in cui utilizzate questa tecnica dello slicing poi per indicizzare gli array oltre allo slicing possiamo utilizzare invece l'indicizzazione intera cosiddetta l'indicizzazione intera vi permette di costruire degli array arbitrari a partire di nuovo da un altro array con un'altra modalità che è quella che andiamo a vedere anche qui l'import non è necessario quindi possiamo togliere ok qui abbiamo creato l'array a e questo è come funziona l'indicizzazione tramite numeri interi qui abbiamo selezionato un array che ha vedete forma 3 quindi un array di fatto riga e come abbiamo fatto a selezionare gli elementi che sono poi l'1, il 4 e il 5 li abbiamo specificato di fatto vedete tramite queste due liste delle coppie che sono la coppia 0,0 la coppia 1,1 e la coppia 2,0 quindi dovete leggerle come indici omologhi e questi indici corrispondono agli indici dell'array originale da cui andate a prelevare degli elementi quindi l'elemento con l'indice 0,0 è l'elemento con l'indice 1 che è l'elemento scusate che corrisponde all'1 l'elemento con l'indice 1,1 è prima riga prima colonna cioè il 4 l'elemento 2,0 e l'elemento seconda riga colonna 0 scusatemi terza riga riga con l'indice 2 0,1 e 2 vi ricordo abbiamo come indici e quindi è l'elemento che qui è il 5 e qui nella cella sotto c'è proprio quello che vi stavo dicendo cioè io potrei andare equivalentemente a dirgli prendi l'elemento 0,0 a 1,1 a 2,0 e lui mi avrebbe stampato la stessa cosa e vedete lo posso mettere in maniera più compatta se vogliamo tramite semplicemente l'indicizzazione intera cioè prendo A e gli vado a passare queste due liste una per ogni per ogni praticamente dimensione dell'array originale riga e colonna va bene? ok? ok? ho domande su questo? o andiamo avanti? andiamo avanti? siamo? bene allora un'ulteriore capacità di indicizzazione ci viene fornita appunto da quello che viene chiamato indicizzazione booleana l'indicizzazione booleana è un altro strumento abbastanza versatile che vi permette di selezionare degli elementi arbitrari di un array elementi che soddisfano ad esempio una determinata condizione allora partendo di nuovo dal nostro dal nostro array che possiamo definire in maniera del tutto arbitraria che stampiamo che in questo caso è sempre lo stesso l'array A possiamo creare una nuova matrice ok? che è una matrice che avrà la stessa dimensione della stessa shape dell'array A che semplicemente è una matrice in cui andiamo a estrarre creata diciamo ricavando tutti gli indici che soddisfano una determinata condizione in questo caso la condizione è A maggiore di 2 quindi in questo modo noi implicitamente andiamo a caricare nella variabile bool idx in quella matrice a creare una matrice in cui elemento per elemento andiamo a vedere alla stessa forma dell'array originale A e andiamo a vedere elemento per elemento se A è maggiore di 2 oppure no se è maggiore di 2 restituiamo true altrimenti restituiamo false e vedete il risultato è questo se poi andiamo a stampare questa matrice che abbiamo chiamato bool idx vedete una matrice in cui il primo elemento riga 0 colonna 0 è false perché 1 è minore di 2 il secondo elemento è false analogamente perché 2 è uguale a 2 quindi non è strettamente maggiore e gli altri sono tutti true perché 3 4 5 6 sono tutti maggiori di 2 e quindi ovviamente se io cambiassi invece ad esempio qui mettessi 3.5 chiaramente avrei false anche l'elemento con riga 1 colonna 0 e così via va bene allora l'indicizzazione booleana degli array può essere utilizzata per costruire ad esempio un array anche di rango 1 che corrisponde ai valori true di quella serie di indici cosa voglio dire io qui ho 4 indici true posso costruire un array riga di 4 elementi di quei 4 elementi quindi andare a utilizzare quegli indici e dire prendi a di boolean index e lui mi va a estrarre qual è il valore di a che corrisponde a quegli indici ok quindi dove è true lo va a selezionare e va a metterli in unico vettore riga tutto questo può essere fatto con una notazione molto compatta e molto intuitiva con un singolo una singola riga di comando una singola istruzione in questo modo cioè andiamo a stampare che cosa a dove andiamo a prendere tutti gli elementi di a che soddisfano la condizione a maggiore di 2 e il risultato è questo vedete molto conciso molto compatto molto anche direi intuitivo perché è abbastanza intuitivo capire che cosa fa un'istruzione di questo genere va a prendere tutti i valori di a che soddisfano la condizione a maggiore di 2 va bene ci siamo? ok da casa? sì tutto chiaro perfetto allora se è tutto chiaro andiamo pure avanti e andiamo a vedere alcune questioni riguardanti i tipi di dato diciamo come vi ho detto prima gli array in unpy sono delle griglie quindi gli elementi quindi sono degli array che hanno la stessa che sono omogene e che hanno la stessa tipologia i tipi di dato numerico che potete che potete utilizzare sono ovviamente quelli che ci possiamo aspettare quindi avete la possibilità di creare dei costrui e di array di interi oppure dei floating e così via essendo una libreria python diciamo quello che si segue è il principio di tipizzazione dinamica di python cioè non dovete dichiarare il tipo ma questo tipo viene in maniera automatica ricavato dall'interprete python a seconda appunto del contesto quindi se per esempio specificate come in questa cella un vettore x con gli elementi 1 e 2 poi chiedete all'interprete di restituire qual è il tipo di dato lui vi dice che questo è un int che è codificato a 64 bit e quindi questo è ragionevole visto che gli abbiamo passato degli interi se invece gli avessimo passato dei numeri reali quindi dei floating point lui li avrebbe codificati esattamente come dei float a 64 bit che sono appunto i float la dimensione di default del sistema in questo caso in questione su cui deve lavorare ovviamente io posso anche forzare questo tipo di codifica per cui posso anche dirgli per esempio che questo è un array costituito dagli elementi 1 e 2 dove i tipi in questo caso sono degli interi a 64 e lui mi restituisce questo ma potrei anche dirgli che questi li voglio interpretare come dei floating point a quel punto avrebbe acquisito il tipo e per cui se io devo fare la stampa di x vedete me li restituisce con 1.0 o 2.0 perché li interpreta come floating point benissimo una volta che abbiamo definito gli array e sappiamo accedere anche agli elementi o agli sottinsiemi o ai singoli elementi degli array quello che possiamo fare è costruirci sopra delle elaborazioni per costruirci sopra delle elaborazioni NumPy vi mette a disposizione delle funzioni matematiche di base che lavorano sia su array interi che su singoli elementi dell'array queste funzioni sono solitamente disponibili sia come funzioni del modulo NumPy specifico oppure come sovraccarico degli operatori quindi qualcosa che ha che utilizza la sintassi di un altro operatore ma che applicato a degli array NumPy diciamo ne rappresenta un overload ad esempio io posso creare l'array x e l'array y in questione che sono due array vedete in floating point e posso andare a fare la somma elemento per elemento allora la somma elemento per elemento la potete fare tramite la funzione add di NumPy che prende un primo vettore x scusate un primo array x e un secondo array y e somma elemento per elemento quindi l'1 lo somma al 5 il 2 lo somma al 6 il 3 al 7 e il 4 all'8 il risultato è 6, 8, 10, 12 ok? quindi una matrice sempre che ha 2 per 2 e questo è ovviamente quello che fa la funzione add allo stesso modo come vi dicevo prima a proposito dell'overload degli operatori posso usare l'operatore più che è l'operatore che in python viene utilizzato per la normale somma tra elementi e x più y ci restituisce esattamente la stessa cosa che fa l'operatore la funzione add ok? quindi è qualcosa che ci possiamo aspettare intuitivamente che possa fare ed è rappresenta appunto quello che è il sovraccarico dell'operatore più allo stesso modo posso andare a fare la differenza elemento per elemento tra elementi di array quindi se io faccio x meno y oppure invoco la funzione subtract x virgola y lui prende l'array a quindi la matrice nel nostro caso 2 per 2a prende la matrice scusate la matrice x e la matrice y e sottrae da x y element wise cioè elemento per elemento analogamente posso fare la stessa cosa con la moltiplicazione quindi x per y oppure utilizzare la funzione multiply a cui passo i due argomenti x e y e ottengo esattamente lo stesso risultato oppure anche la divisione di nuovo qui funzione divide oppure sovraccarico dell'operatore slash che indica la divisione se volessi accedere a altre funzionalità tipo radice quadrata semplicemente posso prendere la mia il mio array e andare a fare la calcolare la radice quadrata di ogni elemento dell'array e otterrei questo chiaramente la radice quadrata di 1 e 1 la radice quadrata di 4 e 2 quindi lungo la diagonale avete 1 e 2 queste sono le radice quadrata rispettivamente di 2 e di 3 sull'altra antidiagonale una differenza per chi per esempio conosce MATLAB alcune di queste operazioni sono familiari per quelli che hanno avuto modo di utilizzare un ambiente di calcolo scientifico come MATLAB oppure come Octave che è la versione open source diciamo non è proprio la versione open source diciamo è un analogo in versione open source di MATLAB diciamo cerca di approcciare la stessa tipologia di problemi con una sintassi abbastanza simile ecco chi ha familiarità con quegli ambienti sa che in quel caso l'operatore asterisco quindi quello che qui abbiamo utilizzato come operatore della moltiplicazione elemento per elemento in quel caso invece è una moltiplicazione tra matrici e non una moltiplicazione elemento per elemento se noi vogliamo invece in NumPy utilizzare la funzione la moltiplicazione tra matrici possiamo farlo in diversi modi uno dei quali è l'operatore dot la funzione dot che permette proprio di calcolare il prodotto scalare il prodotto interno tra vettori moltiplicare un vettore per una matrice o moltiplicare due matrici tra di loro chiaramente ci deve essere coerenza nelle dimensioni degli array che passiamo a questa questa funzione però diciamo questo è ovviamente di per sé ragionevole nel senso che non possiamo da un punto di vista matematico fare una moltiplicazione matrice per matrice tra due matrici che non sono compatibili da un punto di vista degli elementi che costituiscono la matrice le matrici stesse allora la funzione dot è disponibile sia come funzione del modulo Numpy ma anche come istanza del metodo degli oggetti array che abbiamo creato e qui lo vediamo lo vediamo bene anche in questo caso abbiamo definito due matrici x e y che sono due matrici 2 per 2 abbiamo definito due vettori v e w come due vettori riga da due elementi e queste sono le loro shape quindi 2,2 e 2 virgola o se io volessi calcolare il prodotto scalare quello che viene chiamato anche prodotto interno tra i due vettori v e w non dovrei il prodotto scalare quindi è il prodotto elemento per elemento di elementi che hanno indici omologhi nel caso di v e w sarebbe 9 per 11 più 10 per 12 ok quindi 99 più 120 99 più 120 fa 219 e questo lo posso fare semplicemente andando a invocare la funzione o la funzione dot di Nampi e avete la riga 3 a cui passate i due vettori oppure prendete il primo vettore v è un oggetto che avete creato quell'oggetto ha il metodo dot a cui potete passare un secondo parametro che è il secondo vettore di cui volete calcolare il prodotto scalare e ovviamente i due risultati sono del tutto chiaramente equivalenti in maniera analoga potrei fare un prodotto matrice per vettore quindi per esempio prendere la matrice X come l'abbiamo generata che è una matrice 2 per 1 e moltiplicarla per un vettore che è un vettore con una riga e due colonne e il risultato è chiaramente una matrice 2 per 2 perché 2 per 1 per 1 per 2 vi dà con la regola del prodotto tra matrici una matrice di dimensione 2 per 2 va bene? ok qui in questa riga commentata cosa abbiamo fatto? abbiamo utilizzato una reshape e vedete che abbiamo fatto il prodotto tra X e la reshape del vettore in 2,1 che vi dà un qualcosa di diverso perché in questo caso io ho fatto una reshape di V in un vettore due righe e una colonna esplicitamente e ok e quindi qui vi fornisce chiaramente un vettore colonna però direi che questo lo possiamo anche adesso togliere per più confusione che altro ok benissimo prodotto matrice per matrice se invece faccio il prodotto tra le due matrici X e Y non ottengo questo e anche qui lo posso fare in due modi utilizzando la funzione dot utilizzando il metodo dot benissimo allora nel momento in cui abbiamo queste queste matrici abbiamo anche molte funzioni utili altre oltre a queste che diciamo quelle basilari che abbiamo appena appena introdotto che possono che possono essere utilizzate una sicuramente molto utile in diverse applicazioni è fare la somma degli elementi somma degli elementi di un array somma degli elementi di un array lungo tutte le righe o somma degli elementi lungo tutte le colonne quindi se io definisco ad esempio questo array X in questo modo lo vado a stampare e poi invoco la funzione sum di X quello che fa questa funzione è stampare e calcolare semplicemente la somma di tutti gli elementi dell'array e la somma di questi elementi è pari a 21 se gli passo anche un secondo argomento che è axis e specifico axis uguale a 0 sto intendendo che voglio la somma lungo ogni colonna quindi lui mi stamperà tanti valori quanti sono quante sono le colonne della mia matrice in questo caso sono due colonne quindi mi stamperà due valori che corrispondono a 9 e a 12 che sono rispettivamente la somma degli elementi sulla prima e sulla seconda colonna se invece specificassi axis uguale a 1 lui andrebbe a calcolarmi la somma degli elementi lungo ogni riga quindi siccome l'array da cui stiamo partendo ha tre righe due colonne mi restituisce in questo caso tre numeri che sono rispettivamente la somma di 2 più 1 gli elementi che stanno sulla prima riga 3 più 4 che sono gli elementi che stanno sulla seconda e 6 più 5 che sono gli elementi che stanno sulla terza riga ok e questo diciamo è abbastanza comodo perché diverse applicazioni qualcosa di routine che viene fatto e può capitare appunto spesso di doversi ritrovare a fare un costrutto che abbiamo a disposizione all'interno del package che può essere utilizzato direttamente in maniera molto allora qui ci sono altri operatori di base che vi introduco anche in maniera sparsa rispetto a quelli che abbiamo introdotto precedentemente ma se utilizzo l'operatore per o diviso e lo applico a un vettore quindi faccio vector per esempio per 5 o vector diviso 5 dove vector è l'area che ho appena definito il risultato è quello che ci possiamo aspettare cioè ogni elemento viene diviso moltiplicato per quel valore costante la somma la differenza l'abbiamo già vista sopra e quindi direi che rispetto a quello che abbiamo visto sopra non ci sono cose particolari questo era una cella che evidentemente era abbastanza ridondante ma ci permette di riapprezzare di nuovo quelle che sono la semantica di questi operatori e la loro sintassi ecco a proposito del più per esempio vi faccio notare che se l'applico l'operatore più ha due liste python due liste native di python lì otteniamo la concatenazione se l'applichiamo a due array è la somma algebrica ok quindi diciamo c'è una differenza quindi da questo punto di vista il sovraccarico dell'operatore cambia anche la semantica dell'operatore stesso ovviamente la trasposta ecco altra operazione diciamo che capita spesso di dover fare è calcolare la trasposta di una matrice qui abbiamo definito una matrice chiamiamo matrix e la definiamo la stampiamo e il risultato è questo poi alla riga 5 viene invocato il metodo transpose che viene applicato all'oggetto matrix e viene assegnato a una nuova variabile che chiamiamo matrix transpose e se la andiamo a stampare è il risultato che ovviamente è quello che ci aspettiamo cioè la matrice in cui abbiamo invertiti gli indici di righe di colonna per cui eravamo partiti da una matrice 2x3 otteniamo una matrice 3x2 in cui chiaramente gli elementi di righe di colonna sono scambiati le righe diventano colonne e viceversa anche qui non c'è un unico modo di effettuare queste operazioni per cui oltre al metodo transpose c'è un metodo T maiuscolo che fa esattamente la stessa identica cosa ma c'è anche la funzione transpose a cui passiamo come argomento matrix e anche quella fa esattamente la stessa cosa cioè la stampa vedete vi produce esattamente lo stesso risultato quindi abbiamo tre modalità diverse di calcolare la trasposta di una matrice il calcolo in realtà è chiaramente sempre lo stesso tre interfacce diverse per invocare questo tipo di operazione il transpose funziona anche sui vettori monodimensionali? allora se intendi con vettore monodimensionale l'array unidimensionale come viene creato non produce alcun effetto se invece è una matrice quindi la definisci come vettore 6,1 allora a quel punto si si chiedevo se fosse analogo a fare il reshape ma in realtà no perché prima adesso vediamo un po' in memoria dovremmo avere vector qui quindi se tu stampi vector vector vedi è questo ok quindi la shape di vector in realtà è 6 virgola se io adesso faccio vector trasposto vedi non succede niente se invece io facessi la reshape quindi dico fai la reshape e gli passi ad esempio 6,1 ottieni questo vettore colonna e se io adesso di questo vettore colonna andassi a fare la trasposta otterrei il vettore ok ok ho capito ok vedo allora abbiamo visto prima la moltiplicazione con il metodo dot o la funzione dot che fa quello che dicevo prima cioè gli passiamo prendiamo la matrice sinistra quindi se io faccio a per b devo fare a dot b quindi utilizzare il metodo chiamato sulla matrice di sinistra passandogli la matrice destra come argomento ok ricordate matrice destra e sinistra insomma nel calcolo matriciale fa differenza ecco però in maniera alternativa se uno non si vuole sbagliare può chiamare il metodo dot la funzione scusatemi dot non il metodo dot ma quindi passarli come facciamo qui alla riga 12 matrix matrix 2 in cui la prima è la matrice di sinistra la seconda è la matrice di destra quindi forse questo fa un po' meno confusione oppure direttamente forse ancora più semplice invocare la funzione l'operatore chiocciola che fa esattamente la stessa cosa e quindi se mando in esecuzione questo blocco di codice abbiamo moltiplicazione tra matrici del tutto produce risultati chiaramente che sono gli stessi quindi del tutto equivalente metodo dot funzione dot di numpy oppure operatore chiocciola matrix et matrix 2 e vi restituisce lo stesso risultato tre modalità diverse anche qui come per la trasposta ne abbiamo tre ne abbiamo tre anche per per la moltiplicazione tra matrici anche qui sta al vostro gusto di di programmatori utilizzare l'una oppure l'altra il prodotto scalare tra vettori è un prodotto riga per colonna quindi anche questo l'abbiamo visto l'abbiamo visto in una cela precedente ma vale la pena rivederlo se io definisco un vettore colonna un vettore riga a partire dal mio vettore unidimensionale e poi utilizzo l'operatore dot quindi il metodo dot scusatemi su passandoli come primo elemento row vector e come secondo elemento column vector ho chiaramente che cosa un vettore riga moltiplicato per un vettore colonna quindi un vettore di dimensione 1,6 moltiplicato per un vettore per un array scusate un array di dimensione 1,6 moltiplicato per un array 6,1 il risultato sarà uno scalare che esattamente corrisponde a quello che ci possiamo aspettare essere il prodotto scalare tra vettori in questo caso è 55 perché ho fatto 0 per 0 più 1 per 1 più 2 per 2 più 3 per 3 più 4 per 4 più 5 per 5 che fa 55 ok però il risultato ve lo restituisce come a sua volta un array un array di dimensione 1 per 1 cioè se io oltre che fare la stampa di questo vettore andassi a fare la stampa della sua shape vedete che lui mi restituisce scusate mi schiena nulle 2 vedete mi restituisce che è una shape 1 per 1 è uno scalare ma in realtà lui ve lo restituisce come shape 1,1 perché ha fatto un prodotto tra array quindi lui è corrente da questo punto di vista poi sotto sono commentate vabbè due due due istruzioni vale la pena magari guardarla anticipiamo una cosa che vi faccio vedere dopo quindi poi la ricommento andiamo a utilizzare una sottolibreria di NumPy che si chiama LeanAlg che è la libreria dedicata sotto libreria dedicata all'algebra lineare lì dentro c'è la funzione norma che calcola la norma di un vettore ok quindi gli passate vector e lui calcola la norma secondo secondo L2 ok quindi se io vado a invocare questo questa norma vedete norma è esattamente vi restituisce la norma di un vettore o di una matrice ok ok quindi gli passate l'array e e di default se gli passate due no di default scusatemi non c'è un default ma gli potete passare un parametro che vi permette di calcolare norme di tipo diverso quindi ce ne sono diverse a seconda del valore che gli passate se gli passiamo due è la norma Euclidea che abbiamo chiamato norma L2 e quindi con questa invocazione noi stiamo calcolando la norma scusatemi pardon qui non gli passiamo niente questo 2 un errore mio norma di vector vi calcola direttamente la norma Euclidea quindi la norma L2 questo 2 è riferito al fatto che semplicemente stiamo invocando la funzione power quindi quel vettore lo andiamo a elevare al quadrato quindi quello che stiamo facendo è calcolare la norma del vettore al quadrato allo stesso modo potremmo invocare NP linal norm di vector e utilizzare questo operatore asterisco asterisco che gli dice vai a prendere ogni elemento di quel vettore e vai a elevarlo al quadrato il risultato è questo 55 che è esattamente la norma del vettore ma d'altra parte questo è coerente con il risultato che abbiamo trovato sopra perché sopra abbiamo fatto nelle righe dalla 2 alla 6 scusatemi abbiamo calcolato il prodotto scalare ma noi sappiamo che il prodotto scalare di un vettore con se stesso è di fatto la norma al quadrato di quel vettore ok ci siamo adesso questo lo rimetto commentato semplicemente perché poi questa questa libreria viene introdotta formalmente in questo notebook più sotto però ve l'ho anticipato poi ci potete andare un po' a fare delle prove quando andate a rivedere il codice ok ah qui c'è quello che vi dicevo prima l'output della shape ve l'ho fatta già vedere non mi ricordavo che l'avevo poi messa sotto nella cella questa cosa cioè la shape del prodotto scalare è chiaramente 1,1 se volessi ottenere uno scalare potrei accedervi con la funzione di NumPy ndarrayitem è una classe appunto ndarray per cui avete un metodo item che vi restituisce lo scalare in questo caso quando vi passate quel vettore altri operatori tra matrici chi lavora appunto nell'ambito della algebra lineare chi ha un'altra una certa dimestichezza sa che un operatore fondamentale è l'inversione di una matrice l'inversione di una matrice quadrata è un operatore che un'operazione che viene tirata in ballo per diversi tipi di applicazione e in questo caso vengono create una matrice A una matrice scusatemi che viene chiamata matrix un'altra matrice che viene chiamata matrix 2 che sono queste che vedete matrice due righe e tre colonne rispettivamente e matrice tre righe e tre colonne alla matrice matrix 2 viene applicato in questo caso allora la matrice matrix in realtà qui non viene utilizzata non so perché è rimasta forse perché viene riutilizzata sotto adesso non mi ricordo esattamente potrebbe anche essere probabilmente omessa ma di su questo non bisognerebbe andare a vedere se è stata definita sopra correttamente allo stesso modo e come viene riutilizzata sotto e chiaramente nei notebook se voi riutilizzate una variabile ovviamente dovete averla definita sopra e prendi i valori che avete utilizzato sopra per cui adesso direi che non la cancelliamo invece lavoriamo su matrix 2 che è una matrice quadrata una matrice tre righe tre colonne e in questo caso ecco qui introduciamo quello che già vi ho anticipato prima che è il modulo lin alg che effettua vi permette di accedere a tutta una serie di operatori di operazioni di funzioni relative all'algebra lineare e semplicemente invocando il metodo inv applicato a matrix 2 quello che calcolate è la matrice inversa molto semplicemente la matrice inversa della matrice data è questa vedete una matrice scusatemi è una matrice che abbiamo stampato che è questa qui ecco matrice inversa e poi abbiamo fatto una cosa per verifica abbiamo fatto la stampa alla riga 9 di che cosa di matrix 2 et matrix 2 inversa cioè abbiamo fatto il prodotto tra queste due matrici ora il prodotto in algebra lineare tra una matrice in un asso inversa che cosa vi restituisce? cosa vi dovrebbe restituire? la matrice identità quindi una matrice che ha tutti uno sulla diagonale e 0 sulle altre negli altri elementi e vedete che questa matrice che gli abbiamo fatto stampare ha tutti uno sulla diagonale e sugli altri elementi ha dei numeri che non sono 0 ma di fatto sono qualcosa per 10 alla meno 17 per 10 alla meno 18 perché sono chiaramente l'esito di calcoli numerici che vengono effettuati su questa dall'operatore INV ma di fatto è un numero che virtualmente è 0 quindi quella è al netto degli arrotondamenti che sono stati introdotti dagli algoritmi che hanno effettuato questo calcolo quella è di fatto la matrice identità va bene? ci siamo? sì molto bene allora se ci siamo andiamo a vedere un po' di altre cosine interessanti come ad esempio utilizzare il metodo min o il metodo std per calcolare direttamente la media o la deviazione standard di un vettore ad esempio io vado a prendere il vettore row vector che avevamo definito sopra e lo stampo e posso tramite il metodo min di row vector andare ad accedere a calcolare la sua media oppure la sua deviazione standard questo è molto molto rapido insomma degli elementi di una matrice direi che questo lo abbiamo già visto anche questo sopra c'è una certa ridondanza ma andiamo a diciamo male non fa ecco quindi andiamo a rivederlo insieme posso prendere il vettore riga sì qui perché insomma ho fatto un po' di mescolato un po' più cose in parti diverse del notebook però appunto qui ritrovate che cosa il metodo sum applicato al vettore vi calcola la somma degli elementi del vettore se definite una matrice matrix 3 e poi fate la somma di tutti i suoi elementi con il metodo sum avete la somma di tutti i suoi elementi se fate la somma dei suoi elementi lungo l'asse 1 avete chiaramente la somma degli elementi riga per riga lungo l'asse 0 la somma degli elementi colonna per colonna e questo è qualcosa che implicitamente avevamo visto anche sopra anche se in una modalità leggermente diversa però è quello che ci aspettiamo che ci restituisca benissimo o invece quello che non abbiamo visto sopra sono le funzioni min e max che vi permettono di andare a estrarre il minimo il massimo di una matrice di un vettore anche questo lungo specificando eventualmente lungo quali direttrici quindi lungo l'asse 1 l'asse 0 andando a specificare quindi qual è la dimensione lungo la quale volete calcolare il massimo anche qui avete due modi avete sia la funzione di numpy min che i metodi min e max applicati all'oggetto in questione quindi se l'oggetto in questione è questo vettore a riga row vector 2 che creiamo qui alla riga 1 se che io vado a stampare alla riga 2 se vado ad accedere al suo metodo min o al suo metodo max lui mi restituisce il minimo o il massimo di questo vettore e quindi 0 e 5 se vado a stampare la matrice matrix 3 che abbiamo definito prima che è questa e vado ad applicare il metodo min all'asse 1 quello che ottengo è una serie di minimi che sono i minimi riga per riga ok quindi 2 e 1 che sono il 2 e l'1 rispettivamente il minimo della prima e della seconda riga se volessi i massimi e volessi invece non delle righe ma delle colonne potrei andare a specificargli max vedete il metodo max applicato all'oggetto matrix 3 specificando come parametro axis uguale a 0 e lui mi estrae tre valori che sono i massimi delle tre colonne che sono rispettivamente 8 12 e 6 o non solo vi restituisce i valori minimi o massimi ma potete accedere ho chiaramente qui una cosa che ho commentato e potrei fare una cosa equivalente tramite l'operatore tramite la funzione scusatemi max di numpy specificandogli matrix 3 che è l'oggetto su cui devo andare a lavorare axis uguale a 0 quindi gli sto dicendo vai a lavorare sulle colonne e questo avrebbe fatto esattamente la stessa cosa se volessimo invece vi dicevo non solo i valori corrispondenti al minimo o massimo ma volessimo i minimi o il massimi scusatemi volessimo gli indici corrispondenti a questi minimi o massimi potrei utilizzare un'altra funzione estremamente utile che è la funzione argmin argmin vi prende proprio di selezione i minimi e i massimi all'interno del vettore o della matrice quindi in generale dell'array e vi restituisce gli indici che corrispondono a quel minimo o a quel massimo quindi se io ad esempio prendo l'oggetto matrix 3 e gli dico vai a cercare l'argmin lungo axis uguale a 1 quindi gli sto dicendo lungo le righe vi ricordo che andiamo a vedere matrix 3 quanto vale matrix 3 è questa quindi lui va a selezionare l'indice del minimo lungo la prima riga e lungo la seconda riga e chiaramente l'indice è 1 perché è il 2 e 2 perché è il numero 1 quindi 1 e 2 dovrebbe essere quello che ci restituisce andiamo a vedere vedete ci ha restituito 1 e 2 se io gli avessi specificato argmax e avessi cambiato ad esempio l'axis quindi l'asse 0 significa che andiamo a lavorare sulle colonne e gli stiamo chiedendo quali sono gli indici che corrispondono al valore massimo di matrix 3 l'oggetto matrix 3 è questo andiamo a lavorare lungo le colonne e quindi ci restituisce 3 indici che sono rispettivamente l'indice 1 perché è l'indice che corrisponde all'8 di nuovo l'indice 1 che corrisponde al 12 e l'indice 0 che corrisponde al 6 quindi ci dovrebbe restituire 1, 1 e 0 andiamo a vedere è effettivamente è così ok ma diciamo possiamo fare molte altre cose possiamo fare una serie di cose tutt'altro che banali ad esempio il modulo di algebra linear ci permette di come abbiamo visto già di calcolare l'inversione della matrice ma di calcolare anche direttamente la la scomposizione o la o la scusatemi la scomposizione in autovalori autovettori di di un di una matrice e questo abbiamo visto a lezione abbiamo richiamato questi concetti di autovalori autovettori quando abbiamo introdotto le tecniche di ottimizzazione del secondo ordine e e questo problema che non è un problema così banale risolto da un punto di vista matematico chiaramente ma implementarlo da zero in un in un in un codice diciamo richiede comunque una certa attenzione perché sono algoritmi di calcolumerico abbastanza diciamo oggigiorno standard ma che sono sofisticati però non ha senso andarli a implementare da zero e questa libreria di NumPy ci mette a disposizione questi strumenti quindi io posso andare a prendere la la sottolibreria lin alg e andare a invocare la funzione eig eig sta per eigendecomposition eigenvalues eigenvectors vuol dire autoscomposizione autovalori autovettori in inglese quindi se gli passo direttamente la matrice A che abbiamo definito alla riga 1 lui mi calcola gli autovalori e gli autovettori e ve li restituisce nelle variabili eigenvalues e eigenvectors quelle due variabili che avete che avete appena che avete appena invocato vedete se andate a vedere quale ecco un altro consiglio è andare a vedere un pochino le quelle che sono le gli help delle funzioni quindi in questo caso se andate su in realtà da collab se ci passate sopra col mouse ve la dà direttamente quindi sensibile proprio al contesto del passaggio con il mouse sopra il nome della funzione e vedete vi dice che vi restituisce una tupla che ha una serie di attributi quindi autovalori tipo di array e il secondo elemento sono gli autovalori quindi autovalori e autovettori e dopodiché quello che possiamo fare è stamparli alla riga 4 e alla riga 5 se faccio questa cosa adesso lasciamo da parte il ciclo for che andiamo a vedere dopo il risultato è questo vedete io sono andato a stampare gli autovalori gli autovalori sono questi due questa è una matrice 2x2 quindi ha due autovalori e due autovalori il primo autovalore è questo il secondo autovalore è quest'altro ognuno di quegli autovalori è un elemento è a sua volta scusate un vettore a due componenti quindi lui ha calcolato quindi lui ha calcolato due autovalori che sono quei vettori a due componenti e i corrispondenti autovalori vi ricordo la definizione di autovalori e di autovalori qual è è quella per cui vediamo un attimo se riesco a scrivere sulla lavagna qui sopra in sovrapposizione ci provo allora vediamo un attimo se riusciamo a sovrapporci qui forse no forse qui sopra non riesco a vedere vediamo un po' se c'è allora direi che non riesco a vedere i comandi per scrivere qui sopra non lo vedo si sono riuscito a farlo ok allora se io facciamo un altro colore se ne ci dà oppure va bene anche questo vi ricordo che la definizione di autovalore e auto vettore abbiamo la matrice A e x viene detto auto vettore se vale che A per x è uguale a lambda x dove lambda è l'autovalore corrispondente ok allora se noi abbiamo la curiosità di vedere se quello che ci ha calcolato questa questa funzione è coerente con questa definizione possiamo fare una cosa di questo genere che è specificata diciamo nelle righe di codice che vanno dalla 6 fino alla 9 vedete facciamo un ciclo for questo ciclo for che cosa fa allora l'en di eigenvalues vi restituisce la lunghezza di questa lista della lista degli autovalori quindi in questo caso è due quindi è un ciclo con due soli due sole iterazioni ne fa tante quante sono gli autovettori e gli autovalori ok dopodiché cosa andiamo a fare andiamo a calcolare guardate qui scriviamo a per x uguale questa è semplicemente una stringa poi alla riga 7 che cosa facciamo a per eigenvectors di due punti virgola i cioè andiamo a prendere la nostra matrice a e la moltiplichiamo per che cosa per andiamo a selezionare tutte le righe e la colonna iesima di eigenvectors vuol dire che stiamo andando a prendere gli autovettori ok che sono organizzati in colonna quindi in realtà il primo autovettore è quello della diciamo sulla prima colonna e non sulla seconda quindi direi che contrariamente a quello che vi avevo detto prima sono organizzati in colonna ok e andiamo a prendere l'iesima colonna ok l'iesima colonna rappresenta l'autovettore x e andiamo a fare quindi a per x quello che vogliamo che sia verificato è questa condizione quindi noi con questo andiamo a calcolare a per x ok che è questo e vogliamo verificare se è uguale a lambda x per andare a calcolare lambda x cosa prendiamo all'iesima interazione prendiamo l'iesima autovalore e lo moltiplichiamo per l'autovettore corrispondente quindi facciamo lambda per x e andiamo a vedere che cosa succede e quello che succede è esattamente quello che ritrovate scritto qua cioè a per x vi restituisce questo vettore e lambda x vi restituisce quest'altro vedete che sono perfettamente identici e questo ve lo fa per la prima per la seconda iterazione ma anche chiaramente per la prima iterazione per x è questo vettore e questo è lambda x quindi con il primo autovalore e con il primo autovettore qui avete il risultato e questo ce l'avete per il secondo autovalore autovettore ci siamo? ok allora proviamo ad andare avanti adesso direi che questo lo possiamo cancellare e possiamo andare avanti qui abbiamo invece un esempio di come la sottolibreria lean alg vi permette di risolvere un sistema lineare sistema lineare di n equazioni in n incognite quindi capite bene che stiamo facendo con poche righe di codice python qualcosa di non così proprio banale di prima chito di nuovo definiamo una matrice A la andiamo a stampare poi definiamo un vettore B la andiamo a stampare e poi andiamo a fare una cosa che adesso vi spiego allora andiamo a vedere insieme che cosa facciamo qui abbiamo mi ripeto scusate ecco siamo qui allora abbiamo fatto che cosa abbiamo stampato A e questa è A questa è A questo è B e siamo andati a invocare la funzione della libreria di linea che si chiama solve solve A virgola B vi permette di risolvere questa equazione A per X uguale a B che è scusate ve la scrivo in modo che rimane A per X uguale a B è di fatto la forma matriciale di un sistema di equazioni n incognite n equazioni perché perché noi cerchiamo il valore di X X è la nostra incognita quindi il nostro vettore X che soddisfa questa equazione questa se riandate a vedere poi i vostri appunti di algebra lineare è di fatto la definizione appunto di un sistema di equazioni lineari n incognite n equazioni in cui avete il termine noto B che è un vettore in questo caso un vettore 2 per 1 la matrice A nel nostro caso è una matrice 2 per 2 il risultato sarà un vettore 2 per 1 che rappresenta le due soluzioni che il sistema che vi va a risolvere vi permette appunto di risolvere e il risultato è proprio quello che trovate qui quindi la soluzione è esattamente questa le due soluzioni sono 2 e 3 e anche qui possiamo fare un check cioè possiamo andare a fare il prodotto di A per X dove X è il vettore che vi ho appena trovato e verificare che il risultato sia effettivamente uguale a B quindi abbiamo risolto il sistema di equazioni lineari ci siamo? ok? benissimo benissimo allora allora quindi verificato anche che diciamo il il solver il solutore di sistemi lineari effettivamente fa quello per cui è stato costruito in maniera corretta possiamo procedere quindi vedete abbiamo già messo in in in campo analizzato diversi diversi tipi di funzionalità che sono estremamente rendono questo strumento questa libreria estremamente versatile e utile perché se cominciate a metterli insieme insomma sono parecchie cose che possiamo fare ma un aspetto caratteristico ecco che invece vorrei far far notare vorrei sottolineare con adesso le cose nelle tramite l'ausilio delle celle che andiamo a vedere è che queste cose vengono fatte non solo correttamente ma anche in maniera molto efficiente e la chiave di questo è quella che viene chiamata vettorizzazione la vettorizzazione è la possibilità di effettuare del del codice in maniera l'esecuzione di codice in maniera molto efficiente a basso livello in termine una macchina per cui quello che fa NumPy è diciamo tradurre le istruzioni di alto livello in quindi l'implementazione delle funzioni che NumPy si porta dietro vengono attraverso un lavoro diciamo di ingegnerizzazione non banale vengono tradotte in istruzioni diciamo di basso livello quindi vicino all'esecuzione del codice macchina molto efficienti che sfruttano diciamo vari livelli di parallelismo e permettono di effettuare queste operazioni tra vettori diciamo sfruttando appunto al massimo delle possibilità di parallelizzare alcune operazioni allora tutto questo cosa significa? Significa che nel momento in cui voi avete delle operazioni sui vettori e queste operazioni le provate a implementare voi stessi ad esempio con un normale ciclofor quindi un loop standard insomma quindi per esempio pensiamo al prodotto tra vettori ok? o al prodotto tra matrici eccetera lo potete chiaramente fare però quell'implementazione del ciclofor è molto beneficente rispetto all'implementazione che viene che è stata effettuata all'interno di NumPy di quella stessa funzione quindi se prendo per esempio il prodotto tra vettori il dot la funzione dot che abbiamo visto prima NumPy è 25 volte più veloce rispetto a un ciclofor che potete costruire voi per andare a fare il prodotto elemento per elemento tra i due vettori e se dai vettori unidimensionali passiamo alle matrici questo fattore di scala diventa 2000 quindi estremamente più rapido e per vedere questo vabbè possiamo procedere in questo modo adesso qui abbiamo importato la libreria ma non c'era bisogno queste invece sono delle librerie che sono utili time per fare la valutazione dei tempi di esecuzione mentre tqdm è un package che serve per fare il tracking del progresso nel tempo quindi vi permette di costruire delle barre che vi dicono quanto vi stimano quanto manca al termine dell'esecuzione di un determinato task di una determinata porzione di codice e danno una visualizzazione grafica abbastanza carina di quello che è appunto questo tempo rimanente e di quanto ne è trascorso rispetto al totale allora giusto per farvi capire meglio quindi ripeto il problema è andare a vedere la differenza che c'è tra un'implementazione fatta con normale ciclo for da codice python standard che è quello che potreste fare voi con la stessa implementazione effettuata da una funzione di numpy che poi è stata invece ingegnerizzata per arrivare a basso livello a sfruttare la vettorizzazione cioè di fatto a sfruttare il fatto che alcune di queste operazioni tra vettori possono essere parallelizzate a livello di codice di codice mic allora qui per vedere questo vi faccio vedere che cosa succede nel momento in cui andiamo a fare un prodotto tra vettori quindi generiamo casualmente un vettore A e un vettore B con 500.000 elementi quindi mezzo milione di elementi ok per cominciare bisogna salire chiaramente di dimensione per vedere un pochino per apprezzare queste queste dinamiche dopodiché facciamo utilizziamo due funzioni della libreria Time la prima si chiama PerfCounter la seconda si chiama Time servono rispettivamente per andare a vedere il tempo di CPU nella libreria PerfCounter e il tempo quello che viene chiamato tempo di wallclock time cioè il tempo di orologio la differenza è semplicemente che il tempo di CPU va a vedere quello che esattamente la CPU ha dedicato a questo processo il tempo di wallclock va a vedere tutto il tempo che trascorre quindi se in frattempo la CPU fa anche altro tutto il tempo che è trascorso per l'esecuzione di una certa porzione di codice quindi di fatto andiamo a calcolare quanto tempo impiega la macchina a eseguire una certa porzione di codice quale porzione quella specificata tra il primo momento in cui invochiamo la funzione time o time PerfCounter o time punto time e l'istante di tempo in cui rinvochiamo di nuovo questa funzione e quindi chiamiamo questi instanti di tempo rispettivamente tick e toc ok oppure ptick e ptoc quindi per il per le due variabili che calcolano rispettivamente CPU time e wallclock time sono fondamentalmente due modalità analoghe di andare a vedere cosa quanto tempo trascorre per l'esecuzione di una determinata porzione di codice però una tiene anche conto di altri processi che possono essere attivi in quel momento sul sistema poi che cosa facciamo quindi qui di fatto facciamo partire il cronometro alle righe 4 e 5 cronometro che stoppiamo alle righe 13 e 14 ok è come se fossero due cronometri che attiviamo la riga 4 e la riga 5 che fermiamo alla riga 13 e alla riga 14 benissimo allora che cosa facciamo poi qui dentro allora definiamo 0 una variabile 0 e poi alla riga 8 e 9 facciamo la nostra implementazione del prodotto scalare il prodotto scalare che cosa fa semplicemente va a calcolare è un ciclo for dove i varia adesso vi dico cosa vuol dire anche tq di m ma intanto lasciamo da parte tq di m il ciclo for sarebbe for i in range di length di a cosa vuol dire prendiamo la lunghezza del vettore a in questo caso 500.000 elementi generiamo un insieme di interi che vanno da 0 a 500.000 escluso l'estremità di destra quindi un insieme di interi che sono 500.000 interi da 0 a 499.999 e poi per ognuno di questi interi andiamo a fare una corrispondente iterazione quindi facciamo 500.000 iterazioni e in ognuno di queste interazioni andiamo a calcolare adi per bd cioè l'elemento iesimo di i lo moltipliciamo per l'elemento iesimo di b e andiamo a sommare questo al valore calcolato all'iterazione precedente partendo da 0 questa se ci pensate è esattamente la definizione di prodotto scalare in più qui utilizziamo questo strumento che è il tqdm semplicemente ci avvaliamo di questo package che ci permette di fare il tracking del progresso del calcolo cioè lui va a vedere sa che deve fare 500.000 iterazioni in questo caso e vi fa una rappresentazione grafica con una barra che vi fa vedere man mano progressivamente come questa barra viene riempita per dire siamo a quando siamo a 250.000 al 50% di esecuzione va bene? dopodiché viene stampato alla riga 11 il risultato e vengono bloccati i due cronometri e qui ci fermiamo dopodiché viene fatta una print del risultato di nuovo e del calcolo il calcolo viene fatto semplicemente arrotondando allora si prende la differenza tra il cronometro alla fine e il cronometro all'inizio quindi il tempo che è stato necessario per eseguire quel frammento di codice viene moltiplicato per 1000 e il risultato con 6 cifre di rappresentazione è espresso in millisecondi va bene? questo è come funziona quella libreria type la stessa cosa per per per la funzione per counter la stessa cosa per la funzione time ok? il risultato quello che vi restituisce lo dovete moltiplicare per 1000 e il risultato che ottenete sono millisecondi va bene? ok allora andiamo a vedere intanto questa prima ma lo vediamo tutto insieme poi dopo diciamo questa riga di commento quello che succede rifacciamo la stessa cosa cioè facciamo partire il cronometro i due cronometri alla riga 25 gli facciamo stampare il risultato del prodotto scalare di A con B utilizzando la funzione dot quindi funzione implementata in numpy che come vi dicevo è vettorizzata poi blocchiamo i cronometri e andiamo a vedere allo stesso modo quanto tempo ci ha messo quindi questo è il succo del discorso ci siamo qui? ok proviamo a mandare in esecuzione questo codice e vediamo che cosa succede ecco quello che succede è questa cosa qua vedete qui non si è visto perché è stato molto veloce vedete questa è la barra che lui progressivamente andava a riempire è arrivato al 100% ci è arrivato molto velocemente il risultato è questo 125.108.71 che è chiaramente lo stesso risultato che abbiamo ottenuto anche nel secondo caso 125.710 però nel primo caso con la nostra implementazione ci ha messo 304.000 secondi nel secondo caso ci ha messo 8.000 secondi c'è una leggera differenza vabbè tra il wall clock time e cpu time fondamentalmente sono le stesse qui stiamo tra l'altro eseguendo in cloud quindi diciamo ci sono un po' di questioni che riguardano il fatto di non avere perfettamente sotto controllo quello che è la tipologia di sistema su cui stiamo lavorando ma la sostanza del discorso è abbastanza chiara tra 8 prendiamo 10 millisecondi e 300 millisecondi c'è un fattore di scala 30 quello che dicevo prima che vi avevo scritto qua su è che NumPy è circa 25 volte più veloce degli standard loop quando fate il dot product e questo è decisamente insomma qualcosa che va a vantaggio appunto dell'implementazione vettoriale e poi ecco qui sotto c'è un esempio con le matrici che ancora più evidenzia ancora meglio perché ci mette un po' più di tempo quello che è il vantaggio perché è un vantaggio chiaramente che nel momento in cui facciamo un'implementazione di un prodotto tra matrici lì andiamo su un algoritmo che ha una complessità cubica quindi si vede meglio ma direi che questo lo vediamo la prossima volta insieme a un po' di altre cose che andranno a completare diciamo il contenuto di questo notebook e questa esercitazione direi che per oggi se non avete delle domande direi che possiamo fermarci qua non so se ci sono domande se vi è tutto chiaro no nessuna domanda tutto chiaro perfetto allora direi che possiamo bloccare qui la registrazione la prossima volta andiamo avanti è rimasto poco in realtà qui da vedere su vi faccio vedere l'esempio di cosa vuol dire la vettorizzazione ad esempio a livello di moltiplicazione tra matrici e poi vi faccio vedere la funzionalità di matplotlib quindi un'altra libreria che non è solo NumPy ma appunto è matplotlib che è una libreria di supporto alla grafica quindi per generare dei grafici e poi possiamo iniziare anche la prima esercitazione in cui vedremo la prima dedicata diciamo ai modelli alla costruzione di modelli quindi parleremo di regressione linea va bene allora direi che per oggi chiudiamo andiamo grazie a tutti grazie a tutti