allora oggi continuiamo a parlare della parte sequenziale di Erlang quindi parliamo un po' di moduli sottomoduli le liste e i record i record sono una cosa molto importante perché poi vedremo che i record verranno utilizzati nel database di Mnesia e i record nel database di Mnesia essenzialmente una tabella verrà rappresentata come una lista di record quindi i record e le liste sono molto importanti per poter capire più in là il funzionamento di Mnesia ma anche perché le liste sono una struttura data molto fondamentale in Erlang va bene allora la volta scorsa abbiamo visto il modulo chiaramente la struttura principale di un modulo quindi ricordatevi che il modulo deve avere l'intestazione module e il nome del modulo deve essere uguale al nome del file che gli stiamo creando altrimenti beccheremo questo errore e poi per come abbiamo visto per aggiungere per aggiungere per importare le funzionalità di un modulo quello che facciamo è usiamo meno import module name quindi ad esempio vediamo questo questo esempio in cui noi abbiamo due moduli quindi prendiamo il nostro modulo prendiamo il nostro prendiamo il nostro prendiamo il file che abbiamo sviluppato la volta scorsa vediamo se ce lo apre quindi quello che vogliamo se noi creiamo un sottomodulo barra module sub module e lo salviamo in sub module.erl e poi scriviamo una funzione banalmente add ricordatevi le funzioni iniziano sempre con la lettera minuscola perché essenzialmente il nome di una funzione è un atomo mentre qualsiasi cosa inizi con una lettera maiuscola per lui è una per lui intendo per per erlang è una variabile quindi add una funzione semplice che somma due numeri x,y scusate ecco ritorniamo la somma di x più y ovviamente questa funzione la dobbiamo esportare export quindi la esportiamo sempre una lista quindi la funzione un modulo esporta una serie di funzioni e serie vuol dire un insieme una lista quindi portiamo add che prende due parametri ricordatevi che il punto chiude ogni espressione anche qui chiude ogni espressione ok quindi in questo modulo possiamo import modulo importiamo submodule abbiamo detto e importiamo la funzione add che è a ritard 2 ora proviamo a quindi erl per tutto compiliamo il sottomodulo ok ora compiliamo sec se se ok qui c'è un errore importiamo se e ora possiamo utilizzare la funzione somma però non l'abbiamo dichiarato da nessuna parte dove utilizzarla quindi per utilizzarla quello che possiamo fare è e e e e e e e e e e e due parametri ovviamente questo esempio è veramente stupido però per farvi capire come funziona il tutto allora abbiamo due modi per chiamare una funzione di un di un modulo e la funzione il modo più corretto è fare sempre usare il path totale submodule punti add e ritorniamo x più y l'altro modo alternativo è chiamare questa funzione in questo modo add perché lui capisce che add fa parte di questa roba qui però per questioni che vedremo più in là aspettamente nel momento in cui riusciremo a mettere su un server è sempre meglio e dargli il path il full path perché questo perché si costringerà il l'interprete a caricare sempre la versione più recente di questo modulo di questa funzione quindi cosa succede se noi quella compiliamo quindi la modifichiamo la compiliamo lui utilizzata sempre quella più più la funzione più più recente la versione della funzione più recente però questo lo vedremo tra un paio di lezioni allora ricompiliamo il modulo ovviamente vedeteci dall'errore che non lo esportiamo barra expo no barra mia fan di 2 e ora la possiamo utilizzare quindi c di no se di mia fan di 1,1 dovrebbe darci 2 ok quindi vedete in questo modo potete caricare le funzioni e le sottofunzioni di un modulo questo l'abbiamo visto questo è quello che vi dicevo abbiamo due modi per chiamare una funzione o dandogli il suo nome oppure usando il path il path totale se usiamo il path totale forziamo sempre l'interprete a caricare la versione più recente quindi se la funzione cambia sotto lui caricherà la più recente quindi cosa ci vuol dire cosa ci dice questo questo ci dice che possiamo fare nel momento in cui noi metteremo su un server dell'hot swap di codice in maniera del tutto trasparente quindi vuol dire che possiamo cambiare delle funzionalità del mod del server senza che il server venga stoppato e venga riavviato quindi come dicevo questa roba verrà diventerà più semplice nel momento in cui cioè diventerà più chiara nel momento in cui parleremo un po' di concorrenza allora le liste parliamo un po' delle liste abbiamo visto che il costruttore delle liste sono le parenti quadre forse alcuni di voi conosceranno la comprensione delle liste in Python per esempio quindi cos'è la comprensione delle liste? è un modo abbastanza veloce per creare delle delle liste o una qualsiasi struttura dati in maniera veloce quindi per esempio se noi come funziona la comprensione delle liste? quindi io voglio creare una lista di elementi x ad esempio tale che x mi viene pescato da una lista di elementi questa a b c d e f 1 2 3 4 5 6 e e mi metto e tale per cui i valori siano maggiori di 3 quindi cosa voglio dire? voglio dire che voglio creare una lista a partire una sottolista a partire dalla lista di cui tutti gli elementi sono maggiori di 3 questo perché? perché lui prende il codice no questi sono questi sono degli atomi gli atomi si confrontano con gli interi e si fa in questo modo e possiamo anche creare strutture di dati più complesse no? quindi possiamo creare una lista di magari una lista di ad esempio una lista di duple quindi x x più 1 perché nessuno mi no x più 1 no perché poi darà errore sull'atomo quindi x quindi voglio creare una lista di coppie partendo da un'altra lista vedete che cambia il risultato oppure quello che volevo far prima è creare una lista di coppie numero più numero numero e suo successivo nel momento in cui però x sia maggiori di 3 e e ovviamente questa operazione su un atomo da errore quindi devo evitare tutti gli elementi che non sono interi quindi faccio in questo modo e allora mi crea una lista mi crea una lista c'è qualcosa di strano in tutto ciò and x maggiore di poi un attimo x maggiore di 2 e lo sta prendendo andiamo ah ok e l'x maggiore di 2 e l'x maggiore di 2 in questo modo c'è qualcosa di strano in tutto ciò ecco qua ecco qua quindi infatti infatti infatti nel slide ecco questo è un altro errore nel slide era scritto in maniera giusta però io stupidamente non l'ho non l'ho non l'ho fatto quindi tutte le guardie devono essere sempre tra parentesi altrimenti lui capisce fischi per fiaschi quindi quando componiamo le clausole nella nella nella nella condizione bisogna stare attenti bisogna mettere le parentesi per creare la possiamo utilizzare anche questa funzione per creare i valori di ritorni di una funzione ad esempio possiamo creare una funzione quindi siamo creiamo un nuovo modulo barra module lo chiamiamo ls perché il modulo liste funziona quello che voglio fare è ls.rl quello che voglio fare è creare una funzione filter che preso un filtro è una funzione una lista quindi un filtro cos'è? un filtro è un operatore booleano mi ritorna una lista di elementi x tale per cui x viene preso da l e f è vero esattamente quello che stavamo scusate qui è il doppio quindi la esporto esporto filter che prende due elementi e compiliamo compiliamo quindi c c per compilare cdls ok quindi io chiamo ls due punti filter e gli passo una ok ora devo passargli una una funzione e una una lista allora come lista possiamo passargli i primi dieci numeri della lista e come funzione come filtro possiamo creare una funzione runtime quindi fun che prende una x mi ritorna se x è maggiore maggiore di 2 ad esempio quindi cosa succederà se va tutto bene mi ritorna una lista che contiene gli elementi a partire dal 3 fino a 10 ecco ho sbagliato perché manca l'endo finale nel momento in cui creiamo sempre una funzione a runtime questa è una funzione lambda bisogna sempre chiudere lo scopo della funzione ecco come vi dicevo possiamo creare una funzione e filtro in questo modo oppure possiamo dirgli dammi tutti i numeri vediamo un attimo se la ram ora non ricordo più come fare un attimo quindi 2 ram quindi 4 ram 2 vediamo cosa succede 0 ok quindi ritorniamo il fatto che se m è uguale uguale a 0 quindi cosa stiamo facendo stiamo facendo un filtro per creare stiamo filtrando una lista sui i numeri pari quindi il ram è il resto il resto per intero ovviamente se facciamo se facciamo diverso da 0 vuol dire che stiamo ritornando la lista dei dei spari ok in più possiamo anche questa è una funzionalità allora siccome le funzioni sono dei tipi di dato in in Erlang possiamo creare una funzione che restituisca delle funzioni cosa stiamo facendo qui stiamo creando una ad esempio io voglio stiamo creando una lista è più semplice vedere il risultato e poi capire cosa si fa stiamo creando una lista di una lista di funzioni che rendono un parametro e restituiscono x più y possiamo farla molto più semplice dove x è preso da una lista per esempio dai primi 100 numeri naturali no 100 non è troppo perché poi vediamo un attimo cosa succede questo mi creerà una lista di funzioni mi creerà una lista di funzioni che mi ritorneranno 2 3 4 5 6 7 8 9 10 fino a 11 e ovviamente ho sbagliato perché manca l'end ogni volta me lo scordo e ovviamente ho sbagliato perché sec prende due parametri vediamo che ok vedete mi ritorna una lista di funzioni ora se io se io lo applico quindi facciamo qualcosa di questo tipo end entail uguale a questo lo applico lo assegno quindi ritorno una lista quello che faccio è mi prendo la testa quindi head entail di nuovo perché e poi quindi head è una una funzione quindi se head gli applico qualcosa quindi nullo mi restituisce due perché mi restituisce due perché mi prende cos'è cos'è cos'è h h è la prima funzione che mi prende uno e mi somma due cioè scusate che mi prende uno quindi x è uno e mi somma uno la seconda è la funzione che è a due somma uno la terza è la funzione che somma a tre uno la quarta e così via quindi vedete ritorniamo una ritorniamo una lista di funzioni parziali qui era fatto più semplice qui essenzialmente creavamo il creavamo una lista di funzioni che prese un parametro gli sommava uno due tre quattro cinque così via allora come come vi ho detto già prima nelle altre lezioni esiste un il manuale quindi esiste la documentazione online delle di tutti i package che Erlang mette a disposizione generalmente si riferisce a quando quando leggiamo beef sono le built-in functions quindi le built-in functions sono le funzioni fornite quindi i moduli forniti i basici forniti da Erlang il modulo lists è uno dei più comuni dei più potenti e va veramente usato e se noi andiamo a guardare il modulo lists abbiamo un po' di funzioni abbiamo già viste sec2 sec3 l'abbiamo viste abbiamo la funzione filter che che già il nome dovrebbe dirci cosa fa cioè la funzione filter prende una una lista è una funzione booleana applica e ritorna una sottolista che soddisfa i cui elementi soddisfano il valore booleano che il valore booleano che ritorna la seconda lista scusate la seconda funzione ora lo vedremo poi abbiamo folder e foldel forreach e map queste sono veramente importanti ora le vedremo un po' tutte e tre queste funzioni sono veramente importanti e io vi sorto a prendere dimestichezza sicuramente se voi avete fatto l'esame di programmazione logica e funzionale col bernardo dovreste già saperle queste allora abbiamo questo sec è abbastanza importante l'abbiamo vista quindi gli diamo l'estremo inferiore l'estremo superiore e ci ritorna compresi la sequenza di tutti i numeri compresi nell'intervallo che noi abbiamo definito se noi usiamo la sec 3 quello che gli diciamo gli diciamo anche il passo con cui lui deve creare questa sequenza esattamente questa non è nient'altro che il risultato di un for quindi questo è il for in cui inventiamo l'iteratore di 1 e qui lo inventiamo di 2 e così via vedete questa l'avevamo già noi l'avevamo già vista filter allora io posso creare una funzione pari e prendo una lista e mi restituisce quindi punto vedete che c'è differenza tra definire delle funzioni definire delle lambda funzioni quindi la funzione pari che mi fa mi prende list punto filter in cui tutte le funzioni liste cioè filter map e quant'altro il primo elemento è sempre la il primo elemento è sempre la lista no sbagliato l'ultimo elemento è sempre la lista quindi quello che vi stiamo dicendo è applica mi filter su l e la funzione è una funzione che prende un elemento sensualmente questa funzione viene applicata n volte quindi per ogni elemento sensualmente c'è un iteratore per ogni elemento di questo l viene applicata questa funzione quello che noi stiamo facendo è vogliamo una funzione pari quindi vogliamo che x x rem 2 sia uguale a uguale a 0 questo è quello che abbiamo fatto prima la esportiamo e pari barra 2 la esportiamo compiliamo sperando di non aver fatto errori quindi facciamo cdls pari 1 ecco qual è il problema che questa l'ho definita come pari 1 e però la esportavamo come pari 2 e lui diceva guardate questa non riusciamo cioè quella non la utilizzerai mai ok lls di pari in cui li passo il spunto sec da 1 a 100 e quindi vedete mi restituisce la lista dei primi di tutti i pari contenuti contenuti compresi tra 1 e 100 ovviamente noi possiamo anche creare delle vediamo un attimo ovviamente possiamo grazie al pattern matching possiamo utilizzare delle cose un pochino più complicate mettiamo caso che la lista sia una lista di dati strutturati per esempio mettiamo caso che la lista sia sia composta da nome cognome e corso quindi quello che stiamo facendo è voglio creare una lista che mi selezioni già che mi creo mi creo una funzione che mi popola il mio database quindi popolate mi ritorna ad esempio una lista abbiamo detto di elementi tipo disney abcc to ti che segue il corso di IoT ad esempio. Quindi Populate non c'è bisogno di esportarla perché tanto la voglio usare internamente e quello che voglio fare è una... è una filtra che mi filtra sul corso, quindi se io gli do un corso mi deve restituire una list di sister. Ricordate che l'ultimo elemento è sempre la lista. Quello che io posso fare è fare questo. Siccome so che i miei elementi su cui andrò a iterare sono delle duple, quello che posso fare è scrivere una funzione che prende una dupla di cui non mi interessa... e qui posso direttamente scrivere questa roba qui, quindi mi mi filtra tutti gli elementi che hanno come corso il parametro che io gli ho dato in input. E ovviamente questo deve ritornarmi su. Non sono sicuro che funzioni in questo modo, vediamo un attimo se gli piace, altrimenti dobbiamo cambiare un po' la strategia. Esatto. E shadow, vedete, quindi P and P è uguale o uguale a C. Esattamente qualcosa del genere. In questo modo, ora la esportiamo uno. Quindi se non chiamiamo filter di ADCC mi restituisce solo PIP e Pluto. Se io scrivo IoT dovrebbe restituirmi solo DeFi. Vedete, vedete come... Questo lo vediamo. Vedete come in una semplice riga possiamo scrivere una funzione veramente complicata utilizzando anche il pattern matching. Qui stiamo dicendo, guarda, tutti gli elementi della mia lista sono delle triple. A me non interessa il nome e il cognome perché la filter mi restituisce l'elemento che soddisfa questo filtro, questo pattern. Quindi a me quello che mi interessa è confrontare il terzo elemento e vedere se questo terzo elemento è uguale al mio... al corso che... cui sono interessato. Capite che scrivere questa roba qui che prende una lista da questo... da questo... una lista generata sempre staticamente o prendere qualcosa da una lista che è generata da una tabella quello che vi sto dicendo è potete... questa alla fine diventerà una nostra query una nostra query per un database in cui noi diciamo sempre con la stessa funzione e gli diciamo vedimi tutta l'anaglattica degli studenti e trovami tutti gli studenti iscritti al corso ADCC. E lo si fa esattamente con questi... con questi strumenti che vi ho dato né più né meno. Poi lo vedremo più là. Ma... in linea di massima si scrive la funzione di filtro che fa del pattern matching pesantissimo e così via. Ovviamente un altro modo era un modo un po' molto... molto più inefficiente era prendere una... un elemento sapere che questo elemento è fatto in questo modo e... e... e... e... e... e... e... e... e... e... uguale a x e poi fare questo tipo di... e... chiamiamola filt filt filt 1 ok compiliamo quindi se io chiamo filter IoT o filt su IoT e... filt scusate il risultato è uguale però qui cosa ho dovuto fare? qui ho detto invece di definire in maniera concreta gli elementi della mia funzione ho definito una funzione generica e poi ho dovuto spacchettare il contenuto del... del... del... dell'elemento in una tupla e poi confrontarlo quindi sicuramente questa roba qui io posso farla direttamente alla dichiarazione della funzione senza complicarmi la vita ecco qui facevo un esempio con... con... con informatica ad esempio con quegli... con gli iscritti al corso piuttosto che alle... alle... all'esame allora e... la funzione list scusate la funzione filter quello che fa è presa una lista la filtra quindi crea un sotto insieme gli elementi di questa lista che soddisfano un particolare requisito questo particolare requisito è dato dal filtro e il filtro deve essere una funzione che restituisce un booleano quindi o true o false allora però potremmo anche aver bisogno di fare altri tipi di funzioni altri tipi di operazioni su una lista ad esempio calcolare se so che la lista è composta da numeri naturali quello che voglio fare scrivo nella funzione che mi calcoli la somma la somma di... che mi calcoli la somma di questa lista e cosa posso fare? posso farlo in due modi usando la fold r o usando la fold l qual è la differenza? la differenza è che da dove si inizia a calcolare questo aggregato quindi la fold l e la fold r si utilizzano quando io voglio creare un aggregato degli elementi della lista ora o inizio a crearlo dalla dalla sinistra quindi fold l l sta per left oppure inizio dalla destra quindi o dal primo elemento o dall'ultimo elemento o dalla testa o dall'ultima coda che ho generalmente è abbastanza se le operazioni se l'operazione è additiva tipo la somma la somma è additiva questo tipo di usare la fold l o usare la fold r è praticamente uguale quindi quello che sto dicendo è vedete tutte le funzioni delle liste prendono come l'ultimo parametro è sempre la lista su cui iterare il primo parametro è la funzione come la filter però noi prendiamo un accumulatore cos'è l'accumulatore? l'accumulatore è quello che ci ci permette di calcolare l'aggregato e l'aggregato finale sarà l'applicazione della funzione all'ultimo accumulatore e la la prima funzione verrà chiamata con il con il primo accumulatore di nuovo questo è molto più semplice vederlo che scriverlo però se noi vogliamo fare la somma quindi scriviamolo in questo modo dove siamo qui sum list prendo una lista quello che voglio fare è creare mettiamoci al punto altrimenti faremo this fold r no left fold l quello che voglio fare io è questo iterare sulla lista la funzione abbiamo detto che prende un accumulatore ora qual è l'accumulatore? qual è l'elemento? l'accumulatore il primo accumulatore è quello che verrà passato la funzione quindi qual è l'elemento neutro della somma? l'elemento neutro della somma è lo 0 quindi per me il mio primo accumulatore sarà 0 quello che io faccio è scrivere una funzione che prende l'accumulatore e l'elemento iesimo della lista e quello che fa se io voglio calcolare la somma è x più a end perché altrimenti becchiamo qualche errore di compilazione l'esporto quindi sum list di 1 perché prendo un solo elemento ok proviamo a compilare quindi io quello che voglio fare è sum list list list list vediamo se ce la faccio sec quindi io dico di farmi la somma dei primi 10 dei primi 10 numeri naturali 55 dei primi 100 dei primi 1000 e lui lo fa vedete quanto è potente quando uno inizia a capire veramente come poter utilizzare queste liste è come poter utilizzare le funzioni le funzioni le funzioni lambda allora ripetiamo la lista la funzione filter ritorna una lista le funzioni foldl e foldr ritornano un elemento di qualsiasi tipo questo elemento è l'aggregato e quindi ricordate che l'aggregato siccome ritorna un elemento e questo elemento deve essere in qualche modo una composizione degli altri aggregati la funzione prende un ulteriore parametro che è l'accumulatore e questo accumulatore deve essere utilizzato dalla funzione quindi quello che vi sto dicendo io è questo che la prima funzione quindi il primo elemento questa funzione verrà chiamata sul primo elemento della lista che è 1 perché noi stiamo calcolando da 1 a 10 quindi l'elemento sarà 1 e l'accumulatore sarà 10 scusate sarà 0 quindi ritornerà 1 più 0 nella seconda volta l'accumulatore sarà 1 perché è 1 più 0 e l'elemento iesimo sarà 2 quindi faremo ritornerà la somma di 2 più 1 3 ora 3 lo dobbiamo sommare di nuovo a 3 e ritornerà a 7 che verrà sommato a 4 e così via fino ad arrivare alla fine oppure possiamo se noi non ci interessa l'elemento iesimo l'elemento iesimo della lista quello che possiamo fare è calcolare no per esempio mettiamo caso che non ci interessa l'elemento iesimo della lista e vogliamo solo calcolare la dimensione di una lista quello che vogliamo fare è iterare sulla lista e sommare sempre 1 quindi ovviamente ho sbagliato cioè ho sbagliato qui è praticamente uguale però il primo elemento è il primo elemento è l'elemento della lista e il secondo è l'accumulatore quello che io voglio fare è size che prende una lista e mi ritorna la dimensione della lista invece di chiedere list.lang length quello che facciamo è lists fold l pawn ricordate di mettere sempre l'end virgola la lista e l'accumulatore 0 quello che vogliamo fare è vogliamo una lista non mi interessa voglio l'accumulatore e quello che voglio fare è ritornare l'accumulatore più 1 perché voglio contare solo quanti elementi quanti elementi fanno parte della lista chiudo dovrei aver fatto tutto in maniera corretta si esportiamo size prendo un elemento la compilo quindi chiamo size di su 100 mi sono 1000 e dovrebbe ritornarmi 1000 ecco qui ho sbagliato a chiamare la funzione fold no fold fold ok ricompilo fold l ragazzi scusate fold l la funzione è fold l ok vedete mi ritorna 1000 che è la la dimensione quindi ho sommato 1000 volte 1 quindi vuol dire ho sommato il risultato finale è 1000 uno potrebbe anche fare qualcosa di questo tipo di list punto length mi ricordo va bene lasciamo stare ecco un modo abbastanza abbastanza intelligente di fare la reverse di una funzione è utilizzare quindi faccio la reverse presa una lista l mi restituisce punto mi restituisce list hold l altrimenti qui vi ricordate l'ultimo parametro è sempre la funzione scusate è sempre la lista qui il primo parametro è sempre la funzione quindi la funzione prende un elemento è l'accumulatore e quello che ritorna è allora vogliamo invertire la lista quindi cosa facciamo noi è accumulatore più più la lista è l'elemento l'elemento neutro della l'elemento neutro della della concatenazione di delle liste è la lista vuota il contrario x più accumulatore quindi ritorniamo x più più quindi veicola reverse vediamo che prende un parametro compiliamo quindi vediamo quindi lui avverte nel momento in cui voi dichiarate una variabile non la utilizzate mai io qui avevo sbagliato perché qui scrivevo accumulatore mentre qui utilizzavo hack quindi lui diceva guarda questa funzione questa questa variabile non è mai utilizzata allora allora faccio il reverse e ottengo l'inverse ottengo la lista ribaltata ok ok allora abbiamo visto due tipi di funzioni sulle liste uno che data una lista mi ritorna una sottolista di elementi i cui elementi rispettano o si rispettano un determinato filtro due funzioni la fold l e la fold r che data una lista io creo un aggregato e questo aggregato è una funzione che in qualche modo deve fare qualcosa con un accumulatore oppure banalmente io voglio applicare la stessa funzione su tutti gli elementi della lista quindi se solamente preso una lista di n elementi quello che voglio ottenere è una lista di sempre n elementi in cui applico f al primo elemento cioè ottengo una lista di applicazioni della funzione quindi per dirvi per farla semplice quello che posso fare è creare una funzione che presi i primi n numeri mi restituisce la potenza quindi l'elevato a potenza di ogni numero quindi o lo chiamiamo così list map no for each no questa la vediamo un attimo list punto map allora map è quella che mappa questa roba qui quindi prendiamo l di nuovo ritorniamo a parlare di di di una funzione che prende due elementi l'ultimo elemento è sempre la lista quello che faccio è prendere una funzione una funzione e prende il diesimo elemento della lista quello che fa è mi fa x per x per x quindi si la esportiamo ecco qui qual è il problema è che non ho messo il punto finale quindi lui dice guarda questa funzione tu stai esportando una funzione che non esiste perché questa non riusci a interpretarla ok quindi chiamiamo lista di pow su list.sec quindi vedete questo ritorna una lista di applicazioni quindi essenzialmente quello che fa è mi ritorna una lista di se io ho una lista di elementi quello che mi ritorna è una lista di f di x qualcosa del genere però a volte vorremmo anche invece di farci ritornare una lista vorremmo banalmente applicare la stessa funzione a una lista e non tenere conto del risultato quindi non voler creare una lista non voler creare un aggregato ma semplicemente creare cioè iterare la stessa funzione su n su n parametri o n numeri quindi posso utilizzare la lista for each quindi posso scrivere una funzione print all che ha preso una lista mi stampa tutti i numeri della lista video allora end punto quello che facciamo è invece di usare la map perché la map ritorna una lista mentre quello che noi andiamo a utilizzare ora è la for each la for each non ci ritorna ci ritorna ok come atomo quindi ci ritorna il fatto che l'applicazione sia andata a buon fine quindi for each for each scusate qui anche qui l'ultimo parametro è sempre la lista su cui iterare e il primo parametro è una funzione che prende l'iesimo elemento della della lista end e quello che fa è vogliamo stamparlo a video quindi io format iniziamo a prendere dimestichezza anche con questa roba tilde tilde tilde p barra n e con p gli diciamo di questa roba qui quindi cosa gli stiamo dicendo gli stiamo dicendo stampa io format quindi stampa video un elemento generico e questo elemento generico deve essere sempre una lista perché qui sicuramente gli stiamo dicendo stampa il primo parametro che è contenuto nella lista che passa da come parametro questo dovrebbe andare ok print all d1 ok anzi facciamo pure una cosa facciamo pure esportiamo esportiamo esportiamo populate e non prende nessun parametro quindi 0 ora vi spiego perché allora abbiamo sbagliato qualcosa io format end ecco qua quest'end non serve a nulla quest'end è un reso è un refuso ecco qua quindi quello che vogliamo è print all di list punto sec di 1 a 100 e dovrebbe stamparmi a video i primi 100 numeri ecco qua però posso anche chiamarlo siccome sto stampando l'iesimo l'iesimo elemento di una lista genetica posso anche dirgli di stamparmi il mio database vedete e me lo stampa quindi la stessa funzione polimorfa su vari su vari tipi di dato basta che siano liste di di dati e questi dati cioè che la funzione su cui noi applichiamo sia abbastanza generica quindi qui stiamo applicando la la for each la for each che stampa video qualcosa ok vediamo un attimo cosa c'è altro questa l'abbiamo vista ovviamente possiamo ritornare il l'elevato a potenza oppure non è detto che noi dobbiamo ritornare per forza un tipo di dato primitivo possiamo anche creare dei tipi più strutturati in questo caso per esempio se noi scriviamo questa funzione a console direttamente quello che fa è mi ritorna una lista di coppie 10 coppie perché da 0 a 10 e 11 perché da 0 a va da 0 a 10 quindi 11 coppie di elementi formati da numero e numero al quadrato quindi 0 0 1 1 2 4 3 9 4 16 e così via 100 100 10 100 scusate come vi dicevo il come vi dicevo il il il modulo list è veramente potente le liste sono veramente un tipo di dato basico ma importante per Erlang quindi vi permette cioè il mio consiglio è giocate parecchio con le liste quindi iniziate ripetete gli esempi iniziate a farli da soli ora parliamo un attimo di record allora perché parliamo di record i record sono una i record sono un elemento strano perché sono dei tipi di dati compositi però che vengono pesantemente utilizzati da Erlang vedremo che i record vengono mappati in tabelle quindi ogni record è una riga di una tabella e quindi una tabella sarà una lista di record perché dico che è un tipo di dato strano perché essenzialmente un record è una dupla un record con n elementi è rappresentata da Erlang come una dupla con n più 1 elementi il cui primo elemento primo campo è il nome del record stesso quindi per usare il record bisogna cioè buona norma è creare dei file quindi creiamo un file di record .hrl a parte e noi lo includiamo quindi quello che facciamo qui è includiamo sto record hrl e mi creo e mi creo un file quindi scriviamo questa roba qui scusate lo copio e questo lo punto lo salvo come record .hrl allora il mio record lo posso chiamare studente e la struttura del record la vediamo subito come è fatta quindi questo è il nome della mia struttura quindi questo l'ho chiamato persona o associativamente uguale quello che posso chiamare gli do un campo che è nome un campo che è cognome e corza banalmente sto creando una grafica di studenti molto banale ok posso anche creare dei record che hanno dei valori dei valori base dei valori di default scusate quindi posso creare uno studente uno qualcosa di questo tipo in cui la in cui se non esplicito il corso di laurea per me è informatica corso uguale informatica chiamiamolo studente a sto punto no va bene va bene così ok vediamo un attimo se compiliamo che succede va tutto bene allora ora iniziamo a capire cioè iniziamo iniziamo a vedere qual è la differenza essenziale tra l'interprete e il il file compilato ora se io volessi utilizzare il record nella shell lui non capisce cosa stiamo combinando quindi per caricare dei record nella shell bisogna utilizzare la direttiva rr quindi se io faccio ora in questo modo lui capisce lui si carica in memoria le direttive di definizione dei record rr com'era sta roba eccolo qua rr records punto hrl non l'ha trovato perché altrimenti me l'avrebbe detti sicuramente l'ho chiamata record e non records ecco qua ora è andato a buon fine quindi lui si è caricato in memoria studente studente 1 allora vediamo un attimo ecco qui quindi quello che stavamo dicendo è questo abbiamo creato un record di persone abbiamo creato questi due tipi di record quindi quello che vi stavo dicendo è che per importarli quindi questa è la direttiva che noi diamo al compilatore per importarli generalmente uno scrive questo dove appunto hrl lui capisce che sono dei record altrimenti se vogliamo utilizzarli da console quello che bisogna fare è usare la direttiva rr allora noi abbiamo visto che abbiamo creato due tipi di record studenti e studente 1 dove studente è nome e cognome corso studente 1 ha il corso implicito quindi se non gli diamo nulla lui crea uno studente che è scritto al corso di informatica quindi quello che possiamo fare quello che si fa è questo per costruire un record questo è il costruttore però il costruttore bisogna anche dargli il nome quindi studente in questo modo noi creiamo un record vuoto vedete lui mette undefined undefined quello che noi facciamo è nome uguale a Claudio nome uguale sia è corso uguale a informatica e quello che farà lui è mi crea un mi crea un un un record di questo tipo ora quello che possiamo fare è ecco quindi quello che noi facciamo è record name field field è un atomo ricordatevi questo che il campo è un atomo campo 1 uguale a sta roba campo 2 e così via e ovviamente se cioè possiamo anche utilizzare questo tipo di espressione nel momento in cui gli ultimi n campi prendono lo stesso valore quindi esplicitiamo poi diciamo che da da k più 1 in poi tutti i record tutti i campi prendono questo tipo di questo tipo di valore quindi noi abbiamo fatto creiamo qui una funzione quindi quello che possiamo fare è crea studente che prende il nome il cognome è il corso cs il corso di studi quello che fa è crea una persona il cui nome uguale a n cognome uguale a c e cs quindi è il corso uguale a cs né più né meno quello che abbiamo fatto né più né meno quello che abbiamo fatto in console e quindi poi quello che io faccio è questo esportiamo crea come l'ho chiamato la studente e prende tre parametri ok va bene quindi compiliamo cs cs isanused perché cs isanused corso quale cs nome uguale a n cs news e n perché persona non gli piace effettivamente non gli piace perché non è personale studente perché abbiamo creato il record studente non il record personale quindi lui aveva dei problemi a capire cosa noi quindi crea quindi lsd crea studente di pippo vodo pippo disney inform in informatica e mi crea un record di questo tipo ovviamente posso anche creare delle funzioni che prendono che prendono dei record quindi posso creare una funzione che dato quindi quello che sto dicendo io è questo get name ad esempio posso creare una funzione che prende uno studente prende uno studente e mi ritorna il suo nome quindi posso farlo in due modi ora non ricordo bene ma questo lo vedremo più in là non mi ricordo bene se persona image pattern matching no questo lo vediamo più in là questo lo vediamo più in là questo lo vediamo più in là lo vediamo quando vedremo i quando vedremo i i database allora come vi dicevo i record sono sono essenzialmente delle tuple strane in cui il primo elemento è il nome del record ci sono due funzioni molto importanti che utilizzeremo per mappare un record una tabella uno è il record info quindi iniziamo a capire che il record info mi prende di studente abbiamo detto sbagliato fields fields per studente quindi che gli sto dicendo gli sto dicendo dammi le informazioni su questo record e l'informazione che io voglio sono i campi i campi quindi l'umidità nome cognome e corso posso anche dirgli dammi la dimensione quindi size è 4 quindi vedete vedete che la dimensione è 4 mentre i record sono 3 scusate mentre i campi sono 3 perché come abbiamo già detto il primo elemento è il primo elemento è il nome del record stesso quindi noi vedremo un record che si chiamerà studente quindi questo record ad esempio viene rappresentato come una una tupla che ha come primo campo studente poi ha pippo disney e corso ma questo lo vedremo più in là quindi va bene questo conclude la parte iniziale di Erlang sulla parte sequenziale vi vi esorto a giocare un po' con tutto il materiale che è presente nelle slide a cercare di fare più prove possibili quindi modificare un po' i piccoli esempi e dalla prossima lezione parleremo finalmente di concorrenza ma di nuovo parlare di concorrenza vuol dire aggiungere una funzione per creare degli attori è una funzione per mandare un messaggio degli attori quindi se noi abbiamo scritto un programma che funziona in maniera sequenziale scrivere un programma che funziona in parallelo è veramente banale questo lo vedremo nella prossima lezione