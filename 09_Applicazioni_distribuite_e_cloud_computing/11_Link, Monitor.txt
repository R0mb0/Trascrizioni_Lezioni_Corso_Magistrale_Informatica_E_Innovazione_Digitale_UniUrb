ok va bene ragazzi allora e ora iniziamo la parte finale del corso di erlang quindi parleremo di abbiamo iniziato a parlare di erlang distribuito abbiamo visto come usando la spawn 2 invece della spawn 1 la spawn 4 invece la spawn 3 riusciamo a usare lo stesso programma in distribuito con distribuito intendo su vari modi della della rete vari nodi erlang e spawn 2 e spawn 4 il cui primo parametro è il nome del nodo in cui noi vogliamo fare eseguire o attivare quell'attore vi ricordo sempre che le spawn istanziano un attore che segue una funzione quindi se la funzione per qualche modo fallisce allora l'attore muore però la spawn va sempre a buon fine perché perché la spawn l'unica l'unica cosa che vi deve restituire è un è un pid allora ora parliamo un po di parliamo un po di di gestione degli errori no perché finora vi ho venduto erlang come un linguaggio di programmazione software real time l'abbiamo visto poi time out distribuito l'abbiamo visto però abbiamo detto anche che un'altra un'altra feature di erlang è il fatto di essere resiliente agli errori e ora vedremo come si fa essere resiliente agli errori essenzialmente tutto si riduce in erlang in ricevere e processare messaggi quindi un errore vuol dire che uno quando un nodo crash a un qualche nodo suo parente chiamiamolo così viene notificato e come viene notificato secondo voi gli viene mandato un messaggio e questo messaggio ovviamente ha una priorità diversa rispetto ai messaggi normali no perché deve essere gestito in maniera immediata e quindi essenzialmente quello che faremo è che quando noi lanciamo un server quando il monitor del server riceve il messaggio che il server ha terminato in maniera anormale allora lui lo ristanzia da capo essenzialmente questo è il trucco ecco quindi essenzialmente quello che vi dicevo che erlang mette a disposizione dei meccanismi per creare dei monitor su degli attori cosa sono i monitor sono degli attori a loro volta che aspettano dei messaggi ripeto di un certo tipo e agiscono di conseguenza questa conseguenza cos'è risponare un attore quindi risponare da capo la funzione che l'attore è stato eseguendo perché l'idea di base è che un attore non ha mai stato quindi stiamo parlando sempre di oggetti stateless quindi rimetterli su è veramente semplice poi abbiamo visto che i server possono avere lo store e questo store magari è gestito attraverso delle tabelle quindi si tira su un server e lui si ritira su tutte le tabelle che stava usando ecco in maniera abbastanza indolore quindi la cosa distintiva di Erlang è che anche gli errori vengono gestiti come messaggi e di nuovo tutto si distingue si distilla in ricevere messaggi e gestire i messaggi allora come vi dicevo o come avete intuito la filosofia di base è che se un nodo sta per fallire o un attore sta per fallire lo si fa fallire quindi la filosofia di Erlang è il legit crash perché è più semplice è ristanziare l'attore piuttosto che porre il rimedio all'errore che sta facendo perché di nuovo spawnare una funzione costa veramente pochissimo all'environment di Erlang quindi di nuovo qual è la policy? la policy è che se un autore deve fallire o fa un'operazione strana lo si fa terminare perché è più semplice ristanziarlo da capo piuttosto che porre il rimedio all'errore che ha fatto e magicamente di nuovo come si fa a fare sta roba? la si fa attraverso una primitiva di nuovo perché Erlang ha come primitivo il fatto di gestione degli errori quindi la gestione degli errori viene data come una primitiva nativa del linguaggio non viene costruito attraverso altre altre robe esistono due tipi di primitive ora vediamo la link ma vedremo anche la monitor cos'è la link? la link crea un link quindi un canale bidirezionale tra due attori quindi entrambi gli attori sono collegati attraverso questo link quindi nel momento in cui uno fallisce l'altro viene notificato e viceversa quindi è un canale bidirezionale non c'è una direzione quindi entrambi sono posti attraverso il link sono in... sono in... sono peer tra di loro quindi è un link tra peer non esiste un supervisor o un monitor quando parleremo di monitor è unidirezionale quindi quando parleremo di monitor parleremo anche di gerarchia di monitor mentre il link è fatto tra attori dello stesso livello quindi tra peer quindi cosa succede? la link crea un link tra un attore ed un altro e quindi cosa succede? un attore chiama la link dando in parametro un altro pid quindi lega se stesso all'attore come abbiamo visto per creare un attore si usa la spawn quindi uno cosa farebbe? farebbe un attore crea un altro attore e poi crea il link però questa azione non è atomica quindi magari nel momento in cui voi create l'attore poi dal momento in cui avete creato l'attore create un link passa del tempo l'attore è fallito e quindi poi il link non ha motivo di essere quindi cosa fa? cosa fa Erlang? Erlang ha ha in built-in una funzione che vi fa direttamente lo spawn e la link quindi spawna un attore e ve lo linka direttamente quindi la spawn link crea un attore lo linka e in maniera atomica piuttosto che farlo in due passi perché se è fatto in due passi e quello fallisce prima di fargli il link allora non verremo mai notificati noi che invochiamo la spawn più il link non verremo mai notificati del fatto che l'attore non esiste più quindi come vi dicevo i processi sono linkati tra di loro quindi questo è il modo standard di indicare tra di loro e come vi dicevo i link sono dei canali bidirezionali quindi se questo spero che possiate vedere comunque se se questo dove dove dove se questo fallisce allora questo gli arriva un messaggio m s g oppure se questo fallisce quest'altro viene notificato con un messaggio che questo è stato fatto tipo un exit un exit è una ragione quindi essenzialmente è come ricevere un'eccezione quindi nel momento in cui ci avete un link è come se voi aveste un try catch un try catch in cui le throne sono fatte dal dall'interruzione cioè le throne sono gestite come dei messaggi ok no aspetta aspetta cancelliamo sta roba perché rimarrà per sempre ok quindi essenzialmente quello che succede di nuovo continuo a stressare sta cosa perché alla fine Erlang è tutto come dicevo stamani a lezione è tutto una questione di leggere di mandare e ricevere messaggi e di reagire perciò si parla di sistemi inattivi di reagire a certi messaggi che hanno un certo formato quindi quando due processi sono linkati tra di loro e uno termina in maniera anormale l'ecosistema genera un exit un segnale di exit che viene tradotto in un messaggio di exit che verrà gestito dall'altro dal processo dal processo linkato ora abbiamo due tipi di comportamenti se il processo linkato non ha settato la trap quindi non cattura i signal allora lui fallisce a sua volta quindi si crea un effetto domino se il messaggio il processo che ha linkato ha il flag di trap a true allora lui riesce a trattare questo segnale come un messaggio quindi di nuovo quando un un un attore muore viene generato un messaggio e questo messaggio viene mandato a tutti i processi che sono linkati a lui quindi viene creato un messaggio di exit il pid quindi chi è chi è morto perché il pid perché un attore potrebbe essere linkato quindi se noi pensiamo a una topologia a stella un attore può essere linkato a quindi l'attore al centro a n a n altri attori quindi nel momento cui uno di questi n fallisce lui deve capire l'identità di chi è fallito no qualora lui volesse ristanziarlo con una funzione particolare e quindi c'è l'exit che è un atomo è un atomo perché capiamo che è un atomo perché è tra apici il pid quindi chi è morto quindi l'identità di chi è morto e poi la reason la reason why no quindi il sarebbe il messaggio dell'eccezione questo come vi dicevo prima se un attore è legato a più nodi e lui è uno dei suoi nodi muore e lui non cattura questo questo questo messaggio di exit a sua volta fallirà e lo manderà a tutti quelli a lui collegato quindi si fa un effetto domino che essenzialmente è come quando in java non si catturano le eccezioni e si si parte dalla parte più bassa e poi si arriva fino al main e poi se il main non riesce a catturarla esplode tutto il programma no generalmente l'idea gestire gli errori e questa qui tu lo mandi a un livello più alto se riesci a gestirlo bene se non lo continui a mandare continua a mandare se non lo gestisci muori quindi se vediamo questo esempio in cui registriamo allora proviamo a fare questo esempio siamo qui sì quindi touch come l'abbiamo chiamato questa roba a per chiamiamolo fail.l open fail.l quindi quello che stiamo facendo è creare un attore copio di pari passo quello che c'è nelle slide poi su repository no su blended c'è un esempio completo fatto negli altri anni che è molto esaustivo allora quello che noi facciamo è dove sono le slide creiamo un server banale che cioè senzalmente è un incrementatore che incrementa la che incrementa il contatore di un quindi stiamo creando un contatore un contatore distribuito quindi add one loop loop receive vabbè facciamo una cosa diversa quindi quello che stiamo facendo è quindi l'abbiamo chiamato ricordatevi il modulo deve avere lo stesso nome del file module fail quindi quello che facciamo è add one no add one come l'abbiamo chiamato qui loop loop vabbè facciamo un esempio diverso quindi loop quindi la loop che fa receive add and and se riesco quindi se riceve add con x è il pid questo è gli ritorna gli ritorna però questo era più diverso sì ok gli ritorna facciamo facciamo un esempio semplice quindi gli ritorna a p gli ritorna x più 1 ok e poi loop di nuovo perché non deve terminare poi facciamo come dicevo vediamo stamattina se stoppa allora ok quindi questo va chiuso questo lo possiamo chiudere ok quindi poi facciamo una funzione start che fa la spawn spawn link di fail loop un parametro vuoto quindi esportiamo barra export start di 0 e loop di 0 ok finora l'unica cosa che abbiamo fatta in più è usare questa roba qui punto erl c non l'abbiamo chiamato fail ok allora facciamo start no fail di start dobbiamo ok ora esiste quest'attore quindi io mi faccio il pid pid di 0 91 0 e questo è un attore che riceve un numero e lo incrementa quindi di nuovo lo interroghiamo chi con add 10 add 10 e dobbiamo dargli self e se noi facciamo flash dobbiamo riprovarci un messaggio con 11 ok allora cosa vediamo un attimo che succede mettiamo caso che lo interroghiamo in maniera diversa invece di dargli 10 gli diamo un atomo quindi a 1 cosa succede lui fa un'operazione strana scoppia quindi è scoppiato baddarity e vediamo un attimo se modulo ok e quindi se facciamo di nuovo mi sono scordato mi sono scordato se facciamo self e p vedete ora non l'abbiamo visto ma cosa è successo è morto l'attore è morto perché p p è il p era il no p era il messaggio riproviamo a rifare tutto quindi self cosa è self è 96 vediamo un attimo quindi quindi ok quindi lo chiamiamo remoto uguale a r no fault ma non è biancava questa roba fail start ok quindi self questa roba qui ok e quindi self è 96 remoto se io faccio remoto remoto di add mi mando una stringa no però la stringa la prende gli mando pippo virgola self e quindi self era 96 vedete che vedete che la shell è morta perché è morta perché l'oggetto non l'oggetto il il il nostro attore con cui noi eravamo collegati è morto ci è arrivato un interrupt noi non l'abbiamo saputo gestire e siamo morti a nostra a nostra di conseguenza perché siamo morti perché il self è cambiato allora un modo per non morire esattamente è tra intrappolare quindi trappare intrappolare intrappolare intrappolare gli exit quindi bisogna bisogna settare il process flag a true quindi quello che noi facciamo è qui vediamo di fare lo spawn link settiamo il process plug trap exit a true facciamo la stessa roba quindi ricompighiamo c'è un errore perché non abbiamo messo la virgola ovviamente ok e f liberiamo tutte le variabili process flag ok spawn ok quindi chiamiamolo remoto uguale a fail di di la start ora proviamo a farlo fallire di nuovo quindi gli mandiamo remoto allora se gli mandiamo un add 10 e self quindi vediamo se self è 110 facciamo flash dovremmo trovarci un 11 tutto a posto se lo facciamo fallire quindi gli mandiamo un atomo perché fallisce? perché quest'operazione su un atomo non ha senso per lui quindi quando va a fare a runtime quest'operazione muore quindi a 10 quell'altro fallisce vediamo se il nostro feed è cambiato self non è cambiato quindi vuol dire che non siamo morti perché non siamo morti? perché se noi controlliamo ora nella nostra mailbox abbiamo un messaggio strano ecco qua quindi questo cosa è successo? il feed 123 è morto e ci è ritornato questo messaggio quindi cosa facciamo ora noi? facciamo questo per rendere un po' tutto più più dovremmo fare questa allora facciamo questa roba qui ecco perché nell'esempio era fatto in due modi addone quindi creiamo una funzione addone che prende un parametro e no che non prende nulla quindi fa receive receive un messaggio con un intero e un feed e ritorna x più uno quindi cosa stiamo demandando a un altro attore una subroutine ok quindi addone cosa fa? addone fa questo fa spawn spawn link va bene facciamo spawn link di sta roba di fail addone di sta roba qui quindi questo lo chiamiamo rem lo interroghiamo lo interroghiamo rem mi mandiamo add x e mi mandiamo il nostro feed self quindi cosa stiamo facendo? stiamo facendo stiamo demandando questa funzione ad un'altra funzione e poi receive no record scusate ma il mio ide è un po' receive and quello che facciamo è questo receive se noi receive facciamo una cosa del genere ok quindi se noi riceviamo un messaggio con ok e un intero allora mandiamo l'altro quindi ap gli mandiamo x ok se noi riceviamo un messaggio di questo tipo exit questa roba qui quindi a me non interessa la ragione e non interessa ma cosa è successo quello che dobbiamo fare è ristanziare l'attore ora vediamo un attimo come era fatto nelle slide vediamo un attimo no vabbè proviamo a farlo da noi quello che noi facciamo è se abbiamo abbiamo abbiamo ricevuto un messaggio di exit vuol dire che questo ha è fallito allora possiamo scrivere ap qualcosa di questo tipo receive and ok ok ok quindi loop loop scusate e anche qui failed e poi scriviamo no loop ok quindi quello che noi vogliamo fare è trappare l'exit qui aspone add one qui questo qui però dobbiamo farlo solo una volta solo una volta quindi invece di fare loop facciamo init questo b fa capire come si fa in loop server si fa prima la fase di unit in cui trappiamo e poi chiamiamo loop quindi si fa tutta la fase di inizializzazione del processo e poi si fa la fase questa ok add one start questo non ci serve si questo questo a noi ci serve si bisogna trapparlo perché abbiamo due attori spawn link init process spawn link init ok ok ora esportiamo init di 0 e add one vediamo che abbiamo combinato sicuramente c'è qualche errore ok ecco qua 8 8 19 receive 8 ecco qua manca una virgola e stop stop qui è un punto in virgola perché è una clausola e continuiamo ad avere errori 23 23 add one loop allora c'è qualcosa che è allora c fail 23 23 c'è un errore perché dice b sintax 11 11 11 11 11 loop exit end no no no no questo dice l'ora qui non è un attimo cls no clear l c fail ecco qua c'è qualcosa a 23 che non gli piace syntax error b4 punto 23 23 and one receive ah scusate ma qui manca land qui manca palesemente land ecco qua quindi dovrebbe andare bene ok ora lanciamo init quindi remoto remoto è uguale a fail file di init no no dobbiamo fare start dobbiamo fare start perché start chiama sta roba qui e se chiamiamo init cosa è successo va in loop lui quindi va bene c di fail e fail di start ok quindi remoto è uguale al pid di 0 91 0 punto quindi self allora proviamo self 84 proviamo a interrogare ora remoto remoto remoto di add c4 e self flash ok ok perché manca qualcosa manca qualcosa vediamo un attimo cosa manca allora remoto remoto quindi lui riceve questo qua riceve loop lui riceve add abbiamo detto add add 3 questo spawn link rem sta roba qui add x ecco vedete vedete come qual è il problema il problema qual è che questo li mandiamo add x self mentre questo si aspetta qui quindi mandiamo un messaggio con 3 valori 3 parametri passate nel termine mentre qui gli passiamo qui si aspetta un messaggio di tipo con 2 con 2 campi allora dobbiamo fare così quindi c'era un mismatch tra questo e questo allora ricompiliamo early c fail quindi di nuovo stamattina dicevo a lezione che bisogna stare attenti al tipo di messaggi che uno decide di fare perché poi deve rispettare quel tipo di protocollo perché inizioni di messaggi alla fine è un protocollo quindi fail di start quindi rm uguale a no il primo è il mio server server uguale a pid p0 91 0 quindi interroghiamo il server con add 5 sf flash ora dovremmo provare qualcosa nella nostra nel mailbox ok qualcosa abbiamo ricevuto non era quello che ci aspettavamo andiamo a capire cosa è successo add 5 self quindi lui add 5 self allora cosa è successo perché il il allora quando trappiamo quando siccome lui lui ecco vedete ragazzi è successo questo che lui termina termina in maniera buona però però però eh eh eh anche la terminazione in maniera buona genera un messaggio di exit quindi siccome il messaggio di exit ha priorità su questo lui parza exit e manda failed ehm ok proviamo andiamo a vedere un attimo la documentazione e erlang exit message ok vorrei capire un attimo qual è la reason giusta la reason exit vediamo un attimo la reason la reason eh proviamo ecco qui questa è la reason failed proviamo a fare un po' di debugging quindi eh eh c fail liberiamo tutto quindi r di add 5,6 flash normal quindi quello che noi possiamo fare è eh quello che noi possiamo fare è normal andiamo in loop è exit normal qualcosa exit che non è normal è qualcos'altro ma gli mandiamo fail no era ip.fail ecco la loop ecco qua qualcosa di questo tipo vediamo se gli piace questo dobbiamo chiuderla questa ok quindi liberiamo tutto eh quindi r uguale fail start r di add 5 self flash e ora dovremmo ricevere exit killed c'è qualcosa che è add 5 self add 5 exit normal killed allora killed andiamo un attimo mmm ok allora allora allora c'è qualcosa che c'è qualcosa di strano perché perché lui termina sempre quindi loop lo spona sempre no c'è un problema di fondo nella c'è un problema di fondo in questa in come l'abbiamo scritta allora allora facciamo così spawnlink rem self receive se abbiamo x loop e e se abbiamo exit killed no questa sarebbe normal però non va bene dobbiamo ripensare un attimo tutto l'esempio dobbiamo ripensare un attimo tutto l'esempio allora spawnlink e possiamo far così perché questo questo è un questo è un è un cane che si morde la coda allora poi facciamo receive no receive quello che vogliamo fare è questo receive e x e vogliamo rimandarlo ok questo c'è già quello che vogliamo fare è questo after after un secondo quindi un secondo se se questo non ha fatto non è riuscito a far qualcosa allora no però vediamo un attimo cosa c'era nelle slide perché questo va in timeout ok e questo era spawnlink request add1 request self int receive altrimenti ok ok però in questo esempio non c'era nessuna nessuna ok esempio ok monitor questo abbiamo visto come trappare trappare gli errori però quello che succede è che magari poi no su blend ce l'esempio giusto quello che quello che succede è che molte volte a noi non serve avere un link bidirezionale ma quello che serve è avere un monitor quindi avere un link unidirezionale in cui quello che si fa è invece di creare un link si crea un monitor quindi il monitor quindi i link sono bidirezionali i i monitor sono link unidirezionali e quello che si fa è creare un link tra il processo attuale e il processo che si vuole spawnare no quindi si può dare o un pid o un nome registrato e quando quello quindi la vera differenza è che i link sono bidirezionali e bisogna trappare gli errori mentre quando vogliamo usare il link unidirezionale usiamo il monitor non c'è bisogno di trappare gli errori e in questo caso quello che otteniamo non è più un messaggio di exit ma un messaggio di down questa roba qui e in qualsiasi momento possiamo anche dereferenziare il cioè togliere smettere di monitorare un processo quindi in qualsiasi momento un'applicazione può anche smettere di monitorare un processo quindi quello che si fa è creiamo sponiamo questa funzione che siccome non esiste fa un fa un errore poi facciamo monitor monitor com'era la roba era il monitor quindi process process è un atomo e gli si dà pid quindi se non facessimo flash ecco qua quindi vedete che cambia il messaggio e si ottiene un messaggio di un messaggio di down ora avete notato la differenza che anche quando l'attore è morto se noi cerchiamo di attaccarci a un attore morto col monitor ci rendiamo conto che l'attore è morto mentre con link no con link se noi ci colleghiamo a un attore che è morto non riceviamo nessun messaggio di errore quindi riceviamo un messaggio down questa è la referenza di chi è morto process e sta roba qui quindi sono molto il meccanismo è uguale però con i link i link sono bidirezionali bisogna trappare gli errori con i monitor non bisogna trappare gli errori quindi è molto più immediato e il monitor però è unidirezionale quindi sta a voi decidere che tipo di applicazione o che tipo di supervising utilizzare se è un link o un monitor generalmente se abbiamo un rapporto tipo subalterno quello che si fa è generare dei monitor e molto spesso i monitor servono proprio per monitorare necessariamente servono per gestire un server e nel momento in cui il server cade ricevevi il messaggio di down e lo rimetti su essenzialmente questo per poter un'altra un altro allora un'altra un'altra primitiva di Erlang sono le c'è la funzione exit essenzialmente exit può essere utilizzata anche come una throne quindi nel momento in cui abbiamo un errore e non riesciamo a gestirlo o abbiamo qualcosa che non ci piace possiamo fare l'exit pid e reason e se un processo è collegato a noi tramite un link quando lo facciamo exit riceverà un messaggio di exit quando noi invece se c'è un monitor legato al processo che fa exit quello che riceverà il monitor è un messaggio di down allora come come come le varie funzioni come la siccome esiste la spawn 1 e 3 esiste ovviamente la spawn la spawn link 1 e la spawn link 3 ma esistono anche la spawn link 2 e la spawn link 4 ed esistono anche le spawn monitor 2 e le spawn monitor 4 quindi esistono queste queste queste varianti che vanno nel distribuito vi consiglio di andare a controllare l'esempio resilient il punto erlo in cui essenzialmente si faceva un vediamo un attimo come è questo esempio che ho fatto l'anno scorso applicazioni vediamo un attimo no block link monitor resilient vediamo un attimo che file è questo ecco qua è un esempio di una centralina telefonica in cui se un attore quindi se un cellulare prende una banda e muore prima di rilasciare la banda il il il dove qui exit qui la la banda viene rilasciata quindi viene il server il server quindi l'operatore telefonico si rende conto che un cellulare è uscito dal suo raggio quindi può recuperare la banda che gli aveva allocato e la può dare ad un'altra ad un'altra ad un'altra ad un'altra ad un'altra ad un'altra tenza e questo lo si lo facevamo con c'è loop exit git request server list con link perché usavamo il processo quindi c'è da qualche parte una link ecco qua si crea un link quindi è anche un trucco utilizzare il link nel momento in cui voi ricevete un PID potete anche linkarvi a questo PID e monitorare il suo status va bene ragazzi la lezione di oggi finisce qui la prossima volta parleremo un po' di mnesia io vi sorto a fare gli esempi a rivedere bene le slide e a guardare gli esempi fatti l'anno scorso quindi i listati completi sono veramente esplicativi Idet