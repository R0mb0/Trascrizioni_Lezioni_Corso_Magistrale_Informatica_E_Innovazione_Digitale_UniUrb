buongiorno ragazzi e benvenuti al video introduttivo del corso di applicazioni distribuiti cloud computing come come ben sapete questo corso sarà un po sarà gestito in maniera asincrona perché mi trovo in giappone quindi man mano caricherò dei video a seguito a seguito di un paio di lezioni quindi questa è la prima lezione sulla sull'introduzione poi faremo una lezione sull'inter process communication e poi potete già vedere i vecchi video fatti sulle process algebra poi parleremo più in dettaglio di quei video come vi dicevo il corso viene fatto in maniera asincrona quindi teoricamente le lezioni sarebbero il martedì giovedì ma a causa di fuso orario non riesco a garantire la presenza online e quindi vi caricherò i video vi ho già messo tutto il materiale su blend and riguardo erlang essenzialmente il corso intero corso sarà l'ottanta per cento sarà dedicato a linguaggi programmazione erlang molti di voi potrebbero dire perché erlang questo questa è una domanda che tutti i vostri colleghi fa mi fanno all'inizio del corso a fine corso si scoprirà il perché perché usiamo erlang perché erlang non è un linguaggio programmazione ma è uno scusate è un ecosistema erlang viene con erlang ha built in delle procedure per fare concorrenza per fare distribuzione per fare resilienza agli errori viene con un database distribuito replica che si replica in maniera automatica che gestisce transazione ea gratis quindi è built in il database è built in dentro l'ecosistema erlang quindi non c'è bisogno di creare un'applicazione distribuita e interfacciarsi con un altro database quando il database è già built in nel sistema erlang ha anche una console una console per gestire tutti i processi quindi andiamo verso verso il cloud quindi essenzialmente alla fine quello che si scoprirà che erlang si è usato in maniera corretta è un buon linguaggio di programmazione per programmare applicazioni distribuiti e per distribuire scusate e per andare sul cloud tranquillamente allora torniamo a noi e come vi dicevo le lezioni saranno un po asincrone ciò non toglie che se voi qualunque qualora voi aveste bisogno di fare un ricevimento online possiamo concordarlo mi mandato una mail ci troviamo ci accordiamo detto questo io ritornerò in italia verso fine novembre quindi gli ultimi le ultime due settimane direzioni saranno in presenza e quelle settimane farete o faremo le presentazioni dei degli articoli scientifici ora vi spiego meglio come ne è sviluppato questo corso comunque per mandarmi un'email mandatemi un'email al solito indirizzo metteteci il tag adcc così capisco subito che siete degli studenti di magistrale del corso di applicazioni distribuite allora il corso come come come si come si struttura se solamente sono vari moduli la primo modulo che è quello di oggi di un pochino dell'azione che sto registrando ora della prossima lezione saranno delle lezioni basi dei sistemi distribuiti che per chi avesse già fatto il corso di sistemi distribuiti come le conosce abbastanza bene poi parleremo di process algebra e quindi ci sono tutti vivi a seguito di questi due video vi esorterò a guardare i video che già sono presenti su blend sulle process algebra e poi parleremo di di erlang essenzialmente parleremo di erlang se c'è tempo parleremo di go non riesco mai a farlo perché poi erlang veramente un linguaggio completo quindi veramente bisogna approfondirlo in dettaglio quindi non riesco mai a fare go ma se rimane qualche qualche lezione posso farvi go anzi ne approfondire questo credo sia l'anno giusto perché in giappone sto lavorando tanto con go quindi potrebbe essere l'anno giusto in cui potremmo parlare un po di go sono 8 oglie che è consigliabile fare il progetto in erlang e poi parleremo di pattern di sincronizzazione ma quelle sono meccanismi di sincronizzazione che qualora uno riuscisse a implementare li può usare in qualsiasi sistema distribuito allora immaginare il corso come tutti i miei corsi e quello che io le slide sono sufficienti per passare l'esame quindi non chiedo non vi chiedo mai di comprare libri e altra roba quindi se seguite le slide nelle slide io parliamo di erlang vi do tutti gli strumenti necessari per poter passare l'esame allora la parte di algebra di processi ci sono delle note che ho già messo online quindi sono le video registrazioni più le noti che ho già messo online per erlang esistono vari libri due sono uno il primo software for a concurrent world è disponibile gratis online le mie slide sono prese tanto dal dal secondo libro di erlang programming che è disponibile su amazon se siete un po più certosini potete trovare anche delle copie in pdf di questo e poi c'è un libro avanzato che se uno ha voglia lo legge lo guarda ma non tratteremo questa roba che parla di design di scalabilità per erlang e otp otp come come come vedremo più in là è una piattaforma integrata in erlang per le telecomunicazioni perché perché erlang nasce per le telecomunicazioni quindi se noi pensiamo agli anni 70 80 l'unica applicazione distribuita che esisteva nel mondo era la telecomunicazione quindi la tribuna i telefoni necessariamente telefoni la landline quindi telefono fisso su go esiste tanta documentazione online fatta da google quindi è fatta veramente bene bene e per altre robe vi consiglio sempre di per qualsiasi vostro dubbio vi consiglio sempre di googleare di cercare online sicuramente sono materiale molto più fresco di quello che io riesco a fornirvi allora parliamo un attimo dell'esame l'esame l'esame si fa in gruppo di due tre persone quindi l'esame consiste in due in due parti uno la presentazione di un articolo scientifico quindi come vi ho detto durante le ultime lezioni le ultime lezioni saranno dedicate alle vostre presentazioni quindi a fine ottobre fino ottobre si o metà ottobre metterò su blender un po di articoli scientifici che parlano parleranno un po di sistemi distribuiti di programmazione distribuiti di modellazione di sistemi distribuiti voi ne scegliete uno cioè voi come gruppo voi formate un gruppo mi scegliete un articolo mi dite quale volete presentare lo presentate e quindi questa è una parte dell'esame e poi la seconda parte dell'esame consiste nel nella presentazione nella nell'implementazione di un articolo di uno di un progetto il progetto vi darò le specifiche verso fine novembre vi darò le specifiche generalmente due due specifiche di progetto una più semplice e una più più complicata qualora qualcuno volesse puntare a davvero e a volere a a prendere il massimo qui c'è una piccola tabellina su come uno come uno come calcolare il voto dell'esame ripeto formate dei gruppi capisco che ci sono esigenze personali tale per cui qualcuno vuol lavorare da solo perché magari segue segue segue online lavora già però cercate di formare dei gruppi come vi dicevo per il materiale didattico non è necessario acquistare i libri se seguite le slide c'è tutto quello che c'è da sapere sulle slide è come vi dicevo invece di comprare un libro è preferibile che voi andiate online a cercare vari vari siti tipo se uno vuol capire meglio qualche specifico qualche feature o qualche funzione in più di erlang c'è il man quindi sarebbe manuale online di erlang ma ci sono anche vari blog dedicati ad erlang io continuo a parlare di erlang ma magari voi avete sentito parlare tanto di elixir elixir cos'è? essenzialmente elixir è né più né meno che erlang con una sintesi un pochino più semplice ma tutto quello che fa elixir lo fa erlang perché entrambi vengono seguiti sulla macchina virtuale di erlang ecco questa è un'altra cosa che poi scopriremo più in là erlang ha una macchina virtuale che viene chiamata la beam machine quindi essenzialmente noi quando compiliamo erlang generiamo un bytecode questo bytecode quindi l'oggetto non è un binario eseguibile ma è un bytecode che viene interpretato dalla macchina ha un'altra cosa che che mi sono scordato di dirvi durante le lezioni io vi mostro i concetti teorici di erlang e in più programmerò generalmente questo è un corso fatto in maniera corale in cui io a lezione programmo e vi mostro gli errori perché è veramente semplice fare errori di sintassi in erlang è veramente complicato capire quali sono gli errori perché ha un sistema di gestione degli errori veramente becero però se entrate nell'ottica di scrivere un paio di righe compilare vedere se tutto va bene allora riuscirete a scrivere dei programmi veramente certosini in maniera incrementale parliamo un attimo di perché questi due linguaggi ho scelto questi due linguaggi per questo corso come avete già capito quando parlavo di centraline elettroniche e centraline scusate telefoniche erlang è stato sviluppato per programmare gli switch di ericsson quindi erlang è stato sviluppato da ericsson ericsson era questa grandissima compagnia di telecomunicazioni europea è basato quindi è stato sviluppato nell'86 da da elson ora lo trovate in versione open e la versione più mantenuta quella di erlang solution erlang erlang solution è una ditta privata che fa di erlang il suo main core business sensualmente loro sviluppano applicazioni di seguito usando erlang ed evangelizzano anche l'uso di erlang infatti il secondo libro quello che quello che di erlang quello che vi indicavo che è disponibile su amazon quello che è scritto da da cesarini che il ceo di erlang solutions allora parlavo di erlang perché perché è così famoso perché o perché è buono per le applicazioni distribuite perché implementa un paradigma di programmazione che si chiama adattori e quindi essenzialmente tutti gli attori quindi i processi d'ora in poi chiameremo il processo quando inizieremo a parlare di di erlang non parliamo più di processo parliamo di attore e gli attori tra di loro comunicano attraverso lo scambio di messaggi perché come abbiamo visto nel corso di sistemi distribuiti quando vai nel distribuito l'unica cosa può fare è mandare e ricevere messaggi e quindi già mettetevi nell'ottica che qualsiasi oggetto che uno espone online sulla rete ha un'interfaccia questa interfaccia è una sequenza di messaggi pensate anche pensate per esempio alla macchina del caffè potete vedere l'interfaccia della macchina del caffè come prende in input il messaggio contenente i soldi prende in input il messaggio contenente la scelta della bevanda e vi restituisce un messaggio con la bevanda quindi qualsiasi oggetto ripeto può essere messo online e poi gli viene esposto a questa interfaccia questa interfaccia è una sequenza di messaggi e questa interfaccia non è nient'altro che le piai dell'oggetto stesso che noi stiamo mettendo online e magari la stiamo anche distribuendo però questo lo vedremo lo vedremo molto in dettaglio come si fa in erlang ed è veramente banale fare tutto questo in erlang e quindi diciamo che erlang il paradigma di programmazione che usa erlang è quello basato su è passato ad attori erlang è stato utilizzato ed è tuttora utilizzato da parecchie compagnie quindi quando whatsapp fu comprato da erlang scusate quando whatsapp fu comprato da facebook tutto il sistema server side di whatsapp era gestito era programmato era programmato in erlang ma anche la chat di facebook era in erlang e oggigiorno compagnie come bet365 quindi uno dei più grandi servizi online per scommesse sportive ma anche la chat del quindi stiamo parlando di gaming la chat online del gaming online di nintendo è praticamente gestita con erlang e torniamo un attimo a bet perché bet365 usa erlang perché in erlang è veramente facile capire quando un nodo è caduto ed è veramente facile restanziarlo ora se avete ben presente cosa vi ho detto prima sul concetto dei messaggi capire quando un nodo è caduto vuol dire ricevere un messaggio che ha una specie di priorità in cui dice guarda che il nodo x è caduto allora te attore che magari sei un supervisore di quel nodo o di una rete di nodi quando ricevi un messaggio di down o di failure quello che fai è ristanzi di nuovo quel nodo e c'era un articolo di bet365 in cui diceva che in un anno sono stati cioè loro sono stati down nel senso che i loro server non sono stati capaci di rispondere a nessuna richiesta quindi a nessuna scommessa quindi stiamo parlando di perdita di soldi per poche decine di secondi in un intero anno quindi vuol dire che scrivere applicazioni in erlang è veramente affidabile con erlang si possono scrivere applicazioni veramente affidabili allora agli opposti della comunicazione o del paradigma basato ad attori c'è golang che usa l'astrazione dei canali di nuovo anche qui si mandano messaggi perché nel distribuito non ci può essere null'altro che l'invio e la ricezione di messaggi però Go utilizza l'astrazione dei canali cosa è un canale? un canale è semplicemente una mega coda condivisa tra due e tre processi mentre pensavo di averla questa sala forse ciò più in là mentre Go quello che è è tra uno più processi c'è questa mega coda quindi la coda e i messaggi sono ordinati in maniera fifo quindi il primo messaggio che entra sarà il primo ad essere consegnato come vi dicevo bet365 usa elixir abbiamo detto che elixir è solo dello zucchero sintattico rispetto a erlang e loro hanno utilizzato nel 2023 quindi praticamente si parla del 2022 hanno risparmiato scusate sto leggendo due cose contemporaneamente stiamo parlando di bet che usa erlang per le scommesse stiamo parlando di pinterest di pinterest scusate che utilizza che utilizza elixir e pinterest utilizzando elixir risparmia 2 milioni all'anno quindi spende 2 milioni all'anno in meno per la gestione dei server quindi vedete che è veramente un linguaggio di buona nozione che vi permette di costruire roba veramente affidabile ecco questa era la slide che volevo mostrare qui è il concetto di attori ma questo lo vedremo vedremo ampiamente con erlang qual è il concetto di attori? il concetto degli attori è che ogni attore ogni attore scusate ha una casella postale quindi pensate a ognuno di noi che abita ad un civico diverso è l'unico modo per essere contattati è che qualcuno vi mandi una lettera quindi questa lettera banalmente è il messaggio quindi qual è l'idea iniziale? l'idea iniziale è che un attore per essere contattato non deve conoscere nulla del mittente mentre il mittente deve conoscere l'unica cosa che deve conoscere è l'indirizzo del destinatario non è l'indirizzo fisico quindi stiamo parlando di p-address ma essenzialmente deve conoscere l'indirizzo quindi il nome della strada il civico e il capo che è un'astrazione dell'indirizzo fisico quindi essenzialmente nella programmazione di attori un attore per inviare un messaggio ad un altro attore l'unica cosa che deve sapere è il suo indirizzo e la cosa bella è che questo indirizzo può essere mandato ad altri attori attraverso i messaggi quindi io conosco l'indirizzo dell'attore 1 l'attore 2 non conosce l'indirizzo dell'attore 1 vorrebbe comunicare allora anche nel me qual è l'indirizzo e io glielo mando via messaggio e così via mentre come vi dicevo la comunicazione ai canali esiste una mega coda quindi un canale lo potete vedere come una coda tra due attori e questi attori parlano tra di loro scambiandosi messaggi utilizzando una coda come vi ho detto come vi ho detto parleremo un pochino di algebra di processo esistono già su Blended ci sono i corsi riguardo le algebra di processo perché? perché ho deciso di parlarvi di questa roba? un po' perché le algebra di processo vi permettono di processo, scusate vi permettono di astrarre astrarre da tutti i dettagli implementativi del mondo quindi essenzialmente vi permettono di focalizzarvi su le interazioni tra vari processi distribuiti e di nuovo cosa sono queste interazioni? scambio e ricezione di messaggi quindi invio e ricezione di messaggi quindi le algebra di processo vi permettono di concentrarvi su le interazioni che esistono tra i vari processi astraendo del tutto i dettagli implementativi cosa è un dettaglio implementativo? un dettaglio implementativo è come questo messaggio è stato instradato come questo messaggio è stato mandato se è attraverso un socket se è attraverso TCP attraverso DP io a livello di programmazione di un'applicazione distribuita non voglio toccare questa roba a me non interessa altrimenti starei programmando IC e starei facendo networking essenzialmente a me progettista di un'applicazione distribuita importa solo sapere qual è il pattern di comunicazione lo scambio di messaggi qual è il protocollo quindi la serie di messaggi che io devo mandare ad un'altra applicazione affinché i miei due attori le mie due applicazioni si interfaccino tra di loro e affinché non ci sia deadlock perché uno degli errori che il subdoli da trovare in un'applicazione distribuita è un deadlock che io ho mandato un messaggio ad un attore e magari lui aspettava un messaggio diverso quindi un formato diverso e quindi ondevitare questo tipo di mismatch quello che si fa è si si astrae tutto e si rappresentano i processi come sequenze di input output e si vedono e si vede se questi input output funzionano quindi di nuovo le processaggi mi permettono di mi danno una descrizione ad alto livello matematico barra formale però una descrizione ad alto livello del comportamento del processo quindi il comportamento cos'è? quello che uno espone di nuovo se un programma espone un comportamento all'esterno cos'è questo comportamento? la sua interfaccia quindi di nuovo ritorniamo a parlare di interfaccia di messaggi stresso molto questo meccanismo perché questo aspetto perché alla fine di nuovo scrivere programmi in Erlang è veramente semplice una volta che uno ha in mente l'ordine di ricezione di messaggi scrivere in un'applicazione distribuita cioè la cosa complicata non è avere 100 istanze o avere 4 nodi che si sincronizzano tra di loro questo lo fa in maniera automatica Erlang questo lo fa Erlang per voi quello che Erlang vi chiede è qual è il formato di messaggi che questi nodi devono scambiarsi e se il formato di messaggio è giusto quindi se le interazioni sono giuste allora tutto funziona in maniera veramente semplice smooth e basta è questo quindi ovviamente in fase d'esame non vi chiederò la roba sulle processage però guardateci in occhio guardatele per capire che esistono però ripeto dovete iniziare a pensare tutto come una serie di scambi di messaggi come un'interfaccia come dell'interazione tra vari oggetti l'oggetto l'oggetto telefono è un oggetto distribuito io mi interfaccio attraverso l'oggetto mandando messaggi secondo la sua interfaccia e questo quindi parleremo in maniera più o meno strana di computazione distribuita perché il corso è di distribuito e computing e di nuovo quali sono gli elementi chiavi del distribuito e computing è che un'applicazione ha un'alta scalabilità quindi vuol dire che può essere replicato su più macchine quindi che la mia applicazione funzioni su 10 su 100 macchine deve funzionare lo stesso anzi andando su 100 macchine dovrebbe aumentare la prestazione quindi dovrebbe scalare veramente e vedremo che in Erlang quella scalabilità generalmente viene anche legata al concetto di elasticità quindi nel momento in cui il carico della mia applicazione sta subendo un carico di rate veramente alto allora posso decidere di distanziare a runtime più nodi di spacciare tutto questo carico agli altri nodi e nel momento in cui ho degli abbassamenti di carico questi nodi possono anche determinare quindi terminare vuol dire che mi liberano delle risorse quindi questa è la scalabilità la disponibilità la disponibilità vuol dire che in qualsiasi momento la mia applicazione è disponibile quindi la disponibilità va di pari passo con la gestione degli errori quello che vi dicevo prima di bet il fatto che in un anno non sono stati disponibili per pochi secondi in tutto l'arco annuale che è veramente qualcosa di di eclatante il concetto di applicazione distribuita va anche di pari passo col concetto di latenza se io sto progettando un'applicazione distribuita worldwide è normale che io metta dei nodi per aree geografiche perché altrimenti se metto tutti i miei nodi in Europa quelli del Nord America o quelli dell'Asia visto che mi trovo in Asia avranno della latenza in più rispetto quindi avranno un degradamento di performance rispetto agli utenti che utilizzano la mia applicazione in Europa banalmente e poi il concetto di applicazioni distribuite va di pari passo anche col concetto di costo perché invece di avere un mega server stiamo parlando di questo Erlang gira sulle macchine normali invece di avere un mega server che ha tipo 100 core io metto 3-4 mini server mini computerini più piccolini che mi costano un quarto di questo mega server e riesco ancora ad avere un'applicazione distribuita decente coordinando questi vari mini computer piuttosto che avere questo mega super calcolatore centrale allora un'altra cosa che bisogna tenere in mente è che la computazione distribuita diciamo è l'antitesi della computazione di alte prestazioni quello che si chiama high performance computing o HPC generalmente l'HPC usa un mega calcolatore centrale che ha n con n 100 200 core e quello che si fa in HPC è cercare di parallelizzare vedete stiamo parallelizzando non stiamo distribuendo perché parallelizzare vuol dire eseguire in maniera parallela sulla stessa macchina mentre distribuzione vuol dire stiamo eseguendo la stessa applicazione su macchine diverse fisicamente diverse non logicamente diverse fisicamente diverse e come catiremo in Erlang in Erlang è veramente semplice questo è quello che dico sempre a ogni inizio anno ogni inizio del corso allora noi noi inizieremo a programmare nel sequenziale in Erlang quindi la prima parte del corso sarà devoluta sullo sviluppo di programmi sequenziali in Erlang quindi non c'è né distribuzione né concorrenza una volta capito quello scalare quindi parallelizzare è veramente banale bisogna solo utilizzare due o tre primitive una volta capito questo distribuire è di nuovo banale le stesse primitive che noi stiamo usando basta aggiungere un parametro in più di questa funzione invece di eseguirmela in locale e me la esegui su quel nodo ed Erlang lo fa in maniera automatica del tutto trasparente a voi quindi quello che vi sto dicendo è che con Erlang voi scrivete un programma sequenziale se il programma è scritto bene il programma è sequenziale funziona in parallelo e funziona nel distribuito in maniera automatica quindi scalare un'applicazione scalare un programma in Erlang è veramente banale se è scritto in maniera corretta quindi ok questi sono vari esempi di applicazioni distribuite banalmente Whatsapp è un'applicazione distribuita Facebook è un'applicazione distribuita Uber è un'applicazione distribuita tutte le applicazioni mobile che oggigiorno usiamo Instagram è un'applicazione distribuita sono tutte Amazon sono tutte applicazioni distribuite anche usare un Google Doc è un'applicazione distribuita quella è un'applicazione distribuita condivisa con più utenti, ad esempio anche banalmente giocare online. Un videogioco ormai è diventato un'applicazione distribuita con n.000 client che sono i giocatori e vari server che si coordinano tra di loro. E siccome questo corso ha nel libro che fare anche la parola cloud computing, cerchiamo di capire un attimo cos'è cloud computing, anche se vi ho già accennato che faremo cloud computing utilizzando ancora Erlang. Qual è l'idea dei cloud computing? L'idea dei cloud computing è che voi una vostra applicazione la mettete sul cloud e questa viene eseguita. I cloud possono essere pubblici o privati. Una volta che la mettete sul cloud, dal lato cliente non avete... il cloud è una nuvola, quindi è una cosa astratta dal lato di vista dell'utente, quindi non ha idea di quale server, quale nodo del cloud sta eseguendo la mia richiesta. E una cosa buona del cloud, di nuovo, è anche qui che voi prendete AWS, quindi il servizio cloud di Amazon. La vostra applicazione, il vostro server, esegue lì. Nel momento in cui avete bisogno di più risorse, potete a runtime chiedere più risorse, quindi spendere dei soldi in più per quelle risorse in più solo per quel periodo limitato e poi di nuovo chiudere le risorse. Di nuovo, com'è nata l'idea del cloud? Se poi ci pensate, a un certo punto si è iniziato a parlare di cloud. Qual è l'idea di cloud? L'idea dietro al cloud è che grossi colossi, palesemente Amazon, aveva tanti server, scarichi durante tutto l'anno, perché essenzialmente Amazon aveva dei picchi di carico, quindi gli serviva la potenza totale solo durante i periodi, tipo il Black Friday, durante le vacanze natalizie. Lì usava tutte le sue macchine. Negli altri periodi dell'anno, il 50-60% delle macchine, macchine intese come server Amazon, erano scariche, quindi erano lì a consuma corrente, diventavano obsolete e così via. Quindi da lì è nata l'idea di affittare delle proprie macchine, cioè Amazon, se quello che vi fa è vi affitta delle proprie macchine, del proprio cluster, a gente terza e si fa pagare per l'utilizzo di quelle risorse, né più né meno. Quindi, di nuovo, quali sono le proprietà per un'applicazione in cloud, quali sono le proprietà del cloud computing, sono... deve essere flessibile e le risorse devono scalare, quello che vi ho detto prima, se io ho bisogno di più risorse, me le posso comprare o affittare e poi tornare. Esattamente come un pay as you go, te paghi una fee base in cui hai il tuo server che accoglie le richieste, e nel momento in cui hai dei picchi di carico allora ti fai prestare altre risorse, le utilizzi e le rilasci. Un'altra caratteristica è che essenzialmente le macchine cloud sono dei server, però voi, quando affittate un cloud, quello che vedete è un'interfaccia, quello che vedete non dovete capire il sistema operativo che gira sotto. Cioè, essenzialmente astraete da tutti i problemi che comporterebbe avere un server locale in casa, ad esempio. Quindi è veramente facile fare il setup di un sistema cloud e i costi sono veramente banali per voi, per chi lo affitta, non per chi lo gestisce. C'è anche lo scambio sicuro di informazioni, perché i servizi cloud medio-alti forniscono anche meccanismi di sicurezza abbastanza alti. E di nuovo, il concetto principale è quello di salvare spazio ed energia, perché io non uso un server locale, io uso dei server che stanno da un'altra parte, che già sono in uso, quindi il consumo di energia della mia applicazione è veramente risibile rispetto a quello che già stanno consumando, e risparmio spazio fisico, essenzialmente. Quali sono i contro di usare roba cloud? I contro sono che la connessione deve essere stabile, perché magari potremmo avere dei picchi di carico veramente alti, e tutti questi picchi, tutte queste domande devono essere evase. Perché se abbiamo dei ritardi nell'evasione stiamo perdendo soldi. Pensate a Uber. Uber, magari sto prenotando un taxi, o sto facendo Uber Eats, è lenta l'applicazione, allora preferisco andare su Deliveroo. Quindi Uber ha perso dei soldi, oppure sto aspettando un Uber come un taxi, privato, è lento, non sta arrivando, non funziona, allora decido di andare a piedi, oppure decido di prendere un taxi. Quindi di nuovo l'applicazione ha perso dei soldi. Un altro problema è legato di nuovo alle performance di sicurezza. Perché se un sistema... quante volte sentite parlare che un cloud è stato bucato, sono state perse, sono state rubate le password, le identità e le carte di credito. Questo successe tempo fa con i server, per esempio, con i server di gaming di Sony. Quindi dovete sempre affidarvi a dei sistemi cloud decenti. Però il problema è che voi sottoscrivete dei termini di condizioni. Magari la vostra roba, i vostri dati, vengono dati in outsourcing a un'altra azienda. Quindi il servizio cloud che stiamo utilizzando utilizza un outsourcing a un'altra azienda. Però questa cosa non la vediamo perché di nuovo c'è in mezzo la nuvola. E in più è soggetto il cloud a restrizioni amministrative locali dove girano i server, ma anche alle capacità del server stesso. E va bene, questo conclude la prima parte della lezione introduttiva del corso. Ripeto, se avete domande o dubbi o perplessità, scrivetemi un'email. Sono sempre disponibile a rispondere a qualsiasi vostro dubbio. Va bene, ci vediamo al prossimo video in cui parleremo di interprocess communication. Quindi inizieremo a capire come si è passati, quindi un po' di storia, come si è passati, quali sono le astrazioni che permettono a processi, quindi applicazioni, di parlare tra di loro. Grazie.