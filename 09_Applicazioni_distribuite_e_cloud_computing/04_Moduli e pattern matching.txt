Salve ragazzi, allora riprendiamo la lezione da dove si era interrotta nell'ultimo video perché è caduta la connessione e quindi stiamo parlando un po' delle liste. Abbiamo detto che le liste si rappresentano attraverso la lista, una sequenza ordinata di elementi separati da una virgola e racchiusi tra parenze di quadre. Abbiamo visto che l'operazione di somma, quindi non è di somma ma di concatenazione delle liste e stavamo vendendo l'operatore di sottrazione. In più stavamo parlando del fatto che tutta la documentazione ufficiale di Erlang e sul sito Erlang.org. Ok, cerchiamo di finire la lezione. Poi ovviamente abbiamo gli operatori booleani oppure degli operatori di confronto. Abbiamo l'operatore di uguale, l'operatore di non uguale, l'operatore di esattamente uguale. Qual è la differenza tra questi due operatori? È che, per esempio, 1 è uguale a 1.0. Sì. Perché sematicamente sono la stessa cosa. Se usiamo quest'operatore, questa è una comparazione bit a bit. Ovviamente la rappresentazione in memoria di un float, di un floating point, è diversa da un intero. Quindi se usiamo quest'operatore ci darà falso. Poi possiamo comparare anche strutture di dati più complesse. Quindi qui stiamo comparando una dupla con una lista. Ovviamente anche se i valori sono interni, però a livello di costruttore questi sono diversi. Quindi andrà a ridere la falso. Possiamo anche comparare a livello di maggiore e minore. E così via. E concludiamo questa lezione con le variabili. Le variabili, abbiamo detto che le variabili vanno scritte sempre con la lettera maiuscola, perché la lettera minuscola per lui è un atomo. Inoltre le variabili dovete vederle come delle definizioni di costante. Quindi una variabile non può essere aggiornata. Quindi non possiamo scrivere... Non possiamo scrivere... Quindi a uguale a 1... Questa è una variabile. Quindi ogni volta che chiamo a mi dà 1. Non posso scrivere a uguale a più 1. Mi dà errore. Perché? Perché nel momento in cui una variabile è concretizzata, se compare nella parte sinistra dell'operatore di ugualianza, quindi left hand side di un assignment, per lui è un pattern matching. Quindi lui... Cosa gli stiamo dicendo? Lui cosa capisce qui? Capisce che 1 deve matchare 1 con 1 più 1. E quindi lui dice, guarda che non riesco a matchare questa parte, che per lui è 2, non riesce a matchare la con 1. E quindi ogni variabile può essere assegnata solo una sola volta. Ora, finiamo... Ecco, questa era la fine della lezione. Ora, continuiamo la lezione con... La seconda parte della lezione. Quindi iniziamo a parlare un pochino in maniera più concreta di Erlang. Quindi oggi parleremo dei moduli, funzioni e match. Match è un'operazione importante per fare pattern matching, quindi per spacchettare il contenuto di un messaggio o di una variabile. Allora, la prima cosa da fare nel momento in cui uno vuole creare un file per poi compilarlo in Erlang è che deve dichiarare il modulo. Questo l'avevo già fatto. Rifacciamo da capo. ADCC, Erlang... Non ricordo più qual è il path. Allora, tipo di ADCC, esempio 25. Ok. Quindi, quello che vi dicevo è che bisogna dichiarare... Scusate, bisogna salvarlo come... File.savaz.sec.l Quindi, cosa vi sto dicendo? Vi sto dicendo che il modulo deve avere lo stesso nome del file, perché altrimenti il compilatore non capisce. Quindi, se io voglio creare il modulo lists, ad esempio, in Erlang ci sarà un file lists.erl e i file Erlang hanno estensione .erl. Allora, ok. Poi, un modulo, quindi abbiamo l'intestazione di modulo. Vi ricordo che qualsiasi cosa è un'espressione, quindi va chiusa, va finita col punto, e tutte le direttive al compilatore iniziano col trattino. Quindi, tutte le direttive... Questa è una direttiva al compilatore. Poi, meno export. Export. Questa è tutta la lista di funzioni che... Scusate, una lista. Quindi, una lista di funzioni che il modulo esporterà. Quindi, l'interfaccia che il modulo espone all'esterno. Ok. Iniziamo con una funzione abbastanza semplice. Iniziamo con una funzione che calcola la potenza, quindi il quadrato di un numero. Quindi, molto semplicemente io scrivo una funzione, double. Le funzioni iniziano con la lettera minuscola, perché la lettera maiuscola è una variabile. E quindi, da qui capiamo che le funzioni sono degli atomi per lui. Quindi, i nomi delle funzioni sono degli atomi. Quindi, io scrivo una funzione, double, che prende un numero, n, e restituisce n per n. Punto. Quindi, esporto la funzione double. Ecco, qui iniziamo a capire... se voi avete già visto un po' il man di Erlang, forse avete già visto questa annotazione. Qui iniziamo a capire come funziona la signature delle funzioni per Erlang. Essenzialmente Erlang vi dice che per lui una funzione è nome e il numero di parametri che usa. Quindi, double 1. Quindi stiamo esportando la funzione double, che prende un parametro. Andiamo a compilare, quindi Erl. Ovviamente, per compilare bisogna essere nello stesso path di dove c'è il file. Quindi, per compilare usiamo la direttiva C, se l'ho chiamato. Ecco, vedete di nuovo, la compilazione è un'espressione, lui ci ritorna un valore. Ma un valore cos'è questo? Questa è una dupla. È una dupla con due elementi. Il primo elemento è un atomo che ci dice OK e il secondo elemento è il nome del modulo. Se noi compiliamo qualcosa di sbagliato, lui ci darà Error. È la causa dell'errore, quindi non existing. In questo caso non esiste il modulo sec. Allora, abbiamo detto abbiamo compilato. Quindi ora, se io chiamo il modulo sec con double, di tre, dovrebbe risolvermi al mi nove. Quattro. Scusate un attimo. Va bene, continuiamo così con WhatsApp in background. E così via. Ora, facciamo una funzione, scriviamo una funzione più complessa, no? Più complessa nel senso ricorsiva. E definiamo la funzione Fibonacci. Quindi Fib, FibTotal. Ora vi spiego perché la chiamiamo Total. Prendo il numero n. E ritorna if. GuardBody. And. Allora, l'if. Ecco, qui devo chiudere la funzione. And. La guardia qual è? La guardia è se n. n è minore di 1, di 0. Diamo error. Poi, man mano bisogna scostruire tutte le clausole. Le clausole in Erlag vengono separate dal punto di virgola. Quindi, devo scrivere l'altra clausola. Se n è uguale o uguale a 0, Fibonacci mi deve ritornare 1. Se n è uguale o uguale a 1, Fibonacci mi ritorna 1. E ora faccio il caso più generale. Se n è maggiore di 1, mi ritorna Fib di n-1 più Fib di n-2. Ecco, vedete che tutte le clausole chiudono col punto di virgola, tranne l'ultima. L'ultima no, perché lui capisce che è l'ultima quando vede l'end. Quindi, andiamo a compilare. E se non ho fatto qualche errori... Ok. Tutto bene. Quello che becchiamo è un warning. Ho fatto vari errori, tra cui non chiamare FibTotal, ma chiamarla Fib. Quindi FibTotal e FibTotal. Ora, compilo e beccon warning. L'unico warning è che non abbiamo esportato questa funzione. Quindi la esporto. Quindi FibTotal. E di nuovo, siccome prende un parametro, 1. Ok. Compilo. E se chiamo... Quindi se di FibTotal di... No. Proviamo numeri piccoli, altrimenti scoppia. Ecco. Quindi funziona. Allora, perché ho chiamato questa funzione FibTotal e non l'ho chiamata Fibonacci? Perché esiste un altro modo. Erlang vi permette di definire una funzione come unione di clausole. Che è essenzialmente quello che abbiamo fatto un po' qui. Quello che vi dice Erlang è... Io posso definire una funzione Fibonacci, quindi Fib, utilizzando pesantemente il pattern matching. Quindi quello che io definisco qui è Fib. Allora abbiamo detto Fibonacci di 0 è 1. Poi abbiamo detto Fibonacci di 1 è 1. Fib di qualsiasi cosa, di n, ritorna Fib di n-1 più Fib di n-2. E qui va il punto, perché è l'ultima chiusura. È la chiusura della funzione. Allora, poi la esportiamo. Fib di 1. Cosa abbiamo fatto qui? Qui abbiamo definito una funzione, invece di un'unica funzione, l'abbiamo definita come un insieme di clausole. E ovviamente, siccome Erlang utilizza il pattern matching, le clausole, quindi l'unica... Se io chiamo Fibonacci di 0, l'unico pattern matching utile è questo. Fibonacci di 1, l'unico pattern matching è questo. Fibonacci di qualsiasi numero mi va a prendere questo. Generalmente, questi pattern vanno dai più selettivi ai meno selettivi. Quindi questo è meno selettivo. Se io metto questa funzione all'inizio e chiamo Fib di 0, mi verrà sempre invocata questa piuttosto che questa. Quindi i più selettivi vanno all'inizio e così via. Quindi compiliamo. Chiamo invece di Fib total, chiamo Fib di 10 e dovrebbe darmi di nuovo 89. Qui ho sbagliato perché non ho scritto Fib. Tanto è una. Esattamente la stessa funzione. Però c'è un errore qui. C'è un errore perché non l'abbiamo considerato il caso di un numero negativo. Quindi se io chiamo Fib di meno 1, lui va qui e vedete che va ricorsivamente, decrementando sempre di più, sempre di più, quindi va a meno infinito. Quindi quello che dobbiamo fare è scrivere una guardia. Fib. Quindi dobbiamo scrivere una guardia che è... Questa l'abbiamo fatta, abbiamo parlato tutti e un altro chiedere, l'abbiamo fatto, questo l'abbiamo fatto. Ecco, siamo qui, abbiamo dimenticato il fatto che sia negativo. Allora quello che facciamo è... Andiamo a una nuova clausola con una guardia. Quindi quello che facciamo è... Fib di n, when n è minore di 0, allora mi devi dare r. Di nuovo punto e virgola. Mai punto. Cioè il punto chiude tutte le clausole. Quindi compilo. Diamo se di Fib di 10, abbiamo detto, dovrebbe darci 89. Ok? Quindi se lo chiamo di meno 1, quello che mi dà è errore. Ora, visto che abbiamo visto che possiamo scrivere delle clausole con delle guardie un pochino più complicate, possiamo anche compattare questo. Quindi, il commento in Erlang si fa col percentuale, quindi quello che io faccio, Fib di n, when n è maggiore di meno 1, scusate, n è maggiore di meno 1, and n è minore di 2, allora mi dà questa roba, altrimenti mi dà questa altra roba. quindi abbiamo compattato le varie funzioni, le varie clausole, e compiliamo lo stesso risultato. Quindi vedete che è molto più semplice costruire una funzione come unione di clausole piuttosto che costruire una funzione globale. Ora abbiamo visto questa feature, vedete che il fatto che, come dicevo nella lezione precedente, il fatto di avere un linguaggio ad alto livello vi permette veramente un grande livello di astrazione. e quindi è proprio per questo che questo livello di astrazione, il fatto di essere pesantemente pattern matching, vi permette di utilizzare queste cose. Ora vediamo un altro uso intensivo di pattern matching. Supponiamo che vogliamo definire una funzione area, area di un poligono, quindi stiamo scrivendo una funzione polimorfa e estensibile. Quindi ogni volta che vogliamo aggiungere una nuova funzione per un nuovo poligono, estendiamo la funzione. Come la estendiamo? Aggiungiamo una clausola. In Java uno dovrebbe prima creare una classe astratta e poi implementare la classe astratta. Per ogni nuovo poligono deve implementare la classe astratta, che è veramente una cosa molto verbosa, no? Quello che facciamo qui invece è definire una funzione area. Qual è l'idea? L'idea è questa, che la funzione mi prende un parametro, questo parametro è una tupla, e il primo elemento della tupla è un atomo. Quest'atomo mi dice che tipo di poligono io voglio calcolare. Quindi area, area di cerchio. Ora, come faccio in modo di avere i parametri? Il trucco è utilizzare una lista. Quindi il secondo parametro, il secondo elemento della tupla, è una lista. Questa lista ha dimensioni variabili, perché alcuni poligoni mi servono solo un dato, altri poligoni mi servono due dati. Quindi, la lista, quello che io faccio è, se io devo calcolare il cerchio, l'area del cerchio, è raggio al quadrato per pi greco. Quindi, è ragionevole supporre che in questa lista, il primo elemento della lista sia il raggio. Cosa faccio? Utilizzo pattern matching. Quindi, abbiamo visto che una lista si può scrivere come testa e coda. Per me la mia testa è il raggio e la coda non mi interessa. Non mi interessa. Quindi, questa è la wildcard che Erlang utilizza per non mi interessa. E ora lo vedremo. Non mi interessa, quello che io ritorno è raggio per raggio. Ricordatevi che le variabili, sempre il termogiscolo, raggio per raggio per 3,14. Esportiamo area a solo un parametro. Compiliamo. Ecco, qui ho sbagliato perché... ecco qui, scusate. Quindi, questo è uguale a la lista e... quindi, cerchiamo di farla più bella. Questa è la mia funzione. Quindi, per me è L, spacchetto L, come, testa e coda, la cui, per me la testa è il raggio, raggio per raggio, e ritorno, raggio per raggio, per 3,14. Compiliamo. Ok. Quindi, se chiudiamo se di area, e scrivo cerchio, cerchio, e gli do una lista di 2, 4, quello che non mi interessa, però lui ora utilizzerà il raggio 2. Ora, se chiamo area di qualsiasi altra cosa, mi dà errore. quindi, cosa facciamo? Facciamo questo noi. Allora, quello che facciamo è area di qualsiasi altra cosa che io non ho definito. Quindi, vedete, questo è il pattern più l'asco che io posso avere, lo metto come per ultimo. è una lista, do, ritorno un note divined. Vedete che qui ho tolto il punto, ho messo il punto in virgola. Ora, ricompilo. Ok, lui ci dice che questa non la stiamo utilizzando, quindi posso fare anche in questo modo. è vedete quanto è potente questa roba, quanto è potente con una riga in più io gestisco tutti i casi che non sto gestendo, che non ho gestito finora. Poi, io posso anche aggiungere altra roba, no? Quindi posso fare l'area del triangolo di nuovo L e per il triangolo mi serve la base all'altezza. Quindi per me la base, quindi bisogna fare due volte il pattern matching, no? Per me la base è il primo elemento con la coda, quindi con la tail e questa è la mia lista, virgola e poi ora cosa devo spacchettare devo spacchettare questa? Non devo spacchettare più questa, devo spacchettare questa, quindi il prossimo elemento sarà l'altezza, la coda non mi interessa, è uguale a t. E poi ritorno base per altezza diviso 2, ora non ricordo bene, vediamo un attimo la divisione come si fa, 4 diviso 2, ok, diviso 2, quindi compilo, scrivo triangolo, sto giro, e funziona, funziona, posso anche implementare l'area del quadrato, il quadrato prende un solo parametro, quindi è molto semplice, quindi area quadrato, lato, virgola, sempre l, e quello che faccio è, prendo il primo elemento, quindi per me il lato, no, non possiamo stare l perché è già, beh, chiamiamola x, non mi interessa, è uguale a l, virgola, e ritorno l per l, anzi, invece di ritornare l per l, ritorno double, double di l, scusate, di x, ritorno, sempre punto in virgola, solo questa, solo l'ultima, la clausola che dire tutto, ha il punto, quindi compiliamo, area, e, abbiamo detto quadrato, quindi dovrebbe darci 4, quindi vedete che stiamo utilizzando pesantemente il pattern matching e il polymorphismo, il pattern matching ci permette di utilizzare il polymorphismo, perché? Perché sto definendo la stessa funzione con gli stessi parametri, uno, un parametro prende, su diversi domini di input, no? Ora, uno potrebbe dire io non voglio, posso anche definire, cioè, questa è una questione di stile, di gusto, no? Possiamo anche, magari dice non vuole, vedete, ecco, vedete che pattern matching inizia dal fatto che noi gli diamo in input una tupla, se noi, se noi non gli diamo in input una tupla, gli do solo un numero oppure un atomo, tipo scrivo quadrato, non becco neanche quadrato, non becco neanche not define, becco proprio un errore, perché? Non esiste, non esiste una clausola che mi manaccia questa funzione, perché? Perché la funzione area l'ho definita su, ovvero che l'ho definita su un parametro, però questo parametro ha un costruttore, quindi questo parametro deve essere per forza una tupla, per forza. Ora, possiamo anche fare un po' di overriding, possiamo definire area che prende due parametri, quindi questo, Erlang, ci permette di farlo, magari uno dice no, per me è complicato utilizzare il costruttore delle tuple direttamente come pattern matching, quello che uno può fare è definire, allora, siccome stiamo definendo un'altra funzione che prende due parametri che è diversa da questa, quindi, questa chiude questo tipo di clausole, posso definire area, che prende un atomo, quindi di nuovo quadrato e la lista di parametri e di nuovo fare quello che facevo prima, questa roba qui, poi area B, qualsiasi altro poligono che io non ho ancora definito è qualsiasi altra cosa, scrivo not defined, chiudo, chiudo, compiliamo, posso chiamare area di quadrato di lista di 2, funziona, vedete la potenza del linguaggio, la potenza, ora voi mi direte, sì, però qui stiamo ancora vedendo la parte sequenziale, però abbiate fede ragazzi che questa, per ora stiamo definendo una funzione locale, questa, se voi invece, come vi ho detto prima, se voi iniziate a pensare tutto in funzione di messaggi, questa invocazione non sarà nient'altro che un messaggio, l'invio di un messaggio al server che mi calcola l'area di un poligono in cui vi dico calcolami l'area, questo è un messaggio, questo diventerà il contenuto del mio messaggio, calcolami l'area del cerchio, questi sono i parametri, calcolami l'area del quadrato, questi sono i parametri, quindi, come vi dicevo, una volta imparato bene queste basi, poi scala tranquillamente. vediamo se mi sono scordato qualcosa delle slide, questo l'abbiamo fatto, poi, possiamo giocare un po' sulle liste, quindi, possiamo definire una funzione di nuovo add list, quindi che prende, supponiamo che prenda una lista di interi, quindi l, come funziona questa lista? Funziona in questo modo, punto, add list, che mi dice, add list mi dice che, case, no, come era? Sì, case, quindi stiamo utilizzando ora un costruttore, scusate, ora stiamo definendo un, stiamo utilizzando un costrutto, no costrutto, uno statement del linguaggio che vi permette di fare pattern matching, quindi, la lista L, quindi, case L off, se la lista è vuota, devo ritornare la lista vuota, punto e virgola, perché è una clausola, se la lista è composta da head and tail, quello che devo fare è, siccome la sto invertendo, ritornare la tail, quindi la tail, più più la testa, però, ma è un problema qui, il problema è che tail è una lista, la testa non è una lista, perché è un intero, quindi dobbiamo ricastarla di nuovo in questo modo, la esponiamo, virgola, add list, che prende un parametro, compiliamo, quindi se di add list, ok, dobbiamo dargli la lista, 1, 2, 3, 4, 5, 6, 7, 8, chiudiamola qui, 8, vabbè, facciamo 9, e 10, chiudiamo la lista, chiudiamo la parentesi, ok, funziona, abbiamo, no, scusate, ho fatto una cosa, dovevo fare un'altra, quello che volevo fare è, creare una, questa abbiamo fatto una funzione, una funzione che, inverte, la lista, quindi, scusate, ragazzi, scusate, quello che io voglio fare qui è, eh, vabbè, questo la chiamiamo reverse, scusate, ero sopra il pensiero, la idea è reverse, e vogliamo creare una funzione che, add list, che mi sommi tutti i, i numeri, di una lista, quello che io faccio di nuovo è, né più né meno questa roba qui, vabbè, scriviamola, se no, troppa pigrizia, case, l, off, se lista, se la lista è vuota, allora, qual è l'elemento neutro della somma? L'elemento neutro della somma è lo zero. Se la lista è, head, e tail, quello che facciamo è, quello che facciamo è, scriviamo, cioè, ritorniamo, h più, add list, di tail. ricordate che la coda è una lista se stessa. Compiliamo, l'abbiamo esportato, sì, no, add list, prende un parametro, compiliamo, add list, sì, ho salvato, sicuramente l'ho chiamata in maniera diversa, add list 1, vediamo un attimo, export double, and the valid, perché c'è qualche problema, ecco, vedete, questo è un errore che voi beccate, perché la funzione non è definita, ma perché non è definita, perché c'è un errore di sintassi, and, ecco, vedete, perciò vi dico, è veramente facile fare degli errori, e io, nonostante programmi in Erlang, da tanti anni, forse, vuoi anche perché sono un po' sbadato, continuo a rifare sempre gli stessi errori, quindi andiamo a compilare, funziona, vabbè, comunque ce lo dicevo qui, guardate che dopo il punto c'è un errore, ok, abbiamo compilato, funziona, invece di chiamare add list, mi piace questa lista, ne, le voglio chiamare, ah sì, add list, e mi dà 55, ora, se noi andiamo a vedere, il modulo, list, c'è una funzione molto bella, che lo utilizzeremo spesso, per costruirci un iteratore, un iteratore, quindi, sec, eccola qua, sec2, sec3, non ci interessa sec2, per ora, sec2, ci genera una sequenza di interi, da a, quindi noi gli diamo gli estremi, gli estremi sono compresi, quindi, guardate, una sequenza da 1 a 10, lui ci genera i primi 10 numeri, quindi, quello che io faccio è, perché sono pigro, list, sec, da 1 a 10, e magicamente, lo stesso risultato, ovviamente, posso anche chiamare la reverse, e mi rigira la lista, no, la reverse è fatta in modo sbagliato, perché vedete, 2, 3, 4, 5, 6, 7, 8, 9, 10, ma, c'è qualche problema sull'1, perché, andiamo un attimo a vedere che abbiamo combinato, e, reverse, DL, tail, più più, head, ecco, questo abbiamo sbagliato, la chiamata, alla ricorsione, la chiamata ricorsiva sulla, quindi, ora se, reverse list, ora funziona, e va bene ragazzi, ovviamente, l'inversione, la possiamo definire anche come unione di clausole, che è molto più semplice, no, quindi, possiamo scrivere direttamente, la reverse come, inv, inv list, chiamiamola così, che prende direttamente, possiamo direttamente inserire, il pattern matching, nella definizione, della definizione, della funzione, della clausola, quindi, abbiamo detto che, inv, list, di, tail, più più, scusate, h, punto, piccolo, e, inv list, di, lista vuota, ritorna, la lista vuota, punto, quindi, vado a, inv list, di, uno, quindi, chiamo, invece di chiamare la reverse, chiamola inv list, e, banalmente, ritorna lo stesso, lo stesso, risultato, quindi, è, è una questione di gusti, no? A volte uno preferisce, definire le funzioni, totalmente, perciò, qui ho scritto, fib total, o, le funzioni in maniera parziale, come unione di clausole, questo, però, vedete, il linguaggio vi permette di veramente, di fare qualsiasi cosa, con le funzioni, poi vedremo più là, che ci permette anche, di creare delle funzioni, quindi, di scrivere delle funzioni, che ritorno delle funzioni, ok, questo, è abbastanza, per la prima parte, no, per la prima parte, per, per prendere, un po' di, di, di confidenza, col compilatore, con l'interprete, io vi sorto, di sorto, a riprovare, un po' gli esercizi, a modificarli, e a vedere cosa succede, di nuovo, per qualsiasi problema, o, dubbio che voi abbiate, potete mandarvi un'email, oppure, scrivere direttamente sul forno, e, va bene, ci vediamo alla prossima, lezione,