buongiorno ragazzi e benvenuti alla prima lezione di Erlang io spero che voi l'abbiate già installato quindi oggi parleremo brevemente di Erlang e della Sashel e la prossima lezione parleremo un po' dei tipi di dati più complicati più complessi allora prima di tutto c'è da dire che Erlang fornisce due strumenti fornisce l'interpreter che è la Sashel questa è la Sashel Erlang vedete si è avviato e fornisce anche il compilatore quindi per le prime volte interagiremo con la Sashel poi quando inizieremo a scrivere programmi più complessi li faremo compilare e li faremo eseguire dalla virtual machine c'è da dire che uno può intercambiare le due cose e una cosa importante da ricordare è che alcune cose che funzionano in Shell non funzionano nel linguaggio compilato questo per via del binder e delle varie variabili definite nell'ambiente però questo lo vedremo man mano non vi preoccupate allora abbiamo deciso che Erlang è il linguaggio migliore per programmare applicazioni distribuite perché? perché è un linguaggio che è nato con l'idea in mente di avere la concorrenza e la distribuzione quindi concorrenza e distribuzione sono primitive primitive del linguaggio non sono venute dopo tipo se prendete Java o se prendete C è stata la prima sviluppata tutta la parte sequenziale e poi sono stati aggiunti i moduli dei thread i thread in Java sono arrivati molto più in là ma anche i thread in C la libreria P-Tread è arrivata molto più in là mentre Erlang è nato con l'idea di concorrenza primitiva in mente e poi è stato sviluppato il resto quindi mentre tutti gli altri linguaggi di programmazione nascono sequenziali Erlang nasce direttamente concorrente e distribuito ed è anche un linguaggio per programmare sistemi soft real time cosa vuol dire soft real time? vuol dire che non sono critici quindi possono rispondere entro qualche millisecondo a qualche errore i sistemi real time veri, quelli critici, sono per esempio le centrali atomiche se succede qualcosa, le centrali nucleari, se succede qualcosa deve subito intervenire qualcosa e qualcosa deve essere sicuro che avvenga altrimenti succede una catastrofe mentre Erlang è sviluppato per sistemi soft real time supporta operazioni continue, questo lo vedremo molto più in là e supporta la distribuzione di nuovo, questo è uno stress che io metterò durante tutte le lezioni la prima parte delle lezioni sarà sulla programmazione sequenziale una volta che noi capiamo come programmare, come scrivere una funzione sostanzialmente Erlang è un linguaggio funzionale tipo Kamel, tipo Haskell ha una sintasi strana, però ha un linguaggio funzionale quindi qualsiasi cosa è una funzione o meglio, qualsiasi cosa è un'espressione una volta che noi impariamo a programmare queste benedette funzioni metterle in parallelo o distribuirle è veramente questione di una primitiva di chiamare una funzione è veramente banale quindi Erlang scala una volta che noi riusciamo a programmare bene il sequenziale scaliamo subito nel concorrente scaliamo subito nel distribuito senza orpelli successivi ecco allora perché, come vi dicevo Erlang è stato sviluppato da Dall'Erikson e perché è nato questo nuovo linguaggio? è nato dall'esigenza di avere qualcosa per programmare gli switch le centraline telefoniche perché evidentemente con i linguaggi di programmazione di quei tempi non si poteva fare quindi come vediamo tra l'82 e l'85 è stato fatto uno studio su quali linguaggi di programmazione erano esistenti si è capito che bisognava utilizzare linguaggi ad alto livello funzionali quindi tipo Prolog, Lisp, Parlog poi una volta che si sono individuati questi linguaggi si è fatto un ulteriore studio si è capito che le primitive di concorrenza dovevano essere scusate le funzioni le operazioni di concorrenza dovevano essere primitive nel linguaggio non aggiunte dopo e nell'88 si ha la prima versione di Erlang quindi Escape from the Labdor vuol dire che è stata distribuita e poi nei vari anni è stata la virtual machine è stata riscritta un paio di volte e arriviamo nel 91 quando Erlang viene presentato alla comunità scientifica in una conferenza e poi vediamo come nei vari anni è stato sviluppato quindi è stata aggiunta la distribuzione e in più è stata creata nel 97 è stata creata la BIM Machine che è essenzialmente la macchina virtuale attuale che esegue i programmi Erlang Allora come abbiamo detto Erlang è un linguaggio funzionale quindi tenete in mente che è un linguaggio funzionale qualsiasi cosa deve essere una funzione e quindi vuol dire che qualsiasi cosa deve ritornare un valore ora perché è un linguaggio funzionale? qual è l'idea di base di avere un linguaggio funzionale per la concorrenza e la distribuzione? come dovreste sapere o come scoprirete più in là i linguaggi funzionali non hanno side effect quindi una funzione una volta che finisce, finisce non ha effetti sulla memoria quindi è molto facile avviare una funzione metterla in parallelo e restanziarla se questa funzione muore se succede qualcosa di strano perché restanziarla? perché non ha stato quindi le computazioni con le funzioni non hanno stato quindi ecco esattamente non ci sono side effect mentre nella programmazione strutturale tipo C C è basato sul side effect pensate per esempio al passaggio per puntatori il passaggio in cui noi modifichiamo direttamente una cella di memoria quello è un side effect poi passato un puntatore a una funzione C questa è void, non ritorna nulla però per esempio mi modifica dei parametri che mi modifica il valore referenziato dal puntatore che gli avete dato ad esempio quindi abbiamo detto che la computazione è fatta da stati mutabili a stati immutabili poi vedremo esistono dei modi per trarre traccia quindi queste sono le tabelle TS che sono delle hash table distribuite queste le vedremo molto più in là quindi ricordiamo non ha side effect tutto funzionale e ogni linea di comando è un'espressione quindi ogni linea di comando deve ritornare un valore inoltre è compilato e quindi verrà interpretato da una virtual machine è un po' come Java quindi Java viene interpretato sulla bytecode machine e Erlang viene interpretato sulla BIM machine e più come abbiamo visto nelle lezioni precedenti quando vogliamo programmare nel distribuito non esistono altro che l'invio di messaggi e in questo caso abbiamo invio asincrono di messaggi quindi cosa vuol dire? vuol dire che l'invio questa è una cosa un po' strana l'invio va sempre a buon fine mentre la ricezione può essere cioè l'invio ritorna sempre è un side effect di questa scelta è che l'invio ha sempre successo quindi non non non non vi tornerà mai un errore se voi mandate un messaggio a un attore inesistente oppure un attore che è morto perché scrivere e mandare un messaggio è sempre considerato di che la funzione ritorna sempre quindi è sempre considerato un successo quindi messaggi asincroni quindi scrittura manda sempre non si blocca abbiamo le receive quindi la ricezione dei messaggi è bloccante però poi la possiamo programmare con dei time out poi vedremo come si fa usa Erlang una una nozione di di di di parallelismo di thread veramente ultra leggera e questo questo concetto di unità parallela di di di di di di di ultraleggera non è nient'altro che l'attore allora perché parliamo di ultraleggero perché l'attore sulla stessa macchina intesa non computer ma sulla stessa e quindi potete spawnare tipo un milione di at bottlene di attori e le le prestazioni non degradano tranquillamente pensate un milione di attori su una macchina, avete un'applicazione distribuita con vari nodi, ogni nodo fino a uno o dieci milioni di attori riesce a gestirli tranquillamente, quindi vedete che veramente scala, se voi scrivete un programma java che vi lancia 100 thread, avete già ammazzato la macchina fisica su cui state eseguendo. Un'altra caratteristica di Erlang è che potenzialmente i programmi possono eseguire all'infinito, premesso che non va mai via la corrente, però perché possono eseguire l'infinito? Perché come vi dicevo nelle altre lezioni quello che succede è questo, Erlang oltre a primitive native di concorrenza distribuzione ha anche un concetto di fault tolerance che è nativo. Questo vuol dire che un attore può essere demandato come monitor o supervisore di un altro attore, quindi questo è il nostro server, il nostro server risponde a delle richieste, pensate per esempio al server che accetta le scommesse, quello di bet, nel momento in cui questo server per un qualche motivo crasha, cosa succede? Il supervisore viene notificato, e cosa vuol dire che viene notificato? Il servizio riceve un messaggio particolare che ha priorità, quindi questo riceve il messaggio. Cosa succede ora? Siccome abbiamo detto che gli attori non hanno stato, non hanno memoria, nel momento in cui questo riceve il messaggio, crea una nuova istanza del server e quindi tutti i client che da lì in poi manderanno richieste al server non noteranno la differenza tra il server vecchio e il server nuovo, perché è giusto una nuova istanza. Allora, un'altra feature un po' pochino strana, e questo rende un po' Erlang un po' difficile da apprendere. Quindi il problema di Erlang è che la curva di apprendimento è veramente complicata, però poi nel momento in cui apprendiamo tutta la parte sequenziale, è veramente lineare apprendere la concorrenza della distribuzione, è la fort tolerance, è la fort tolerance, è le tabelle distribuite, è il database distribuito, è il meccanismo di interrogazione dei database, è come mettere su un server per un'applicazione, quindi abbiate fiducia. Allora, è un linguaggio tipato dinamicamente, cosa vuol dire? Vuol dire che mentre noi scriviamo nel nostro codice non ci sarà mai una informazione di tipo, questo tipo viene desunto a runtime e questo comporterà degli errori stranissimi a runtime, il primo errore che becchiamo, cioè uno degli errori più comuni che farete, farò, farò durante gli esercizi che svolgerò durante queste video lezioni, il primo errore che becchiamo è il vero errore di pattern matching, e questo vi servirà perché io farò involontariamente farò un casino di errori, cioè tanti errori, perché Erlang è così, e quindi capirete voi, cioè dopo un po' inizierete a capire che errore è, perché un altro problema di Erlang è che il sistema di notifiche, di messaggi è veramente strano, non pensate che andando su Elixir le cose cambiano, no, perché è sempre la stessa virtual machine, però una volta imparate queste debolezze diciamo, uno le aggira e riesce veramente a far tutto con Erlang, ok, dicevo che è un linguaggio tipato di metà mente, quindi a runtime, per questo beccate degli errori strani, e tanti errori sono dovuti al fatto di pattern matching, il pattern matching l'abbiamo un po' visto quando abbiamo parlato di duple, ci permette per esempio di ricevere un messaggio complesso, quindi strutturato, e selezionare, mentre stiamo ricevendo, di selezionare alcuni campi di quel messaggio che a noi interessano, gli altri vengono buttati via, questo è veramente potente, e in più in Erlang qualsiasi cosa è un attore, anche la Shell è un attore, vedremo che la Shell quando la Shell crasha, viene ristanziata, e noi non ce ne accorgeremo mai, l'unico modo per accorgersi è vedere che la Shell cambia il suo indirizzo, il suo PID, questo perché? è come quello che vi ho detto prima, l'esempio del server delle scommesse, perché la Shell ha un supervisore, il suo supervisore ogni volta che vede che la Shell muore, la ristanzia. Per farvi un esempio, questa è la Shell, poi vi faccio una cosa strana, la Shell è morta, però è risuscitata, perché questo è un palese errore per divisione zero. La Shell è morta, è risorta, e io posso ancora continuare a programmare, a interagire con la Shell. Ripeto, quello che è cambiato sotto è l'attore, è l'istanza che mi segue la Shell. La Shell, dal mio lato, cliente, questa è l'interfaccia, l'interfaccia rimane la stessa. Allora, come vi dicevo, ogni comando in Erlang, ogni espressione deve terminare con un punto. Il punto è la fine della mia espressione, e quindi il compilatore, non il compilatore, l'interprete, quando vede il punto capirà che da lì indietro è tutta un'espressione. Quindi, valore 1 è un punto, una somma, scusate, il valore 1 è un'espressione. Quindi, la somma dei numeri è un'espressione e la devo sempre terminare. Vedete, se io non la termino, lui aspetta l'altra roba, quindi posso ancora scrivere l'altra roba, più 4. Allora, termino l'espressione e lì mi dà la somma finale, che è 2, 4, più 4, 8. Quindi, che in quanto lui non vede il punto, non termina l'interpretazione di quella espressione. Quindi, cosa vi deve far capire questo? Che quando scriviamo una funzione, in una funzione in Erlang, la funzione quando termina, terminerà con un punto. Se l'interprete non vede il punto continua, pensa che sia tutto una sequenza di... anzi, pensa che sia un'unica espressione. Se vogliamo sequenziare le espressioni, bisogna utilizzare la virgola, però questo lo vedremo più in là. Quindi, anche i numeri con la virgola si scrivono sempre col punto, però lui riesce a capire. Allora, un tipo base di Erlang, questo è veramente importante, è l'atomo. L'atomo lo vedremo, lo utilizzeremo tanto come etichetta nei messaggi e come etichetta pesantemente nel pattern matching. Quindi, quando riceverò un messaggio il cui primo elemento è l'atomo pippo, io so che devo fare qualcosa. Se ricevo Pluto, so che devo fare qualcos'altro. Quindi, vedete, stiamo iniziando a mischiare già i concetti, l'atomo con il pattern matching. Allora, l'atomo cos'è? E' veramente una cosa strana, perché non esiste nessun'altra cosa simile negli altri linguaggi di innovazione. Allora, l'atomo è qualsiasi sequenza di caratteri che iniziano con la lettera minuscola, quindi vedete che le variabili non possono iniziare con la lettera minuscola, non è un problema, ma è una prima fonte di errore, perché spesso noi abbiamo un bias che è tutti i linguaggi di programmazione, finora le variabili le abbiamo sempre utilizzate con la lettera minuscola, pensiamo a C. Quindi, cosa ci sto dicendo? Che se io scrivo questo modo, questo è l'atomo x, se io scrivo x uguale a 1, questa è la variabile x, quindi quando la richiamo, la richiamo, mi dà quel valore. Quindi state molto attenti, gli atomi iniziano sempre con le lettere minuscole, quindi tutto quello che inizia con le lettere minuscole è un atomo. Ovviamente posso anche mischiare A11, questo è un atomo per me, per lui, non per me. Se vogliamo far iniziare un atomo con le lettere minuscole, dobbiamo utilizzare, o se vogliamo far iniziare un atomo con le... vediamo un attimo... vedete, questo però se vogliamo far iniziare un atomo con una maiuscola o con un numero, bisogna utilizzare gli abigetti. Vedete? Ora lui sa che quello è un atomo. Questo è quello che vi stavo dicendo, quindi... però per regola generale di programmazione di stile è che tutti gli atomi iniziano con le lettere minuscole ed è inutile, cioè essenzialmente è inutile usare questa forzatura, perché poi uno potrebbe confondersi con le variabili, quindi gli atomi iniziano con le minuscole, questa è una convenzione che utilizzeremo durante tutto il corso, le variabili iniziano con le maiuscole, perché le variabili devono iniziare con la maiuscola. Quindi vedete, pippo piccolo è un atomo, pippo grande è una variabile, pippo tra apici di nuovo diventa un atomo. E questo è uno degli errori più comuni in Erlang che faremo, che farò, che farete, perché è veramente controintuitiva, perché finora abbiamo pensato che le variabili fossero scritte nelle lettere viscole. Però una volta che uno ci fa la bocca, questa roba poi va tutto da sé. Ovviamente abbiamo anche... abbiamo parlato un po' degli atomi, abbiamo parlato poi degli interi, dei float... Ah, io vi do i concetti base, però vi esorto a sperimentare questa roba, tranquillamente. Abbiamo i booleani. Anche qui i booleani sono un po' strani, però ora lo vedremo. Abbiamo i booleani, quindi l'operatore di uguaglianza, uno potrebbe pensare che è uguale a uguale. Quindi uno è uguale a uguale a due? Lui dice no. Poi abbiamo l'operatore di minore o di maggiore, tranquillamente. Allora, siccome gli atomi sono dei tipi di dati preventivi, possiamo anche compararli. Quindi io ho l'atomo pippo e il minore di Pluto. Per lui questa è un'espressione totalmente lecita, quindi less maggiore di more... scusate, ho sbagliato... e così via. Quindi state veramente attenti a quando utilizzate gli atomi. Magari dovete vedere queste due variabili. Avete variabili con le lettere magnusclee, però utilizzate gli atomi, cioè i loro omonimi atomi piccolini. Quindi state veramente attenti. Abbiamo anche altri... Quindi gli atomi sono ordinati per ordine lessicografico, quindi banalmente avremo che l'atomo A è minore dell'atomo B. L'atomo A, per un attimo, B, B, B. L'atomo AA è sempre minore perché conta la prima lettera. Un dato strutturato che noi utilizzeremo spesso per i messaggi sono le tuple. Cosa è la tupla? La tupla è una qualsiasi sequenza, quindi sequenza vuol dire serie di tipi di dato separati da delle virgole. Quindi una tupla è una qualsiasi sequenza racchiusa tra le graffe. Quindi una tupla, questa è la tupla vuota. Se voi avete fatto programmazione logico-funzionale con il colp. San Bernardo, la tupla vuota è il costruttore. Uno potrebbe vederlo... cioè no, è il costruttore della... Quindi questa è una tupla vuota, questa è una tupla che contiene 1, questa è una tupla che contiene 1, 2, Però nulla mi vieta di poter creare una tupla più complicata, con Pippo, Pluto, un'altra tupla all'interno, 1,2, e una stringa. Mi sono scordato che le stringhe sono tra doppie apici, mentre i singoli apici sono per gli atomi. Sono una stringa. Ora... sì. Questa è una tupla, è una tupla composta da 1, 2, 3, 4, 5 elementi. Ricordate, 5 elementi. Quindi una tupla è un insieme di elementi e posizionale. Quindi il primo elemento è questa roba, il secondo è questo, il terzo è questo. Il quarto elemento è un elemento complesso a sua volta, e così via. Possiamo... esistono delle funzioni, siccome le tuple sono dei tipi di dato primitivo, abbiamo delle funzioni built-in. Quindi se io metto tutta questa roba, lui mi darà 5. Esattamente. Poi possiamo anche selezionare l'iesimo elemento di una tupla, però questo ve lo proibirò sempre, perché potete usare pattern matching per selezionare l'iesimo. Non c'è bisogno di utilizzare queste funzioni elementi. Quindi selezioniamo il quarto elemento di questa tupla, dovremmo avere la tupla che contiene 1 e 2. Esattamente. E più le plute, le tuple, essendo tipi di dati primitivi, si possono comparare, no? Anche qui posso comparare le tuple. Essenzialmente questo operatore viene applicato in sequenza ai primi elementi, ai secondi, ai terzi, ai quarti, e quindi perché becchiamo è un aggregato. Allora, abbiamo parlato di tuple. Tuple sono una sequenza ordinata di elementi. Esistono altre sequenze ordinata di elementi, che sono le liste. Qual è la vera differenza? La differenza vera è che le tuple, una volta che noi le definiamo, hanno una dimensione fissa. Noi non possiamo aumentare la... 1, 2, 3, 4... No, questa è una tupla di due elementi. Vedete, questa è una tupla di due elementi... no, scusate. Questa è una tupla di tre elementi, il cui secondo elemento è un elemento composito. Questa tupla, una volta che è definita, non si può aumentare. Quindi dimensione 3 avrà sempre dimensione 3. Possiamo creare altre tuple a partire da questo, però questa in particolare non può aumentare. Se noi abbiamo necessità di avere una struttura di dati che è una sequenza ordinata infinita, questa è una sequenza ordinata finita, infinita, quello che usiamo è solo le liste. Quindi... Quindi... La... Quindi liste e tuple sono simili, e... L'operatore di spaziatura, di sequenza, è sempre la virgola. Quello che cambia è il costruttore, no, ovviamente. Quindi... Io ho una tupla di uno, due... Uno, due, tre... Io ho anche una lista di un, due, tre. Vedete? Nel fricolto non gli do il punto, lui non interpreta nulla. E anche qui io posso divertirmi ad utilizzare... Allora, cerchiamo di fare qualcosa di più sensato. Quindi persona... Mi sto creando... Vedete? È un... Inizia con la lettra maiuscola, quindi... È una variabile. Persona... Audio... Vergine... Sto creando una tupla... Sto creando una tupla... Quindi un record che rappresenta il nome, il cognome e l'età. Ecco... Questo è un errore comune... Perché scrivendo maiuscolo non è un atomo ma è una variabile... Quindi quello che devo fare è utilizzare le stringhe... Allora io volessi continuare questa rappresentazione. Ora posso creare una lista, ad esempio, di uno, due, tre... Posso creare una lista di record... Ecco, metto Pippo Disney 50... Una cosa del genere. Vedete? Lui crea la lista con i primi due campi... I primi due valori che sono delle copie della mia persona... E poi un terzo campo. Quindi vedete, per esempio, io posso rappresentare una... Una... Un'agenda telefonica... O... Iniziamo a pensare già così... Una tabella di un database... Come una lista di tupla. Esistimamente è questo che faremo. Quando andremo a... Quando andremo a... A parlare di... Mnesia, che è il database built-in di Erlang... Le tabelle saranno delle liste di tuple. E qual è la cosa bella di tucio? La cosa bella di tucio è che... Se voi imparate a maneggiare le... Le liste e le tuple... Potete... Modificare tranquillamente le... Tabelle del database. E... Un'altra cosa... Notevole di avere un database built-in... Tutti i tipi di dato... Di Erlang... Possono essere... Inseriti nel database. Quindi non ci sarà mai un mismatch di dati. Io voglio... Un tipo di dato per me è una funzione. Posso anche registrare nel database una funzione. Tranquillamente. E c'è un matching uno a uno... Tra i tipi di dato che... Nel database accetta... E i tipi di dato che Erlang fa. Quindi c'è proprio un'integrazione... E... Invisibile. Che vostri... Cioè... Vi darà l'amministrazione di lavorare... Di nuovo su delle liste di tuple. Piuttosto che su una tabella... Di un database distribuito. Ok. Ehm... Allora. Abbiamo visto un po' le stringhe. Cosa sono le stringhe? Le stringhe sono un po'... Le stringhe di C. Sono una lista di caratteri. Quindi una stringa è vista come una lista di caratteri. E il dollaro, per esempio... Si usa per... Per rappresentare il carattere... Per esempio... Dollaro H vuol dire... Dammi il carattere H. Dollaro E vuol dire... Dammi il carattere H. Dollaro E vuol dire... Dammi il carattere E. E essenzialmente questo... E' come quando... Se voi... In C... In C... Le stringhe sono una lista di caratteri. I caratteri cosa sono? Degli interi. I caratteri sono degli interi. Caratteri... Asci. Stiamo parlando di roba Asci. Quindi vedete... Questa è la rappresentazione... In Asci... Di questa stringa. Quindi se io prendo questa stringa... Scusate... Questa... Dupla... Questa lista... E lui mi interpreta come Hello World. Perché... 72 è la H maiuscola... 101 è la E... E così via. Sì. Allora... Come vi dicevo prima... Questo è il caratteri... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Asci... Il costruttore... Questo è il costruttore... O l'elemento vuoto... Delle tuple... E questo è l'elemento vuoto... Delle liste... La differenza... Come vi dicevo... È che le liste... Si possono costruire... Si possono concatenare... Le tuple no. Le tuple no. Non esistono operatori di concatenazione. Quindi... Iniziamo a vedere un po' le operazioni... 1... 2... 3... Io faccio... Size... size è per le tuple e length è per le liste. I caratteri sono interi e si possono sommare, quindi la maiuscola, se sommiamo 32 diventa la minuscola, perché i caratteri minuscoli sono più alti in tabella rispetto ai caratteri maiuscoli del codice ASCII. Allora, torniamo un po' alle liste. Come vi dicevo, le liste sono delle strutture infinite. E nonostante noi scriviamo, nonostante il parser o l'interprete questa ce la prende valida, questa cos'è? Una lista, la cui testa contiene uno e la cui coda contiene un'interior lista fatta da una lista e così via. Quindi qual è il costruttore vero delle liste? Una lista viene fatta e una lista si costruisce in questo modo, c'è l'elemento che è la testa e la coda. Quindi quando vedrete la barra, la barra ci permette di differenziare la testa dalla coda, e la barra la possiamo utilizzare anche in pattern matching. Quindi, come vi dicevo prima, la lista... questo è essenzialmente dello zucchero sintattico per esprimere questo. Quindi una lista composto da un elemento e la coda 2 e 3. Ma di nuovo, la coda cos'è? Una lista? Quindi, essenzialmente questa... scusate... è la versione piatta di scrivere tutta questa roba. Quindi prendiamo, iniziamo a... abbiamo detto che la barra è l'operatore di concatenazione, se io prendo una lista, uno, e la concateno con la lista vuota, quello che tengo è la lista che ha un solo elemento. Se io concateno la lista con una lista, scusate, con una lista che ha A, B, due atomi, questi due atomi, sono i due atomi, quello che tengo è una lista che ha il primo elemento, il primo elemento, il numero 1, e poi il secondo elemento l'atomo A e il terzo elemento l'atomo B. Ovviamente esiste un... questo lo vedremo pesantemente... esiste il... il package, il package, una raccolta di funzioni delle... di un modulo, una raccolta di funzioni di liste, perché le liste sono veramente importanti per Erlang, quindi esiste un modulo intero per... per programmare le liste. Iniziamo a prendere... iniziamo a prendere... dimestichezza coi moduli. Vedete, qui sto utilizzando list.max, quindi cosa vuol dire? vuol dire che sto invocando la funzione max del modulo list, quindi nel momento in cui voi vedrete... questo è un errore, questo è un errore, è solo un... un... due punti, quindi se io... se qualora vedete, cioè in qualsiasi codice Erlang, se vedete M, due punti, F, vuol dire che sto chiamando la funzione F del modulo M, quindi ad esempio list, vedete, list, i moduli, e mi dà... se io schiaccio tab, mi dà tutte le possibili... tutte le possibili funzioni di questo modulo. list.max volevo fare... di una lista... uno, due, tre, quattro, cinque... e sei, sei... e allora mi dovrebbe ritornare sei... il massimo di questa lista. quindi abbiamo... io vi risolto ad andare a vedere il package... il package... il package... allora, volevo aprire un'altra finestra... new window... ok... quindi se io vado a vedere il package... il modulo... il modulo list... quindi... modulo list... Erlang... ecco qua... ecco, questa è un'altra cosa che iniziate a vedere... esiste il... ecco no, volevo... volevo usare questo... esiste il MAN, quindi la documentazione ufficiale di Erlang è mantenuta su erla.org e qui trovate tutta la documentazione... questo è un po' come il javadoc, no? quindi... questo... questa è la documentazione per... il modulo... continuo a chiamarlo package... ma questo è un modulo... il modulo lista... liste... e qui vedete tutto... tutte le varie... vedete quante funzioni... il modulo... vi mette a disposizione... quindi noi stavamo vedendo... max... eccola qua... quindi... lista max... prende una lista e ci ritorna il massimo... quindi la lista è... una serie di elementi di tipo T... e lui ci ritorna... il massimo che è un elemento T... quindi ci ritorna il primo massimo della lista... e così via... dobbiamo fare funzioni... ora... più in là... nelle lezioni vedremo... generalmente... quelle che noi utilizzeremo... sono la... sono la Fold... la Folder... la M... la...