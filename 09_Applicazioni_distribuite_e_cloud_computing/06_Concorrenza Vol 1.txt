buongiorno ragazzi e benvenuti di nuovo al corso di applicazioni distribuite cloud computing come vi avevo promesso oggi inizieremo a parlare della parte più interessante di Erlang della concorrenza quindi come avevamo un po anticipato durante le lezioni iniziali quelle su inter process communication cosa è un modello di concorrenza? Un modello di concorrenza specifica come processi o thread in un dato sistema collaborano in modo tale da eseguire un compito che gli è stato dato quindi di nuovo lo stress è sul fatto che abbiamo più programmi che eseguono contemporaneamente e collaborano di nuovo questa collaborazione come avviene può avvenire in due modi uno è tramite shared memory non l'abbiamo visto e l'altro che è più indicato per i sistemi distribuiti è basato sullo scambio di messaggi ecco come vi ho sempre detto Erlang utilizza un modello di concorrenza basato a scambio di messaggi e vedremo che è veramente questa la scelta vincente di Erlang in Erlang i thread o i processi vengono chiamati si chiamano attori anche se io molte volte chiamerò un attore lo chiamerò un processo però mi riferisco sempre a un attore quindi in Erlang i processi sono attori e gli attori tra di loro comunicano mandandosi messaggi niente di più e niente di meno quindi come un po anticipando e siccome in Erlang tutto è un'espressione cosa è un attore? un attore è un attore è un processo che esegue una funzione questa funzione aspetta messaggi processa messaggi e manda messaggi e poi termina ovviamente se è una funzione ricorsiva non terminerà mai se è una funzione che riceve un messaggio calcola qualcosa e manda il messaggio allora poi terminano allora iniziamo a vedere un po queste funzioni benedette funzioni che vi ho sempre detto che sono alla fine se uno conosce se uno ha imparato a programmare Erlang sequenziale per fare Erlang concorrente gli servono solo due funzioni e nella fattispecie ora vedremo la funzione spawn1 e la funzione spawn3 allora di nuovo come dovreste aver capito spawn1 prende un parametro e spawn3 prende tre parametri le due e le quattro per ora non le consideriamo magicamente quando parleremo di Erlang distribuito useremo la funzione 2 e la funzione 4 questo di nuovo per dirvi che nel momento in cui noi riusciamo a programmare parallelo o concorrente in locale una volta che riusciamo a non masterizzare padroneggiare una volta che riusciamo a padroneggiare questo tipo di paradigma allora andrà scalare nel distribuito comporta solo aggiungere un parametro in più quindi vedete che la spawn2 e la spawn1 più un altro parametro e la spawn4 e la spawn3 più un altro parametro però lo vedremo più avanti allora vediamo un attimo cosa succede quando uno crea una spawn quando facciamo una spawn come vi ho detto prima un attore esegue una funzione quindi la spawn parliamo della spawn1 prende una funzione e che fa? crea un attore quindi fa istanzia un nuovo attore ora come facciamo come facciamo a capire chi è questo attore come comunicare a questo attore Erlang ci dà il PID il PID che lui è raramente diciamo chiama process identifier il PID cos'è? è quel benedetto indirizzo il civico no? è l'indirizzo di casa a cui mandare le lettere i messaggi quindi vediamo subito vediamo un attimo se c'è la shell sì se facciamo una spawn di una funzione che non fa nulla quindi fun1 non si può fare la funzione quindi facciamo 1 più 1 una funzione che ritorna 1 quindi vedete mi ritorna questa roba qui questa tripletta questa tripletta no? questa tupla particolare e quello è l'indirizzo su cui noi andremo a mandare i messaggi quindi l'unico modo per comunicare con degli attori è conoscere il loro PID la cosa buona è che il PID può essere mandato in un messaggio quindi può essere mandato da un attore ad un altro e quindi si fa discovery dinamica degli attori ok infatti questo nell'esempio noi spawniamo la funzione che ritorna 1 quindi la funzione costante 1 e ci crea il ci crea un process identifier allora come vi ho detto il process identifier è una tripletta il primo numero identifica diciamo il nodo nella rete però questo è già un'anticipazione della distribuzione quindi se noi lavoriamo in locale il primo numero è sempre 0 poi il secondo numero effettivamente rappresenta il process identifier del processo e il terzo numero è l'incarnation number però questo è una cosa che non vedremo una cosa più di livello della BIM Abstract Machine allora come vi ho detto prima l'unico modo per comunicare cioè l'unico modo per mandare un messaggio a un processo è conoscere il suo PID quando spawniamo un processo conosciamo il PID di chi abbiamo creato ma come fa un processo a conoscere il suo PID? ok generalmente Erlang mette a disposizione questa funzione self e ora torniamo al discorso del fatto che la shell è un attore self quindi ogni processo vedete la shell ha un PID diverso scusate ha un PID diverso da questo perché un process identifier è diverso come vi ho detto la shell è un attore ma anche un attore particolare perché è sempre monitorato quindi se noi facciamo crashare la shell tipo 1 più atomo atomo atomo ok e richiamiamo self vedete cosa è successo? è successo questo che la shell è morta però è stata ristanziata dal padre dal monitor e noi non ci siamo accorti e questo per dirvi che Erlang gestisce veramente bene i fallimenti degli attori ora vediamo anche un'altra cosa siccome questa shell è da un paio di settimane che era aperta la console stessa aveva un PID molto vecchio dove siamo qui? la console aveva un PID molto vecchio questo era il PID della funzione avevamo sponato la shell è morta è stata ristanziata però ha preso un PID successivo quindi il 263 quindi vedete che è progressivo al 260 quindi per dire che i PID vengono creati in maniera progressiva all'interno di un nodo che sta in una macchina allora come si può comunicare? abbiamo il PID quindi abbiamo scriviamo sulla lettera il destinatario non c'è bisogno di scrivere il mittente il mittente lo mettiamo solo se vogliamo essere ricontattati come facciamo? abbiamo un'operazione di invio messaggio l'operazione di invio messaggio è banalmente il punto esclamativo quindi il punto esclamativo quando noi vediamo un punto esclamativo vuol dire che stiamo mandando un messaggio quindi qual è la semantica? vogliamo mandare il processo vuol mandare un messaggio al PID al processo identificato dal PID e la cosa bella di Erlang è che qui dentro nel messaggio si può mettere qualsiasi tipo di struttura dati voi abbiate perché tutti i tipi di dati sono nativi in Erlang quindi molto banalmente giochiamo un po' con la console di nuovo la console è un attore quindi se io mi prendo scusate che console? quella è self e quindi mando a console un messaggio per convenzione io i messaggi li metto sempre in una tupla però uno può mandare qualsiasi cosa questo io ho mandato un messaggio ciao quindi se io vado a vedere se io vado a a flashare la coda o la mailbox della console quello che vedo è il messaggio ciao quindi questo è il messaggio che gli ho mandato ovviamente come ho detto qualsiasi tipo di dato può essere mandato questa è una tupla che contiene un atomo posso anche mandargli questo eh tranquillamente per lui va bene lo stesso però capite che questo è diverso da questo per convenzione i messaggi vanno sempre tra tra tuple perché poi manderemo messaggi composti quindi è veramente raro mandare un messaggio con un unico con un unico elemento quindi come vi dicevo state molto attenti al al formato dei messaggi che date perché poi quando noi vediamo la funzione per ricevere un messaggio questa funzione è bloccante e se non riceve il messaggio che soddisfa il pattern allora rimarrà bloccata indefinitivamente quindi questo è un tipico errore di Erlang mandare un messaggio in formato diverso da quello che uno si attende e quindi vuol dire il programma in deadlock è capire il deadlock di programmi distribuiti è veramente complicato allora ora abbiamo scusate ora abbiamo un meccanismo per mandare un messaggio qual è la controparte? ricevere un messaggio e in Erlang per ricevere un messaggio si usa la prima l'istruzione receive vedete receive and e come vi ho detto la receive ha tanti cioè bisogna specificare i pattern dei messaggi che noi vogliamo ricevere quindi pattern 1 con la guardia o senza generalmente si usa il pattern senza la guardia quindi se ricevo un messaggio che soddisfa il pattern 1 allora vado in questo ramo del mio della mia receive se ricevo il pattern se ricevo un messaggio che soddisfa il pattern 2 vado in questo ramo e così via ecco generalmente poi se non ricevo se se l'esclusione di tutti questi pattern è il pattern più generico possibile allora qui dico qualcos'altro se lo voglio ricevere allora come funziona il pattern matching? il pattern matching funziona in maniera strana le Erlang le code le mailbox sono delle code quindi la la la la la politica è una politica fifo quindi first in first out però il first out è il primo elemento della testa che soddisfa il pattern più vicino il pattern più non vicino più sì più vicino alla receive quindi se io ho nella testa due messaggi il primo non mi soddisfa nulla e il secondo mi soddisfa il pattern due allora Erlang prenderà il pattern due e utilizzerà il secondo messaggio il primo messaggio rimarrà sempre lì fino a che non verrà consumato o fino a che l'attore non muore quindi come vi dicevo il pattern è sempre applicato alla testa della coda dal quindi cosa si fa ogni volta che il il programma incontra una receive inizia a vedere se il primo messaggio prende il primo messaggio questo messaggio quale pattern soddisfa iniziando da da sopra verso sotto se lo trovo se il primo pattern che soddisfa questo messaggio allora viene triggerato altrimenti si passa al secondo messaggio e così via terzo messaggio quindi è un po' come quando quando definivamo le clausole della funzione queste essenzialmente sono delle clausole ragion per cui si mette il punto in virgola come definivamo le clausole ovviamente si mette la più la più le più discriminative sono sempre le prime e quelle più lasche sono le ultime questo perché se lo mettiamo come questa che vuol dire qualsiasi messaggio io ho letto devo fare qualcosa se questo viene messa come prima come primo pattern allora gli altri non verranno mai eseguiti perché Erlang il primo pattern che matcha lo utilizza lui è veramente così quindi questo questo è quello che vi sto cercando di dire quindi la valutazione la valutazione dei pattern è veramente lesi quindi bisogna stare attenti a questa roba va bene allora proviamo un attimo una funzioncina proviamo un attimo un ping pong no? lo proviamo da shell e allora mi creo la funzione f fun che quando viene chiamata si mette in attesa quindi receive di nuovo siccome io ho intenzione di mandargli una tupla la receive questo mio pattern deve contenere una tupla quindi io cosa voglio ricevere? voglio ricevere un messaggio che ha ping ping e poi creo una variabile p il secondo parametro io lo voglio legare a questa variabile ora vi spiego un attimo perché perché è il pid del mittente quindi come vi dicevo i messaggi possono essere anonimi o no chi riceve un messaggio non conosce esplicitamente l'identità di chi gli ha mandato a meno che chi gli ha mandato il messaggio non fa safe disclosure quindi non scrive nel messaggio chi è il mittente quindi qui sto scrivendo il mittente ipotizzo di ricevere il mettente quindi la receive che fa ricevo un messaggio quindi qualora io ricevo un messaggio di ping quindi che contenga come primo elemento l'automo ping allora io rispondo pong and and punto dovrebbe andare bene quindi qualsiasi messaggio che io gli mando questa receive non verrà mai lanciata a meno che io non gli mando un messaggio di ping un messaggio il cui primo elemento è un atomo è esattamente l'atomo ping quindi dovete stare attenti a questo e quindi vedete che se uno usa un formato tuple generalmente la prima il primo elemento della tupla è il tipo di messaggio che gli sto mandando poi vedremo più in là questo è il tipo di se noi stiamo invocando un server stiamo mandando un messaggio al server per invocare una funzione gli stiamo dicendo voglio la funzione a piuttosto che la funzione b piuttosto che la funzione c questa funzione sono essenzialmente quelle esposte dal server quindi sono le API quindi potete vedere che io sto chiamando l'API ping del mio server perché questa è una funzione remota diventerà prima o poi una funzione remota che aspetta dei messaggi allora abbiamo creato la funzione cioè abbiamo creato una variabile che contiene la funzione spawniamo la funzione però voglio un attimo vediamo se ok pid is unbound pid uguale spawn di f quindi stiamo spawnando la funzione avrei potuto scrivere direttamente questa roba l'avrei potuto scrivere direttamente qui dentro ma siccome sono le prime volte cerco di fare le cose in maniera incrementale in modo tale che voi non abbiate problemi di comprensione allora c'ho il pid che faccio quello che volevo fare io gli scrivo ping allora proviamo un attimo scriviamogli ping senza null'altro poi scriviamogli solo self vedete che lui lui non mi ha mandato nulla ancora perché aspetta ancora un messaggio cui ping io gli aspetta un messaggio formato da questa roba ping e self self io gli dico rispondi pong a questo indirizzo quindi se io faccio flash ho ottenuto pong quindi vedete nel momento in cui lui ha ricevuto un messaggio che soddisfaceva quel pattern questo pattern dove siamo qui questo pattern è stato soddisfatto dalla mia tupla dalla mia tupla ping e il mio pid allora lui ha preso ma risposto ora lui è morto se noi proviamo a mandargli un'altra un'altra cosa non riceviamo più nulla quindi lui è morto per fare in modo che lui continui a a rispondere ai messaggi bisogna usare la spawn 3 e bisogna usare una funzione non lambda perché lui una volta che finisce di ricevere il messaggio allora si deve ricorsicamente richiamare ora forse l'avete già intuito però vedete questo comportamento veramente strano di Erlang perché anche se l'attore è morto noi possiamo continuare a mandare i messaggi cosa vi sto dicendo l'invio dei messaggi va sempre a buon fine anche se l'attore non esiste più perché l'idea è che le send non sono bloccanti e le receive sono bloccanti quindi bisogna stare anche attenti bisogna mettere ovviamente quando noi parleremo di tutto Erlang avremo dei meccanismi per capire se un attore è morto quindi è inutile mandare il messaggio se questo è morto però per ora state attenti a questa cosa quindi se noi esponiamo di nuovo l'attore però dovevo liberare F che ho liberato un po' di variabili quindi se io richiamo di nuovo l'attore vedete con F liberiamo tutte le variabili legate nel sistema quindi sono riuscito a ricreare di nuovo la funzione F se non l'avessi fatto mi avrebbe dato errore perché mi avrebbe dato un errore di match quindi cosa voglio fare voglio sponare facciamo così P uguale spawn di S quindi l'attore che mi risponderà al PID contenuto nella variabile P si aspetta un messaggio si aspetta un messaggio di due elementi se io invece di scrivere gli ping gli scrivo Pongo di nuovo lui non mi risponderà perché lui si aspetta esattamente quest'atomo quindi se io faccio flash lui continuerà a rimanere bloccato all'infinito perché la risipe è bloccante fino a che non riceve un pattern di nuovo non riceve un messaggio che si è disperso pattern se io scrivo PIN per esempio di nuovo lui non mi risponde lui risponderà solo se ho questo ping e ora ho beccato il messaggio allora le receive possono essere c'è una differenza tra concatenare due receive e avere una receive che può ricevere messaggi contemporaneamente quindi se io ho due receive in questo caso e sono in sequenziale allora la seconda receive non verrà mai abilitata affinché non viene soddisfatta la prima receive quindi vuol dire che io sto imponendo una sequenzializzazione del mio programma voglio prima ricevere la funzione il messaggio fu e poi ricevere il messaggio bar quindi cosa vuol dire questo che il messaggio bar viene letto dopo perché sto imponendo dopo il messaggio fu anche se il messaggio fu può essere inviato stiamo parlando di concorrenza quindi anche se il messaggio bar arriva prima all'attore 3 lui non lo processerà fino a che non arriva non gli arriva il messaggio fu mentre se io scrivo una una receive in cui io mi aspetto questi due tipi di messaggio questo dipende veramente dall'ordine di arrivo dei messaggi quindi se mi arriva prima il messaggio fu viene processato fu se nell'attore se nella coda arriva prima il messaggio pid viene scusate il messaggio bar viene processato il messaggio bar questo l'abbiamo visto come vi dicevo la shell è un attore particolare perché c'è un padre affettuoso e sto padre affettuoso ogni volta che vede che la shell si fa male la cura quindi la restanzia l'altra volta e di nuovo questo si può fare perché non c'è stato non c'è stato nel momento in cui nasce il more si perde tutto e bisogna solo restanziare una funzione ci sono vari pattern che vedremo più in là ma il pattern più comune per scrivere che esattamente il pattern che utilizzeremo per scrivere il server il pattern più comune per un'applicazione distribuita per un server è questa qui abbiamo lo start una procedura di una fase di inizializzazione magari lanciamo un po' di monitor di link un po' di pid questa roba qui e poi abbiamo quello che si chiama il receive evaluate loop il receive loop forse l'avete capito quando ho detto prima che generalmente una funzione quando viene esponata deve essere una funzione ricorsiva altrimenti muore subito quindi il receive cos'è il receive viene messo in un loop e quindi io mi aspetto metto la lista di tutti i possibili messaggi che potrei ricevere pensate per esempio ad una calcolatrice una calcolatrice remota parliamo di di di di operazioni banali su interi una calcolatrice cosa si aspetta si aspetta i messaggi di quali sono le operazioni che possiamo fare con la calcolatrice somma sottrazione differenza moltiplicazione quindi sono quattro messaggi quindi uno li può astrarre può dire che l'interfaccia ha quattro messaggi e io faccio una funzione che è sempre in attesa di messaggi di questi quattro tipi di messaggi il cui il primo atomo mi dice che tipo di operazione io devo fare quindi insomma differenza moltiplicazione o divisione intera ora lo vediamo come vi dicevo la spawn tree è nient'altro che la spawn 1 però in cui sponiamo una funzione con nome gli diciamo il modulo quindi modulo il modulo dove si trova la funzione la funzione stessa e gli argomenti che deve prendere la funzione ora gli argomenti è una cosa un po' complicata gli argomenti vanno sempre tra quadre anche se la funzione non prende non prende argomenti bisogna indicare la lista vuota quindi quando dico tra quadre intendo una lista quindi proviamo a fare questo benedetta calcolatrice che vi dicevano ecco qui quindi proviamo a fare calc punto erl open calc punto erl ecco qua e ora richiamiamo di nuovo allora stiamo creando un modulo calcolatrice di nuovo i moduli devono avere lo stesso nome del file siccome l'ho chiamato calc il file deve essere il modulo scusate deve essere calc e andiamo un attimo cosa era qui ok quindi lo chiamiamo barra export quindi stiamo se torniamo indietro stiamo saltando la fase di inizializzazione stiamo creando direttamente il loop quindi come vi dicevo export loop zero vedete io ora esporto il loop non esporto le singole funzioni perché le singole funzioni mi vengono esposte tramite questa funzione loop ora lo vedremo meglio quindi loop mettiamo la fine allora che fa la loop come vi dicevo receive end la receive mi dice che se io ricevo add ovviamente mi aspetto una funzione che mi mi aspetto un messaggio che mi indica sommami questi due numeri x e y scusate x e y e poi ovviamente devo sapere dove rispondere quindi il pid di chi mi ha invocato quindi se io ricevo questa roba qui quello che faccio è al pid mi mando x più y facciamo facciamo un'altra facciamo un'altra facciamo un'altra sub sub x meno y proviamo a compilare vi dico già che c'è un errore un errore c calc c'è un errore non sintattico ma semantico perché nel momento in cui io ricevo per esempio un messaggio add risponde questa funzione risponde col messaggio giusto e poi che fa termina termina quest'altra pure termina se voglio che questo mi diventi un loop veramente un loop quello che devo fare è andare in ricorsione e così così questo questo questo server questo è un serverino non morirà mai a patto che a meno che io non gli dica generalmente si fa questa roba quindi nel momento in cui io ricevo un messaggio di stop allora cioè chiunque mi può stoppare allora io termino in maniera gracefully in maniera tranquilla controllata ok quindi ricordate questo serve per un messaggio di stop per terminare quindi io che faccio abbiamo detto bisogna usare la spawn 3 spawn il modulo con le calc la funzione è loop e gli passo nessun parametro vedete nessun parametro deve essere questo modo qui chiudo qui ho sbagliato è spawn spawn e me lo metto come calcolatrice ora se io la calcolatrice gli voglio fare la come l'ho chiamata add di 4,5 e devo se gli faccio questa roba qui faccio self lui non mi ha risposto nulla perché perché no è flush scusate perché lui si aspetta una quadropla quindi gli devo mettere self che sarebbe self flush e prendo 9 perché la somma di 4,9 e di nuovo ora lo posso interrogare di nuovo 6 e lui continua a rispondermi perché lui è in continuo ascolto una volta che mi esegue l'operazione si rimettono qui e questo è bloccante quindi se io gli faccio sub continua gli diamo 10 diciamo 10 quindi dovremmo avere meno 4 flash teniamo meno 4 quando gli mandiamo stop mandiamo stop lui termina noi non ce ne accorgiamo però se gli mando qualcosa altro vedete che lui non mi risponde più perché lui lui ha terminato veramente in maniera carina e controllata ecco un'altra cosa un'altra cosa che dovete rendervi conto un po' come la la send la spawn non fallisce mai se voi spawnate una funzione scritta male lui vi dà un PID poi l'attore che va a eseguire la crasha però lui Erlang vi restituisce un PID quindi state veramente attenti anche quando spawnate una funzione questo per dirvi che avere un PID non vuol dire che l'attore è vivo anche se voi avete un PID il PID vuol dire che è stata allocata una risorsa che deve eseguire qualcosa quindi il PID è solo un collegamento tra l'environment e quella cosa lì se quella cosa lì nel momento in cui è stata spawnata è morta Erlang se ne frega giusto cioè perché lui la funzione spawn è andata a buon fine perché doveva ritornarvi un'unità di allocazione poi sta a voi capire che è successo veramente quindi se noi per dirvi se io faccio se io spawno una funzione uso la spawn trendy di un modulo che non esiste vabbè calc calc c'era invece di loop lo chiamo server vedete questa roba vedete lui questa questa è ritornata questo mi ha dato un PID proprio però poi questo è l'attore 0 113 che è crashato perché non esiste dice guardate calc deserve è undefined per me però questo è successo in un secondo momento quindi state veramente attenti a questa roba quindi questo è un esercizio che potete fare completate la calcolatrice completate la calcolatrice e se avete qualche problema scrivetemi ora vediamo va bene ragazzi allora continuiamo un ottimo parlare di concorrenza continuiamo un po' a giocare con la concorrenza come compito vi avevo lasciato cioè nelle slide precedenti vi ho lasciato quello di completare la calcolatrice ora vediamo un attimo un serverino cioè ora vediamo un attimo un serverino con con un po' di di di di stato no perché la calcolatrice è è un server che è uno server stateless ora vediamo di avere qualcosa di statful è quello che andremo a fare è banalmente un fruit shop è un fruit shop che quindi un fruttivendolo che prende gli ordini e fa degli ordini e aggiorna la lista ecco ecco ho già spoilerato la lista cos'è la lista la lista è il magazzino il magazzino io mi aspetto che sia una lista di tuple con il frutto e la quantità quindi quello che faccio sto simulando quello che faccio è mi mi creo allora facciamo quindi non calc new module fruit e quindi devo chiamarlo fruit.erl quindi mi mi mi creo una funzione con clausole perché con clausole perché poi la voglio aggiornare man mano senza far casino quindi cost cost di orange uno due scusate cost di lowquat che sarebbe sarebbero le lenespole questa è una cosa che ho imparato ora in giappone uno e poi cost di qualcosa di indefinito gli do zero no? perché voglio un costo io quindi meno export qualcosa per quello di uno ora vedete perché e poi il mio fruit shop è lo chiamiamo shop scusate allora shop che prende una lista no sto andando troppo cerchiamo di quindi vediamo un attimo vediamo un attimo di di scrivere di vedete questo cosa sto cercando di capire sto cercando di capire questo qual è il tipo di interfaccia che io voglio è a seconda del tipo di interfaccia di nuovo il tipo di messaggi che io voglio ricevere allora di conseguenza scrivo le le API no? quindi un po' come model driven development quindi mdd allora quindi io mi aspetto dei messaggi che mi dicono guarda aggiungi questa questa quantità questo frutto e qualcuno che mi dica quanto costa la spesa quindi qual è lo skeleton del mio shop questo receive add print stop vedete quando io scrivo un server voglio sempre un modo per poterlo stoppare perché altrimenti lui non si stoppa quindi quello che possiamo fare è scusate sì questo va bene punto receive quindi quello che faccio è preparo lo skeleton e qualora io ricevo uno stop ritorno in maniera buona quindi se io ricevo come abbiamo detto add fruit and quantity quello che devo fare è aggiungere aggiungere e aggiungere la quantità quindi aggiungo la quantità al mio storno quindi cosa devo fare siccome è una lista devo iniziare a giocare con le liste quindi vediamo un attimo come l'ho implementata qui allora iniziamo dalla print perché altrimenti qui ok quindi se quello che fa è lists punto for each allora ricordatevi che le liste le funzioni sulle liste come ultimo parametro prendono sempre la lista quindi l che è il mio store e quindi che faccio è una funzione che prende una tubla che è frutta e quantità ok quello che fa è end virgola quindi questo è il primo parametro della for each questo è il secondo io format quello che fa è questo quindi frutta quindi quello che possiamo fare questo frutto sbagliato no di nuovo i qt di nuovo questa roba qui magari questo lo posso ok stringiamo un attimo e la io format prende una lista di parametri qui sto dicendo prendimi il primo parametro qui sto dicendo prendimi il secondo parametro quindi di f virgola q ok end end ok questa dovrebbe andare quindi chiudiamo la clausola questa per ora la commentiamo perché è un caso 8 quindi proviamo a compilare come ho chiamato fruit vediamo quanti errori ho commesso a allora sicuramente questa chiude la questa chiude la questa chiude la end questa chiude questa ok questa roba chiude quest'altra e poi print shop receive vediamo un attimo export ah perché non ho salvato ecco perché no proviamo un attimo cost cost di 1 virgola c'è qualcosa che non lo convince allora lui dice che ecco questo non ci deve stare perché la questo è un refuso questo non ci deve stare il l'ultima clausola del l'ultima clausola del di una receive non deve avere nulla ecco era questo quindi anche questo possiamo toglierlo mi darà un warning però a me non interessa e abbracciamo altrimenti ok però voglio fare un'altra cosa prima voglio fare un'altra cosa voglio fare una funzione populate questa l'abbiamo già vista che mi popola il mio il mio che mi crea una lista di quindi ho orange ho 10 arance e lowquat ne ho 30 populate ok questo va col punto e questo anche esportiamo anche se non c'è bisogno di velo populate no scusate populate di 0 vediamo se va bene ok quindi quello che io faccio ora spawn di fruit virgola shop ora gli dovrei dare una lista come lista gli do come lista gli do la come lista gli do questa fruit populate vediamo se allora questo è il mio server lo chiamo s allora già il fatto che non vediamo roba con error già vuol dire che la spawn è andata a buon fine per ora quindi proviamo a interrogare il mio server gli dico print ok ora mi sono scordato l'accavo quindi qui mettiamo l'accavo e mi sono scordato un'altra cosa quindi mi sono scordato l'accavo e va bene però se io mi sono scordato di fare la chiamata ricorsiva quindi il server è morto allora quello che noi facciamo è quello che noi facciamo qui è chiamare di nuovo il server con in cui passiamo la lista ora badate bene che non lo chiamo shop direttamente lo chiamo col nome totale questo perché ora lo vediamo quindi ricompiliamo liberiamo le variabili quindi free quindi rifacciamo di nuovo la stessa cosa la stessa roba quindi s print ora è formattato in maniera più bella allora facciamo una funzione che mi cambi lo stato del mio server e quindi facciamo una funzione che mi aggiunga una un frutto nuovo quindi add frutto virgola quantiti quindi cosa dobbiamo fare dobbiamo controllare se il frutto esiste se il frutto esiste se il frutto esiste bisogna aumentare la aumentare la quantità altrimenti bisogna aggiungerlo alla lista allora aggiungere la lista è molto banale quindi come facciamo controllare che un frutto sia presente nella lista usiamo il un po' le funzioni sulle liste quindi list di filter quindi cosa faccio io filtro sul frutto quindi gli do il mio store e quello che voglio fare è questo voglio filtrare quindi fan che mi prende la frutta la quantità non mi interessa scusate è così e mi deve ritornare se il frutto è uguale al frutto che io ho quindi stiamo filtrando sulla lista e mi sto dicendo dammi solo gli elementi il cui primo campo è il frutto che io voglio cercare quindi questa F è questo continuo questo messaggio quindi chiamiamolo flag quindi quindi se la lista è vuota vuol dire che il frutto è nuovo quindi se la lista è vuota che devo fare devo ritornare il shop di l più più quindi sto concatenando il frutto e la quantità quindi sto aggiungendo un nuovo elemento sto scoprendo un nuovo elemento cioè se la lista non è vuota bisogna creare una lista in cui solo un elemento cambia quindi cosa possiamo fare possiamo quindi voglio creare una lista quindi uso la la la la la la la la la la la la la la la la la la la la la la la la la la la la la indifferente ovviamente di nuovo la lista che è il mio stato quindi l l è sempre lo stato del mio server quindi sto modificando lo stato del mio server quindi cosa devo fare devo fare questo quindi fun di nuovo anche qui una funzione che mi prende ft e la quantità suggero la quantità mi interessa qt però la chiamo perché altrimenti allora case quindi se la frutta si ft è uguale o uguale alla frutta f allora devo ritornare scusate devo ritornare il frutto con la quantità più la qt altrimenti devo ritornare la tupla iniziale quindi ft e qt and and quindi non vi spaventate cosa sto facendo sto facendo un quindi sto applicando questa funzione la fold mi restituisce una la fold mi restituisce una funzione scusate una lista quindi quello che sto facendo è questo itero su tutta la lista se ora non ricordo bene se la fold l stiamo usando la mappa quindi siamo la mappa quindi essenzialmente stiamo facendo questo ora si può fare o ora lo vediamo in entrambi i modi quindi usiamo la mappa perché la fold e la fold r vogliono un accumulatore quindi noi stiamo usando data una siccome noi non vogliamo creare un aggregato vogliamo creare una lista a partire da una lista quindi quello che vi faccio è una funzione che prende che itera sul dove itera su questo su questi sugli elementi di questa lista e quindi se il frutto è uguale al frutto che voglio aumentare allora mi fa questa roba altrimenti mi restituisce la stessa la stessa tupla quindi vediamo un attimo se prima di tutto se sta roba compila liberiamo tutto mandiamoli pure stop perché voglio ah è unbound va bene quindi sitax error prima di questo perché perché non ho chiuso la clausola ancora ancora qualche errore allora questa roba qui allora vediamo un attimo case forza ecco ho sbagliato tutto quindi era off case il case è sempre così quindi se è true facciamo sta roba qui altrimenti quindi il case in questo me lo dimentico sempre il case prende la condizione e poi i vari match sulla condizione ok ora dovrebbe andare troppi end vediamo un attimo troppo troppo end quest'end mi chiude il case quest'altro end dovrebbe chiudermi la funzione ok allora qual è il problema vediamo un attimo ragazzi perché questo è il bello di questo corso perché continuo a fare gli stessi errori anno per anno in questo modo voi non fate questi errori allora allora case case off true questa roba qui end è anche questo scusate no è anche questo allora questo end chiude il case, questo end chiude la funzione, senza rischi che vedremo l'ignore della legge. ah è questo scusate io mi stavo concentrando su qualcos'altro è questo perché questo è il case questo case e lui dice guarda che manca c'era un errore sintattico prima di questo quindi perché abbiamo giunto un'altra clausola e mancava ancora non gli piace before listful for each ancora non gli piace quindi questa roba chiude questa and e poi di nuovo mi sono scordato perché bisogna chiudere la clausola di questa roba qui ora dovrebbe andare ok ora vediamo che abbiamo combinato ecco ancora abbiamo sbagliato perché ci siamo scordati di mettere il loop quindi shop due punti no shop fruit fruit due punti loop allora questa roba qui va andava messa qui quindi questo andava bene quindi facciamo cerchiamo di fare in maniera un pochino più decente new new list new store uguale a tutta questa roba qui e poi quello che devo fare è shop quindi fruit di shop di new new store new store ecco qua ora questa cioè questa roba qui potevo metterla direttamente nel fruit shop però per separare un po' la roba perché è troppo funzionale poi quando uno inizia ad avere degli errori veramente non capisce nulla quindi ok allora facciamo di nuovo questa roba qui sponiamo il ok che se diciamo print ok allora cerchiamo di capire se questa funzione abbiamo scritto modifica veramente lo stato o no del mio del mio del mio server quindi add proviamo prima il caso il caso banale lowquat e gli mettiamo due oh funziona proviamo il caso difficile no era questo il caso difficile proviamo il caso facile ora lowquat mettiamo le banane quindi banana 20 banane ecco caso facile abbiamo sbagliato quindi c'è qualche problema nel caso vedete che il server stava andando poi abbiamo scelto di aggiungere le banane e adesso ci si sa qualcosa funfile fruitline23 inizia di allora lui dice che c'è un errore nella linea 23 vedete che tutto o atomi o tuple o list di tuple quindi la linea 23 print questa roba qui non gli è piaciuta al perché sicuramente ecco mi sto sorridendo perché vedete lui ha avuto st'errore qui perché lui si aspetta una lista di elementi fatti in tuple e quello che noi abbiamo fatto è abbiamo scordato di mettere il costruttore quindi lui non si è trovato questa roba qui ora il server è morto liberiamo tutto rifacciamo da capo print funziona vedete che fino a quando noi abbiamo scritto abbiamo aggiunto le banane fino a quando a lui gli sembra una operazione consentita quindi abbiamo aggiunto due elementi nella lista piuttosto che un elemento con due sotto elementi quello andava bene poi è la fritch che è fallita non la non la la ad print di nuovo c'è qualcosa che non gli piace ma ho salvato ho compilato no non ho compilato non ho compilato quindi ancora lo stesso problema mannaggia la miseria f quindi c fruit ora print banana print ah finalmente ok qui vediamo due cose uno che va bene due che questo è l'output generato dal server e questo è l'output generato dalla console quindi vedete che siccome siamo in concorrenza le cose si mischiano poi ovviamente non è insensato perché sia il server che il client che sarebbe la console condividono lo stesso output è impensabile che poi noi facciamo stampare a video a un server quello che si fa è ci facciamo ritornare la lista ci facciamo ritornare un messaggio contenente tutto questo che si fa quindi però avete visto che funziona funziona nel momento in cui abbiamo ricompilato quindi abbiamo ricompilato e quindi questo è quanto ora esiste o negli esercizi che ho condiviso abbiamo anche un modo per calcolare il costo di una shopping list quindi quindi quello che vi chiederei è di continuare l'esercizio F trovare un modo per aggiornare in maniera dinamica il costo dei frutti è nel momento in cui vogliamo evadere una vogliamo evadere una una spesa decrementare tutti i decrementare tutte le quantità nella maniera opportuna ora se voi riflettete bene l'operazione di calcolare ok calcolare la spesa calcolare la somma totale di quanto mi costerebbe una spesa è un'operazione tranquilla evadere una spesa bisogna prima controllare che tutta la spesa sia evadibile poi evadere la spesa e poi decrementare tutto vedete che sono che è un'operazione atomica però che noi facciamo in vari passi ecco questo è veramente non è complicato è macchinoso poi vedremo quando vedremo quando arriveremo verso la fine del corso in cui utilizzeremo il database quello che noi facciamo è decrementiamo direttamente e nel momento in cui troviamo un frutto la cui quantità è minore di quella che noi vogliamo facciamo il revertito dell'intera transazione senza fare tre check o trenta check ogni volta va bene questo conclude la lezione sulla concorrenza la prossima lezione parleremo un po' di se avete notato la receive è bloccante parleremo di un modo per rendere non bloccante la receive