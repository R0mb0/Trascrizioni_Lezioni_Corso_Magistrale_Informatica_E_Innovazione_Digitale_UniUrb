buongiorno ragazzi allora oggi parliamo di una cosa di una struttura dati abbastanza importante per erlang io vi ho sempre detto che in erlang tutto è un'espressione ovvero tutto è una funzione quindi non ci sono mai side effects ecco con le tabelle con le tabelle le potete vedere come degli spazi di memoria su cui scrivere e leggere quindi con le tabelle ets e all'anno introduce un modo di avere side effects quindi essenzialmente memoria condivisa stiamo parlando di memoria condivisa allora perché erlang ha deciso di far questo abbiamo sempre parlato del fatto che computazioni distribuite non devono avere a stato perché perché perché lo stato poi difficilmente è difficile da mantenere da replicare e da riportare su quando un server cade però applicazioni distribuite hanno bisogno di se si mette una computazione è una trasformazione di dati in altri dati quindi applicazioni distribuite hanno bisogno di mantenere grossi mole di dati pensiamo ad esempio un'applicazione che mantiene in memoria in cache e la cache aggiornata che invece di fare sempre delle richieste mantiene una cache delle ultime richieste fatte proprio per velocizzare il tutto quindi essenzialmente quello che si fa è di avere delle strutture dati in memoria quindi dalla dal facile accesso quindi dal veloce accesso e erlang quello che ci dà ci dà anche un modo per per interrogare queste strutture dati in maniera in maniera semplice la cosa interessante che tutti i tipi di dati di erlang quindi per aver che sia una funzione che sia una tupla che sia un record vanno nelle tabelle vedremo che poi quello che si va a fare è aggiungere dei record proprio perché poi le le ricerche nei record sono molto più semplici da fare di nuovo le applicazioni distribuite molte integrano dei database non SQL proprio per avere questa capacità di avere una molle di dati assurdi parecchi parliamo degli ordini dei giga e di poterli interrogare in maniera veloce allora quello che quello che è la fa è mettere a disposizione due tipi di tabelle e i secondi tipi li vedremo la prossima lezione sono praticamente un mapping no 1 quindi i primi tipi di tabelle sono le ets i primi tipi sono le ets le ets sono delle tabelle sul disco quindi su memoria persistente c'è praticamente un mapping quasi 1 a 1 tra le ets e le ets ora vedremo che le ets non hanno un tipo di dato che le ets hanno quindi le ets sono erlang term storage quindi sono delle tabelle in ram dovete pensare a questo sono delle tabelle in ram mentre le le dets sono delle tabelle sul disco e sono delle tabelle hanno dei meccanismi tutti loro per essere molto efficienti dal punto di vista di read and write perché ora stiamo parlando di una struttura data in cui tutti possono scrivere o tutti possono leggere e questo tutti lo possiamo decidere come vi ho sempre anticipato erlang mette anche a disposizione un database quindi alla fine quando finiremo quando sviluppremo una applicazione completa distribuita useremo anche il database quindi le tabelle non vanno viste come storage a lungo termine ma vanno viste come qualcosa di temporaneo o di veloce accesso ecco perché poi qualcosa di persistente e magari un pochino più lento quello andrà tutto su amnesia allora come vi dicevo c'è un filo conduttore tra tutto quello che vi ho spiegato finora quindi i record vanno pari pari dentro le tabelle ts e una tabella ts ma anche una tabella dez ma anche lo ripeto una tabella amnesia sono visti come possono essere visti come una lista di quindi una collezione di records e di nuovo i record sono non sono nient'altro che delle tuple speciali il cui primo elemento è il nome della tupla quindi poi vedremo che questo nome abusando un po' della notazione quindi il nome del record che sarebbe il tipo non il tipo della struttura che abbiamo creato diventerà il nome della tabella che sarà su ets che sarà su amnesia allora ora lo vediamo lo vediamo meglio però la le ts sono una strazione sono una strazione di una collezione ordinata e quindi questa collezione che c'è sotto può essere di vari tipi abbiamo quattro tipi di strutture dati sotto sotto le ts abbiamo i set quindi gli insiemi in cui come gli insiemi matematici o algebrici in cui ogni chiave può comparire solo una volta quindi se noi pensiamo a una grafica di studenti la chiave la chiave parlando ora sto parlando proprio di basi dati la chiave primaria è la la matricola perché la matricola identifica unicuvocamente uno studente all'interno dell'ateneo potrebbe anche essere il codice fiscale però se parliamo di matricola non possiamo avere due studenti con la stessa matricola in un set no? come giusto sia oltre ai set abbiamo anche i set ordinati ordinati cosa vuol dire che sono ogni volta che si fa l'inserzione di un nuovo elemento tutta la struttura viene ordinata in maniera decrescente o crescente di quello che questo lo possiamo decidere poi abbiamo i bag quindi sacchi in cui più entità possono avere la stessa chiave ma gli elementi devono essere differenti quindi possiamo avere più elementi con la stessa chiave ma non possiamo aggiungere molteplicità dello stesso elemento questo lo vedremo più avanti sarà più chiaro e poi abbiamo i bug duplicati in cui possiamo avere più elementi con la stessa chiave ma più elementi più duplicati dello stesso elemento ora di tutti questi le dets non ne hanno no le dets sì escludono uno essenzialmente escludono quello che è più difficile da implementare visto che ogni volta che ogni operazione fatta su una dets è un'operazione fatta su disco quindi l'operazione più difficile da fare banalmente è l'ordinamento quindi questo tipo di strutture non saranno quindi quando vi dicevo che c'è un map quasi uno a uno con le dets mi rilisco al fatto che se noi abbiamo una ets ordered set non possiamo avere una dets ordered set perché questo? perché generalmente quando si inserisce un elemento sui file quello che si fa si fa in append si fa in append only e quindi modificare tutta la struttura di un file è veramente complicato cioè si può fare però è un'operazione atomica che comporta troppo tempo allora vediamo subito vediamo subito un attimo pulisco gli occhiali ecco qua scusate vediamo subito come si crea una tabella allora visto che stiamo parlando di ets e visto che Erlang per ogni modulo per ogni sì per ogni componente diciamo crea un modulo allora il modulo da utilizzare guarda caso è il modulo ets allora l'ets quindi Erl ets new quindi con questa la new prende due parametri con questo questa funzione noi creiamo una tabella allora la la cosa fa la la cosa fa la la quali sono i parametri che prende allora prende un atomo che è il nome della il nome della della della tabella che voglio creare quindi e poi prende dei parametri i parametri sono una lista sono una lista quindi se noi creiamo se noi la chiamiamo con i parametri vuoti quello che succede è ci ritorna una lista vedete ci ritorna scusate ci ritorna una una una un riferimento e questo riferimento è il puntatore che utilizzeremo per accedere alla lista allora qui qui c'è un qui c'è un errore qui qui c'è un qui dovrebbe essere lista vuota ora ora correggo le slide non capisco perché c'è scritto 0 pts però è questo quindi se noi diamo se noi la tabella che abbiamo appena creato è di questo tipo quindi se noi diamo le opzioni vuote quello che ci fa lei cioè Erlang ci crea una una tabella set set quindi tutte le chiavi devono essere univoche ci crea la posizione della chiave primaria deve essere il primo campo quindi non possiamo mettere tuple non possiamo mettere tuple che hanno lo stesso campo lo stesso primo campo stiamo dicendo questo e la tabella viene creata in modalità protetta cosa vuol dire modalità protetta? la modalità protetta vuol dire che vediamo prima di sbagliare che il il creatore può può cioè l'unico che può scrivere è il creatore quindi in questo caso l'abbiamo creata sulla sulla shell quindi la shell può scriverla tutti i thread che fanno parte cioè tutti gli attori che fanno parte o che verranno spawnati dalla dalla dalla dalla console possono quindi tutti i figli del proprietario della della tabella possono leggere basta non possono scrivere quindi di default quello che si fa è creare la protetta cosa vuol dire protetto di nuovo? che il proprietario può scrivere e tutti gli altri possono leggere quindi uno può implementare una uno store uno store quindi il fruit shop usando una una una tabella protetta oppure una tabella privata in cui nessuno conosce l'identità di questa tabella nessuno può accedervi se non il suo creatore o public non pubblica quindi tutti possono possono accedere tutti possono scrivere ovviamente se tutti possono scrivere abbiamo un problema di concorrenza quindi se tutti cercano di scrivere lo stesso oggetto poi abbiamo veramente problemi di concorrenza e bisogna sempre coordinarsi allora un'altra cosa importante che mi vedrete fare succede questo se noi creiamo allora qui abbiamo creato una tabella se la console crasha ovviamente la tabella fa parte del suo stato la tabella muore quindi è un errore molto comune creare questo ovviamente non succede se noi scriviamo il programma se noi stiamo eseguendo il programma questo succede da console quello che vi voglio dire è questo che se che se create una tabella e ci state giocando poi succede qualcosa e continuate a giocarci inizierete ad avere degli errori che non esiste più quella tabella perché? perché poi magari durante l'esecuzione la console ha crashato è stata restanziata voi non ve ne accorgete però ha perso tutto il suo stato ecco qua questo è quello che vi stavo dicendo quindi se un attore muore muoiono tutte le tabelle che lui ha creato ovviamente non muoiono i riferimenti quelle tabelle quindi se qualcuno ha un riferimento può accedere però poi succede un caso 8 allora quali sono le altre opzioni che che uno può dare nella lista nella lista nella lista degli attributi che uno vuol dare allora quello che può dare può decidere che tipo di set scusate che tipo di tabella o di struttura dati sottostante vuole utilizzare quindi può dire un set un order set un bag un duplicate bag questo gli può dire quindi questo questo è equivalente a dire set teoricamente vediamo mia tab quindi queste due tabelle sono praticamente uguali dal punto di vista della struttura sottostante ho usato mia tab ora perché a me serve il riferimento se voglio fare dell'operazione di inserzione o di delete posso usare il riferimento oppure posso usare il nome ora lo vediamo meglio un'altra un'altra opzione è keypos keypos vuol dire la posizione della chiave quindi stiamo stiamo parlando di tabelle che memorizzano tuple la keypos la keypos di default è uno però abbiamo visto che se noi vogliamo utilizzare i record la keypos deve essere il secondo campo non il primo perché il primo campo è la cioè se noi utilizziamo il record la keypos deve essere tutto tranne il primo campo perché il primo campo è il nome del record quindi se utilizziamo un set di record e ci scordiamo di cambiare la la keypos allora non riusciremo mai ad inserire più di un elemento ecco qua quindi possiamo decidere se public o private e e possiamo nominare una tabella quindi decidere di darle un nome nel momento in cui le diamo un nome possiamo scordarci di utilizzare il riferimento e utilizzare il nome il nome è un atomo è un po' come i nomi registrati quindi stiamo registrando una tabella con un atomo come quando registriamo i pid con un atomo esattamente quindi allora liberiamo l'ambiente creiamo la tabella questo è inutile no? è ridondante perché è un set chiamiamola mt ricordatevi le variabili vanno sempre maiuscole perché se un letterale inizia con la minuscola è un atomo ok ora possiamo fare possiamo giocare un po' con la tabella allora le prime cose le prime informazioni che possiamo fare è leggere leggere la prima operazione che uno può fare sulla tabella è leggere il tipo di tabella su cui stiamo operando quindi ets info e gli do mt guardate vedete questi sono i questi sono i parametri questi sono i parametri che lui usa di default quindi vedete che è questo è il nome sì il tipo è un set vedete chi possere il primo elemento quindi ora siccome ho creato una tabella di frutti il primo elemento deve essere la chiave del frutto quindi il nome del frutto no? l'owner l'owner che se guardiamo se facciamo self guarda caso è il pid della console perché l'owner è quello che l'ha creato questi sono i flag per la concorrenza questi li vediamo più avanti questo quanto occupa in memoria la dimensione è zero perché ha zero elementi cos'altro è il tipo di protezione quindi il default è protetto quindi se non mettiamo un se non specificiamo delle opzioni creiamo un set protetto e con kipos 1 allora di nuovo la chiave la chiave deve essere interpretata come la chiave primaria di un database quindi state molto attenti a decidere qual è la kipos e ad avere e agire di conseguenza quindi la kipos deve essere univoca allora inseriamo siccome stiamo parlando ho creato una tabella di frutti inseriamo i frutti quindi quello che io posso fare è ah queste sono le potete vedere come delle tabelle hash quindi la kipos è l'indice che mi fa entrare nella tabella quindi io quello che faccio è ets scusate ets uso la protezione insert il primo elemento cioè insert prende due parametri la tabella su cui fare l'operazione è il è il tipo di oggetto che voglio inserire nella tabella allora il nome possiamo dargli o il riferimento o il nome però il nome solo se l'abbiamo creata nominale ora vi spiego noi abbiamo creato qui una tabella l'abbiamo chiamata fruit però questo questo atomo viene buttato perché non ha non l'abbiamo creata named quindi per riferirci alla tabella dobbiamo utilizzare il riferimento quindi mt virgola e inseriamo il frutto range 10 true vedete questo vi dovrebbe avere acceso una lampadina perché quando registriamo quando registriamo un un un un un pid riceviamo true quindi anche i pid i nomi registrati sono registrati in una tabella ets che appartiene al nodo quindi se non vi ricordate register console virgola serzo ad esempio mi restituisce true vuol dire che è andata bene l'inserzione è andata bene allora quindi una volta che ho inserito quindi inseriamo anche ets insert mt virgola banana 20 ora che ho inserito posso fare il look up quindi quello che voglio fare è fare il retrieve delle informazioni quindi ets look up mt sempre il primo il primo elemento è sempre il nome della tabella o il riferimento banana e il look up si fa ovviamente sulla chiave primaria siccome di default qui la chiave primaria la keypos è 1 quindi il primo elemento quindi lui andrà a cercare il record che ha guarda caso mi ritorna quello che io volevo se io voglio le orange ora guardate un po' guardate un po' questo comportamento no ritorna una lista quindi se io cerco qualcosa di sbagliato mt ets luk orange ora ora ora ah scusate perché lui questo l'ha interpretato come un operatore logico io volevo volevo cercare qualcosa che non esiste quindi ora allora vedete che quello che succede ci ritorna una lista perché perché lui siccome la funzione è generica non sa se noi stiamo utilizzando un set o un bag nel momento in cui noi utilizziamo un bag possiamo avere più record che hanno la stessa chiave per cui ritornare una collezione di elementi per Erlang è sempre è sempre come cioè Erlang ritorna sempre una lista quindi state attenti il look up ritorna sempre una lista anche se siamo sicuri che è un solo elemento ritorna una lista quindi per poter utilizzare questo elemento bisogna spacchettarlo come si spacchetta con con del pattern matching quindi nel momento in cui io faccio questa roba qui voglio controllare essenzialmente io quello che devo fare devo fare del pattern matching in cui assegno mio frutto la tail qui che a me non interessa e allora posso utilizzare il mio frutto posso anche essere in questo in questo frangente posso anche essere più più fine quindi so che mi restituisce una tupla quello che posso fare allora facciamo così mio frutto e allora posso utilizzare il mio frutto vedete che è questa roba qui però posso anche essere più fine e fare so che il primo elemento è una no so che ogni elemento di questa lista è un un record scusate una tupla quindi frutto è quantità e posso utilizzare f e posso utilizzare q tranquillamente ok vediamo un attimo di creare un un bug allora qui quando io inserisco allora se io inserisco banana 30 mi da true però quando io vado a cercare le banane essenzialmente cosa fa il bug il bug mi sovrascrive quindi se io vado a cercare le banana ho 30 non ho più 20 quindi ho perso il dato vecchio se io non so perché per vari motivi voglio conservare questo tipo di informazione allora quello che utilizzo è il bug quindi mb mb il mio bug è uguale ets ets new chiamiamo bug ma non ci interessa per ora gli dico che è un bug quindi ets ets insert in questo caso cosa sto facendo sto inserendo e ricordatevi sempre il primo elemento è la tabella mentre nelle liste l'ultimo elemento è sempre nelle funzioni delle liste l'ultimo elemento è sempre la lista su cui fare qualcosa nelle tabelle il primo elemento è sempre il nome o il riferimento a quella tabella quindi mb quello che inseriamo è 1 pippo quindi di default il keypos è il primo elemento quindi io sto sto cercando di quello che io faccio è ritorno aggiungo di nuovo 1 pippo ecco se vi faccio il look up a questo giro di mb virgola 1 quello che tengo è una lista di due elementi scusate mb non dovevo farlo perché mb è la è la mia vediamo se ecco qua ecco qua l'esempio che vi dicevo qui ho sbagliato ad utilizzare di nuovo la stessa variabile quindi ha andato a fare lui pensava di dover fare pattern matching è crashato è crashato è morto sono morte tutte le tabelle quindi quando io ho cercato di fare questa roba qui non esiste più la tabella quindi state molto attenti quando giocate con le tabelle bag vi faccio un'auto liberiamo l'environment f sta per free liberiamo tutte le variabili legate cosa volevo fare io ecco qua allora andiamo un po' la shell quindi mb insert questa roba qui questa roba qui quello che voglio fare è c'è qualcosa non l'ho non l'ho preso bug similar quindi ets ets vediamo un attimo etsinfo ah scusate scusate ho sbagliato non l'ho sbagliato il bug permette duplicazione sulla chiave ma di elementi diversi ecco perché non me lo dà mi devo mettere Pluto quindi ecco qua se noi volessimo duplicare anche l'oggetto dovremmo utilizzare un duplicated bag quindi vedete la differenza tra questo tipo di struttura in cui la chiave primaria può essere replicata il bug però l'oggetto deve essere diverso col set in cui le chiave primarie devono essere tutte univoche allora ora succede qualcosa di strano ora Erlang dà il peggio di se stesso veramente il peggio di se stesso vi dà l'opportunità di iterare iterare su una su una tabella perché perché alla fine la tabella cos'è una lista di record o una lista di two player lui allora perché dà il peggio di sé perché lui vi dà due funzioni la prima per iterare sul primo elemento e la seconda è per iterare sul resto del sul resto della tupla scusate sul resto della struttura e bisogna stare attenti a beccare quest'atomo che indica l'end of file o l'end of l'end of table quindi bisogna veramente stare attenti quindi cerchiamo un attimo di farlo con la console e poi lo facciamo da programmino quindi quello che io faccio è first ets ets first di mb e il primo e questo mi restituisce la prima chiave la prima chiave della della la prima chiave del del del del record e poi bisogna fare il per continuare a iterare bisogna fare il next e bisogna passargli il precedente quindi second quindi second è uguale ets next di mb però bisogna passargli il primo mb e bisogna passargli quello precedente quindi first no scusate dovevo fare allora quindi creiamo una tabella Pluto no creiamo una tabella bug ets ovviamente se noi facciamo se no se no ora facciamo il next il first riciderò direttamente il l'end of ecco qua in first l'end of table vedete perché la tabella è vuota se io vado a fare il next l'end of table becco un errore quindi stiamo molto attenti quindi cosa volevo fare io qui volevo ets insert mb virgola 1 ipo 1 puto 2 paverino ok quindi se io ora chiamo il f perché first l'abbiamo già fatto ora per lui è first f abbiamo 1 poi voglio chiamare il prossimo next in qmb passo f e questo lo chiamo secondo e poi voglio prendere quindi vedete c'è dato il secondo elemento cioè non è il secondo elemento c'è dato la seconda chiave quindi il paverino quindi se io chiamassi ets next su secondo quello che otterrei è end of table ok quindi vedete c'è questo disaccoppiamento tra prendere il primo elemento parliamo di iterazione sulla lista tra prendere il primo elemento e iterare sulla lista allora andiamo un attimo a vedere le scusate scusate un attimo blended andiamo un attimo a vedere il no ecco qui è qui andiamo un attimo a vedere il listing che ho messo sul blended della delle tabelle allora abbiamo sia abbiamo sia un listato sulla grafica che un listato sulla no vabbè possiamo farlo via lo replichiamo quindi l'idea è questa allora questa me la porto questa me la porto qui ok allora l'idea è che io voglio creare un'anagrafica quindi modulo anagrafica no questo era in come si chiama sta roba esempio 2025 ok perl ok lo voglio salvare come anagrafica quindi cosa volevo fare io vediamo un attimo ok vogliamo creare un'anagrafica di fatto di questi in questo modo in cui la prima posizione è la mia kpos ed è la nazionalità quindi italy italy italy ok quindi come sempre mi creo la funzione opulate db che mi serve per creare la mia la mia quindi quello che faccio è italy virgola claudio virgola pros pros quindi sto creando una grafica di persone con nazionalità nome e professione italy marco prof poi japan shoji che è il professore che è il mio ospedente a pone prof poi mettiamo maria no scusate italy maria qualcosa di questo tipo e poi mettiamo musa woofy character actor actor diciamo che pippo è un attore quindi quello che io faccio è mi crea una funzione init che mi crea il mio la mia tabella e ets new quello che voglio fare è questo la chiamo mi faccio dare il nome mi prendo come parametro il nome quindi n la chiamo n qui e siccome io mi sono stancato di utilizzare il riferimento gli dico che è una named table quindi una delle una delle una delle delle opzioni è dire dov'era qui in interna grafica named table che mi dice d'ora in poi invece di utilizzare posso utilizzare il riferimento ma posso utilizzare anche il sono quindi stiamo registrando stiamo registrando la tabella con quel nome e voglio che sia un bag quindi table virgola bag la default keep host position è il 1 quindi barra export mi scusate export no barra punto stiamo esportando ovulate di 0 e init di 1 ora ora abbiamo creata ma io vorrei anche popolarla quello che facciamo è quello che facciamo è iteriamo la lista iteriamo la lista quindi iter uguale cerco di farla in maniera o o full db piccola quindi cosa faccio iterare voglio iterare questa roba qui quello che faccio è una for each lists for each di ricordate bisogna prendere l'iteratore scusate la lista va come ultimo argomento quindi di iter chiamiamolo db altrimenti 1 1 fa confusione db e quello che faccio è una funzione fun che iterà sulla lista e quello che fa è ts insert il nome di i end vediamo un attimo se sono riuscito a fare qualche errore quindi c anagrafica allora c'è qualche modul anagrafica export populate populate db prendi tutto c'è qualcosa che non gli piace sicuramente error anagrafica da 10 1 error eh qui mi sono scordato la virgola infatti troppo ho scritto troppe righe consecutivamente ho fatto troppi errori qui mi sono scordato la freccia quindi state attenti il bello di questo corso è il fatto che io continui a fare gli stessi errori anno per anno allora no no no no no no no no è questo perché questa ci stava già era la virgola perché stiamo sto concatenando più più ecco qua finalmente finalmente un paio di ciufoli cerchiamo di vedere se la roba funziona quindi io voglio fare init anagrafica init anagrafica gli do il nome il nome questo nome viene registrato quindi se io facessi io faccio eccessi info info di anagrafica o funziona perché funziona perché abbiamo inserito 5 elementi 1 2 3 4 5 quindi vedete vedete come tutto inizia ad amalgamarsi in maniera in maniera corretta nel senso che usiamo usiamo delle funzioni che abbiamo visto sulle liste per popolare il database allora quello che volevamo fare è questo vogliamo fare una funzione print che prende il nome della tabella e mi stampa a video la allora cerchiamo di non fare errori quindi quello che io faccio è first ets first dn giusto quindi io format quello che voglio stampare è il primo elemento della lista virgola è il ets lookup di first membro f ora come faccio stampare il seguito lo devo fare con una funzione ricorsiva uno vorrebbe fare un while però è più semplice farlo con una funzione ricorsiva e quindi quello che io faccio è print mi crea una funzione print next next in cui passo il next oh mamma mia in cui passo il nome e gli passo l'iteratore scusate la ripetizione dei nomi ragazzi e quindi mi crea una funzione print next che prende la tabella e mi stampa l'iteratore no prende una tabella e l'iteratore quello che facciamo è questo next uguale a ets inf no ets next di n e i bisogna controllare case next of questa roba complicata che è un atomo dove siamo ecco qua quindi se se siamo alla fine della lista ok punto e virgola perché è altrimenti punto e virgola perché stiamo chiudendo una clausola altrimenti quello che facciamo è questa roba qui ma non di f ma di next next e poi chiamiamo ricorsivamente la print next di di cosa dn virgola ets no next perché poi lui quando sale su la richiama end ok chiudiamo quindi questo end chiude questo case mettiamo il punto per chiudere la funzione allora dovremo print next che prende due e poi print che prende un parametro dovremmo essere a posto print next is unbound qui perché noi stiamo utilizzando le f ok quindi se io chiamassi se io chiamassi print anagrafica print di come lo chiamavo sta roba anagrafica oh mamma mia questo questo l'errore qui è firth c'è scritto firth non first quindi first first quindi compiliamo ora il problema è che non esiste più la se io chiamo ora non esiste più la tabella se io chiamo questo abbiamo un errore quindi bisogna fare di nuovo bisogna fare tutto quindi anagrafica init anagrafica e print di anagrafica ets lookup ets lookup qui c'è qualche problema c'è qualche errore ets lookup a ah ti è su un cappo bisogna dargli bisogna dargli la il nome della tabella su cui riterare tutto sono troppo veloce allora creiamo di nuovo l'anagrafica ok finalmente becchiamo un ok eh questo è un altro errore perché questa roba deve essere la io format prende delle rinforziamo da capo c'è una grafica ok init riusciamo a stamparla non ancora e di nuovo perché qui manca quest'altro diciamo che questa fa parte delle lezioni del laboratorio allora allora init anche qui n o finalmente finalmente finalmente abbiamo fatto qualcosa quindi vedete che in questo modo vedete è veramente strano e complicato iterare però il pattern è questo al di là di tutti gli errori che ho fatto oggi il pattern è questo si itera sul primo e poi si itera ricorsivamente sul sul resto della lista e bisogna controllare sempre che non siamo alla fine perché se siamo alla fine e cerchiamo il e chiamiamo il next sulla tabella scoppia tutto ok allora siccome stiamo parlando di applicazioni concorrenti cosa succede se noi iteriamo quindi abbiamo una tabella abbiamo una tabella pubblica quindi iteriamo e qualcuno ci cambia la la collezione sottostante nel caso di perciò di default è protetta è protetta perché uno può cerca di evitare errori di concorrenza ma anche nel caso in cui sia protetta se uno ha letto quindi sta attraversando la lista e il proprietario della lista la cambia quindi anche nel caso protetto potremmo avere dei problemi di concorrenza quello che si fa se sappiamo che qualcun altro generalmente le tabelle uno le crea private quindi sa che c'è un attore demandato a far tutta quella roba lì se però noi vogliamo usare le tabelle protette o pubbliche e sappiamo che più di uno mi accederà a questa tabella quello che possiamo fare è settare il flag di concorrenza a true in modo tale che anche se se io becco un iteratore quindi se io sto iterando anche se la la la collezione sottostante mi cambia non non avrò dei problemi ovviamente avrò una versione vecchia della list della della collezione su cui sto iterando però va bene va bene lo stesso allora iterare una lista iterare una tabella è veramente abbiamo visto che una volta che uno ha imparato lo schema lo può fare quello che possiamo fare è siccome nella tabella mettiamo dei dei record e siccome possiamo usare pesantemente il pattern matching sui record possiamo creare delle funzioni che ci selezionano tutti per esempio ci selezionano ora parlando della grafica tutte tutte le persone che appartengono a una nazionalità o tutte le persone che hanno un certo tipo di lavoro quello che si fa è utilizzare le funzioni di match di match direttamente sulle tabelle quindi quello che noi vogliamo fare è selezionare tutti gli elementi della mia tabella la cui professione è di un certo tipo quindi quello che noi facciamo è questa la copio per evitare di fare dei casini e ora la commentiamo è di utilizzare la funzione vedete perciò vi dicevo che una volta che uno ha imparato a utilizzare la parte sequenziale tutti i pezzi di Erlang si incastrano si va a scalare quindi abbiamo delle funzioni per utilizzare del match per utilizzare del match su delle tabelle quindi gli diamo il nome la professione e siccome sappiamo che ripeto sappiamo che l'anagrafica è composta da tre elementi da tuple che hanno tre elementi adesso qui nazionalità nome e cognome noi vogliamo selezionare tutti gli elementi che hanno come nazionalità che hanno come professione una professione che gli diamo in input quindi quello che stiamo dicendo è matchami tutti gli elementi della tabella che sono delle triple uno due il cui terzo argomento terzo elemento deve essere esattamente uguale all'input che gli passo e gli altri due a me non interessa cioè non è che interessa li voglio però li lego li lego alla variabile uno e alla variabile due ora vediamo un attimo quindi come si chiama questa roba select profession e prende due argomenti vedete che questa è proprio una select è select asterisco from tabella where profession quindi essenzialmente questa è nient'altro che select asterisco from table where il terzo elemento quindi chiamiamolo chiamiamolo così praticamente questo quello che stiamo facendo quindi io vorrei compilarla e chiamare anagrafica di select profession di anagrafica con actor dovrebbe darmi o scoppia o mi da pippo e poi ho sbagliato poi a scrivere goofy l'ho chiamato goody però va bene lo stesso e se io scrivo prof cosa fa? mi ritorna la chiave e l'elemento su cui ho essenzialmente cosa mi sta ritornando? mi sta ritornando dollar1 e dollar2 non mi sta ritornando la professione però va bene quindi iniziamo a capire come funziona la match quello che uno può fare è scrivere una select invece di usare la match uno può scrivere una select veramente più bella quindi quello che uno fa è scrivere una select utilizzando questo tipo di queering language che è built in in in in erlang allora ora lo scriviamo e poi lo quindi chiamiamolo better select e prendiamo il nome della tabella e la professione quello che facciamo è ora ve lo spiego ragazzi ok quindi quello che voglio fare è uguale uguale dollaro 3 profession e voglio restituire tutto dollaro 1 dollaro 2 e dollaro 3 quindi cosa stiamo facendo stiamo dicendo che la mia tabella io leggo tutti i campi con delle variabili dollaro 1 dollaro 2 questo è un po' simile agli script bash di linux questo è il filtro che voglio applicare quindi mi deve il dollaro 3 che sarebbe la professione deve essere uguale alla professione che gli do in input qui mettiamo il nome della tabella perché te ne metti scoppia tutto e questo è il formato della roba che mi devi restituire allora scherzo in questo modo better selection che prende 2 vediamo un attimo se funziona better select 2 manca il punto manca il punto qui allora questo l'abbiamo visto select profession better select se io chiamassi scrivessi better select vedete che ora mi ritorna più roba praticamente sono uguali quindi la match serve per ritornare diciamo fa una match immediata però se io voglio fare una una select molto più bella quello che faccio è utilizzare invece della match utilizzare la select nell'esempio delle slide voglio matchare voglio ritornare tutti i tutte le tutti i record che non hanno la cui nazionalità è diversa da quella che gli do in input mentre nell'esempio che ho fatto ora run time sto ancora selezionando sulla professione quindi vedete che noi decidiamo il formato state molto attenti allora lui prende questa è una match specification lo vedremo lui prende una lista la match specification è una lista e qui bisogna dirgli il match su cui cioè come scompattare la lista come filtrare gli elementi della lista e cosa voglio ritornare e ritornare vedete qui posso anche invertirli nell'esempio io ritorno ritorno in maniera ordinata quello che c'è nella quello che c'è nella tabella però posso anche invertirli tranquillamente 2 rimane 2 ovviamente e 1 rimane 1 quindi se io ricompilo e chiamo di nuovo better select vedete tra questa chiamata e questa io ho deciso il formato di output che voglio dare e io lo do sotto forma di lista però posso anche decidere di restituire una tupla posso veramente è veramente potente questo meccanismo quindi se io ricompilo e ritorno non gli è piaciuto perché non gli è piaciuto vediamo se il contrario funziona no il contrario non dovrebbe funzionare no perché scusate lui ritorna sempre delle liste scusate questo è un mio errore lui ritorna sempre delle liste poi possiamo immaginare qualcosa su queste liste però lui ritorna sempre delle liste perché lui si si si aspetta una lista di liste per il ritorno quindi possiamo complicare ancora di più possiamo complicare ancora di più il select come in SQL quindi possiamo aggiungere più più clausole di selezione quindi io voglio selezionare su professione e nazionalità quindi quello che voglio fare è questo quindi select nationality quindi come la chiamiamo nationality and profession quindi profession and nationality nationality quello che io voglio fare è questo che in questa lista siccome questa è una lista posso aggiungere più filtri quindi la professione sia questa e che magari la nationality sia diversa diversa quindi usiamo questo quindi la nationality è il secondo no il primo è la chiave quindi voglio selezionare tutti i professionisti di una certa materia che non appartengono che non sono cittadini di una certa nazione quindi tre dovrebbe essere vediamo se c'è una grafica ovviamente qui è cresciato quindi bisogna ricreare tutto infatti quindi e poi anagrafica print vediamo un attimo se abbiamo creato print print normale di anagrafica ok ora quello che voglio fare è selezionare tutti i professori che non sono del giappone quindi dovrebbe ritornarmi questa roba qui quindi anagrafica select np di anagrafica profession abbiamo detto prof e nationalità italia no japan japan abbiamo detto povero shaggy ok qui non gli è piaciuto qualcosa anagrafica questo non gli è piaciuto no allora è questo not uguale andiamo un attimo sì ho sbagliato ho sbagliato ho sbagliato l'operatore l'operatore di not uguale è questo quindi scusate un attimo compiliamo facciamo la la init ecco quindi funziona vedete che è veramente una volta uno capisce come utilizzare il pattern matching capisce come utilizzare i filtri è veramente potentissima questa roba piuttosto che ovviamente io questa me la potevo fare a mano reiterando tutta la lista e filtrando tutto però è veramente complicato invece lo fa lui per noi perché abbiamo visto che è veramente Erlang veramente prono agli errori quindi più semplice dare in pasto a lui la roba piuttosto che farla a noi questo l'abbiamo fatto allora come come come come come vi siete resi conto è veramente scrivere le matching list è veramente un casino veramente complicato allora uno si chiede se esiste un modo più semplice visto che stiamo parlando di linguaggio d'alto livello il linguaggio d'alto livello dovrebbe permettervi di scrivere cose molto semplici con una riga ecco Erlang viene in aiuto ci viene in aiuto e quello che fa è crea ci dà in in dote una funzione che trasforma una funzione in una matching specification questa è una matching specification quindi quello che facciamo è scriviamo una funzione come se fosse il nostro filtro e lui prende e ce la trasforma a matching specification quindi quello che noi facciamo è quello che noi facciamo è questo gli diamo una funzione quindi io voglio una funzione che prende tre parametri quando questi sono i filtri che noi vogliamo applicare quando la nazionalità è il job o quella profession allora mi devi restituire questa roba qui lui se gli diamo in pasto questa roba mi restituisce questo tipo di matching specification questo è le matching specification che dobbiamo usare dentro la funzione allora state molto attenti se io questo lo chiamo da console va bene ecco qua se io lo chiamo da console questo va bene se io lo chiamo da file non va bene perché lui deve avere delle dettive in più quindi bisogna includere questa direttiva questa direttiva un po' come i record no? bisogna includere questa direttiva quindi la includiamo questo è veramente importante ragazzi se non mettete questa direttiva lui davvero si perde allora quello che voglio fare è io my select che prende nome e una professione quindi voglio selezionare tutti quelli che hanno questa professione in Italia quello che faccio è mi crea una matching specification uguale questa roba qui no questa roba qui quindi era ets fun to match specification quindi quello che voglio fare io è questo quindi sto creando una funzione una lambda function questo è come quando noi abbiamo abbiamo definito le funzioni con le clausole quindi creo una funzione ripeto so che gli elementi della mia tabella sono delle delle delle tuple so che sono delle tuple di tre elementi quindi crea una funzione che prende tre elementi che prende una tupla composta da tre elementi e quando la nazionalità è Italia è il job è il job è questo qui job uguale a prof ah scusate qui dovrei fare questo io ok è il job è uguale alla professione alla professione che gli passo in input allora mi devo restituire qualcosa fatto da name e job oppure posso questo vabbè andiamo per gradi altrimenti questo e quindi quello che posso fare è ets scusate questo diamo in un tab perché altrimenti non vedete quello che posso fare è ets select della della funzione scusate della tabella e in cui gli do la matching specification vediamo un attimo se vi piace la mettiamo la mettiamo qui la esportiamo come l'ho chiamata my select di 2 credo ok allora gli diamo una grafica e prof select select quindi allora libraiamo un po' di roba quindi una grafica di init una grafica schiamata troppo troppo lunga questa roba quindi una grafica di my select di tab on prof oh mamma mia select si vede che è tardi allora ho salvato l'ho compilato andefano select select ok dovrebbe andare a buon fine ora ecco qua vedete vedete che è veramente al netto degli errori di sintassi veramente potentissima questa roba perché ho un modo di crearmi delle matching specification in maniera ad alto livello gliele passo in pasto alla select e la select mi fa questa roba qui qui abbiamo fatto una select se noi volessimo abbiamo fatto select select from n when n punto n punto nation uguale a italy and and n punto job è uguale è uguale a prof profession quindi cosa abbiamo detto noi abbiamo creato veramente questo select n punto name e n punto job from n ecco questa è la query questa è la query corrispondente a questa roba qui e l'abbiamo fatta in una riga di codice nota bene qual è la la la la la la la la la la la la la la la la la la la la la la la la la la è fatto non c'è bisogno di interfacciarsi con database io non sto utilizzando un un driver questa è una funzione built in sto utilizzando delle tabelle che sono fornite gratuitamente da erlang le posso interrogare con delle funzioni con delle funzioni lambda che io ho scritto e la cosa più importante è che non c'è il mismatch di dati perché tutto quello che io metto nel mio database su tutti i dati che io posso utilizzare sono dati nativi di erlang quindi probabilmente potrei anche infilare in una tabella una una una funzione e lui se la prenderebbe ok quindi ci sono vari esempi continuate a a vederli usare il match object quindi che ci ritorna tutti gli oggetti che matchano quella roba lì quindi anche qui invece di scrivere se io dovesse scrivere una select complessa cioè una select se io dovesse scrivere questo in una select sarebbe più è più semplice scriverlo come come un match object quindi gli dico ritornami tutti i campi di tutti gli oggetti che la cui professione è questa roba qui quindi lo possiamo fare direttamente da console invece invece di scrivere una ripeto invece di scrivere una una select fatta in maniera un po' complicata se io dovesse se io devo fare una select veramente semplice quello che posso fare è utilizzare la match object e quello che fa la match object è prende una tabella quindi mi filtra una tabella su un particolare match e la tabella è la mia no l'ho chiamata tab e quello che io voglio dire è ritornami tutto quindi un due tre il cui il cui terzo campo è l'atomo prof quindi vedete mi ritorna tutto è un pochino diverso rispetto a fare la la match perché la match mi ritornava solo i due elementi se io voglio ritornare tutti gli elementi della della tabella quello che faccio è questa roba qui e posso anche essere più più certosino quindi qui posso dire italy dammi tutti i professori italiani oppure qui lasciarlo indefinito no scusate qui lasciarlo ah vedete che queste sono delle variabili però per lui sono delle variabili di uno scripting language però devono essere degli atomi quindi vanno sempre messe tra abigetti quindi posso anche continuare dimmi davanti ecco qua quindi vedete che questo pacchetto questo questo questo modulo è veramente potente vi permette di costruire un'applicazione distribuita che utilizza delle tabelle in memoria e sono veramente facili da accedere da interrogare quello che io vi sorto a fare è giocate un po' con queste select con la match con la match object con le varie cose giocate un po' provate a fare il fruit shop invece che con le che con le liste di farlo con le tabelle e ci vediamo alla prossima lezione in cui parleremo di deaths che essenzialmente sono le ets però le possiamo salvare su disco una dimenticato e che si avviene il si avviene all' v vitamins vediamo i v im i i su i i