ok buongiorno ragazzi allora continuiamo a parlare di ovviamente di erlang e oggi parleremo di distribuzione come come vi ho sempre detto il concetto di distribuzione è nativo in erlang e quindi ci sono delle primitive ad hoc per fare distribuzione e come vi ho sempre detto se uno impara a programmare bene in sequenziale allora in concorrenza andare in paralleli quindi andare in concorrenza è veramente semplice e allo stesso motivo andare in distribuito è veramente semplice quindi questa è la vera caratteristica di erlang che poi può scalare lo stesso codice può scalare quindi possiamo replicarlo sulla stessa macchina oppure andare su macchine diverse basta solo cambiare un parametro ad una procedura ecco quindi vi dicevo che come vi ho sempre detto erlang è stato concepito sin dall'inizio con l'idea di avere la distribuzione in mente e quindi qualsiasi codice che uno scrive a patto che funzioni può essere eseguito su una macchina in maniera singola sulla stessa macchina varie istanze quindi quelle spawn normali oppure su vari su vari nodi su una stessa rete oppure su vari nodi su reti diverse erlang vi permette di fare tutto questo solo cambiando un parametro o un paio di parametri alla banalmente alle spawn perché finora abbiamo visto la spawn 1 la spawn 3 vi ricordate la spawn 1 spawna una funzione una funzione lambda no quindi rifacciamo un attimo e erl quindi abbiamo detto che la spawn 1 che è questa che quello che fa è spawna una funzione lambda quindi mandiamo a facciamo una cosa semplice pid uguale a sul piano console uguale a self quindi ci ci ci teniamo il pid della della console quindi facciamo spawn di una funzione che che non fa altro che mandare alla console un messaggio quindi console ciao e scriviamo il pid di chi ha mandato il messaggio end quindi siccome il pid dell'oggetto spawnato è 87 ci dovremmo aspettare flash un messaggio ciao da da questo qui esattamente questo quindi questa la spawn 1 se vogliamo e la spawn 3 era nome modulo funzione e parametri parametri no non l'abbiamo visto più nei codici e quindi ricordatevi che i parametri da passare a una spawn vanno sempre hanno sempre in una lista quindi qual è la qual è la vediamo un attimo cosa dico nella slide poi cerchiamo di andare avanti però l'idea è questa che invece della spawn 1 utilizzeremo la spawn 2 invece della spawn 2 utilizzeremo la spawn 4 perché aggiungiamo un parametro e questo parametro cos'è? e questo è il nome del nodo su cui noi vogliamo andare a fare delle operazioni ecco qui quindi erlang ha un modo tutto suo di creare i nodi quando noi creiamo quando noi lanciamo il comando erl quello che la virtual machine fa è creare quindi la beam machine fa è creare un nodo isolato quindi se io ora anticipando un po' la roba se io faccio nodes ecco qua crea un nodo locale che chiama nonod quindi nessun nodo at et nonost quindi vedete che iniziamo a prendere dimestichezza con questa terminologia i nodi hanno un nome ad un host quindi essenzialmente un atomo registrato da qualche parte ad un particolare ip quindi un nodo erlang è un ambiente che esegue un runtime di erlang quindi potete vederlo potete vedere un nodo erlang come un docker un'istanza di docker che esegue la nostra virtual machine e la cosa interessante che di nuovo usando l'analogia di docker è che più nodi possono coesistere sulla stessa macchina quindi possiamo simulare un'applicazione distribuita sulla stessa macchina poi questo codice funzionerà anche nel mondo reale quindi quando andremo a distribuire veramente questa applicazione allora come facciamo a dargli un nome? banalmente meno sname pippo guardate che mi ha creato ora mi ha dato un nome quindi ora lui ha capito che lui ha capito che doveva creare un nodo con un nome generalmente si usa l'opzione dove è? si usa l'opzione meno sname per short name il mio consiglio è di usare sempre gli sname e non i name perché i name dovreste dovreste utilizzare l'ip e questo crea un po' di complicazioni ecco qua quindi creiamo un nodo ora l'ho chiamato pippo meno male sono consistente con le cose quindi l'idea è che quando lanciamo il comando erlang lo lanciamo col comando meno sname ora tutti i programmi che abbiamo scritti nel sequenziale continuano a funzionare però è come se ora appartenessero al nodo pippo ora per capire un nodo per capire un po' come il surf se un nodo vuol capire qual è il suo nome deve utilizzare la funzione nod e questo è il mio nodo pippo at macbook vedete che il nodo è un atomo quindi viene messo tra apici quindi ricordatevi gli atomi vanno messi tra apici singoli non è una stringa è un atomo allora questo vi dicevo prima la spawn1 e la spawn3 funzionano nel locale quello che noi vogliamo fare ora è andare nel distribuito quindi usare la spawn2 e la spawn4 la spawn2 cos'è? la spawn1 in cui il secondo parametro è il nome del nodo dove voglio andare a istanziare una funzione la spawn4 è la spawn3 in cui l'ulteriore parametro quindi l'ultimo parametro è di nuovo il nodo su cui voglio voglio spawnare una funzione ora quello che succederà è che quando creiamo la spawn2 quando chiamiamo la spawn2 e la spawn4 ci viene restituito un pid remoto quindi un pid che fa riferimento ad un altro nodo quindi questo era un po' l'esempio che facevamo prima quindi se io se noi lanciamo la spawn1 che rimane in attesa di un messaggio e poi ci dice bye dal nodo quindi proviamo a farla quindi quello che facciamo noi è ora siamo su questo nodo sì perché manca manca la chiusura no cerchiamo di farla in maniera decente end end ok quindi vedete che questo è un pid locale perché inizia con 0 se io faccio flash no se io mando a questa roba qui quindi pid di 0 95 e 0 dovevo salvarmi il pid gli mando ciao da self lui mi restituisce flash lui mi restituisce buy dal nodo dal nodo in cui sta eseguendo ora facciamo una cosa creiamo creiamo un'altra shell nod erl meno sname pluto pluto questo è pippo no pippo pluto ok quindi quello che io devo fare nod quello che io devo fare è questo copiamo quindi quello che io devo fare è no pippo quello che io devo fare è questo pid però lo chiamiamo pid remoto magari ok pid r quindi invece di usare la spawn 1 utilizzo la spawn 2 e vediamo cosa succede è il contrario ragazzi è il contrario bisogna mandare il secondo il primo parametro è sempre il nodo su cui vogliamo andare a a mandare su cui vogliamo onare una funzione quindi questo infatti lui mi ha detto che il primo il primo elemento non è un atomo quindi lui voleva il primo elemento un atomo allora quello che facciamo è questo ora pid allora facciamo una cosa liberiamo l'ambiente quello che noi vogliamo fare è questa roba qui quindi il primo parametro è sempre il nodo se vogliamo andare a spawnare la roba ok vedete vedete che ci ha ritornato un pid questo questo è un pid remoto perché remoto perché inizia con un numero diverso da zero quindi esiste questo pid remoto quindi qui dentro dovremmo avere una dovremmo poter essere in grado di vedere un processo che sta facendo che sta aspettando un messaggio quindi se io vado a vedere yes se io vado a vedere yes dovrebbe essere uno degli ultimi eccola qua questo è il mio processo questo è il processo che qui siamo su su su su Pluto quindi vedete che esiste un attore che è in attesa di avere una Resive 2 no 96 vediamo un attimo se vedete vedete 96 è proprio il pid di riferimento a questo processo ora invece di perderci in chiacchiere quello che facciamo è pid r gli mandiamo un ciao di self vedete vedete ora una cosa strana self restituisce un pid locale però quando noi andiamo vediamo un attimo se funziona quando noi andiamo a quando noi andiamo a mandare un messaggio lui prende questo pid locale capisce capisce che lo deve mandare altrove quindi lo trasforma in un pid globale quindi vedete ora abbiamo ricevuto da da da Pluto da Pluto quindi dalla seconda shell abbiamo ricevuto da Pluto il il il messaggio di risposta quindi avete visto che lo stesso lo stesso esempio dal locale si può mandare in globale utilizzando un parametro in più e questo parametro è il primo prima ho detto una cosa sbagliata è il primo è il primo è il nome del nodo come vi dicevo vi rendete subito conto un pid locale inizia con 0 mentre un pid globale inizia con un il primo numero non è il numero 0 ma è il numero alto quindi quello allora tornando a cosa sono i pid i pid sono delle triplette in cui il primo numero indica il nodo il secondo numero indica diciamo è un è un è un è un è un contatore che ti dice quanti processi sono stati creati finora e il terzo è è l'istanza di quel particolare processo quindi questa è l'istanza cioè sarebbe la prima istanza quindi l'istanza 0 poi Erlang ci dà tante tante altre funzioni o funzioni per vedere se un nodo è vivo o meno oppure per testare il fatto che un nodo è vivo quindi per esempio se noi usiamo Erlang is alive ci dice se il sistema Erlang in quel particolare nodo è vivo o meno ovviamente due nodi per comunicarsi devono essere alive se un nodo è morto non riescono a comunicarsi allora però questa cosa no il fatto che noi abbiamo diversi nodi e questi nodi magari non si conoscono ecco una cosa che mi sono dimenticato di dirvi è node ci dà il ci dà il la lista ci dà il nome del nostro nodo nodes ci dà la lista dei nodi che un nodo conosce quando due nodi vengono in contatto quello che fanno si scambiano la lista dei nodi quindi per esempio qui ora se noi facciamo nodes vediamo che c'è pippo ora creiamo un terzo nodo creiamo un terzo nodo erl erl meno s name donald e quello che facciamo è donald manda qualcosa a no facciamo così che di nuovo questo qui invece di mandare a pluto manda a donald di qui scriviamo donald slash no slash id di ciao non serve ora se io faccio nodes vediamo che la lista dei nodi è aumentata però la cosa la cosa è interessante che vedete donald al tempo zero non conosceva nessuno nel momento in cui è stato contattato da da pluto da chi era da pippo cosa fa conosce tutti i nodi che che pippo conosce quindi essenzialmente cosa fa pippo gli manda tutti i suoi nodi e di conseguenza anche pluto gli manda i suoi nodi però essendo la lista vuota gli manda la lista vuota e nulla quindi cosa vi sto cercando di dire è che se due nodi se abbiamo una un'applicazione distribuita fatta ad albero in cui due nodi comunicano quelli di sotto quindi conoscono tutti i loro i loro sottoposti nel momento in cui questi due nodi diciamo le due radici comunicano tra di loro si scambiano tutti i nodi che conoscono quindi alla fine quello che si ottiene è un grafo fortemente connesso quindi una full mesh di tutti i nodi con tutti i nodi questo a volte può portare anche delle dei rallentamenti no perché il fatto di avere una full mesh vuol dire che tutti i nodi sono connessi con tutti cosa vuol dire che ci sono n a quadrato connessioni TCP Erlang ha un modo per limitare il numero di nodi che vengono scambiati ogni volta che si fa discovery ora lo vediamo tornando a noi quello che volevo dirvi è questo che è essenzialmente un po' strano che un nodo ad un certo punto può comunicare con tutti quello che si fa è che si crea una password quindi quello che quello che fa Erlang è ci dà un piccolo meccanismo di sicurezza cos'è la password di nuovo un atomo quindi chiunque abbia quella password può comunicare con me quel cookie altrimenti no quindi ammazziamo tutto ok quindi meno set cookie basta e set cookie ok quindi questo meno set cookie basta e quest'altro non gli diamo il cookie quindi nel momento in cui nel momento in cui no Donald esatto proviamo a mandare qualcosa a Donald vedete Donald ci ha rifiutato la connessione perché Donald non ha il nostro non ha il nostro stesso cookie mentre se noi se noi facciamo la stessa roba con Pluto quindi Donald mettiamo qui Pluto PID P di Pluto lui me l'ha accettata e vediamo vediamo qui che sempre da Donald dalla console ci dice guardate c'è stato un attempt quindi un tentativo di connessione da parte di un nodo però è stato è stato rigettato perché la challenge nel senso dammi il cookie rispondimi con lo stesso cookie non andò da buon fine allora abbiamo visto la spawn 2 la spawn 4 è banalmente la spawn 3 in cui il primo parametro è il nome del nodo ovviamente bisogna fare un bisogna fare un un distinguo qui allora affinché i nodi funzionino in maniera corretta devono avere la stessa distribuzione di Erlang inoltre affinché finquanto noi cerchiamo di invocare delle librie standard di Erlang va tutto bene se noi vogliamo invocare pezzi di codici nostro da un'altra applicazione da un altro nodo quello che si deve fare è che tutti nodi allora qual è la la prassi la prassi è questa che tutti i nodi devono avere la stessa versione di Erlang è la stessa baseline di codice quindi lo stesso codice quindi se noi vogliamo invocare il modulo m la funzione f con i parametri p in un nodo questo nodo deve avere quel codice deve avere il codice corrispondente al modulo f al modulo m la funzione f e la parametri c'è bisogno quindi quello che vi sto cercando di dire è che prima di avviare la nostra applicazione copiamo lo stesso codice su tutti i vari nodi quindi su tutti i vari computer la cosa più semplice è avere un git repository quindi fare il check out di tutti cioè su ogni macchina fare il check out dello stesso codice e poi lanciare dallo stesso dallo stesso folder varie istanze no? ovviamente essendo suddistribuito possiamo anche fare il ping il ping di un nodo per vedere se il nodo esiste o meno noi intrinsecamente l'abbiamo già fatto al momento in cui gli facciamo una spawn prima di fare la spawn lui fa un ping ecco perché poi nel momento in cui un nodo riceve un ping questo lo può accettare e quindi può farsi scoprire o lo può rifiutare come vi dicevo nod ci dà l'automo del nome del nodo nod ci dà la lista dei nodi conosciuti ovviamente queste liste più i nodi conoscono la cosa bella è questa che i nodi possono essere scoperti a runtime nel momento in cui vengono scoperti a runtime tutti i nodi si conoscono quindi se noi avessimo un triangolo il nodo A comunica con il nodo B il nodo A comunica con il nodo A comunica con il nodo B nel momento in cui il nodo A il nodo C comunica con uno di questi due allora si crea si creano tutte le connessioni per evitare per evitare il fatto di per evitare il fatto di avere troppe connessioni quindi se noi abbiamo dieci nodi avremo dieci alla dieci connessioni no? perché tutti sono collegati con tutti allora possiamo anche limitare il numero di connessioni quindi possiamo anche settare il flag connect all false quindi di default non mi devo connettere con nessuno come vi dicevo i nodi vengono condivisi e allora un nodo può evitare di connettarsi con tutti col flag oppure qual è l'idea? l'idea è questa è che si possono utilizzare si possono utilizzare dei nodi nascosti quindi avere dei nodi proxy che che per definizione si fanno conoscere e tutti i nodi sotto questo proxy non devono essere conosciuti quindi essenzialmente vengono dichiarati come come nodi come nodi nascosti in questo modo nessuno può scoprirli ovviamente il proxy li conosce e si può e può utilizzarli ovviamente quello che noi andremo nel progetto nella piccola applicazione che farete non c'è bisogno di nascondere i nodi però se siete interessati a questo aspetto di Erlang vi esorto ad andare a controllare la documentazione o anche il libro in cui viene spiegato veramente bene come questo succede esattamente questo è un esempio del libro di Cesarini in cui si vede come i nodi vengono connessi o non connessi quindi fare una ping a un nodo oppure connettersi a un nodo è essenzialmente la stessa perché per fare la ping o per fare la connessione bisogna sempre aprire una connessione TCP con il nodo quindi è praticamente uguale inoltre se siete interessati alla parte networking di Erlang esistono due moduli netkernel e netadmin che vi permette veramente di sperimentare la fase di networking di Erlang ovviamente Erlang da l'astrazione degli attori dei PID ma tutto è fatto su dei socket perché due macchine internet è fatto con i socket quindi due macchine comuni tra di loro utilizzando i socket quindi quindi quello che vi vi lascio di fare è provare qualche esempio che voi avete per prendere i vecchi esempi che abbiamo fatto di di spawn 1 spawn 3 magari prendete lo shop il fruit shop e lo lanciate su una lo lanciate in maniera distribuita quindi lanciate lo shop su un nodo e interagite con lo shop quindi il client interagisce da un altro nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo su un nodo