ok salve ragazzi allora continuiamo a parlare di tabelle ets quindi abbiamo visto questo meccanismo veramente potente di erlang di gestire enormi moli di dati va bene io nella lezione precedente ho fatto degli esempi veramente banali però potete veramente caricare un milione due milioni di entry e le prestazioni non decadono quindi è veramente so veramente pensate queste tabelle per processare dati in memoria in maniera ottimale oggi vediamo un attimo le le ds che sono essenzialmente le ets on disk quindi disk ets quindi tabelle ets salvato sul disco però prima parliamo un po della della della relazione di come poter utilizzare i record i record con le tabelle abbiamo visto che le tabelle sono possono essere viste come una lista di tuple oggi vedremo come le tabelle possono essere viste come una lista di record perché i record sono banalmente delle tuple speciali il cui primo elemento è il nome del tipo noi il nome della tupla il nome del tipo del record stessa per ora ora lo vediamo allora ovviamente erlang è un linguaggio ad alto livello quindi vi permette di salvare sul disco e di importare da disco delle tabelle quindi ets se voi andate a vedere io vi ho eserciato sempre per ogni modulo che noi vedremo di andare a controllare la documentazione sul man quindi voi andate a vedere il man abbiamo due funzioni tab to file che prende una tabella e la trasforma in un file e che prende il nome della tabella il nome della tabella o la referenza della tabella e gli ritorniamo in il ritmo il pat il pat è una stringa quindi e lo salva e poi carica questa tabella dalla dal dal dal dal dal dal dal dal dal da da disco quindi con la funzione file to tab in trasforma un file in una tabella ovviamente se la tabella è corrotta lui ha problemi quindi vi darà error e rison un'altra un'altra cosa importante da ricordare che quando voi caricate una tabella e anche se voi l'avevate salvata e questa tabella era nominata quindi aveva un nome quando voi la caricate non mi può dare il nome il sistema vi dà una una referenza e quindi da da in poi dovrete utilizzare la referenza quindi state veramente attenti poi per rimarcare il fatto che le tabelle sono delle liste abbiamo una funzione che presa una tabella di ritorna la lista poi abbiamo questo etsi per dare l'informazione su tutte le tabelle registrate su tutte le tabelle che esistono nell'ecosistema quindi per esempio chiudiamo qui per sto avviando un nodo già vi sto facendo uno spoiler visto avviando un nodo locale erlang vediamo un attimo se io faccio etsi vedete quante tabelle nominate nominali o quante tabelle e quante referenze esistono erlang quando sa quando avvia quando avvia tutti i suoi demoni e registra tutte queste tabelle per per indicare proprio il fatto che erlang utilizza i suoi strumenti stessi per autoregolarsi allora di nuovo vi ricordate che quando dovreste ricordarvi che quando creiamo una tabella è senza indicare la posizione della chiave lui di default prende la chiave la prima posizione però qual è il problema il problema è questo guardate prendiamo questo questa definizione di record qui stiamo agendo a livello di console quindi se io se io definisco questo record che ne ho definito un record di tipo persona lo creo guardate che è anche il costruttore dovrebbe darvi un'indicazione del fatto che il record nient'altro che una una tupla speciale person devo stare attento perché ogni volta faccio errori di questo tipo allora name uguale audio age uguale spoiler 42 on uguale a una stringa 0 0 0 1 e non metto la strada perché prenderà il valore di default quindi cosa facciamo assegniamo questa questa questo record a una variabile quindi io la chiamerò v vedete lui ci ha creato questo record quindi se io chiamo v mi riterranea questo record però se io vado a stampare questo record con io format effettivamente io format stampa la rappresentazione di questo record essenzialmente un to string quindi se io faccio il dp e gli dico stampami v cosa abbiamo ottenuto una tupla una tupla il cui primo elemento una persona quindi capite se noi creiamo una un ets con un ets di di record persona person non possiamo dire di indicizzarla sul primo sul primo campo perché il primo campo è il tipo della tu del del record e tutti avranno lo stesso campo quindi non è una chiave primaria quindi bisogna creare una bisogna di egli a erlang di indicizzare la tabella in un campo diverso da un come si fa si fa dando quest'ulteriore parametro alla creazione dei dei della della tabella quindi creiamo una tabella agenda la registriamo quindi diciamo che d'ora in poi vogliamo riferirci a questa tabella col nome agenda e vedete la chi posizione quindi usiamo come chiave primaria la il nome della della della della persona quindi se io faccio se io copio questa roba per il rischio a copiarlo perché attività ti faccio un casino di errori di battitura past ecco qua ora e se io faccio ets info di agenda vedete che vedete che dove dove dove dove che una tabella nominata questo l'abbiamo visto e che la key position è eccola qua quindi un tipo set perché di default per lui prende set e la che posizione è 2 quindi io posso fare vi ricordate avevo creato questa roba qui posso fare ets insert insert v che è il riprodurre ricordate che il primo parametro io non lo ricordo mai il primo parametro della di tutte le operazioni su ets e il nome della tabella ora è morto tutto non esiste più la tabella quindi se io se io chiamassi questo è undefined quindi di nuovo creiamo questa roba qui liberiamo le variabili ets info agenda esiste creo creo creo creo il record questa roba qui ets insert di agenda eccola v true quindi true vuol dire che l'ha inserita vuol dire che non esisteva nessuna chiave con quella roba lì e se io faccio ets look up look up look up di claudio perché ricordiamo che il la chiave primaria è il nome mi dovrebbe ritornare porca caccia la miseria miseria miseria miseria caccia allora mi sono scordato di nuovo il nome della della tabella però ora è morta quindi rifacciamo da capo infatti è un andefined e creo questa insert ets look up via agenda virgola virgola e vovo no vo claudio e ora dovrebbe a finalmente finalmente siamo riusciti a fare una sequenza di comandi senza dare errori quindi vedete anche questa cosa qui che è siccome la shell crea la tabella quando la shell muore tutto lo stato muore allora quindi ricordatevi che se noi stia se noi usiamo i record in in shell bisogna caricarli in memoria perché lui non riesce a capire di cosa vogliamo parlare mentre se usiamo dei record in in da file bisogna utilizzare questa direttiva ricordatevi che tutte le direttive al compilatore iniziano con meno quindi per esempio qui io mi sono creato record persona quello che abbiamo fatto alla all in console inoltre ho inserito questo questo questo se vi ricordate è necessario per utilizzare le match specification quindi qui le sto utilizzando ecco qua per esempio possiamo abbiamo già visto possiamo aggiungere una persona a una tabella cioè aggiungere un nuovo record a la tabella facendo essenzialmente questa roba qui inoltre possiamo utilizzare le stesse funzioni che abbiamo visto la volta scorsa la match object però questa volta la cosa bella è che possiamo direttamente utilizzare il costruttore quindi io dico tornami tutti ritornami tutti gli oggetti di tipo persona il cui nome è uguale al nome che gli do in input il resto non importa perché io voglio matchare tutta la roba che è uguale al primo campo un pochino come quando facevamo la volta scorsa ritornami tutte le tutte le persone che sono di nazionalità italiana no? e inoltre posso anche utilizzare delle matching specification vedete che è molto molto potente ora la roba di inizia diventa veramente potente perché io gli dico va bene voglio una matching specification che mi prende una persona il cui nome è uguale a allora il nome io lo sto legando questo è veramente potente io il nome lo sto legando a n è un po' come quando utilizzavamo i dollari il nome di telefono lo sto legando a p e p deve essere uguale al numero che gli passo in input quindi se io compilo cccc tab ok ora la cosa bella è che lui ha già in memoria l'agenda che gli ho dato quindi se io faccio cc tab tab quindi devo trovare una persona che ha un numero in particolare quindi di agenda e guarda caso voglio trovare chi ha il numero 00 01 allora lui dovrebbe darmi Claudio quindi dovrebbe darmi la chiave che è Claudio e così via quindi potete veramente sbizzarrirvi potete veramente sbizzarrirvi e creare dei pattern veramente dei filtri o delle look up veramente complicate a partire da c'è in una semplice riga e qui è veramente come vi dicevo veramente potente il meccanismo perché noi mettiamo cioè se io vogessi filtrare su un unico campo quello che si fa è il campo iesimo deve avere questo valore tutto il resto non importa quindi questo invece di se noi utilizzassimo delle tuple normali dovremmo dire tutto il resto non importa quindi questo invece di se noi utilizzassimo delle tuple normali dovremmo dire tutti i campi fino alla fine qui questo l'abbiamo visto quindi si possono utilizzare delle match specification allora questa è una cosa importante e questa è una cosa che va verso il cloud perché Erlang vi permette di visualizzare tutto quello che succede nella vi da una console ma non una console tipo linea di comando vi da proprio un pannello di controllo quindi observer start quindi io sto chiamando l'oggetto scusate l'attore observer start tra le varie cose che poi io vi esorto a giocare un po' con questa roba quello che potete vedere è tableviewer vedete tutte le tabelle utilizzate dall'ecosistema tutte le tabelle non private e guarda caso c'è agenda che abbiamo inserito noi ora siccome l'agenda di default è protected l'ho chiuso male scusate è crashata la va bene c tab è crashata la la la solo side observer stiamo parlando di observer There di star allora quello che volevo dire vi è questo che qui vediamo le tabelle ora ovviamente è morto tutto quindi non vedremo più io voglio creare una tabella e ts la chiamo prova allora bisogna stare attenti quindi named table e la voglio public la voglio public ora se io refrescio questa roba qui esiste prova quindi forse la faccio ets insert ora non sto utilizzando record e faccio una cosa veramente prova di eccola allora uno ciao tipo qualcosa di questo tipo e vado a vedere prova c'è la roba che io ho inserito e siccome l'ho creata pubblica quindi vuol dire che tutti possono scriverci anche l'observer ci può accedere ovviamente lo serve si può accedere perché di default è privato e protected quindi pippo a me non piace pippo gli dico pluto e quindi se io facessi ets lookup di prova virgola 1 perché di default la key position è 1 è diventato pluto mentre prima l'avevo inserito come pippo perché perché attraverso l'observer lo posso cambiare posso anche cambiare la chiave primaria se io facessi 2 ecco siccome che ho cambiato la chiave primaria mi ha creato una copia con la chiave primaria 2 e quindi se io prova 1 non non esiste prova 2 ecco ecco mi sono scordato di dirvi l'altra volta che ets delete utilizzando la chiave primaria quindi 2 io cancello mi mi sono scordato di dargli di dargli la prova però ora non funziona più perché è morto vabbè comunque in questo modo si fa la delete allora l'observer lo stavamo di ne stavamo parlando tableviewer questo questo potete sbizzarri a giocare con la record persona però ricordatevi che di default è protetta quindi se volete visualizzare cambiare i dati dal cioè visualizzare si può fare perché protetta cambiare i dati dall'observer dovete crearla pubblica ecco questo questo lo possiamo fare perché di nuovo ets no tab init di agenda io mi ero creato questa questa funzione quindi essenzialmente sto chiamando questa funzione init e mi crea un name table con keypos persona name persona name e questa roba qui poi chiamo una funzione siccome continuo a fare errori ets no ets tab insert ad person su agenda audio claudio claudio claudio poi devo dare un nome un age 42 e un phone 00 001 non gli è piaciuto perché insert agenda persone grazie uno street ah perché non esisteva agenda io ho fatto init agenda però non gli è piaciuto perché dovevo caricare in memoria la roba quindi c tab facciamo questa roba qui init agenda agenda c'è quindi ad person ecco ragazzi è tardi eh sono stanco però quello che sto sbagliando è di sto sbagliando a dare il nome agenda no agenda ecco qua scusate quindi se io vado a vedere nel table miseria sto table di volta crash allora l c pub pub int agenda poi tab insert ad person di agenda il claudio virgola 42 virgola 001 vediamo che riusciamo a fare questa roba qui observer start questo per dirvi che di nuovo conferma del fatto che vedete il primo campo è il nome della persona cioè il nome del record quindi di nuovo insisto su questo fatto la key post non può essere il primo campo deve essere tutto tranne il primo e continua a crescere questo è un problema del porting su mac va bene cancel allora al di là dei vari crash dove eravamo ecco qua ovviamente se la shell crea l'observer poi la shell crasha l'observer viene proprio staccato quindi dovete stare anche qui attenti a non far crashare la shell va bene ora parliamo di tabelle su disco abbiamo visto delle tabelle abbiamo visto record allora quello che vi da erlang è avere delle tabelle e ogni tanto lui le salva in maniera automatica al posto vostro questa è l'idea è l'idea è anche che siccome oggigiorno le operazioni cioè oggi sono quasi tutti i computer portati gli hanno gli ssd le operazioni di accesso a disco ormai sono veramente banali non si parla più di secondi millisecondi ma si parla proprio di macro di micro di ose o di nanosecondi proprio quindi tutto quello abbiamo visto sulle ets funziona sulle death tranne il fatto che le death non possono essere un set ordinato questo perché ve l'avevo detto in una selezione precedente perché è difficile veramente cioè non è difficile è complicato e macchinoso dovere ordinare tenere sempre ordinato un file perché chiaramente quello che si fa l'inserzione in append però bisogna fare l'append e poi riordinare tutto questo si fa per 10 20 entri ma se abbiamo un file con mille entri prende troppo tempo quindi vedete la differenza la differenza invece di fare la new si fa un open file table e option le option sono un pochino uguali a quelle delle delle dts allora l'option sono queste ogni quanto si deve salvare di default sono ogni tre minuti di ci salva quindi tutte le operazioni fatte negli ultimi tre minuti lui le salva sul disco ovviamente c'è anche una copia in ram quindi voi vedrete sempre la copia in ram il file il file nel dove dove andare a farla repair bull se vogliamo che scusate se vogliamo che per esempio se la tabella crash e vogliamo recuperarla quindi se vogliamo recuperarla il file mentre stava scrivendo la tabella crash a tutto quindi la tabella il file che rappresenta la tabella è rimasta in maniera inconsistente se noi mettiamo ripari per bull allora lui cerca di ripararla cosa vuol dire ripararla cerca si va in log ogni tanto un po come i log dei sistemi operativi quindi cerca di fare il recovery all'ultima copia funzionante e type varietà che abbiamo set bug e duplicate bug ma non order ed set ricordate non order ed set poi qui quanto quanti quanti slot massimi può avere come ho detto può ottenere fino di default sono due milioni quindi vedete il valore di default sono due milioni quindi una tabella può ottenere due milioni di entry è veramente tanta roba i numeri minimi di slot e poi se tenere o meno la copia sul ram quindi se velocizzare le operazioni di lettura scrittura quindi se velocizzare il fatto di avere le operazioni di lettura scrittura e poi lui ogni tanto fa il flash cosa succede succede questo che se noi dichiariamo la tabella ram file true ovviamente tutte le operazioni sulla tabella vengono fatte su quella della ram e poi bisogna o chiamare la tabella oppure flashare tutto quando chiediamo la tabella quindi giochiamo un po sulle tabella apriamo questa allora quindi stiamo aprendo una tabella ets vedete non si crea più la tabella si apre la tabella la chiamiamo cibo la vogliamo di tipo bug perché vogliamo metterci più roba con la stessa più roba con la stessa chiave primaria perché perché voglio creare un set di scusate un bug di cibi che appartengono a varie nazionalità e la chiamiamo è la salvo su food punto quindi a partire da questa folder dove sto seguendo la shell non gli è piaciuto perché questi non sono gli apici giusti ok ok food quindi vedete poi io faccio né più né meno su death quindi sto chiamando il modulo death insert di food virgola italy questo è il campo su cui indicizzeremo perciò italy pizza italy pasta a japan visto che ora mi trovo in giappone sushi ormai lo fanno tutti okonomiyaki ad esempio ho sbagliato sbagliato perché perché dovevo scrivere qui in italia quindi cerchiamo di cerchiamo di recuperarla vediamo se riusciamo a recuperarla vediamo se riusciamo a recuperarla visto che era in open open ecco qua copy cerchiamo di recuperarla siccome esiste già cerchiamo di recuperarla l'abbiamo chiamata food vediamo se oh quindi non tutti gli sbagli vengono per noi vengono per noi però vedete che ora non possiamo più chiamarla food ma bisogna utilizzare la referenza quindi io che faccio utilizzo il pattern matching la chiamiamo food perché è facile questa roba qui quindi sbagliando ho fatto crashare tutto l'ho recuperata quindi quello che volevo fare è death insert di food in japan japan ok ok ok ok ok ok ok vediamo se scoppia tutto ok oh funziona andiamo a vedere se server ok ah siccome l'abbiamo recuperata vediamo un attimo death lookup italy pod italy vediamo se l'abbiamo recuperata vedete vedete quindi lui si è creato i dati erano salvati su file e quando è crashata la tabella è crashato tutto la tabella è morta però lui aveva salvato salvato questi dati vedete come è potente erlang e voi non dovete preoccuparvi di salvare scrivere fare tutte queste robe perché lo fa lui basta settare opportunamente parametri quindi si tratta solo di capire quali sono i migliori parametri per la vostra applicazione a patto che riusciate a capire come la vostra applicazione debba inviare e leggere i messaggi tutto tutto qui allora cosa volevamo fare qui volevamo ecco volevo vedere quello server il server dei punti start start andiamo a tableviewer vedete che non esiste la tabella perché non è una tabella ts non è una tabella ts quindi non la possiamo vedere perché è un file anche qui questo è uno spoiler quindi vedete qui da view posso vedere o le ts table o le amnesia table le amnesia table sono le tabelle del database anche qui vedete vi da errore perché non esiste questo però questo lo vedremo tra 3 4 lezioni va bene come le ts potete inserire questo abbiamo fatto cercare cibo inserire e modificare i dati cancellare dei dati oppure potete fare una funzione cercami il cibo cercami tutti dentro il cui cibo non appartiene l'italia e come lo facciamo creiamo una funzione una match specification che prende la località la location e il food e quando la location è diversa da italy mi restituisce questa roba qui questo non è più nemmeno di quello che abbiamo visto con le ts poi per chiudiamo in questo modo poi per chiudere una tabella la chiudiamo in questo modo quindi se io voglio chiudere in maniera decente per far crashare tutto cosa faccio? e poi quando la ri-rediro e poi quando la location è diversa da italy mi restituisce questa roba qui questo non è più nemmeno di quello che abbiamo visto con le ts poi per chiudere una tabella la chiudiamo in questo modo quindi se io voglio chiudere in maniera decente per far crashare tutto cosa faccio? the ts the ts the ts close eeeh food ok e poi quando la ri-rediro su la ri-rediro su vedete? questo è quello che vi dicevo. una volta che la ri-prite non potete più utilizzare il nome anche se l'avevate registrato perché quel nome poi si perde la corrispondenza di quel nome allora come le ts anche le deaths si possono creare utilizzando i record e vi esorto a guardare l'esempio che ho messo quello del telefono che è stato fatto veramente bene che è preso dal libro di cesarini in cui si utilizzano sia le ts che le deaths quindi si utilizzano le ts e poi ogni tanto si si salvano sulle deaths e vedete che la deaths si apre specificando la keyposition e la keyposition in questo caso è il numero di telefono dell'utente perché il numero di telefono è univoco quindi un utente può avere più numeri di telefono ma un numero di telefono appartiene solo a un'utenza quindi vi esorto a guardare l'esempio tel.erl che è sul blended e va bene abbiamo finito la parte sulle tabelle la prossima lezione sarà sulla distribuzione e e e e e e e e e e e e